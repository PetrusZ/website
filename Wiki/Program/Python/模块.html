<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2020-07-22 Wed 14:44 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>模块</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Petrus.Z">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<style> #content{max-width:1400px;}</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">模块</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org57250ba">有关模块的更多信息</a></li>
<li><a href="#orgcd86405">以脚本的方式执行模块</a></li>
<li><a href="#orgb123094">模块搜索路径</a></li>
<li><a href="#org284cefd">“编译过的”Python 文件</a></li>
<li><a href="#org09b5a17">标准模块</a></li>
<li><a href="#orgde08cf1">dir() 函数</a></li>
<li><a href="#org078fc80">包</a></li>
<li><a href="#org2761b40">从包中导入 *</a></li>
<li><a href="#org974c891">子包参考</a></li>
<li><a href="#org9344322">多个目录中的包</a></li>
</ul>
</div>
</div>
<p>
Python 有一种方法可以把定义放在一个文件里，并在脚本或解释器的交互式实例中使用它们。这样的文件被称作 模块 ；模块中的定义可以 导入 到其它模块或者 主 模块（你在顶级和计算器模式下执行的脚本中可以访问的变量集合）。
</p>

<p>
模块是一个包含 Python 定义和语句的文件。文件名就是模块名后跟文件后缀 .py 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 <b>name</b> 的值获得。例如，使用你最喜爱的文本编辑器在当前目录下创建一个名为 fibo.py 的文件， 文件中含有以下内容:
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Fibonacci numbers module</span>

    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">fib</span>(n):    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">write Fibonacci series up to n</span>
        <span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>
        <span style="color: #51afef;">while</span> a &lt; n:
            <span style="color: #51afef;">print</span>(a, end=<span style="color: #98be65;">' '</span>)
            <span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">b</span> = b, a+b
        <span style="color: #51afef;">print</span>()

    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">fib2</span>(n):   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">return Fibonacci series up to n</span>
        <span style="color: #dcaeea;">result</span> = []
        <span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">b</span> = <span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>
        <span style="color: #51afef;">while</span> a &lt; n:
            result.append(a)
            <span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">b</span> = b, a+b
        <span style="color: #51afef;">return</span> result
</pre>
</div>

<p>
现在进入 Python 解释器，并用以下命令导入该模块:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">import</span> fibo

    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#22312;&#24403;&#21069;&#30340;&#31526;&#21495;&#34920;&#20013;&#65292;&#36825;&#24182;&#19981;&#20250;&#30452;&#25509;&#36827;&#20837;&#21040;&#23450;&#20041;&#22312; fibo &#20989;&#25968;&#20869;&#30340;&#21517;&#31216;&#65307;&#23427;&#21482;&#26159;&#36827;&#20837;&#21040;&#27169;&#22359;&#21517; fibo &#20013;&#12290;&#20320;&#21487;&#20197;&#29992;&#27169;&#22359;&#21517;&#35775;&#38382;&#36825;&#20123;&#20989;&#25968;:</span>
    &gt;&gt;&gt; fibo.fib(<span style="color: #da8548; font-weight: bold;">1000</span>)
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #da8548; font-weight: bold;">13</span> <span style="color: #da8548; font-weight: bold;">21</span> <span style="color: #da8548; font-weight: bold;">34</span> <span style="color: #da8548; font-weight: bold;">55</span> <span style="color: #da8548; font-weight: bold;">89</span> <span style="color: #da8548; font-weight: bold;">144</span> <span style="color: #da8548; font-weight: bold;">233</span> <span style="color: #da8548; font-weight: bold;">377</span> <span style="color: #da8548; font-weight: bold;">610</span> <span style="color: #da8548; font-weight: bold;">987</span>
    &gt;&gt;&gt; fibo.fib2(<span style="color: #da8548; font-weight: bold;">100</span>)
    [<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">13</span>, <span style="color: #da8548; font-weight: bold;">21</span>, <span style="color: #da8548; font-weight: bold;">34</span>, <span style="color: #da8548; font-weight: bold;">55</span>, <span style="color: #da8548; font-weight: bold;">89</span>]
    &gt;&gt;&gt; fibo.<span style="color: #c678dd;">__name__</span>
    <span style="color: #98be65;">'fibo'</span>

    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#22914;&#26524;&#20320;&#24819;&#32463;&#24120;&#20351;&#29992;&#26576;&#20010;&#20989;&#25968;&#65292;&#20320;&#21487;&#20197;&#25226;&#23427;&#36171;&#20540;&#32473;&#19968;&#20010;&#23616;&#37096;&#21464;&#37327;:</span>
    &gt;&gt;&gt; <span style="color: #dcaeea;">fib</span> = fibo.fib
    &gt;&gt;&gt; fib(<span style="color: #da8548; font-weight: bold;">500</span>)
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #da8548; font-weight: bold;">13</span> <span style="color: #da8548; font-weight: bold;">21</span> <span style="color: #da8548; font-weight: bold;">34</span> <span style="color: #da8548; font-weight: bold;">55</span> <span style="color: #da8548; font-weight: bold;">89</span> <span style="color: #da8548; font-weight: bold;">144</span> <span style="color: #da8548; font-weight: bold;">233</span> <span style="color: #da8548; font-weight: bold;">377</span>
</pre>
</div>

<div id="outline-container-org57250ba" class="outline-2">
<h2 id="org57250ba">有关模块的更多信息</h2>
<div class="outline-text-2" id="text-org57250ba">
<p>
模块可以包含可执行的语句以及函数定义。这些语句用于初始化模块。它们仅在模块 第一次 在 import 语句中被导入时才执行。 (当文件被当作脚本运行时，它们也会执行。)
</p>

<p>
每个模块都有它自己的私有符号表，该表用作模块中定义的所有函数的全局符号表。因此，模块的作者可以在模块内使用全局变量，而不必担心与用户的全局变量发生意外冲突。另一方面，如果你知道自己在做什么，则可以用跟访问模块内的函数的同样标记方法，去访问一个模块的全局变量，modname.itemname。
</p>

<p>
模块可以导入其它模块。习惯上但不要求把所有 import 语句放在模块（或脚本）的开头。被导入的模块名存放在调入模块的全局符号表中。
</p>

<p>
import 语句有一个变体，它可以把名字从一个被调模块内直接导入到现模块的符号表里。例如:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">from</span> fibo <span style="color: #51afef;">import</span> fib, fib2
    &gt;&gt;&gt; fib(<span style="color: #da8548; font-weight: bold;">500</span>)
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #da8548; font-weight: bold;">13</span> <span style="color: #da8548; font-weight: bold;">21</span> <span style="color: #da8548; font-weight: bold;">34</span> <span style="color: #da8548; font-weight: bold;">55</span> <span style="color: #da8548; font-weight: bold;">89</span> <span style="color: #da8548; font-weight: bold;">144</span> <span style="color: #da8548; font-weight: bold;">233</span> <span style="color: #da8548; font-weight: bold;">377</span>
</pre>
</div>

<p>
这并不会把被调模块名引入到局部变量表里（因此在这个例子里，fibo 是未被定义的）。
</p>

<p>
还有一个变体甚至可以导入模块内定义的所有名称:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">from</span> fibo <span style="color: #51afef;">import</span> *
    &gt;&gt;&gt; fib(<span style="color: #da8548; font-weight: bold;">500</span>)
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #da8548; font-weight: bold;">13</span> <span style="color: #da8548; font-weight: bold;">21</span> <span style="color: #da8548; font-weight: bold;">34</span> <span style="color: #da8548; font-weight: bold;">55</span> <span style="color: #da8548; font-weight: bold;">89</span> <span style="color: #da8548; font-weight: bold;">144</span> <span style="color: #da8548; font-weight: bold;">233</span> <span style="color: #da8548; font-weight: bold;">377</span>
</pre>
</div>

<p>
这会调入所有非以下划线（_）开头的名称。 在多数情况下，Python 程序员都不会使用这个功能，因为它在解释器中引入了一组未知的名称，而它们很可能会覆盖一些你已经定义过的东西。
</p>

<p>
注意通常情况下从一个模块或者包内调入 * 的做法是不太被接受的， 因为这通常会导致代码的可读性很差。不过，在交互式编译器中为了节省打字可以这么用。
</p>

<p>
如果模块名称之后带有 as，则跟在 as 之后的名称将直接绑定到所导入的模块。
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">import</span> fibo <span style="color: #51afef;">as</span> fib
    &gt;&gt;&gt; fib.fib(<span style="color: #da8548; font-weight: bold;">500</span>)
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #da8548; font-weight: bold;">13</span> <span style="color: #da8548; font-weight: bold;">21</span> <span style="color: #da8548; font-weight: bold;">34</span> <span style="color: #da8548; font-weight: bold;">55</span> <span style="color: #da8548; font-weight: bold;">89</span> <span style="color: #da8548; font-weight: bold;">144</span> <span style="color: #da8548; font-weight: bold;">233</span> <span style="color: #da8548; font-weight: bold;">377</span>
</pre>
</div>

<p>
这会和 <code>import fibo</code> 方式一样有效地调入模块， 唯一的区别是它以 fib
的名称存在的。
</p>

<p>
这种方式也可以在用到 from 的时候使用，并会有类似的效果:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">from</span> fibo <span style="color: #51afef;">import</span> fib <span style="color: #51afef;">as</span> fibonacci
    &gt;&gt;&gt; fibonacci(<span style="color: #da8548; font-weight: bold;">500</span>)
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #da8548; font-weight: bold;">13</span> <span style="color: #da8548; font-weight: bold;">21</span> <span style="color: #da8548; font-weight: bold;">34</span> <span style="color: #da8548; font-weight: bold;">55</span> <span style="color: #da8548; font-weight: bold;">89</span> <span style="color: #da8548; font-weight: bold;">144</span> <span style="color: #da8548; font-weight: bold;">233</span> <span style="color: #da8548; font-weight: bold;">377</span>
</pre>
</div>

<blockquote>
<p>
注解 出于效率的考虑，每个模块在每个解释器会话中只被导入一次。因此，如果你更改了你的模块，则必须重新启动解释器， 或者，如果它只是一个要交互式地测试的模块，请使用 importlib.reload()，例如 import importlib; importlib.reload(modulename)。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgcd86405" class="outline-2">
<h2 id="orgcd86405">以脚本的方式执行模块</h2>
<div class="outline-text-2" id="text-orgcd86405">
<p>
当你用下面方式运行一个 Python 模块:
</p>

<p>
<code>python fibo.py &lt;arguments&gt;</code>
</p>

<p>
模块里的代码会被执行，就好像你导入了模块一样，但是 <code>__name__</code> 被赋值为 <code>"__main__"</code> 。 这意味着通过在你的模块末尾添加这些代码:
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #51afef;">if</span> <span style="color: #c678dd;">__name__</span> == <span style="color: #98be65;">"__main__"</span>:
        <span style="color: #51afef;">import</span> sys
        fib(<span style="color: #c678dd;">int</span>(sys.argv[<span style="color: #da8548; font-weight: bold;">1</span>]))
</pre>
</div>

<p>
你既可以把这个文件当作脚本又可当作一个可调入的模块来使用， 因为那段解析命令行的代码只有在当模块是以“main”文件的方式执行的时候才会运行:
</p>

<div class="org-src-container">
<pre class="src src-sh">    $ python fibo.py <span style="color: #da8548; font-weight: bold;">50</span>
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #da8548; font-weight: bold;">13</span> <span style="color: #da8548; font-weight: bold;">21</span> <span style="color: #da8548; font-weight: bold;">34</span>
</pre>
</div>

<p>
如果模块是被导入的，那些代码是不运行的。
</p>

<p>
这经常用于为模块提供一个方便的用户接口，或用于测试（以脚本的方式运行模块从而执行一些测试套件）。
</p>
</div>
</div>

<div id="outline-container-orgb123094" class="outline-2">
<h2 id="orgb123094">模块搜索路径</h2>
<div class="outline-text-2" id="text-orgb123094">
<p>
当一个名为 spam 的模块被导入的时候，解释器首先寻找具有该名称的内置模块。如果没有找到，然后解释器从 sys.path 变量给出的目录列表里寻找名为 spam.py 的文件。sys.path 初始有这些目录地址:
</p>

<ul class="org-ul">
<li>包含输入脚本的目录（或者未指定文件时的当前目录）。</li>
<li>PYTHONPATH （一个包含目录名称的列表，它和 shell 变量 PATH
有一样的语法）。</li>
<li>取决于安装的默认设置</li>
</ul>

<blockquote>
<p>
注解：在支持符号链接的文件系统上，包含输入脚本的目录是在追加符号链接后才计算出来的。换句话说，包含符号链接的目录并没有 被添加到模块的搜索路径上。
</p>
</blockquote>

<p>
在初始化后，Python 程序可以更改 sys.path。包含正在运行脚本的文件目录被放在搜索路径的开头处， 在标准库路径之前。这意味着将加载此目录里的脚本，而不是标准库中的同名模块。 除非有意更换，否则这是错误。更多信息请参阅 标准模块。
</p>
</div>
</div>

<div id="outline-container-org284cefd" class="outline-2">
<h2 id="org284cefd">“编译过的”Python 文件</h2>
<div class="outline-text-2" id="text-org284cefd">
<p>
为了加速模块载入，Python 在 <code>__pycache__</code> 目录里缓存了每个模块的编译后版本，名称为 <code>module.version.pyc</code> ，其中名称中的版本字段对编译文件的格式进行编码； 它一般使用 Python 版本号。例如，在 CPython 版本 3.3 中，spam.py 的编译版本将被缓存为 <code>__pycache__/spam.cpython-33.pyc</code> 。此命名约定允许来自不同发行版和不同版本的 Python 的已编译模块共存。
</p>

<p>
Python 根据编译版本检查源的修改日期，以查看它是否已过期并需要重新编译。这是一个完全自动化的过程。此外，编译的模块与平台无关，因此可以在具有不同体系结构的系统之间共享相同的库。
</p>

<p>
Python 在两种情况下不会检查缓存。首先，对于从命令行直接载入的模块，它从来都是重新编译并且不存储编译结果；其次，如果没有源模块，它不会检查缓存。为了支持无源文件（仅编译）发行版本， 编译模块必须是在源目录下，并且绝对不能有源模块。
</p>

<p>
给专业人士的一些小建议:
</p>

<ul class="org-ul">
<li>你可以在 Python 命令中使用 -O 或者 -OO 开关， 以减小编译后模块的大小。 -O 开关去除断言语句，-OO 开关同时去除断言语句和 <code>__doc__</code> 字符串。由于有些程序可能依赖于这些，你应当只在清楚自己在做什么时才使用这个选项。“优化过的”模块有一个 opt- 标签并且通常小些。将来的发行版本或许会更改优化的效果。</li>
<li>一个从 .pyc 文件读出的程序并不会比它从 .py 读出时运行的更快，.pyc 文件唯一快的地方在于载入速度。</li>
<li>compileall 模块可以为一个目录下的所有模块创建.pyc 文件。</li>
<li>关于这个过程，PEP 3147 中有更多细节，包括一个决策流程图。</li>
</ul>
</div>
</div>

<div id="outline-container-org09b5a17" class="outline-2">
<h2 id="org09b5a17">标准模块</h2>
<div class="outline-text-2" id="text-org09b5a17">
<p>
Python 附带了一个标准模块库，在单独的文档 Python 库参考（以下称为“库参考”）中进行了描述。一些模块内置于解释器中；它们提供对不属于语言核心但仍然内置的操作的访问，以提高效率或提供对系统调用等操作系统原语的访问。这些模块的集合是一个配置选项，它也取决于底层平台。例如，=winreg= 模块只在 Windows 操作系统上提供。一个特别值得注意的模块 sys，它被内嵌到每一个 Python 解释器中。变量 <code>sys.ps1</code> 和 <code>sys.ps2</code> 定义用作主要和辅助提示的字符串:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">import</span> sys
    &gt;&gt;&gt; sys.ps1
    <span style="color: #98be65;">'&gt;&gt;&gt; '</span>
    &gt;&gt;&gt; sys.ps2
    <span style="color: #98be65;">'... '</span>
    &gt;&gt;&gt; <span style="color: #dcaeea;">sys.ps1</span> = <span style="color: #98be65;">'C&gt; '</span>
    C&gt; <span style="color: #51afef;">print</span>(<span style="color: #98be65;">'Yuck!'</span>)
    Yuck!
    C&gt;
</pre>
</div>

<p>
这两个变量只有在编译器是交互模式下才被定义。
</p>

<p>
<code>sys.path</code> 变量是一个字符串列表，用于确定解释器的模块搜索路径。该变量被初始化为从环境变量 <code>PYTHONPATH</code> 获取的默认路径，或者如果 <code>PYTHONPATH</code> 未设置，则从内置默认路径初始化。你可以使用标准列表操作对其进行修改:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">import</span> sys
    &gt;&gt;&gt; sys.path.append(<span style="color: #98be65;">'/ufs/guido/lib/python'</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgde08cf1" class="outline-2">
<h2 id="orgde08cf1">dir() 函数</h2>
<div class="outline-text-2" id="text-orgde08cf1">
<p>
内置函数 dir() 用于查找模块定义的名称。 它返回一个排序过的字符串列表:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">import</span> fibo, sys
    &gt;&gt;&gt; <span style="color: #c678dd;">dir</span>(fibo)
    [<span style="color: #98be65;">'__name__'</span>, <span style="color: #98be65;">'fib'</span>, <span style="color: #98be65;">'fib2'</span>]
</pre>
</div>

<p>
如果没有参数，dir() 会列出你当前定义的名称:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #dcaeea;">a</span> = [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">5</span>]
    &gt;&gt;&gt; <span style="color: #51afef;">import</span> fibo
    &gt;&gt;&gt; <span style="color: #dcaeea;">fib</span> = fibo.fib
    &gt;&gt;&gt; <span style="color: #c678dd;">dir</span>()
    [<span style="color: #98be65;">'__builtins__'</span>, <span style="color: #98be65;">'__name__'</span>, <span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'fib'</span>, <span style="color: #98be65;">'fibo'</span>, <span style="color: #98be65;">'sys'</span>]
</pre>
</div>

<p>
注意：它列出所有类型的名称：变量，模块，函数，等等。
</p>

<p>
dir() 不会列出内置函数和变量的名称。如果你想要这些，它们的定义是在标准模块 builtins 中:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">import</span> builtins
    &gt;&gt;&gt; <span style="color: #c678dd;">dir</span>(builtins)
</pre>
</div>
</div>
</div>

<div id="outline-container-org078fc80" class="outline-2">
<h2 id="org078fc80">包</h2>
<div class="outline-text-2" id="text-org078fc80">
<p>
包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块名 A.B 表示 A 包中名为 B 的子模块。正如模块的使用使得不同模块的作者不必担心彼此的全局变量名称一样，使用加点的模块名可以使得 NumPy 或 Pillow 等多模块软件包的作者不必担心彼此的模块名称一样。
</p>

<p>
假设你想为声音文件和声音数据的统一处理，设计一个模块集合（一个“包”）。由于存在很多不同的声音文件格式（通常由它们的扩展名来识别，例如：.wav， .aiff， .au），因此为了不同文件格式间的转换，你可能需要创建和维护一个不断增长的模块集合。 你可能还想对声音数据还做很多不同的处理（例如，混声，添加回声，使用均衡器功能，创造人工立体声效果）， 因此为了实现这些处理，你将另外写一个无穷尽的模块流。这是你的包的可能结构（以分层文件系统的形式表示）：
</p>

<pre class="example">
    sound/                          Top-level package
          __init__.py               Initialize the sound package
          formats/                  Subpackage for file format conversions
                  __init__.py
                  wavread.py
                  wavwrite.py
                  aiffread.py
                  aiffwrite.py
                  auread.py
                  auwrite.py
                  ...
          effects/                  Subpackage for sound effects
                  __init__.py
                  echo.py
                  surround.py
                  reverse.py
                  ...
          filters/                  Subpackage for filters
                  __init__.py
                  equalizer.py
                  vocoder.py
                  karaoke.py
                  ...
</pre>

<p>
当导入这个包时，Python 搜索 <code>sys.path</code> 里的目录，查找包的子目录。
</p>

<p>
必须要有 <code>__init__.py</code> 文件才能让 Python 将包含该文件的目录当作包。 这样可以防止具有通常名称例如 string 的目录在无意中隐藏稍后在模块搜索路径上出现的有效模块。 在最简单的情况下，=__init__.py= 可以只是一个空文件，但它也可以执行包的初始化代码或设置 <code>__all__</code> 变量，具体将在后文介绍。
</p>

<p>
包的用户可以从包中导入单个模块，例如:
</p>

<p>
<code>import sound.effects.echo</code>
</p>

<p>
这会加载子模块 sound.effects.echo 。但引用它时必须使用它的全名。
</p>

<p>
<code>sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)</code>
</p>

<p>
导入子模块的另一种方法是
</p>

<p>
<code>from sound.effects import echo</code>
</p>

<p>
这也会加载子模块 echo ，并使其在没有包前缀的情况下可用，因此可以按如下方式使用:
</p>

<p>
<code>echo.echofilter(input, output, delay=0.7, atten=4)</code>
</p>

<p>
另一种形式是直接导入所需的函数或变量:
</p>

<p>
<code>from sound.effects.echo import echofilter</code>
</p>

<p>
同样，这也会加载子模块 echo，但这会使其函数 echofilter() 直接可用:
</p>

<p>
<code>echofilter(input, output, delay=0.7, atten=4)</code>
</p>

<p>
请注意，当使用 <code>from package import item</code> 时，item 可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 <code>import</code> 语句首先测试是否在包中定义了 item；如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 ImportError 异常。
</p>

<p>
相反，当使用 <code>import item.subitem.subsubitem</code> 这样的语法时，除了最后一项之外的每一项都必须是一个包；最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量。
</p>
</div>
</div>

<div id="outline-container-org2761b40" class="outline-2">
<h2 id="org2761b40">从包中导入 *</h2>
<div class="outline-text-2" id="text-org2761b40">
<p>
当用户写 =from sound.effects import *=会发生什么？理想情况下，人们希望这会以某种方式传递给文件系统，找到包中存在哪些子模块，并将它们全部导入。这可能需要很长时间，导入子模块可能会产生不必要的副作用，这种副作用只有在显式导入子模块时才会发生。
</p>

<p>
唯一的解决方案是让包作者提供一个包的显式索引。import 语句使用下面的规范：如果一个包的 <code>__init__.py</code> 代码定义了一个名为 <code>__all__</code> 的列表，它会被视为在遇到 <code>from package import *</code> 时应该导入的模块名列表。在发布该包的新版本时，包作者可以决定是否让此列表保持更新。包作者如果认为从他们的包中导入 * 的操作没有必要被使用，也可以决定不支持此列表。例如，文件 <code>sound/effects/__init__.py</code> 可以包含以下代码:
</p>

<p>
<code>__all__ = ["echo", "surround", "reverse"]</code>
</p>

<p>
这意味着 <code>from sound.effects import *</code> 将导入 sound 包的三个命名子模块。
</p>

<p>
如果没有定义 <code>__all__=，=from sound.effects import *</code> 语句 不 会从包 sound.effects 中导入所有子模块到当前命名空间；它只确保导入了包 sound.effects （可能运行任何在 <code>__init__.py</code> 中的初始化代码），然后导入包中定义的任何名称。这包括 <code>__init__.py</code> 定义的任何名称（以及显式加载的子模块）。它还包括由之前的 import 语句显式加载的包的任何子模块。
</p>

<p>
虽然某些模块被设计为在使用 <code>import *</code> 时只导出遵循某些模式的名称，但在生产代码中它仍然被认为是不好的做法。
</p>

<p>
请记住，使用 <code>from package import specific_submodule</code> 没有任何问题！ 实际上，除非导入的模块需要使用来自不同包的同名子模块，否则这是推荐的表示法。
</p>
</div>
</div>

<div id="outline-container-org974c891" class="outline-2">
<h2 id="org974c891">子包参考</h2>
<div class="outline-text-2" id="text-org974c891">
<p>
当包被构造成子包时（与示例中的 sound 包一样），你可以使用绝对导入来引用兄弟包的子模块。例如，如果模块 sound.filters.vocoder 需要在 sound.effects 包中使用 echo 模块，它可以使用 <code>from sound.effects import echo</code> 。
</p>

<p>
你还可以使用 import 语句的 <code>from module import name</code> 形式编写相对导入。这些导入使用前导点来指示相对导入中涉及的当前包和父包。例如，从 surround 模块，你可以使用:
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #51afef;">from</span> . <span style="color: #51afef;">import</span> echo
    <span style="color: #51afef;">from</span> .. <span style="color: #51afef;">import</span> formats
    <span style="color: #51afef;">from</span> ..filters <span style="color: #51afef;">import</span> equalizer
</pre>
</div>

<p>
请注意，相对导入是基于当前模块的名称进行导入的。由于主模块的名称总是
<code>"__main__"</code> ，因此用作 Python 应用程序主模块的模块必须始终使用绝对导入。
</p>
</div>
</div>

<div id="outline-container-org9344322" class="outline-2">
<h2 id="org9344322">多个目录中的包</h2>
<div class="outline-text-2" id="text-org9344322">
<p>
包支持另一个特殊属性， <code>__path__</code> 。它被初始化为一个列表，其中包含在执行该文件中的代码之前保存包的文件 <code>__init__.py</code> 的目录的名称。这个变量可以修改；这样做会影响将来对包中包含的模块和子包的搜索。
</p>

<p>
虽然通常不需要此功能，但它可用于扩展程序包中的模块集。
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">&#20316;&#32773;: Petrus.Z</p>
<p class="date">Created: 2020-07-22 Wed 14:44</p>
</div>
</body>
</html>
