<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2020-07-22 Wed 14:44 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>数字、字符串、列表与流程控制工具</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Petrus.Z">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<style> #content{max-width:1400px;}</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">数字、字符串、列表与流程控制工具</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1443848">数字</a></li>
<li><a href="#orgc75243c">字符串</a></li>
<li><a href="#org8adadd8">列表</a></li>
<li><a href="#orgf07f21d">其他流程控制工具</a>
<ul>
<li><a href="#org4376d5b">for 语句</a></li>
<li><a href="#org82dfae0">range() 函数</a></li>
<li><a href="#org6732db8">break 和 continue 语句，以及循环中的 else 子句</a></li>
<li><a href="#org432d1ff">pass 语句</a></li>
<li><a href="#orge630c10">定义函数</a></li>
<li><a href="#orgf703fb3">函数定义的更多形式</a>
<ul>
<li><a href="#orgd0cb3b3">参数默认值</a></li>
<li><a href="#orga4487af">关键字参数</a></li>
<li><a href="#org62e4773">特殊参数</a>
<ul>
<li><a href="#orgc0b2b13">位置或关键字参数</a></li>
<li><a href="#org3f8af4e">仅限位置参数</a></li>
<li><a href="#orgd182fdf">仅限关键字参数</a></li>
<li><a href="#org44b2ffb">概括</a></li>
</ul>
</li>
<li><a href="#org2e77522">任意的参数列表</a></li>
<li><a href="#orgd594c61">Lambda 表达式</a></li>
<li><a href="#orgcf7378a">文档字符串</a></li>
<li><a href="#orge5bdad6">函数标注</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org57fdc05">Misc</a></li>
<li><a href="#org606ec20">Links</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1443848" class="outline-2">
<h2 id="org1443848">数字</h2>
<div class="outline-text-2" id="text-org1443848">
<p>
除法运算 (/) 永远返回浮点数类型。如果要做向下取整除法得道一个整数结果，可以使用 <code>//</code> 运算符；如要要计算余数则使用 <code>%</code> 。
</p>

<p>
在 Python 中，可以使用 ** 运算符来计算乘方。
</p>

<p>
在交互模式下，上一次打印出来的表达式被赋值给变量 _。这意味着当你把 Python 用作桌面计算器时，继续计算会相对简单。
</p>
</div>
</div>

<div id="outline-container-orgc75243c" class="outline-2">
<h2 id="orgc75243c">字符串</h2>
<div class="outline-text-2" id="text-orgc75243c">
<p>
如果你不希望前置了  的字符转义成特殊字符，可以使用 原始字符串 方式，在引号前添加 r 即可:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">print</span>(r<span style="color: #98be65;">'C:\some\name'</span>)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">note the r before the quote</span>
    C:\some\name
</pre>
</div>

<p>
字符串字面值可以跨行连续输入。一种方式是用三重引号："""&#x2026;""" 或 '''&#x2026;'''。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个  即可。
</p>

<p>
字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复。
</p>

<p>
相邻的两个或多个 字符串字面值 （引号引起来的字符）将会自动连接到一起。
</p>

<p>
把很长的字符串拆开分别输入的时候尤其有用:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #dcaeea;">text</span> = (<span style="color: #98be65;">'Put several strings within parentheses '</span>
    ...         <span style="color: #98be65;">'to have them joined together.'</span>)
    &gt;&gt;&gt; text
    <span style="color: #98be65;">'Put several strings within parentheses to have them joined together.'</span>
</pre>
</div>

<p>
只能对两个字面值这样操作，变量或表达式不行。
</p>

<p>
如果你想连接变量，或者连接变量和字面值，可以用 + 号。
</p>

<p>
字符串是可以被 索引 （下标访问）的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串。索引也可以用负数，这种会从右边开始数。
</p>

<p>
除了索引，字符串还支持 切片。索引可以得到单个字符，而 切片 可以获取子字符串。注意切片的开始总是被包括在结果中，而结束不被包括。这使得 s[:i] + s[i:] 总是等于 s。切片的索引有默认值；省略开始索引时默认为 0，省略结束索引时默认为到字符串的结束:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #dcaeea;">word</span> = <span style="color: #98be65;">'Python'</span>
    &gt;&gt;&gt; word[:<span style="color: #da8548; font-weight: bold;">2</span>]   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">character from the beginning to position 2 (excluded)</span>
    <span style="color: #98be65;">'Py'</span>
    &gt;&gt;&gt; word[<span style="color: #da8548; font-weight: bold;">4</span>:]   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">characters from position 4 (included) to the end</span>
    <span style="color: #98be65;">'on'</span>
    &gt;&gt;&gt; word[-<span style="color: #da8548; font-weight: bold;">2</span>:]  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">characters from the second-last (included) to the end</span>
    <span style="color: #98be65;">'on'</span>
</pre>
</div>

<p>
使用越界索引会产生一个错误。但是，切片中的越界索引会被自动处理。
</p>

<p>
Python 中的字符串不能被修改，它们是 immutable 的。因此，向字符串的某个索引位置赋值会产生一个错误。如果需要一个不同的字符串，应当新建一个。
</p>
</div>
</div>

<div id="outline-container-org8adadd8" class="outline-2">
<h2 id="org8adadd8">列表</h2>
<div class="outline-text-2" id="text-org8adadd8">
<p>
和字符串（以及各种内置的 sequence 类型）一样，列表也支持索引和切片。所有的切片操作都返回一个包含所请求元素的新列表。 这意味着以下切片操作会返回列表的一个 浅拷贝:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; squares[:]
    [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">4</span>, <span style="color: #da8548; font-weight: bold;">9</span>, <span style="color: #da8548; font-weight: bold;">16</span>, <span style="color: #da8548; font-weight: bold;">25</span>]
</pre>
</div>

<p>
列表同样支持拼接操作。与 immutable 的字符串不同, 列表是一个 mutable 类型，就是说，它自己的内容可以改变：
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #dcaeea;">cubes</span> = [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">27</span>, <span style="color: #da8548; font-weight: bold;">65</span>, <span style="color: #da8548; font-weight: bold;">125</span>]  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">something's wrong here</span>
    &gt;&gt;&gt; <span style="color: #da8548; font-weight: bold;">4</span> ** <span style="color: #da8548; font-weight: bold;">3</span>  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">the cube of 4 is 64, not 65!</span>
    <span style="color: #da8548; font-weight: bold;">64</span>
    &gt;&gt;&gt; <span style="color: #dcaeea;">cubes</span>[<span style="color: #da8548; font-weight: bold;">3</span>] = <span style="color: #da8548; font-weight: bold;">64</span>  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">replace the wrong value</span>
    &gt;&gt;&gt; cubes
    [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">27</span>, <span style="color: #da8548; font-weight: bold;">64</span>, <span style="color: #da8548; font-weight: bold;">125</span>]
</pre>
</div>

<p>
你也可以在列表结尾，通过 append() 方法 添加新元素:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; cubes.append(<span style="color: #da8548; font-weight: bold;">216</span>)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">add the cube of 6</span>
    &gt;&gt;&gt; cubes.append(<span style="color: #da8548; font-weight: bold;">7</span> ** <span style="color: #da8548; font-weight: bold;">3</span>)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">and the cube of 7</span>
    &gt;&gt;&gt; cubes
    [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #da8548; font-weight: bold;">27</span>, <span style="color: #da8548; font-weight: bold;">64</span>, <span style="color: #da8548; font-weight: bold;">125</span>, <span style="color: #da8548; font-weight: bold;">216</span>, <span style="color: #da8548; font-weight: bold;">343</span>]
</pre>
</div>

<p>
给切片赋值也是可以的，这样甚至可以改变列表大小，或者把列表整个清空:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #dcaeea;">letters</span> = [<span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'b'</span>, <span style="color: #98be65;">'c'</span>, <span style="color: #98be65;">'d'</span>, <span style="color: #98be65;">'e'</span>, <span style="color: #98be65;">'f'</span>, <span style="color: #98be65;">'g'</span>]
    &gt;&gt;&gt; letters
    [<span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'b'</span>, <span style="color: #98be65;">'c'</span>, <span style="color: #98be65;">'d'</span>, <span style="color: #98be65;">'e'</span>, <span style="color: #98be65;">'f'</span>, <span style="color: #98be65;">'g'</span>]
    &gt;&gt;&gt; <span style="color: #5B6268;"># </span><span style="color: #5B6268;">replace some values</span>
    &gt;&gt;&gt; <span style="color: #dcaeea;">letters</span>[<span style="color: #da8548; font-weight: bold;">2</span>:<span style="color: #da8548; font-weight: bold;">5</span>] = [<span style="color: #98be65;">'C'</span>, <span style="color: #98be65;">'D'</span>, <span style="color: #98be65;">'E'</span>]
    &gt;&gt;&gt; letters
    [<span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'b'</span>, <span style="color: #98be65;">'C'</span>, <span style="color: #98be65;">'D'</span>, <span style="color: #98be65;">'E'</span>, <span style="color: #98be65;">'f'</span>, <span style="color: #98be65;">'g'</span>]
    &gt;&gt;&gt; <span style="color: #5B6268;"># </span><span style="color: #5B6268;">now remove them</span>
    &gt;&gt;&gt; <span style="color: #dcaeea;">letters</span>[<span style="color: #da8548; font-weight: bold;">2</span>:<span style="color: #da8548; font-weight: bold;">5</span>] = []
    &gt;&gt;&gt; letters
    [<span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'b'</span>, <span style="color: #98be65;">'f'</span>, <span style="color: #98be65;">'g'</span>]
    &gt;&gt;&gt; <span style="color: #5B6268;"># </span><span style="color: #5B6268;">clear the list by replacing all the elements with an empty list</span>
    &gt;&gt;&gt; <span style="color: #dcaeea;">letters</span>[:] = []
    &gt;&gt;&gt; letters
    []
</pre>
</div>

<p>
也可以嵌套列表 (创建包含其他列表的列表)
</p>
</div>
</div>

<div id="outline-container-orgf07f21d" class="outline-2">
<h2 id="orgf07f21d">其他流程控制工具</h2>
<div class="outline-text-2" id="text-orgf07f21d">
</div>
<div id="outline-container-org4376d5b" class="outline-3">
<h3 id="org4376d5b">for 语句</h3>
<div class="outline-text-3" id="text-org4376d5b">
<p>
Python 中的 for 语句与你在 C 或 Pascal 中可能用到的有所不同。 Python 中的 for 语句并不总是对算术递增的数值进行迭代（如同 Pascal），或是给予用户定义迭代步骤和暂停条件的能力（如同 C），而是对任意序列进行迭代（例如列表或字符串），条目的迭代顺序与它们在序列中出现的顺序一致。
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Measure some strings:</span>
    ... <span style="color: #dcaeea;">words</span> = [<span style="color: #98be65;">'cat'</span>, <span style="color: #98be65;">'window'</span>, <span style="color: #98be65;">'defenestrate'</span>]
    &gt;&gt;&gt; <span style="color: #51afef;">for</span> w <span style="color: #51afef;">in</span> words:
    ...     <span style="color: #51afef;">print</span>(w, <span style="color: #c678dd;">len</span>(w))
    ...
    cat <span style="color: #da8548; font-weight: bold;">3</span>
    window <span style="color: #da8548; font-weight: bold;">6</span>
    defenestrate <span style="color: #da8548; font-weight: bold;">12</span>
</pre>
</div>

<p>
在遍历同一个集合时修改该集合的代码可能很难获得正确的结果。通常，更直接的做法是循环遍历该集合的副本或创建新集合：
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #51afef;">for</span> user, status <span style="color: #51afef;">in</span> users.copy().items():
        <span style="color: #51afef;">if</span> status == <span style="color: #98be65;">'inactive'</span>:
            <span style="color: #51afef;">del</span> users[user]

    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Strategy:  Create a new collection</span>
    <span style="color: #dcaeea;">active_users</span> = {}
    <span style="color: #51afef;">for</span> user, status <span style="color: #51afef;">in</span> users.items():
        <span style="color: #51afef;">if</span> status == <span style="color: #98be65;">'active'</span>:
            <span style="color: #dcaeea;">active_users</span>[user] = status
</pre>
</div>
</div>
</div>

<div id="outline-container-org82dfae0" class="outline-3">
<h3 id="org82dfae0">range() 函数</h3>
<div class="outline-text-3" id="text-org82dfae0">
<p>
如果你确实需要遍历一个数字序列，内置函数 range() 会派上用场。它生成算术级数。
</p>

<p>
要以序列的索引来迭代，您可以将 range() 和 len() 组合如下:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #dcaeea;">a</span> = [<span style="color: #98be65;">'Mary'</span>, <span style="color: #98be65;">'had'</span>, <span style="color: #98be65;">'a'</span>, <span style="color: #98be65;">'little'</span>, <span style="color: #98be65;">'lamb'</span>]
    &gt;&gt;&gt; <span style="color: #51afef;">for</span> i <span style="color: #51afef;">in</span> <span style="color: #c678dd;">range</span>(<span style="color: #c678dd;">len</span>(a)):
    ...     <span style="color: #51afef;">print</span>(i, a[i])
    ...
    <span style="color: #da8548; font-weight: bold;">0</span> Mary
    <span style="color: #da8548; font-weight: bold;">1</span> had
    <span style="color: #da8548; font-weight: bold;">2</span> a
    <span style="color: #da8548; font-weight: bold;">3</span> little
    <span style="color: #da8548; font-weight: bold;">4</span> lamb
</pre>
</div>

<p>
然而，在大多数这类情况下，使用 enumerate() 函数比较方便，请参见 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tut-loopidioms">循环的技巧</a> 。
</p>

<p>
range() 所返回的对象在许多方面表现得像一个列表，但实际上却并不是。此对象会在你迭代它时基于所希望的序列返回连续的项，但它没有真正生成列表，这样就能节省空间。
</p>

<p>
我们称这样对象为 iterable，也就是说，适合作为这样的目标对象：函数和结构期望中从获取连续的项直到所提供的项全部耗尽。我们已经看到 for 语句就是这样一种结构，而接受可迭代对象的函数的一个例子是 sum():
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #c678dd;">sum</span>(<span style="color: #c678dd;">range</span>(<span style="color: #da8548; font-weight: bold;">4</span>))  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">0 + 1 + 2 + 3</span>
    <span style="color: #da8548; font-weight: bold;">6</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6732db8" class="outline-3">
<h3 id="org6732db8">break 和 continue 语句，以及循环中的 else 子句</h3>
<div class="outline-text-3" id="text-org6732db8">
<p>
循环语句可能带有 else 子句；它会在循环耗尽了可迭代对象 (使用 for) 或循环条件变为假值 (使用 while) 时被执行，但不会在循环被 break 语句终止时被执行。
</p>

<p>
当和循环一起使用时，else 子句与 try 语句中的 else 子句的共同点多于 if 语句中的同类子句: try 语句中的 else 子句会在未发生异常时执行，而循环中的 else 子句则会在未发生 break 时执行。 有关 try 语句和异常的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3/tutorial/errors.html#tut-handling">处理异常</a>。
</p>
</div>
</div>

<div id="outline-container-org432d1ff" class="outline-3">
<h3 id="org432d1ff">pass 语句</h3>
<div class="outline-text-3" id="text-org432d1ff">
<p>
pass 语句什么也不做。当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它。
</p>

<p>
pass 的另一个可以使用的场合是在你编写新的代码时作为一个函数或条件子句体的占位符，允许你保持在更抽象的层次上进行思考。 pass 会被静默地忽略：
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">def</span> <span style="color: #c678dd;">initlog</span>(*args):
    ...     <span style="color: #51afef;">pass</span>   <span style="color: #5B6268;"># </span><span style="color: #5B6268;">Remember to implement this!</span>
    ...
</pre>
</div>
</div>
</div>

<div id="outline-container-orge630c10" class="outline-3">
<h3 id="orge630c10">定义函数</h3>
<div class="outline-text-3" id="text-orge630c10">
<p>
关键字 def 引入一个函数 定义。它必须后跟函数名称和带括号的形式参数列表。构成函数体的语句从下一行开始，并且必须缩进。
</p>

<p>
函数体的第一个语句可以（可选的）是字符串文字；这个字符串文字是函数的文档字符串或 docstring 。（有关文档字符串的更多信息，请参阅 <a href="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#tut-docstrings">文档字符串</a> 部分）有些工具使用文档字符串自动生成在线或印刷文档，或者让用户以交互式的形式浏览代码；在你编写的代码中包含文档字符串是一种很好的做法，所以要养成习惯。
</p>

<p>
函数的 执行 会引入一个用于函数局部变量的新符号表。 更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，再然后是全局符号表，最后是内置名称的符号表。 因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在 <code>global</code> 语句中定义的全局变量，或者是在 <code>nonlocal</code> 语句中定义的外层函数的变量），尽管它们可以被引用。
</p>

<p>
在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；因此，实参是通过 按值调用 传递的（其中 值 始终是对象 引用 而不是对象的值）。1 当一个函数调用另外一个函数时，将会为该调用创建一个新的本地符号表。
</p>

<p>
函数定义会把函数名引入当前的符号表中。函数名称的值具有解释器将其识别为用户定义函数的类型。这个值可以分配给另一个名称，该名称也可以作为一个函数使用。这用作一般的重命名机制:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; fib
    &lt;function fib at 10042ed0&gt;
    &gt;&gt;&gt; <span style="color: #dcaeea;">f</span> = fib
    &gt;&gt;&gt; f(<span style="color: #da8548; font-weight: bold;">100</span>)
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #da8548; font-weight: bold;">3</span> <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #da8548; font-weight: bold;">8</span> <span style="color: #da8548; font-weight: bold;">13</span> <span style="color: #da8548; font-weight: bold;">21</span> <span style="color: #da8548; font-weight: bold;">34</span> <span style="color: #da8548; font-weight: bold;">55</span> <span style="color: #da8548; font-weight: bold;">89</span>
</pre>
</div>

<p>
如果你学过其他语言，你可能会认为 <code>fib</code> 不是函数而是一个过程，因为它并不返回值。事实上，即使没有 return 语句的函数也会返回一个值，尽管它是一个相当无聊的值。这个值称为 None （它是内置名称）。一般来说解释器不会打印出单独的返回值 None ，如果你真想看到它，你可以使用 print()
</p>
</div>
</div>

<div id="outline-container-orgf703fb3" class="outline-3">
<h3 id="orgf703fb3">函数定义的更多形式</h3>
<div class="outline-text-3" id="text-orgf703fb3">
</div>
<div id="outline-container-orgd0cb3b3" class="outline-4">
<h4 id="orgd0cb3b3">参数默认值</h4>
<div class="outline-text-4" id="text-orgd0cb3b3">
<p>
最有用的形式是对一个或多个参数指定一个默认值。这样创建的函数，可以用比定义时允许的更少的参数调用。
</p>

<p>
默认值是在 定义过程 中在函数定义处计算的，所以
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">5</span>

    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">f</span>(arg=i):
        <span style="color: #51afef;">print</span>(arg)

    <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">6</span>
    f()
</pre>
</div>

<p>
会打印 <code>5</code>
</p>

<p>
<b>重要警告</b> ： 默认值只会执行一次。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数:
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">f</span>(a, L=[]):
        L.append(a)
        <span style="color: #51afef;">return</span> L

    <span style="color: #51afef;">print</span>(f(<span style="color: #da8548; font-weight: bold;">1</span>))
    <span style="color: #51afef;">print</span>(f(<span style="color: #da8548; font-weight: bold;">2</span>))
    <span style="color: #51afef;">print</span>(f(<span style="color: #da8548; font-weight: bold;">3</span>))

    <span style="color: #5B6268;"># </span><span style="color: #5B6268;">&#23558;&#25171;&#21360;&#20986;</span>

    [<span style="color: #da8548; font-weight: bold;">1</span>]
    [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>]
    [<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>, <span style="color: #da8548; font-weight: bold;">3</span>]
</pre>
</div>

<p>
如果你不想要在后续调用之间共享默认值，你可以这样写这个函数:
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">f</span>(a, L=<span style="color: #a9a1e1;">None</span>):
        <span style="color: #51afef;">if</span> L <span style="color: #51afef;">is</span> <span style="color: #a9a1e1;">None</span>:
            <span style="color: #dcaeea;">L</span> = []
        L.append(a)
        <span style="color: #51afef;">return</span> L
</pre>
</div>
</div>
</div>

<div id="outline-container-orga4487af" class="outline-4">
<h4 id="orga4487af">关键字参数</h4>
<div class="outline-text-4" id="text-orga4487af">
<p>
也可以使用形如 <code>kwarg=value</code> 的 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-keyword-argument">关键字参数</a> 来调用函数。例如下面的函数:
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">parrot</span>(voltage, state=<span style="color: #98be65;">'a stiff'</span>, action=<span style="color: #98be65;">'voom'</span>, <span style="color: #c678dd;">type</span>=<span style="color: #98be65;">'Norwegian Blue'</span>):
        <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"-- This parrot wouldn't"</span>, action, end=<span style="color: #98be65;">' '</span>)
        <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"if you put"</span>, voltage, <span style="color: #98be65;">"volts through it."</span>)
        <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"-- Lovely plumage, the"</span>, <span style="color: #c678dd;">type</span>)
        <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"-- It's"</span>, state, <span style="color: #98be65;">"!"</span>)
</pre>
</div>

<p>
接受一个必需的参数（ <code>voltage</code> ）和三个可选的参数（ <code>state</code> , <code>action</code> ，和 <code>type</code> ）。这个函数可以通过下面的任何一种方式调用:
</p>

<div class="org-src-container">
<pre class="src src-python">    parrot(<span style="color: #da8548; font-weight: bold;">1000</span>)                                          <span style="color: #5B6268;"># </span><span style="color: #5B6268;">1 positional argument</span>
    parrot(voltage=<span style="color: #da8548; font-weight: bold;">1000</span>)                                  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">1 keyword argument</span>
    parrot(voltage=<span style="color: #da8548; font-weight: bold;">1000000</span>, action=<span style="color: #98be65;">'VOOOOOM'</span>)             <span style="color: #5B6268;"># </span><span style="color: #5B6268;">2 keyword arguments</span>
    parrot(action=<span style="color: #98be65;">'VOOOOOM'</span>, voltage=<span style="color: #da8548; font-weight: bold;">1000000</span>)             <span style="color: #5B6268;"># </span><span style="color: #5B6268;">2 keyword arguments</span>
    parrot(<span style="color: #98be65;">'a million'</span>, <span style="color: #98be65;">'bereft of life'</span>, <span style="color: #98be65;">'jump'</span>)         <span style="color: #5B6268;"># </span><span style="color: #5B6268;">3 positional arguments</span>
    parrot(<span style="color: #98be65;">'a thousand'</span>, state=<span style="color: #98be65;">'pushing up the daisies'</span>)  <span style="color: #5B6268;"># </span><span style="color: #5B6268;">1 positional, 1 keyword</span>
</pre>
</div>

<p>
在函数调用中，关键字参数必须跟随在位置参数的后面。传递的所有关键字参数必须与函数接受的其中一个参数匹配（比如 actor 不是函数 parrot 的有效参数），它们的顺序并不重要。这也包括非可选参数，（比如 parrot(voltage=1000) 也是有效的）。不能对同一个参数多次赋值。
</p>

<p>
存在一个形式为 <code>**name</code> 的最后一个形参时，它会接收一个字典 (参见 映射类型 &#x2014; dict)，其中包含除了与已有形参相对应的关键字参数以外的所有关键字参数。 这可以与一个形式为 <code>*name</code> ，接收一个包含除了与已有形参列表以外的位置参数的 元组 的形参 (将在下一小节介绍) 组合使用 (<code>*name</code> 必须出现在 <code>**name</code> 之前。)
</p>
</div>
</div>

<div id="outline-container-org62e4773" class="outline-4">
<h4 id="org62e4773">特殊参数</h4>
<div class="outline-text-4" id="text-org62e4773">
<p>
默认情况下，函数的参数传递形式可以是位置参数或是显式的关键字参数。 为了确保可读性和运行效率，限制允许的参数传递形式是有意义的，这样开发者只需查看函数定义即可确定参数项是仅按位置、按位置也按关键字，还是仅按关键字传递。
</p>

<p>
函数的定义看起来可以像是这样：
</p>

<div class="org-src-container">
<pre class="src src-python">    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">f</span>(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
          -----------    ----------     ----------
            |             |                  |
            |        Positional <span style="color: #51afef;">or</span> keyword   |
            |                                - Keyword only
             -- Positional only
</pre>
</div>

<p>
在这里 <code>/</code> 和 <code>*</code> 是可选的。如果使用这些符号则表明可以通过何种形参将参数值传递给函数：仅限位置、位置或关键字，以及仅限关键字。关键字形参也被称为命名形参。
</p>
</div>

<div id="outline-container-orgc0b2b13" class="outline-5">
<h5 id="orgc0b2b13">位置或关键字参数</h5>
<div class="outline-text-5" id="text-orgc0b2b13">
<p>
如果函数定义中未使用 <code>/</code> 和 <code>*</code> ，则参数可以按位置或按关键字传递给函数。
</p>
</div>
</div>

<div id="outline-container-org3f8af4e" class="outline-5">
<h5 id="org3f8af4e">仅限位置参数</h5>
<div class="outline-text-5" id="text-org3f8af4e">
<p>
在这里还可以发现更多细节，特定形参可以被标记为 仅限位置。 如果是 仅限位置 的形参，则其位置是重要的，并且该形参不能作为关键字传入。 仅限位置形参要放在 <code>/</code> (正斜杠) 之前。 这个 <code>/</code> 被用来从逻辑上分隔仅限位置形参和其它形参。 如果函数定义中没有 <code>/</code> ，则表示没有仅限位置形参。
</p>

<p>
在 <code>/</code> 之后的形参可以为 位置或关键字 或 仅限关键字。
</p>
</div>
</div>

<div id="outline-container-orgd182fdf" class="outline-5">
<h5 id="orgd182fdf">仅限关键字参数</h5>
<div class="outline-text-5" id="text-orgd182fdf">
<p>
要将形参标记为 仅限关键字，即指明该形参必须以关键字参数的形式传入，应在参数列表的第一个 仅限关键字 形参之前放置一个 <code>*</code> 。
</p>

<blockquote>
<p>
Note：仅限位置形参的名称可以在 <code>**kwds</code> 中使用而不产生歧义
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org44b2ffb" class="outline-5">
<h5 id="org44b2ffb">概括</h5>
<div class="outline-text-5" id="text-org44b2ffb">
<p>
<code>def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):</code>
</p>

<p>
作为指导：
</p>

<ul class="org-ul">
<li>如果你希望形参名称对用户来说不可用，则使用仅限位置形参。这适用于形参名称没有实际意义，以及当你希望强制规定调用时的参数顺序，或是需要同时收受一些位置形参和任意关键字形参等情况。</li>
<li>当形参名称有实际意义，以及显式指定形参名称可使函数定义更易理解，或者当你想要防止用户过于依赖传入参数的位置时，则使用仅限关键字形参。</li>
<li>对于 API
来说，使用仅限位置形参可以防止形参名称在未来被修改时造成破坏性的 API
变动。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org2e77522" class="outline-4">
<h4 id="org2e77522">任意的参数列表</h4>
<div class="outline-text-4" id="text-org2e77522">
<p>
最后，最不常用的选项是可以使用任意数量的参数调用函数。这些参数会被包含在一个元组里（参见 元组和序列 ）。在可变数量的参数之前，可能会出现零个或多个普通参数。
</p>

<p>
一般来说，这些 可变参数 将在形式参数列表的末尾，因为它们收集传递给函数的所有剩余输入参数。出现在 *args 参数之后的任何形式参数都是 ‘仅关键字参数'，也就是说它们只能作为关键字参数而不能是位置参数。
</p>
</div>
</div>

<div id="outline-container-orgd594c61" class="outline-4">
<h4 id="orgd594c61">Lambda 表达式</h4>
<div class="outline-text-4" id="text-orgd594c61">
<p>
可以用 lambda 关键字来创建一个小的匿名函数。这个函数返回两个参数的和： lambda a, b: a+b 。Lambda 函数可以在需要函数对象的任何地方使用。它们在语法上限于单个表达式。从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用所包含域的变量:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">def</span> <span style="color: #c678dd;">make_incrementor</span>(n):
    ...     <span style="color: #51afef;">return</span> <span style="color: #51afef;">lambda</span> x: x + n
    ...
    &gt;&gt;&gt; <span style="color: #dcaeea;">f</span> = make_incrementor(<span style="color: #da8548; font-weight: bold;">42</span>)
    &gt;&gt;&gt; f(<span style="color: #da8548; font-weight: bold;">0</span>)
    <span style="color: #da8548; font-weight: bold;">42</span>
    &gt;&gt;&gt; f(<span style="color: #da8548; font-weight: bold;">1</span>)
    <span style="color: #da8548; font-weight: bold;">43</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgcf7378a" class="outline-4">
<h4 id="orgcf7378a">文档字符串</h4>
<div class="outline-text-4" id="text-orgcf7378a">
<p>
以下是有关文档字符串的内容和格式的一些约定。
</p>

<p>
第一行应该是对象目的的简要概述。为简洁起见，它不应显式声明对象的名称或类型，因为这些可通过其他方式获得（除非名称恰好是描述函数操作的动词）。这一行应以大写字母开头，以句点结尾。
</p>

<p>
如果文档字符串中有更多行，则第二行应为空白，从而在视觉上将摘要与其余描述分开。后面几行应该是一个或多个段落，描述对象的调用约定，它的副作用等。
</p>

<p>
Python 解析器不会从 Python 中删除多行字符串文字的缩进，因此处理文档的工具必须在需要时删除缩进。 这是使用以下约定完成的。 文档字符串第一行 之后 的第一个非空行确定整个文档字符串的缩进量。（我们不能使用第一行，因为它通常与字符串的开头引号相邻，因此它的缩进在字符串文字中不明显。）然后从字符串的所有行的开头剥离与该缩进 "等效" 的空格。 缩进更少的行不应该出现，但是如果它们出现，则应该剥离它们的所有前导空格。 应在转化制表符为空格后测试空格的等效性（通常转化为 8 个空格）。
</p>

<p>
下面是一个多行文档字符串的例子:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">def</span> <span style="color: #c678dd;">my_function</span>():
    ...     <span style="color: #98be65;">"""Do nothing, but document it.</span>
<span style="color: #98be65;">    ...</span>
<span style="color: #98be65;">    ...     No, really, it doesn't do anything.</span>
<span style="color: #98be65;">    ...     """</span>
    ...     <span style="color: #51afef;">pass</span>
    ...
    &gt;&gt;&gt; <span style="color: #51afef;">print</span>(my_function.<span style="color: #c678dd;">__doc__</span>)
    Do nothing, but document it.

        No, really, it doesn<span style="color: #98be65;">'t do anything.</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge5bdad6" class="outline-4">
<h4 id="orge5bdad6">函数标注</h4>
<div class="outline-text-4" id="text-orge5bdad6">
<p>
函数标注 是关于用户自定义函数中使用的类型的完全可选元数据信息（有关详情请参阅 PEP 3107 和 PEP 484 ）。
</p>

<p>
函数标注 以字典的形式存放在函数的 <b>annotations</b> 属性中，并且不会影响函数的任何其他部分。 形参标注的定义方式是在形参名称后加上冒号，后面跟一个表达式，该表达式会被求值为标注的值。 返回值标注的定义方式是加上一个组合符号 -&gt;，后面跟一个表达式，该标注位于形参列表和表示 def 语句结束的冒号之间。 下面的示例有一个位置参数，一个关键字参数以及返回值带有相应标注:
</p>

<div class="org-src-container">
<pre class="src src-python">    &gt;&gt;&gt; <span style="color: #51afef;">def</span> <span style="color: #c678dd;">f</span>(ham: <span style="color: #c678dd;">str</span>, eggs: <span style="color: #c678dd;">str</span> = <span style="color: #98be65;">'eggs'</span>) -&gt; <span style="color: #c678dd;">str</span>:
    ...     <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"Annotations:"</span>, f.<span style="color: #c678dd;">__annotations__</span>)
    ...     <span style="color: #51afef;">print</span>(<span style="color: #98be65;">"Arguments:"</span>, ham, eggs)
    ...     <span style="color: #51afef;">return</span> ham + <span style="color: #98be65;">' and '</span> + eggs
    ...
    &gt;&gt;&gt; f(<span style="color: #98be65;">'spam'</span>)
    Annotations: {<span style="color: #98be65;">'ham'</span>: &lt;<span style="color: #51afef;">class</span> <span style="color: #98be65;">'str'</span>&gt;, <span style="color: #98be65;">'return'</span>: &lt;<span style="color: #51afef;">class</span> <span style="color: #98be65;">'str'</span>&gt;, <span style="color: #98be65;">'eggs'</span>: &lt;<span style="color: #51afef;">class</span> <span style="color: #98be65;">'str'</span>&gt;}
    Arguments: spam eggs
    <span style="color: #98be65;">'spam and eggs'</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org57fdc05" class="outline-2">
<h2 id="org57fdc05">Misc</h2>
<div class="outline-text-2" id="text-org57fdc05">
<ul class="org-ul">
<li><a href="https://docs.python.org/zh-cn/3/library/copy.html#shallow-vs-deep-copy">copy &#x2014; 浅层 (shallow) 和深层 (deep) 复制操作</a></li>
</ul>
</div>
</div>
<div id="outline-container-org606ec20" class="outline-2">
<h2 id="org606ec20">Links</h2>
<div class="outline-text-2" id="text-org606ec20">
<p>
<a href="https://docs.python.org/zh-cn/3/index.html">https://docs.python.org/zh-cn/3/index.html</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">&#20316;&#32773;: Petrus.Z</p>
<p class="date">Created: 2020-07-22 Wed 14:44</p>
</div>
</body>
</html>
