<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2020-09-09 Wed 21:01 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>C++ Primer 第 IV 部分 高级主题</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Petrus.Z">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<style> #content{max-width:1400px;}</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">C++ Primer 第 IV 部分 高级主题</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge32c2ba">第 17 章 标准库特殊设施</a>
<ul>
<li><a href="#org3002204">17.1 tuple 类型</a>
<ul>
<li><a href="#org76a9624">17.1.1 定义和初始化 tuple</a>
<ul>
<li><a href="#orgdba8ef2">关系和相等运算符</a></li>
</ul>
</li>
<li><a href="#orgba67282">17.1.2 使用 tuple 返回多个值</a></li>
</ul>
</li>
<li><a href="#org4e60bea">17.2 bitset 类型</a>
<ul>
<li><a href="#orgb561d11">17.2.1 定义和初始化 bitset</a>
<ul>
<li><a href="#org5ae9813">用 unsigned 值初始化 bitset</a></li>
<li><a href="#orgb710937">从一个 string 初始化 bitset</a></li>
</ul>
</li>
<li><a href="#orgd3e1a6d">17.2.2 bitset 操作</a>
<ul>
<li><a href="#orgcb96be6">提取 bitset 的值</a></li>
<li><a href="#org49262ff">bitset 的 IO 运算符</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org5b4577f">17.3 正则表达式</a>
<ul>
<li><a href="#orge3df8d7">17.3.1 使用正则表达式库</a>
<ul>
<li><a href="#org34023ff">指定 regex 对象的选项</a></li>
<li><a href="#org01b12e6">指定或使用正则表达式时的错误</a></li>
<li><a href="#org8ed6c23">正则表达式和输入序列类型</a></li>
</ul>
</li>
<li><a href="#org421cab0">17.3.2 匹配与 Regex 迭代器类型</a>
<ul>
<li><a href="#orgb280e75">使用匹配数据</a></li>
</ul>
</li>
<li><a href="#orgfd29434">17.3.3 使用子表达式</a>
<ul>
<li><a href="#org8e87fea">使用子匹配操作</a></li>
</ul>
</li>
<li><a href="#orgd153c26">17.3.4 使用 regex_replace</a>
<ul>
<li><a href="#org975aca3">用来控制匹配的格式的标志</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc05bb12">17.4 随机数</a>
<ul>
<li><a href="#org4a44624">17.4.1 随机数引擎和分布</a>
<ul>
<li><a href="#org74eea2e">分布类型和引擎</a></li>
<li><a href="#orgedf9e47">引擎生成一个数值序列</a></li>
<li><a href="#org973fca9">设计随机数发生器种子</a></li>
</ul>
</li>
<li><a href="#org6a97575">17.4.2 其他随机数分布</a>
<ul>
<li><a href="#org09876d3">生成随机实数</a></li>
<li><a href="#org824ec65">bernoulli_distribution 类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge662cb2">17.5 IO 库再探</a>
<ul>
<li><a href="#orga5efd9a">17.5.1 格式化输入与输出</a>
<ul>
<li><a href="#org544ebc6">很多操纵符改变格式状态</a></li>
<li><a href="#org97934f3">指定整型值的进制</a></li>
<li><a href="#orgf18d9be">指定浮点数记数法</a></li>
<li><a href="#orgf449f08">输出补白</a></li>
</ul>
</li>
<li><a href="#org559d636">17.5.2 未格式化的输入/输出操作</a>
<ul>
<li><a href="#orgbc038d4">单字节操作</a></li>
<li><a href="#orge047d25">将字符放回输入流</a></li>
<li><a href="#orga69b58e">从输入操作返回的 int 值</a></li>
<li><a href="#org1818289">多字节操作</a></li>
<li><a href="#org95aa527">确定读取了多少个字符</a></li>
</ul>
</li>
<li><a href="#org262dd52">17.5.3 流随机访问</a>
<ul>
<li><a href="#org2a5af93">seek 和 tell 函数</a></li>
<li><a href="#org8f09a66">只有一个标记</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgdbe1dd7">第 18 章 用于大型程序的工具</a>
<ul>
<li><a href="#org9cc074e">18.1 异常处理</a>
<ul>
<li><a href="#orgb879785">18.1.1 抛出异常</a>
<ul>
<li><a href="#org127ca03">栈展开</a></li>
<li><a href="#org3e7991b">栈展开过程中对象被自动销毁</a></li>
<li><a href="#org1e41187">析构函数与异常</a></li>
<li><a href="#org38bbdf1">异常对象</a></li>
</ul>
</li>
<li><a href="#orgd51b263">18.1.2 捕获异常</a>
<ul>
<li><a href="#orgac0831d">查找匹配的处理代码</a></li>
<li><a href="#org9bb0dca">重新抛出</a></li>
<li><a href="#org9491107">捕获所有异常的处理代码</a></li>
</ul>
</li>
<li><a href="#org1512981">18.1.3 函数 try 语句块和构造函数</a></li>
<li><a href="#org8524cc0">18.1.4 noexcept 异常说明</a>
<ul>
<li><a href="#orgc339f1d">违反异常说明</a></li>
<li><a href="#org807fb86">异常说明的实参</a></li>
<li><a href="#org1d11789">noexcept 运算符</a></li>
<li><a href="#orge5c9772">异常说明与指针、虚函数和拷贝控制</a></li>
</ul>
</li>
<li><a href="#orga71046f">18.1.5 异常类层次</a></li>
</ul>
</li>
<li><a href="#org8003ad3">18.2 命名空间</a>
<ul>
<li><a href="#org04fc7aa">18.2.1 命名空间定义</a>
<ul>
<li><a href="#org7b616db">每个命名空间都是一个作用域</a></li>
<li><a href="#org00d5359">命名空间可以不是连续的</a></li>
<li><a href="#orgd47d623">定义命名空间成员</a></li>
<li><a href="#orgc8569fd">模板特例化</a></li>
<li><a href="#org0301c07">全局命名空间</a></li>
<li><a href="#org443fbd0">内联命名空间</a></li>
<li><a href="#orga6c743a">未命名的命名空间</a></li>
</ul>
</li>
<li><a href="#orgf19440b">18.2.2 使用命名空间成员</a>
<ul>
<li><a href="#org4c5e35a">命名空间的别名</a></li>
<li><a href="#org441905d">using 声明：扼要概述</a></li>
<li><a href="#org12f39be">using 指示</a></li>
<li><a href="#orgdfc869a">头文件与 using 声明或指示</a></li>
</ul>
</li>
<li><a href="#orgc7b05da">18.2.3 类、命名空间与作用域</a>
<ul>
<li><a href="#org79917d2">实参相关的查找与类类型参数</a></li>
<li><a href="#org15c1d7b">友元声明与实参相关的查找</a></li>
</ul>
</li>
<li><a href="#org04a9196">18.2.4 重载与命名空间</a>
<ul>
<li><a href="#orgb184047">与实参相关的查找与重载</a></li>
<li><a href="#org00597fa">重载与 using 声明</a></li>
<li><a href="#orga998913">重载与 using 指示</a></li>
<li><a href="#org4c5b532">跨越多个 using 指针的重载</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc49242e">18.3 多重继承与虚继承</a>
<ul>
<li><a href="#org5eb1c0f">18.3.1 多重继承</a>
<ul>
<li><a href="#org5ec663b">多重继承的派生类从每个基类中继承状态</a></li>
<li><a href="#org9b45c6c">派生类初始化所有基类</a></li>
<li><a href="#org3a4489a">继承的构造函数与多重继承</a></li>
<li><a href="#org8a49d6a">析构函数与多重继承</a></li>
<li><a href="#org81f3ed1">多重继承和派生类的拷贝与移动操作</a></li>
</ul>
</li>
<li><a href="#org4de0d3e">18.3.2 类型转换与多个基类</a>
<ul>
<li><a href="#org0f3891e">基类指针类型或引用类型的查找</a></li>
</ul>
</li>
<li><a href="#org2b72f42">18.3.3 多重继承下的类作用域</a></li>
<li><a href="#org5ec5612">18.3.4 虚继承</a>
<ul>
<li><a href="#orga55b234">使用虚基类</a></li>
<li><a href="#org5c0fcbb">支持向基类的常规类型转换</a></li>
<li><a href="#org6179efd">虚基类成员的可见行</a></li>
</ul>
</li>
<li><a href="#orgf5edcdd">18.3.5 构造函数与虚继承</a>
<ul>
<li><a href="#orgcb7ce22">虚继承的对象的构造方式</a></li>
<li><a href="#orgac16f57">构造函数与析构函数的次序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#org029fdef">第 19 章 特殊工具与技术</a>
<ul>
<li><a href="#org29a5b4d">19.1 控制内存分配</a>
<ul>
<li><a href="#org960b0c4">19.1.1 重载 new 和 delete</a>
<ul>
<li><a href="#orga10b138">operator new 接口和 operator delete 接口</a></li>
</ul>
</li>
<li><a href="#orgd3ba628">19.1.2 定位 new 表达式</a>
<ul>
<li><a href="#orgbb17ac1">显示的析构函数调用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgca60bd1">19.2 运行时类型识别</a>
<ul>
<li><a href="#orge4e348c">19.2.1 dynamic_cast 运算符</a>
<ul>
<li><a href="#orga262467">指针类型的 dynamic_cast</a></li>
<li><a href="#orgbe2083a">引用类型的 dynamic_cast</a></li>
</ul>
</li>
<li><a href="#orga3802c0">19.2.2 typeid 运算符</a>
<ul>
<li><a href="#orgc4b0546">使用 typeid 运算符</a></li>
</ul>
</li>
<li><a href="#orga706d46">19.2.4 type_info 类</a></li>
</ul>
</li>
<li><a href="#org2198f02">19.3 枚举类型</a>
<ul>
<li>
<ul>
<li><a href="#org898f92d">枚举成员</a></li>
<li><a href="#orgc5f70de">和类一样，枚举也定义新的类型</a></li>
<li><a href="#org9c1a71f">指定 enum 的大小</a></li>
<li><a href="#org38e71ee">枚举类型的前置声明</a></li>
<li><a href="#org5719b77">形参匹配与枚举类型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4c1863b">19.4 类成员指针</a>
<ul>
<li><a href="#orgc660363">19.4.1 数据成员指针</a>
<ul>
<li><a href="#org73ec9eb">使用数据成员指针</a></li>
<li><a href="#orgc64fb5d">返回数据成员指针的函数</a></li>
</ul>
</li>
<li><a href="#orgd279c91">19.4.2 成员函数指针</a>
<ul>
<li><a href="#orgaa71ce0">使用成员函数指针</a></li>
<li><a href="#org494c911">使用成员指针的类型别名</a></li>
<li><a href="#org0ab2ac9">成员指针函数表</a></li>
</ul>
</li>
<li><a href="#orga8caca9">19.4.3 将成员函数用作可调用对象</a>
<ul>
<li><a href="#orgf16a023">使用 function 生成一个可调用对象</a></li>
<li><a href="#org683d498">使用 mem_fn 生成一个可调用对象</a></li>
<li><a href="#orgfa47c7e">使用 bind 生成一个可调用对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org20c4726">19.5 嵌套类</a>
<ul>
<li>
<ul>
<li><a href="#orgd07ea83">在外层类之外定义一个嵌套类</a></li>
<li><a href="#org0393ff1">嵌套类作用域中的名字查找</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgc5844ba">19.6 union：一种节省空间的类</a>
<ul>
<li>
<ul>
<li><a href="#org3f12765">定义 union</a></li>
<li><a href="#orgd1a34e3">使用 union 类型</a></li>
<li><a href="#org0b249af">匿名 union</a></li>
<li><a href="#orgabf4c2a">含有类类型成员的 union</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcf0e399">19.7 局部类</a>
<ul>
<li>
<ul>
<li><a href="#org31f4e63">局部类不能使用函数作用域中的变量</a></li>
<li><a href="#org5abc9ad">常规的访问保护规则对局部类同样适用</a></li>
<li><a href="#orga80d450">局部类中的名字查找</a></li>
<li><a href="#orgab7341d">嵌套的局部类</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgcf72d49">19.8 固有的不移植的特性</a>
<ul>
<li><a href="#org0523f36">19.8.1 位域</a></li>
<li><a href="#org93f93af">19.8.2 volatile 限定符</a>
<ul>
<li><a href="#org1e67342">合成的拷贝对 volatile 对象无效</a></li>
</ul>
</li>
<li><a href="#orgadc55cd">19.8.3 链接指示：extern "C"</a>
<ul>
<li><a href="#orge21dd2e">声明一个非 C++的函数</a></li>
<li><a href="#org5ce813d">链接指示与头文件</a></li>
<li><a href="#org68adff6">指向 extern "C"函数的指针</a></li>
<li><a href="#orgfff78b9">链接指示对整个声明都有效</a></li>
<li><a href="#org203ec94">导出 C++函数到其他语言</a></li>
<li><a href="#orgf3a9977">重载函数与链接指示</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orge32c2ba" class="outline-2">
<h2 id="orge32c2ba">第 17 章 标准库特殊设施</h2>
<div class="outline-text-2" id="text-orge32c2ba">
</div>
<div id="outline-container-org3002204" class="outline-3">
<h3 id="org3002204">17.1 tuple 类型</h3>
<div class="outline-text-3" id="text-org3002204">
<p>
<b>tuple</b> 是类似 pair 的模板。每个 pair 的成员类型都不相同，但每个 pair 都恰好有两个成员。不同 tuple 类型的成员类型也不相同，但一个 tuple 可以有任意数量的成员。每个确定的 tuple 类型的成员数目是固定的，但一个 tuple 类型的成员数目可以于另一个 tuple 类型不同。下表列出了 tuple 支持的操作。tuple 类型及其伴随类型和函数都定义在 tuple 头文件中
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;1&nbsp;</span> tuple 支持的操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">tuple&lt;T1, T2, &#x2026;, Tn&gt; t;</td>
<td class="org-left">t 是一个 tuple，成员数为 n，第 i 个成员的类型为 Ti，所有成员都进行值初始化</td>
</tr>

<tr>
<td class="org-left">tuple&lt;T1, T2, &#x2026;, Tn&gt; t(v1, v2, &#x2026;, vn);</td>
<td class="org-left">t 是一个 tuple，成员类型为 T1&#x2026;Tn，每个成员用对应的初始值 vi 进行初始化。此构造函数是 explicit 的</td>
</tr>

<tr>
<td class="org-left">make_tuple(v1, v2, &#x2026;, vn)</td>
<td class="org-left">返回一个用给定初始值初始化的 tuple。tuple 的类型从初始值的类型推断</td>
</tr>

<tr>
<td class="org-left">t1 == t2</td>
<td class="org-left">当两个 tuple 具有相同数量的成员且成员对应相等时，两个 tuple 相等。</td>
</tr>

<tr>
<td class="org-left">t1 != t2</td>
<td class="org-left">这两个操作使用成员的==运算符来完成。一旦发现某对成员不等，接下来的成员就不用比较了</td>
</tr>

<tr>
<td class="org-left">t1 relop t2</td>
<td class="org-left">tuple 的关系运算符使用字典序。两个 tuple 必须具有两同数量的成员。使用&lt;运算符比较 t1 的成员和 t2 中的对应成员</td>
</tr>

<tr>
<td class="org-left">get&lt;t&gt;(t)</td>
<td class="org-left">返回 t 的第 i 个数据成员的引用；如果 t 时一个左值，结果时一个左值引用；否则，结果时一个右值引用。tuple 的所有成员都是 public 的</td>
</tr>

<tr>
<td class="org-left">tuple_size&lt;tupleType&gt;::value</td>
<td class="org-left">一个类模板，可以通过 tuple 类型来初始化。它有一个名为 value 的 public constexpr static 数据成员，类型为 size_t，表示给定 tuple 类型中成员的数量</td>
</tr>

<tr>
<td class="org-left">tuple_element&lt;i, tupleType&gt;::type</td>
<td class="org-left">一个类模板，可以通过一个整型常量和一个 tuple 类型来初始化。它有一个名为 type 的 public 成员，表示给定 tuple 类型中指定成员的类型</td>
</tr>
</tbody>
</table>

<blockquote>
<p>
Note：
</p>

<p>
我们可以将 tuple 看作一个“快速而随意”的数据结构。
</p>
</blockquote>
</div>
<div id="outline-container-org76a9624" class="outline-4">
<h4 id="org76a9624">17.1.1 定义和初始化 tuple</h4>
<div class="outline-text-4" id="text-org76a9624">
</div>
<div id="outline-container-orgdba8ef2" class="outline-5">
<h5 id="orgdba8ef2">关系和相等运算符</h5>
<div class="outline-text-5" id="text-orgdba8ef2">
<blockquote>
<p>
Note：
</p>

<p>
由于 tuple 定义了&lt;和==运算符，我们可以将 tuple 序列传递给算法，并且可以在无序容器中将 tuple 作为关键字类型。
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgba67282" class="outline-4">
<h4 id="orgba67282">17.1.2 使用 tuple 返回多个值</h4>
<div class="outline-text-4" id="text-orgba67282">
<p>
tuple 的一个常见用途时从一个函数返回多个值。
</p>
</div>
</div>
</div>
<div id="outline-container-org4e60bea" class="outline-3">
<h3 id="org4e60bea">17.2 bitset 类型</h3>
<div class="outline-text-3" id="text-org4e60bea">
<p>
在 4.8 节中我们介绍了将整型运算对象当作二进制位集合处理的一些内置运算符。标准库还定义了 <b>bitset</b> 类，使得位运算符的使用更加容易，并且能够处理超过最长整型类型大小的位集合。bitset 类定义在头文件 bitset 中。
</p>
</div>
<div id="outline-container-orgb561d11" class="outline-4">
<h4 id="orgb561d11">17.2.1 定义和初始化 bitset</h4>
<div class="outline-text-4" id="text-orgb561d11">
<p>
下表列出了 bitset 的构造函数。bitset 类时一个类模板，他类似 array 类，具有固定的大小。当我们定义个 bitset 时，需要声明它包含多少个二进制位：
</p>

<p>
<code>bitset&lt;32&gt; bitvec(1U);  // 32 位；低位为1，其他位为0</code>
</p>

<p>
大小必须时一个常量表达式。这条语句定义 bitvec 为一个包含 32 位的 bitset。就像 vector 包含未命名的元素一样，bitset 中的二进制位也是未命名的，我们通过位置来访问它们。二进制的位置是从 0 开始编号的。因此，bitvec 包含编译从 0 到 31 的 32 个二进制位。编号从 0 开始的二进制位被称为 <b>低位(low-order)</b> ，编编号到 31 结束的二进制位被称为 <b>高位(high-order)</b> 。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;2&nbsp;</span> 初始化 bitset 的方法</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">bitset&lt;n&gt; b;</td>
<td class="org-left">b 有 n 位；每一位均为 0，此构造函数是一个 constexpr</td>
</tr>

<tr>
<td class="org-left">bitset&lt;n&gt; b(u);</td>
<td class="org-left">b 是 unsigned long long 值 u 的低 n 位的拷贝。如果 n 大于 unsigned long long 的大小，则 b 中超出 unsigned long long 的高位被置位 0。此构造函数是一个 constexpr</td>
</tr>

<tr>
<td class="org-left">bitset&lt;n&gt; b(s, pos, m, zero, one);</td>
<td class="org-left">b 是 string s 从位置 pos 开始 m 个字符的拷贝。s只能包含字符 zero 或 one；如果 s 包含任何其他字符，构造函数会抛出 invaid_argument 异常。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">字符在 b 中分别保存为 zero 和 one，pos 默认为 0，m 默认为 string::npos，zero 默认为'o'，one 默认为'1'</td>
</tr>

<tr>
<td class="org-left">bitset&lt;n&gt; b(cp, pos, m, zero, one);</td>
<td class="org-left">与上一个构造函数相同，但从 cp 指向的字符数组中拷贝字符，如果未提供 m，则 cp 必须指向一个 C 风格字符串。如果提供了 m，则 cp 开始必须至少有 m 个 zero 或 one 字符</td>
</tr>
</tbody>
</table>

<p>
接受一个 string 或一个字符指针的构造函数是 explicit 的。在新标准中增加了为 0 和 1 执行其他字符的功能。
</p>
</div>
<div id="outline-container-org5ae9813" class="outline-5">
<h5 id="org5ae9813">用 unsigned 值初始化 bitset</h5>
<div class="outline-text-5" id="text-org5ae9813">
<p>
当我们使用一个整型值来初始化 bitset 时，此值将被转换为 unsigned long long 类型并被当作位模式来处理。bitset 中的二进制位将是此模式的一个副本。如果 bitset 的大小大于一个 unsigned long long 中的二进制位数，则剩余的高位被置位 0。如果 bitset 的大小小于一个 unsigned long long 中的二进制位数，则只使用给定值中的低位，超出 bitset 大小的高位被丢弃：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">bitvec1&#27604;&#21021;&#22987;&#20540;&#23567;&#65307;&#21021;&#22987;&#20540;&#20013;&#30340;&#39640;&#20301;&#34987;&#20002;&#24323;</span>
<span style="color: #ECBE7B;">bitset</span>&lt;<span style="color: #da8548; font-weight: bold;">13</span>&gt; <span style="color: #dcaeea;">bitvec1</span>(<span style="color: #da8548; font-weight: bold;">0xbeef</span>);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20108;&#36827;&#21046;&#20301;&#24207;&#21015;&#20026;1111011101111</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">bitvec2&#27604;&#21021;&#22987;&#20540;&#22823;&#65307;&#23427;&#30340;&#39640;&#20026;&#34987;&#32622;&#20301;0</span>
<span style="color: #ECBE7B;">bitset</span>&lt;<span style="color: #da8548; font-weight: bold;">20</span>&gt; <span style="color: #dcaeea;">bitvec2</span>(<span style="color: #da8548; font-weight: bold;">0xbeef</span>);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20108;&#36827;&#21046;&#20301;&#24207;&#21015;&#20026;00001011111011101111</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22312;64&#20301;&#26426;&#22120;&#20013;&#65292;long long 0ULL&#26159;64&#20010;0&#27604;&#29305;&#65292;&#22240;&#27492;~0ULL&#26159;64&#20010;1</span>
<span style="color: #ECBE7B;">bitset</span>&lt;<span style="color: #da8548; font-weight: bold;">64</span>&gt; <span style="color: #dcaeea;">bitvec3</span>(~<span style="color: #da8548; font-weight: bold;">0ULL</span>);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">0-63&#20301;&#20026;1&#65307;63-127&#20301;&#20026;0</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb710937" class="outline-5">
<h5 id="orgb710937">从一个 string 初始化 bitset</h5>
<div class="outline-text-5" id="text-orgb710937">
<p>
我们可以从一个 string 或字符数组指针来初始化 bitset。两种情况下，字符都直接表示位模式。与往常一样，当我们使用字符串表示数时，字符串中下标最小的字符对应高位，反之亦然：
</p>

<p>
<code>bitset&lt;32&gt; bitvec4("1100");  // 2、3两位为1，剩余两位为0</code>
</p>

<p>
如果 string 包含的字符数比 bitset 少，则 bitset 的高位被置位 0。
</p>

<blockquote>
<p>
Note：
</p>

<p>
string 的下标编号习惯与 bitset 恰好相反；string 中下标最大的字符（最右字符）用来初始化 bitset 中的低位（下标为 0 的二进制位）。当你用一个 string 初始化一个 bitset 时，要记住这个差别。
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgd3e1a6d" class="outline-4">
<h4 id="orgd3e1a6d">17.2.2 bitset 操作</h4>
<div class="outline-text-4" id="text-orgd3e1a6d">
<p>
bitset 操作定义了多种检测或设置一个或多个二进制位的方法。bitset 类还支持我们在 4.8 节中介绍过的位运算符。这些运算符用于 bitset 对象的含义与内置运算符用于 unsigned 运算对象相同。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;3&nbsp;</span> bitset 操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">b.any()</td>
<td class="org-left">b 中是否存在置位的二进制位</td>
</tr>

<tr>
<td class="org-left">b.all()</td>
<td class="org-left">b 中所有位都置位了吗</td>
</tr>

<tr>
<td class="org-left">b.none()</td>
<td class="org-left">b 中不那在置位的二进制位吗</td>
</tr>

<tr>
<td class="org-left">b.count()</td>
<td class="org-left">b 中置位的位数</td>
</tr>

<tr>
<td class="org-left">b.size()</td>
<td class="org-left">一个 constexpr 函数，返回 b 中的位数</td>
</tr>

<tr>
<td class="org-left">b.test(pos)</td>
<td class="org-left">u 哦 pos 位置的位是置位的，则返回 true，否则返回 false</td>
</tr>

<tr>
<td class="org-left">b.set(pos,v)</td>
<td class="org-left">将位置 pos 处的位设置为 bool 值 v。v 默认为 true。</td>
</tr>

<tr>
<td class="org-left">b.set()</td>
<td class="org-left">如果未传递实参，则将 b 中所有位置位</td>
</tr>

<tr>
<td class="org-left">b.reset()</td>
<td class="org-left">将位置 pos 处的位复位或将 b 中所有位复位</td>
</tr>

<tr>
<td class="org-left">b.reset()</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">b.flip(pos)</td>
<td class="org-left">改变位置 pos 处的位的状态或改变 b 中每一位的状态</td>
</tr>

<tr>
<td class="org-left">b.flip()</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">b[pos]</td>
<td class="org-left">访问 b 中位置 pos 处的位；如果 b 是 const 的，则当该位置位时 b[pos]返回一个 bool 值 true，否则返回 false</td>
</tr>

<tr>
<td class="org-left">b.to_ulong()</td>
<td class="org-left">返回一个 unsigned long 或一个 unsigned long long 值，其位模式与 b 相同。如果 b 中位模式不能放入指定的结果类型，则抛出一个 overflow_error 异常</td>
</tr>

<tr>
<td class="org-left">b.to_ullong()</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">b.to_string(zero, one)</td>
<td class="org-left">返回一个 string，表示 b 中的位模式。zero 和 one 的默认值分别为 0 和 1，用来表示 b 中的 0 和 1</td>
</tr>

<tr>
<td class="org-left">os &lt;&lt; b</td>
<td class="org-left">将 b 中二进制打印为字符 1 或 0，打印到流 os</td>
</tr>

<tr>
<td class="org-left">is &gt;&gt; b</td>
<td class="org-left">从 is 读取字符存入 b。当下一个字符不是 1 或 0 时，或是已经读入 b.size()个位时，读取过程停止</td>
</tr>
</tbody>
</table>

<p>
count、size、all、any 和 none 等几个操作都不接受参数，返回整个 bitset 的状态。其他操作——set、reset 和 flip 则改变 bitset 的状态。改变 bitset 状态的成员函数都是重载的。对每个函数，不接受参数的版本对整个集合执行给定的操作：接受一个位置参数的版本则对指定位执行操作。
</p>

<p>
下标运算符对 const 属性进行了重载，const 版本的下标运算符在指定位置时返回 true，否则返回 false。非 const 版本返回 bitset 定义的一个特殊类型，它允许我们操纵指定位的值：
</p>

<div class="org-src-container">
<pre class="src src-C++">bitvec[<span style="color: #da8548; font-weight: bold;">0</span>] = <span style="color: #da8548; font-weight: bold;">0</span>;            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23558;&#31532;&#19968;&#20301;&#22797;&#20301;</span>
bitvec[<span style="color: #da8548; font-weight: bold;">31</span>] = bitvec[<span style="color: #da8548; font-weight: bold;">0</span>];   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23558;&#26368;&#21518;&#19968;&#20301;&#35774;&#32622;&#20026;&#19982;&#31532;&#19968;&#20301;&#19968;&#26679;</span>
bitvec[<span style="color: #da8548; font-weight: bold;">0</span>].flip();         <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#32763;&#36716;&#31532;&#19968;&#20301;</span>
~bitvec[<span style="color: #da8548; font-weight: bold;">0</span>];               <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#31561;&#20215;&#25805;&#20316;&#65292;&#20063;&#26159;&#32763;&#36716;&#31532;&#19968;&#20301;</span>
<span style="color: #ECBE7B;">bool</span> <span style="color: #dcaeea;">b</span> = bitvec[<span style="color: #da8548; font-weight: bold;">0</span>];       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23558;bitvec[0]&#30340;&#20540;&#36716;&#25442;&#20026;bool&#31867;&#22411;</span>
</pre>
</div>
</div>
<div id="outline-container-orgcb96be6" class="outline-5">
<h5 id="orgcb96be6">提取 bitset 的值</h5>
<div class="outline-text-5" id="text-orgcb96be6">
<p>
to_ulong 和 to_ullong 操作都返回一个值，保存了与 bitset 对象相同的位模式。只有当 bitset 的大小小于等于对应的大小（to_ulong 为 unsigned long，to_ullong 为 unsigned long long）时，我们才能使用这两个操作。
</p>

<blockquote>
<p>
Note：
</p>

<p>
如果 bitset 中的值不能放入给定类型中，则这两个操作会抛出一个 overflow_error 异常。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org49262ff" class="outline-5">
<h5 id="org49262ff">bitset 的 IO 运算符</h5>
<div class="outline-text-5" id="text-org49262ff">
<p>
输入运算符从一个输入流读取字符，保存到一个临时的 string 对象中。直接读取的字符数达到对应 bitset 的大小时，或是遇到不是 1 或 0 的字符时，或是遇到文件尾或输入错误时，读取过程才对停止。随即用临时 string 对象来初始化 bitset。如果读取的字符小于 bitset 的大小，则与往常一样，高位将被置位 0.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org5b4577f" class="outline-3">
<h3 id="org5b4577f">17.3 正则表达式</h3>
<div class="outline-text-3" id="text-org5b4577f">
<p>
我们重点介绍如果使用 C++正则表达式库（RE 库），它是新标准库的一部分。RE 库定义在头文件 regex 中，它包含多个组件。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;4&nbsp;</span> 正则表达式库组件</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">regex</td>
<td class="org-left">表示有一个正则表达式的类</td>
</tr>

<tr>
<td class="org-left">regex_match</td>
<td class="org-left">将一个字符序列与正则表达式匹配</td>
</tr>

<tr>
<td class="org-left">regex_search</td>
<td class="org-left">寻找第一个与正则表达式匹配的子序列</td>
</tr>

<tr>
<td class="org-left">regex_replace</td>
<td class="org-left">使用给定格式替换一个正则表达式</td>
</tr>

<tr>
<td class="org-left">sregex_iterator</td>
<td class="org-left">迭代器适配器，调用 regex_search 来遍历一个 string 中所有匹配的子串</td>
</tr>

<tr>
<td class="org-left">smatch</td>
<td class="org-left">容器类，保存在 string 中搜索的结果</td>
</tr>

<tr>
<td class="org-left">ssub_match</td>
<td class="org-left">string 中匹配的子表达式的结果</td>
</tr>
</tbody>
</table>

<p>
<b>regex</b> 类表示一个正则表达式。除了初始化和赋值之外，regex 还支持其他一些操作。
</p>

<p>
函数 <b>regex_match</b> 和 <b>regex_search</b> 确定一个给定字符序列与一个给定 regex 是否匹配。如果整个输入序列与表达式序列匹配，则 regex_match 函数返回 true；如果输入序列中有一个子串与表达式匹配，则 regex_search 函数返回 true。还有一个 regex_replace 函数，我们将在 17.3.4 节中介绍。
</p>

<p>
下表列出了 regex 的函数参数。这些函数都返回 bool 值，且都被重载了：其中一个版本接受一个类型为 <b>smatch</b> 的附加参数。如果匹配成功，这些函数将成功匹配的相关信息保存在给定的 smatch 对象中。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;5&nbsp;</span> regex_search 和 regex_match 的参数</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">注意：这些操作返回 bool 值，指出是否找到 i 匹配。</td>
</tr>

<tr>
<td class="org-left">(seq, m, r, mft)</td>
<td class="org-left">在字符序列 seq 中查找 regex 对象 r 中的正则表达式。seq 可以是一个 string、表是范围的一堆迭代器以及一个指向空字符结尾的字符串数组的指针</td>
</tr>

<tr>
<td class="org-left">(seq, r, mft)</td>
<td class="org-left">m 是一个 match 对象，用来保存匹配结果的相关细节。m和 seq 必须具有兼容的类型（参见 17.3.1 节）</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">mft 是一个可选的 regex_constants::match_flag_type 值。表 17.13 描述了这些值，他们会影响匹配过程</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-orge3df8d7" class="outline-4">
<h4 id="orge3df8d7">17.3.1 使用正则表达式库</h4>
<div class="outline-text-4" id="text-orge3df8d7">
</div>
<div id="outline-container-org34023ff" class="outline-5">
<h5 id="org34023ff">指定 regex 对象的选项</h5>
<div class="outline-text-5" id="text-org34023ff">
<p>
当我们定义一个 regex 或是对一个 regex 调用 assign 为其赋予新值时，可以指定一些标志来影响 regex 如何操作。这些标志控制 regex 对象的处理过程。下标列出的最后 6 个标志指出编写正则表达式所用的语言。对这 6 个标志，我们必须设置其中之一，且只能设置一个。默认情况下，ECMAScript 标志被设置，从而 regex 会使用 ECMA-262 规范，这也是很多 Web 浏览器所使用的正则表达式语言。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;6&nbsp;</span> regex（和 wregex）选项</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">regex r(re)</td>
<td class="org-left">re 表是一个正则表达式，它可以是一个 string、一个表示字符范围的迭代器对、一个指向空字符结尾的字符数据的指针、一个字符指针 h 额一个计数器或是一个花括号包围的字符列表。</td>
</tr>

<tr>
<td class="org-left">regex r(re, f)</td>
<td class="org-left">f 是指出对象如何处理的标志。f通过下面列出的值来设置。如果未指定 f，其默认值为 ECMAScript</td>
</tr>

<tr>
<td class="org-left">r1 = re</td>
<td class="org-left">将 r1 中的正则表达式替换为 re。re 表是一个正则表达式，它可以是另一个 regex 对象、一个 string、一个指向空字符结尾的字符数组的指针或一个花括号包围的字符列表</td>
</tr>

<tr>
<td class="org-left">r1.assign(re, f)</td>
<td class="org-left">与使用赋值运算符（=）效果相同；可选的标志 f 与 regex 的构造函数中对应的参数含义相同</td>
</tr>

<tr>
<td class="org-left">r.mark_count()</td>
<td class="org-left">r 中子表达式的数目（我们将在 17.3.3 节中介绍）</td>
</tr>

<tr>
<td class="org-left">r.flags()</td>
<td class="org-left">返回 r 的标志集</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">注：构造函数和赋值操作可能会包出类型为 regex_error 的异常</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left"><b>定义 regex 时指定的标志</b></td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">定义在 regex 和 regex_constants::syntax_option_type 中</td>
</tr>

<tr>
<td class="org-left">icase</td>
<td class="org-left">在匹配过程中忽略大小写</td>
</tr>

<tr>
<td class="org-left">nosbus</td>
<td class="org-left">不保存匹配的子表达式</td>
</tr>

<tr>
<td class="org-left">optimize</td>
<td class="org-left">执行速度优于构造速度</td>
</tr>

<tr>
<td class="org-left">ECMAScript</td>
<td class="org-left">使用 ECMA-262 指定的语法</td>
</tr>

<tr>
<td class="org-left">basic</td>
<td class="org-left">使用 POSIX 基本的正则表达式语法</td>
</tr>

<tr>
<td class="org-left">extended</td>
<td class="org-left">使用 POSIX 扩展的正则表达式语法</td>
</tr>

<tr>
<td class="org-left">awk</td>
<td class="org-left">使用 POSIX 版本的 awk 语言的语法</td>
</tr>

<tr>
<td class="org-left">grep</td>
<td class="org-left">使用 POSIX 版本的 grep 的语法</td>
</tr>

<tr>
<td class="org-left">egrep</td>
<td class="org-left">使用 POSIX 版本的 egrep 的语法</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org01b12e6" class="outline-5">
<h5 id="org01b12e6">指定或使用正则表达式时的错误</h5>
<div class="outline-text-5" id="text-org01b12e6">
<p>
我们可以将正则表达式本身看作用一种简单程序设计语言编写的“程序”。这种语言不是由 C++编译器解释的。正则表达式是在运行时，当一个 regex 对象被初始化或被赋予一个新模式时，才被“编译”的。与任何其他程序设计语言一样，当我们用这种语言编写正则表达式也可能有错误。
</p>

<blockquote>
<p>
Note：
</p>

<p>
需要意识到的非常重要的一点是，一个正则表达式的语法是否正确是在运行时解析的。
</p>
</blockquote>

<p>
如果我们编写的正则表达式存在错误，则在运行时标准库会抛出一个类型为 <b>regex_error</b> 的异常。类似标准异常类型，regex_error 有一个 what 操作来描述发生了什么错误。regex_error 还有一个名为 code 的成员，用来返回某个错误类型对应的数值编码。code 返回的值是由具体实现定义的。RE 库能抛出的标准错误如下表所示：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">try</span> {
  <span style="color: #5B6268;">//  </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;alnum&#28431;&#25481;&#20102;&#21491;&#25324;&#21495;&#65292;&#26500;&#36896;&#20989;&#25968;&#20250;&#25243;&#20986;&#24322;&#24120;</span>
  <span style="color: #ECBE7B;">regex</span> <span style="color: #dcaeea;">r</span>(<span style="color: #98be65;">"[[:alnum:]+\\.(cpp|cxx|cc)$"</span>, <span style="color: #a9a1e1;">regex</span>::icase);
} <span style="color: #51afef;">catch</span> (<span style="color: #ECBE7B;">regex_error</span> <span style="color: #dcaeea;">e</span>)
  { cout &lt;&lt; e.what() &lt;&lt; <span style="color: #98be65;">"\ncode:"</span> &lt;&lt; e.code() &lt;&lt; endl; }
</pre>
</div>

<table>
<caption class="t-above"><span class="table-number">&#34920;7&nbsp;</span> 正则表达式错误类型</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">定义在 regex 和 regex_constants::error_type 中</td>
</tr>

<tr>
<td class="org-left">error_collate</td>
<td class="org-left">无效的元素校对请求</td>
</tr>

<tr>
<td class="org-left">error_ctype</td>
<td class="org-left">无效的字符类</td>
</tr>

<tr>
<td class="org-left">error_escape</td>
<td class="org-left">无效的转义字符或无效的尾置转义</td>
</tr>

<tr>
<td class="org-left">error_backref</td>
<td class="org-left">无效的向后引用</td>
</tr>

<tr>
<td class="org-left">error_brack</td>
<td class="org-left">不匹配的方括号（[或]）</td>
</tr>

<tr>
<td class="org-left">error_paren</td>
<td class="org-left">不匹配的小括号（(或)）</td>
</tr>

<tr>
<td class="org-left">error_brace</td>
<td class="org-left">不匹配的花括号（{或}）</td>
</tr>

<tr>
<td class="org-left">error_badbrace</td>
<td class="org-left">{}中无效的范围</td>
</tr>

<tr>
<td class="org-left">error_range</td>
<td class="org-left">无效的字符范围（如[z-a]）</td>
</tr>

<tr>
<td class="org-left">error_space</td>
<td class="org-left">内存不足，无法处理此正则表达式</td>
</tr>

<tr>
<td class="org-left">error_badrepeat</td>
<td class="org-left">重复字符（*、?、+或{）之前没有有效的正则表达式</td>
</tr>

<tr>
<td class="org-left">error_complexity</td>
<td class="org-left">要求的匹配过于复杂</td>
</tr>

<tr>
<td class="org-left">error_stack</td>
<td class="org-left">栈空间不足，无法处理分配</td>
</tr>
</tbody>
</table>

<p>
我们的编译器定义了 code 成员，返回比上表列出的错误类型的编号，与往常一样，编号从 0 开始。
</p>

<blockquote>
<p>
建议：避免创建不必要的正则表达式
</p>

<p>
如我们所见，一个正则表达式所表是的“程序”是在运行时而非编译时编译的。正则表达式的编译是一个非常慢的操作，特别时在你使用了扩展的正则表达式语法或复杂的正则表达式时。因此，构造一个 regex 对象以及向一个已存在的 regex 赋予一个新的正则表达式大可能时非常耗时的。为了最小化这种开销，你应该努力避免创建很多不必要的 regex。特别是，如果你在一个循环中使用正则表达式，应该在循环外创建它，而不是在每步迭代时都编译它。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org8ed6c23" class="outline-5">
<h5 id="org8ed6c23">正则表达式和输入序列类型</h5>
<div class="outline-text-5" id="text-org8ed6c23">
<p>
我们可以搜索多种类型的输入序列。输入可以是普通 char 数据或 wchar_t 数据，字符可以保存在标准库 string 中或是 char 数组中（或是宽字符版本，wstring 或 wchat_t 数组中。RE 为这些不同的输入序列类型都定义了对应的类型。
</p>

<p>
例如，regex 类保存类型 char 的正则表达式。标准库还定义了一个 wregex 诶保存类型 wchar_t，其操作与 regex 完全相同。两种唯一的差别是 wregex 的初始值必须使用 wchar_t 而不是 char。
</p>

<p>
匹配和迭代器类型（我们将在下面小节中介绍）更为特殊。这些类型的差异不仅在于字符类型，还在于序列是在标准库 string 中还是在数组中：smatch 表示 string 类型的输入序列；cmatch 表示字符数组序列；wsmatch 表示宽字符串（wstring）输入；而 wcmatch 表示宽字符数组。
</p>

<p>
重点再与我们使用的 RE 库类型必须与输入序列类型匹配。下标列出了 RE 库类型与输入序列类型的对应关系。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;8&nbsp;</span> 正则表达式库类</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">如果输入序列类型</th>
<th scope="col" class="org-left">则使用正则表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">string</td>
<td class="org-left">regex、smatch、ssub_match 和 sregex_iterator</td>
</tr>

<tr>
<td class="org-left">const char*</td>
<td class="org-left">regex、cmatch、csub_match 和 cregex_iterator</td>
</tr>

<tr>
<td class="org-left">wstring</td>
<td class="org-left">wregex、wsmatch、wssub_match 和 wsregex_iterator</td>
</tr>

<tr>
<td class="org-left">const wchar_t*</td>
<td class="org-left">wregex、wcmatch、wcsub_match 和 wcregex_iterator</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org421cab0" class="outline-4">
<h4 id="org421cab0">17.3.2 匹配与 Regex 迭代器类型</h4>
<div class="outline-text-4" id="text-org421cab0">
<p>
regex 迭代器是一种迭代器适配器（参见 9.6 节），被绑定到一个输入序列和一个 regex 对象上。如上表所述，每种不同的输入序列类型都有对应的特殊 regex 迭代器类型。迭代器操作如下表所述。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;9&nbsp;</span> sregex_iterator 操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">这些操作也适用于 cregex_iterator、wsregex_iterator 和 wcregex_iterator</td>
</tr>

<tr>
<td class="org-left">sregex_iterator</td>
<td class="org-left">一个 sregex_iterator，遍历迭代器 b 和 e 指定的 string</td>
</tr>

<tr>
<td class="org-left">it(b, e, r)</td>
<td class="org-left">它调用 sregex_search(b, e, r)将 it 定位到输入中第一个匹配的位置</td>
</tr>

<tr>
<td class="org-left">sregex_iterator end;</td>
<td class="org-left">sregex_iterator 的尾后迭代器</td>
</tr>

<tr>
<td class="org-left">*it</td>
<td class="org-left">根据最后一个调用 regex_search 的结果，返回一个 smatch 对象的引用或一个指向指向 smatch 对象的指针</td>
</tr>

<tr>
<td class="org-left">it-&gt;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">++it</td>
<td class="org-left">从输入序列当前匹配尾值开始调用 regex_search。前置版本返回递增后迭代器；后置版本返回旧值</td>
</tr>

<tr>
<td class="org-left">it++</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">it1 == it2</td>
<td class="org-left">如果两个 sregex_iterator 都是尾后迭代器，则他们相等。如果两个非尾后迭代器都是从相同的输入序列和 regex 对象构造，则它们相等</td>
</tr>
</tbody>
</table>

<p>
当我们将一个 sregex_iterator 绑定到一个 string 和一个 regex 对象时，迭代器自动定位到给定 string 中第一个匹配尾值。即，sregex_iterator 构造函数对给定 string 和 regex 调用 regex_search。当我们解引用迭代器时，会得到一个对应最近一次搜索结果的 smatch 对象。当我们递增迭代器时，它调用 regex_search 在输入 string 中查找下一个匹配。
</p>
</div>
<div id="outline-container-orgb280e75" class="outline-5">
<h5 id="orgb280e75">使用匹配数据</h5>
<div class="outline-text-5" id="text-orgb280e75">
<table>
<caption class="t-above"><span class="table-number">&#34920;10&nbsp;</span> smatch 操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">这些操作也适用于 cmatch、wsmatch、wcmatch 和对应的 csub_match、wssub_match 和 wcsub_match</td>
</tr>

<tr>
<td class="org-left">m.ready()</td>
<td class="org-left">如果已经通过调用 regex_search 或 regex_match 设置了 m，则返回 true；否则返回 false，如果 ready 返回 false，则对 m 进行操作时未定义的</td>
</tr>

<tr>
<td class="org-left">m.size()</td>
<td class="org-left">如古匹配失败，则返回 0；否则返回最近一次匹配的正则表达式中子表达式的数目</td>
</tr>

<tr>
<td class="org-left">m.empty()</td>
<td class="org-left">若 m.size()为 0，则返回 true</td>
</tr>

<tr>
<td class="org-left">m.prefix()</td>
<td class="org-left">一个 ssub_match 对象，表示当前匹配之前的序列</td>
</tr>

<tr>
<td class="org-left">m.suffix()</td>
<td class="org-left">一个 ssub_match 对象，表示当前匹配之后的部分</td>
</tr>

<tr>
<td class="org-left">m.format(&#x2026;)</td>
<td class="org-left">见表 17.12</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">在接受一个索引的操作中，n的默认值为 0 且必须小于 m.szie()。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">第一个子匹配（索引为 0）表示整个匹配</td>
</tr>

<tr>
<td class="org-left">m.length(n)</td>
<td class="org-left">第 n 个匹配的子表达式的大小</td>
</tr>

<tr>
<td class="org-left">m.position(n)</td>
<td class="org-left">第 n 个子表达式距序列开始的距离</td>
</tr>

<tr>
<td class="org-left">m.str(n)</td>
<td class="org-left">第 n 个子表达式 i 匹配的 string</td>
</tr>

<tr>
<td class="org-left">m[n]</td>
<td class="org-left">对应第 n 个子表达式的 ssub_match 对象</td>
</tr>

<tr>
<td class="org-left">m.begin(),m.end()</td>
<td class="org-left">表示 m 中 sub_match 元素范围的迭代器。与往常一样，cbegin 和 cend 返回 const_iterator</td>
</tr>

<tr>
<td class="org-left">m.cbegin(),m.cend()</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgfd29434" class="outline-4">
<h4 id="orgfd29434">17.3.3 使用子表达式</h4>
<div class="outline-text-4" id="text-orgfd29434">
<p>
正则表达式的模式通常包含一个或多个 <b>子表达式</b> 。一个子表达式时模式的一部分，本身也具有意义。正则表达式语法通常用括号表示子表达式。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">r&#26377;&#20004;&#20010;&#23376;&#34920;&#36798;&#24335;&#65306;&#31532;&#19968;&#20010;&#26159;&#28857;&#20043;&#21069;&#34920;&#31034;&#25991;&#20214;&#21517;&#30340;&#37096;&#20998;&#65292;&#31532;&#20108;&#20010;&#34920;&#31034;&#25991;&#20214;&#25193;&#23637;&#21517;</span>
<span style="color: #ECBE7B;">regex</span> <span style="color: #dcaeea;">r</span>(<span style="color: #98be65;">"([[:alnum:]]+)\\.(cpp|cxx|cc)$"</span>, <span style="color: #a9a1e1;">regex</span>::icase);
</pre>
</div>

<p>
上述模式包含两个括号括起来的子表达式：
</p>
<ul class="org-ul">
<li><code>([[:alnum:]]+)</code> ，匹配一个或多个字符的序列</li>
<li><code>(cpp|cxx+cc)</code> ，匹配文件扩展名</li>
</ul>

<p>
匹配对象除了提供匹配整体的相关信息外，还提供访问模式中每个子表达式的能力。子匹配是按位置来访问的。第一个子匹配位置为 0,表示整个模式对应的匹配，随后是每个子表达式对应的匹配。因此，本例模式中第一个子表达式，即表示文件名的子表达式，其位置为 1，而文件扩展名对应的子表达式位置为 2.
</p>

<p>
例如，如果文件名为 foo.cpp，则 results.str(0)将保存 foo.cpp；results.str(1)将保存 foo；而 results.str(2)将保存 cpp。
</p>
</div>
<div id="outline-container-org8e87fea" class="outline-5">
<h5 id="org8e87fea">使用子匹配操作</h5>
<div class="outline-text-5" id="text-org8e87fea">
<table>
<caption class="t-above"><span class="table-number">&#34920;11&nbsp;</span> 子匹配操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">注意：这些操作适用于 ssub_match、csub_match、wssub_match、wcsub_match。</td>
</tr>

<tr>
<td class="org-left">matched</td>
<td class="org-left">一个 public bool 数据成员，指出此 ssub_match 是否匹配了</td>
</tr>

<tr>
<td class="org-left">first</td>
<td class="org-left">public 数据成员，指向匹配函徐序列首元素和尾后位置的迭代器。如果未匹配，则 first 和 second 是相等的</td>
</tr>

<tr>
<td class="org-left">second</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">legnth()</td>
<td class="org-left">匹配的大小。如果 matched 未 false，则返回 0</td>
</tr>

<tr>
<td class="org-left">str()</td>
<td class="org-left">返回一个包含输入中匹配部分的 string。如果 matched 为 false，则返回空 string</td>
</tr>

<tr>
<td class="org-left">s = ssub</td>
<td class="org-left">将 ssub_match 对象 ssub 转换为 string 对象 s。等价于 s=ssub.str()。转换运算符不是 explicit 的</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgd153c26" class="outline-4">
<h4 id="orgd153c26">17.3.4 使用 regex_replace</h4>
<div class="outline-text-4" id="text-orgd153c26">
<p>
正则表达式不仅用在我们希望查找一个给定序列的时候，还用在当我们想将找到的序列替换为另一个序列的时候。
</p>

<p>
当我们希望在输入序列中查找并替换一个正则表达式时，可以调用 <b>regex_replace</b> 。下表描述了 regex_replace，类似搜索函数，它接收一个输入字符序列和一个 regex 对象，不同的时，它还接受一个描述我们想要的输出形式的字符串
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;12&nbsp;</span> 正则表达式替换操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">m.format(dest,fmt,mft)</td>
<td class="org-left">使用格式字符串 fmt 生成格式化输出，匹配在 m 中，可选的 match_flag_type 标志在 mft 中。第一个版本写入迭代器 dest 指向的目的位置并接受 fmt 参数，可以是一个 string，也可以是表示字符数组中范围的一对指针。</td>
</tr>

<tr>
<td class="org-left">m.format(fmt,mft)</td>
<td class="org-left">第二个版本返回一个 string，保存输出，并接受 fmt 参数，可以是一个 string，也可以是一个指向空字符结尾的字符数组的指针。mft 的默认值为 format_defualt</td>
</tr>

<tr>
<td class="org-left">regex_replace(dest,seq,r,fmt,mft)</td>
<td class="org-left">遍历 seq，用 regex_search 查找与 regex 对象 r 匹配的子串。使用格式字符串 fmt 和可选的 match_flag_type 标志来生成输出。第一个版本将输出写入到迭代器 dest 指定的位置，并接受一对迭代器 seq 表示范围。</td>
</tr>

<tr>
<td class="org-left">regex_replace(seq,r,fmt,mft)</td>
<td class="org-left">第二个版本返回一个 string，保存输出，且 seq 既可以是一个 string 也可以是一个指向空字符结尾的字符数组的指针。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">在所有情况下，fmt 既可以是一个 string 也可以是一个指向空字符结尾的字符数组的指针，且 mft 的默认值为 match_defualt</td>
</tr>
</tbody>
</table>

<p>
替换字符串由我们想要的字符组合与匹配的子串对应的子表达式而组成。我们用一个符号$后跟子表达式的索引号来表示一个特定的子表达式：
</p>

<p>
<code>string fmt = "$2.$5.$7";   // 将号码格式改为ddd.ddd.dddd</code>
</p>
</div>
<div id="outline-container-org975aca3" class="outline-5">
<h5 id="org975aca3">用来控制匹配的格式的标志</h5>
<div class="outline-text-5" id="text-org975aca3">
<p>
就像标准库定义标志来指导如何处理正则表达式一样，标准库还定义了用来在替换过程中控制匹配或格式的标志。下表列出了这些值。这些标志可以传递给函数 regex_search 或 regex_match 或是类 smatch 的 format 成员。
</p>

<p>
匹配和格式化标志的类型为 match_flag_type。这些值都定义在名为 regex_constants 的命名空间中。类似用于 bind 的 placeholder（参见 10.3.4 节），regex_constants 也是命名空间 std 中的命名空间。为了使用 regex_constants 中的名字，我们必须在名字前同时加上两个命名空间限定符：
</p>

<p>
<code>using std::regex_constants::format_no_copy;</code>
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;13&nbsp;</span> 匹配标志</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">定义在 regex_constants::match_flag_type 中</td>
</tr>

<tr>
<td class="org-left">match_default</td>
<td class="org-left">等价于 format_default</td>
</tr>

<tr>
<td class="org-left">match_not_bol</td>
<td class="org-left">不将首字符作为行首处理</td>
</tr>

<tr>
<td class="org-left">match_not_eol</td>
<td class="org-left">不将尾字符作为行尾处理</td>
</tr>

<tr>
<td class="org-left">match_not_bow</td>
<td class="org-left">不将首字符作为单词首处理</td>
</tr>

<tr>
<td class="org-left">match_not_eow</td>
<td class="org-left">不将尾字符作为单词尾处理</td>
</tr>

<tr>
<td class="org-left">match_any</td>
<td class="org-left">如果存在多余一个匹配，则可返回任意一个匹配</td>
</tr>

<tr>
<td class="org-left">matcn_not_null</td>
<td class="org-left">不匹配任何空序列</td>
</tr>

<tr>
<td class="org-left">match_continuous</td>
<td class="org-left">匹配必须从输入的首字符开始</td>
</tr>

<tr>
<td class="org-left">match_prev_avail</td>
<td class="org-left">输入序列必须包含第一个匹配之前的内容</td>
</tr>

<tr>
<td class="org-left">format_defualt</td>
<td class="org-left">用 ECMAScript 规则替换字符串</td>
</tr>

<tr>
<td class="org-left">format_sed</td>
<td class="org-left">用 POSIX sed 规则替换字符串</td>
</tr>

<tr>
<td class="org-left">format_no_copy</td>
<td class="org-left">不输出输入序列中未匹配的部分</td>
</tr>

<tr>
<td class="org-left">format_first_only</td>
<td class="org-left">只替换子表达式的第一次出现</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc05bb12" class="outline-3">
<h3 id="orgc05bb12">17.4 随机数</h3>
<div class="outline-text-3" id="text-orgc05bb12">
<p>
程序通常需要一个随机数源。在新标准出现之前，C和 C++都依赖于一个简单的 C 库函数 rand 来生成随机数。此函数生成均匀分布的伪随机数整数，每个随机数的范围在 0 和一个系统相关的最大值（至少为 32767）之间。
</p>

<p>
rand 函数有一些问题：即使不是大多数，也有很多程序需要不同范围的随机数。一些应用需要随即浮点数。一些程序需要非均匀分布的数。而程序员为了解决着地写问题而试图转换 rand 生成的随机数的范围、类型或分布时，常常会引入非随机性。
</p>

<p>
定义在头文件 random 中的随机数库通过一组写作的类来解决这些问题： <b>随机数引擎类</b> 和 <b>随机数分布类</b> 。下表描述了这些类。一个引擎类可以生成 unsigned 随机数序列，一个分布类使用一个引擎类生成指定类型的、在给定范围内的、服从特定概率分布的随即数。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;14&nbsp;</span> 随机数库的组成</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">引擎</td>
<td class="org-left">类型，生成随机 unsigned 整数序列</td>
</tr>

<tr>
<td class="org-left">分布</td>
<td class="org-left">类型，使用引擎返回服从特定概率分布的随机数</td>
</tr>
</tbody>
</table>

<blockquote>
<p>
Best Practies：
</p>

<p>
C++程序不应该使用库函数 rand，而而应使用 default_random_engine 类和恰当的分布类对象
</p>
</blockquote>
</div>
<div id="outline-container-org4a44624" class="outline-4">
<h4 id="org4a44624">17.4.1 随机数引擎和分布</h4>
<div class="outline-text-4" id="text-org4a44624">
<p>
随机数引擎是函数对象类（参见 14.8），它们定义了一个调用运算符，运算符不接受参数并返回并返回一个随机 unsigned 整数.我们可以通过调用一个随机数引擎对象来生成原始随机数。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">default_random_engine</span> <span style="color: #dcaeea;">e</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29983;&#25104;&#38543;&#26426;&#26080;&#31526;&#21495;&#25968;</span>
<span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">10</span> ; ++i)
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">e() &#8220;&#35843;&#29992;&#8221;&#23545;&#35937;&#26469;&#29983;&#25104;&#19979;&#19968;&#20010;&#38543;&#26426;&#25968;</span>
  cout &lt;&lt; e() &lt;&lt; <span style="color: #98be65;">" "</span>;
</pre>
</div>

<p>
标准库定义了多个随机数引擎类，区别在于性能和随机性质量不同。每个编译器都会指定其中一个作为 default_random_engine 类型。此类型一般具有最常用的特性，下表列出了随机数引擎操作，标准库定义的引擎类型列在附录 A3.2 中。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;15&nbsp;</span> 随机数引擎操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Engine e;</td>
<td class="org-left">默认构造函数；使用该引擎类型默认的种子</td>
</tr>

<tr>
<td class="org-left">Engine e(s);</td>
<td class="org-left">使用整型值 s 作为种子</td>
</tr>

<tr>
<td class="org-left">e.seed(s)</td>
<td class="org-left">使用种子 s 重值引擎的状态</td>
</tr>

<tr>
<td class="org-left">e.min()</td>
<td class="org-left">此引擎可生成的最小值和最大值</td>
</tr>

<tr>
<td class="org-left">e.max()</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Engine::result_type</td>
<td class="org-left">此引擎生成的 unsigned 整型类型</td>
</tr>

<tr>
<td class="org-left">e.discard(u)</td>
<td class="org-left">将引擎推进 u 补；u的链诶行为 unsigned long long</td>
</tr>
</tbody>
</table>
</div>
<div id="outline-container-org74eea2e" class="outline-5">
<h5 id="org74eea2e">分布类型和引擎</h5>
<div class="outline-text-5" id="text-org74eea2e">
<p>
为了得到在一个指定范围内的数，我们使用一个分布类型的对象：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29983;&#25104;0&#21040;9&#20043;&#38388;&#65288;&#21253;&#21547;&#65289;&#22343;&#21248;&#20998;&#24067;&#30340;&#38543;&#26426;&#25968;</span>
<span style="color: #ECBE7B;">uniform_int_distribution</span>&lt;<span style="color: #ECBE7B;">unsigned</span>&gt; <span style="color: #dcaeea;">u</span>(<span style="color: #da8548; font-weight: bold;">0</span>,<span style="color: #da8548; font-weight: bold;">9</span>);
<span style="color: #ECBE7B;">default_random_engine</span> <span style="color: #dcaeea;">e</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#29983;&#25104;&#26080;&#31526;&#21495;&#38543;&#26426;&#25968;</span>
<span style="color: #51afef;">for</span> (<span style="color: #ECBE7B;">size_t</span> <span style="color: #dcaeea;">i</span> = <span style="color: #da8548; font-weight: bold;">0</span>; i &lt; <span style="color: #da8548; font-weight: bold;">10</span>; ++i)
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23558;u&#20316;&#20026;&#38543;&#26426;&#25968;&#28304;</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27599;&#20010;&#35843;&#29992;&#36820;&#22238;&#22312;&#25351;&#23450;&#33539;&#22260;&#20869;&#24182;&#26381;&#20174;&#22343;&#21248;&#20998;&#24067;&#30340;&#20540;</span>
  cout &lt;&lt; u(e) &lt;&lt; <span style="color: #98be65;">" "</span>;
</pre>
</div>

<p>
此处我们将 u 定义为 uniform_int_distribution&lt;unsigned&gt;。此类型生成均匀分布的 unsigned 值。当我们定义一个这种类型的对象时，可以提供想要的最小值和最大值。在此程序中，u(0,9)表示我们希望得到 0 到 9 之间（包含）的数。随机数分布类会使用博阿寒的范围，从而我们可以得到给定整型类型的每个可能值。
</p>

<p>
类似引擎类型，分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。
</p>

<p>
注意，我们传递给分布对象的是引擎对象本身，即 u(e)。如果我们将调用写成 u(e())，含义变为将 e 生成的下一个值传递给 u，会导致一个编译错误。我们传递的是引擎本身，而不是它生成的下一个值，原因是某些分布可能需要调用引擎多次才能得到一个值。
</p>

<blockquote>
<p>
Note：
</p>

<p>
当我们说 <b>随机数发生器</b> 时，是指分布对象和引擎对象的组合。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgedf9e47" class="outline-5">
<h5 id="orgedf9e47">引擎生成一个数值序列</h5>
<div class="outline-text-5" id="text-orgedf9e47">
<p>
随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来像是随机的，但对一个给定的发生器，每次运行程序它都会返回相同的数值序列。序列不变这一事实在调试时非常有用。但另一方面，使用随机数发生器的程序也必须考虑这一特性。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为 static 的。否则，每次调用函数都会生成相同的序列。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org973fca9" class="outline-5">
<h5 id="org973fca9">设计随机数发生器种子</h5>
<div class="outline-text-5" id="text-org973fca9">
<p>
随机数发生器会生成相同的随机数序列这一特性在调试中很有用。但是，一旦我们的程序调试完毕，我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个 <b>种子</b> 来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。
</p>

<p>
为引擎设置种子有两种方式：在创建引擎对象时提供种子，或者 a 调用引擎的 seed 成员。
</p>

<p>
选择一个好的种子，与生成好的随机数所涉及的其他大多数事情相同，是极其困难的的。可能最常用的方式时调用系统函数 time。这个函数定义在头文件 ctime 中，它返回从一个特定时刻到当前经过了多少秒。函数 time 接受单个指针参数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单地返回时间：
</p>

<p>
<code>default_random_engine e1(time(0));  // 稍微随机些的种子</code>
</p>

<p>
由于 time 返回以秒计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
如果程序作为一个自动过程的一部分反复运行，将 time 的返回值作为种子的方式就无效了；它可能多次使用的都是相同的种子。
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org6a97575" class="outline-4">
<h4 id="org6a97575">17.4.2 其他随机数分布</h4>
<div class="outline-text-4" id="text-org6a97575">
</div>
<div id="outline-container-org09876d3" class="outline-5">
<h5 id="org09876d3">生成随机实数</h5>
<div class="outline-text-5" id="text-org09876d3">
<p>
程序常需要一个随机浮点数的源。特别是，程序经常需要 0 到 1 之间的随机数。
</p>

<p>
最常用但不正确的从 rand 获取一个随机浮点数的方法时用 rand()的结果除以 RAND_MAX，即，系统定义的 rand 可以生成的最大随机数的上界。这种方法不正确的原因是随机整数的精度通常低于随机浮点数，这样，有一些浮点值就永远不会被生成了。
</p>

<p>
使用新标准库设施，可以很容易地获得随机浮点数。我们可以定义一个 uniform_real_distribution 类型的对象，并让标准库来处理从随机整数到随机浮点小树的映射。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;16&nbsp;</span> 分布类型的操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Dist d;</td>
<td class="org-left">默认构造函数；使 d 准备好被使用</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">其他构造函数依赖于 Dist 的类型；参见附录 A.3</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">分布类型的构造函数是 explicit 的</td>
</tr>

<tr>
<td class="org-left">d(e)</td>
<td class="org-left">用相同的 e 连续调用 d 的话，会根据 d 的分布是类型生成一个随机数序列；e是一个随机数引擎对象</td>
</tr>

<tr>
<td class="org-left">d.min()</td>
<td class="org-left">返回 d(e)能生成的最小值和最大值</td>
</tr>

<tr>
<td class="org-left">d.max()</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">d.reset()</td>
<td class="org-left">重建 d 的状态，使得随后对 d 的使用不依赖于 d 已经生成的值</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org824ec65" class="outline-5">
<h5 id="org824ec65">bernoulli_distribution 类</h5>
<div class="outline-text-5" id="text-org824ec65">
<blockquote>
<p>
WARNING：
</p>

<p>
由于引擎返回相同的随机序列（参见 17.4.1 节），所以我们必须在循环外声明引擎对象。否则，每步循环都会创建一个新引擎，而从每步循环都会生成相同的值。类似的，分布对象也要保持状态，因此也应该在循环外定义。
</p>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-orge662cb2" class="outline-3">
<h3 id="orge662cb2">17.5 IO 库再探</h3>
<div class="outline-text-3" id="text-orge662cb2">
<p>
在第 8 章中我们介绍了 IO 库的基本结构及其最常用的部分。在本节中，我们将介绍三个更特殊的 IO 库特性：格式控制、未格式化 IO 和随机访问。
</p>
</div>
<div id="outline-container-orga5efd9a" class="outline-4">
<h4 id="orga5efd9a">17.5.1 格式化输入与输出</h4>
<div class="outline-text-4" id="text-orga5efd9a">
<p>
除了条件状态外（参见 8.1.2 节），每个 iostream 对象还维护一个格式状态来控制 IO 如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽断等。
</p>

<p>
标准库定义了一组 <b>操纵符</b> （参见 1.2 节）来修改流的格式状态。一个操作符 shingle 函数或是一个对象，会影响力流的状态，并能用作输入或输出运算符的运算符对象。类似输入和输出运算符，操纵符也返回它所处理的流对象，因此我们未可以在一条语句中组合操纵符和数据。
</p>

<p>
我们已经在程序使用过一个操纵符——endl，我们将它“写”到输出流，就像它是一个值一样。但 endl 不是一个普通值，而是一个操作：它输出一个换行符并刷新缓冲区。
</p>
</div>
<div id="outline-container-org544ebc6" class="outline-5">
<h5 id="org544ebc6">很多操纵符改变格式状态</h5>
<div class="outline-text-5" id="text-org544ebc6">
<p>
草丛服用于两大类输出控制：控制数值的输出形式以及控制补白的数量和位置。大多数改变格式状态的操纵符都是设置/复原成对的；一个操纵符用来将格式状态设置成新值，而另一个用来将其复原，恢复为正常的默认格式。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
当操纵符改变流的格式状态时，通常改变后的状态对素有后续 IO 都生效。
</p>
</blockquote>

<p>
当我们有一组 IO 操作希望使用相同的格式时，操纵符对格式状态的改变是持久的这一特性很有用。实际上，一些程序会利用操纵符的这一特性对其所有输入或输出重值一个或多个格式规则的行为。在这种情况下，操纵符会改变流这一特性就是满足要求了。
</p>

<p>
但是，很多重续（而且更重要的是，很多程序员）期望流的状态符合标准库正常的默认设置。在这些情况下，将流的状态置于一个非标准状态可能会导致错误。因此，通常最好在不再需要特殊格式时尽快将流恢复到默认状态。
</p>
</div>
</div>
<div id="outline-container-org97934f3" class="outline-5">
<h5 id="org97934f3">指定整型值的进制</h5>
<div class="outline-text-5" id="text-org97934f3">
<blockquote>
<p>
Note：
</p>

<p>
操纵符 hex、oct 和 dec 只影响整型运算符对象，浮点值的表示形式不受影响。
</p>
</blockquote>

<table>
<caption class="t-above"><span class="table-number">&#34920;17&nbsp;</span> 定义在 iostream 中的操纵符</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">boolalpha</td>
<td class="org-left">将 true 和 false 输出为字符串</td>
</tr>

<tr>
<td class="org-left">* noboolalpha</td>
<td class="org-left">将 true 和 false 输出为 1，0</td>
</tr>

<tr>
<td class="org-left">showbase</td>
<td class="org-left">对整型值输出表示进制的前缀</td>
</tr>

<tr>
<td class="org-left">* noshowbase</td>
<td class="org-left">不生成表示进制的前缀</td>
</tr>

<tr>
<td class="org-left">showpoint</td>
<td class="org-left">对浮点值总是显式小数点</td>
</tr>

<tr>
<td class="org-left">* noshowpoint</td>
<td class="org-left">只有当浮点值包含小数部分时才显示小数点</td>
</tr>

<tr>
<td class="org-left">showpos</td>
<td class="org-left">对非负数显示+</td>
</tr>

<tr>
<td class="org-left">* noshowpos</td>
<td class="org-left">对非负数不显示+</td>
</tr>

<tr>
<td class="org-left">uppercase</td>
<td class="org-left">在十六进制中打印 0X，在科学记数法中打印 E</td>
</tr>

<tr>
<td class="org-left">* nouppercase</td>
<td class="org-left">在十六进制中打印 0x，在科学记数法中打印 e</td>
</tr>

<tr>
<td class="org-left">* dec</td>
<td class="org-left">整型值显示为是禁止</td>
</tr>

<tr>
<td class="org-left">hex</td>
<td class="org-left">整型值显示为十六进制</td>
</tr>

<tr>
<td class="org-left">oct</td>
<td class="org-left">整型值显示为八进制</td>
</tr>

<tr>
<td class="org-left">left</td>
<td class="org-left">在值的右侧添加填充字符</td>
</tr>

<tr>
<td class="org-left">right</td>
<td class="org-left">在值的左侧添加填充字符</td>
</tr>

<tr>
<td class="org-left">internal</td>
<td class="org-left">在符号和值之间添加填充字符</td>
</tr>

<tr>
<td class="org-left">fixed</td>
<td class="org-left">浮点值显示为定点十进制</td>
</tr>

<tr>
<td class="org-left">scientific</td>
<td class="org-left">浮点值显示为科学记数法</td>
</tr>

<tr>
<td class="org-left">hexfloat</td>
<td class="org-left">浮点值显示为十六进制（C++11 新特性）</td>
</tr>

<tr>
<td class="org-left">defaultfloat</td>
<td class="org-left">重值浮点数格式为十进制（C++11 新特性）</td>
</tr>

<tr>
<td class="org-left">unitbuf</td>
<td class="org-left">每次输出操作后都刷新缓冲区</td>
</tr>

<tr>
<td class="org-left">* nounitbuf</td>
<td class="org-left">恢复正常的缓冲区刷新方式</td>
</tr>

<tr>
<td class="org-left">* shipws</td>
<td class="org-left">输入运算符跳过空白符</td>
</tr>

<tr>
<td class="org-left">noskipws</td>
<td class="org-left">输入运算符不跳过空白符</td>
</tr>

<tr>
<td class="org-left">flush</td>
<td class="org-left">刷新 ostream 缓冲区</td>
</tr>

<tr>
<td class="org-left">ends</td>
<td class="org-left">插入空字符，然后刷新 ostream 缓冲区</td>
</tr>

<tr>
<td class="org-left">endl</td>
<td class="org-left">插入换行符，然后刷新 ostream 缓冲区</td>
</tr>

<tr>
<td class="org-left">* 表示默认流状态</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orgf18d9be" class="outline-5">
<h5 id="orgf18d9be">指定浮点数记数法</h5>
<div class="outline-text-5" id="text-orgf18d9be">
<blockquote>
<p>
Best Practies：
</p>

<p>
除非你需要控制浮点数的表示形式（如，按列打印数据或打印表示金额或百分比的数据），否则由标准库选择记数法是最好的方式。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgf449f08" class="outline-5">
<h5 id="orgf449f08">输出补白</h5>
<div class="outline-text-5" id="text-orgf449f08">
<p>
当按列打印数据时，我们常常需要非常精细地控制数据格式。标准库提供了一些操纵符帮助我们完成所需的控制：
</p>
<ul class="org-ul">
<li>setw 指定下一个数字或字符串值的最小空间。</li>
<li>left 表示左对齐输出</li>
<li>right 表示右对齐输出，右对齐是默认格式</li>
<li>internal 控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满所有中间空间。</li>
<li>setfill 允许指定一个字符代替默认的空格来补白输出。</li>
</ul>

<blockquote>
<p>
Note：
</p>

<p>
setw 类似 endl，不改变输出流的内部状态。它只决定了下一个输出的大小。
</p>
</blockquote>

<table>
<caption class="t-above"><span class="table-number">&#34920;18&nbsp;</span> 定义在 iomanip 中的操纵符</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">setfill(ch)</td>
<td class="org-left">用 ch 填充空白</td>
</tr>

<tr>
<td class="org-left">setprecision(n)</td>
<td class="org-left">将浮点精度设置为 n</td>
</tr>

<tr>
<td class="org-left">setw(w)</td>
<td class="org-left">读或写值的宽度为 w 个字符</td>
</tr>

<tr>
<td class="org-left">setbase(b)</td>
<td class="org-left">将整数输出为 b 进制</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-org559d636" class="outline-4">
<h4 id="org559d636">17.5.2 未格式化的输入/输出操作</h4>
<div class="outline-text-4" id="text-org559d636">
<p>
到目前为止，我们的程序只使用过 <b>格式化 IO</b> 操作。输入和输出运算符（ <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> ）根据读取或写入的数据类型来格式化它们。输入运算符忽略空白符，输出运算符应用补白、精度等规则。
</p>

<p>
标准库还提供了一组低层操作，支持 <b>未格式化 IO</b> 。这些操作允许我们将一个流当当作一个无解释的字节序列来处理。
</p>
</div>
<div id="outline-container-orgbc038d4" class="outline-5">
<h5 id="orgbc038d4">单字节操作</h5>
<div class="outline-text-5" id="text-orgbc038d4">
<p>
有几个未格式化操作每次一个字节地处理流。这些操作列在下表中，它们会读取而不是忽略空白符。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;19&nbsp;</span> 单字节地层 IO 操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">is.get(ch)</td>
<td class="org-left">从 istream is 读取下一个字节存入字符 ch 中。返回 is</td>
</tr>

<tr>
<td class="org-left">os.put(ch)</td>
<td class="org-left">将字符 ch 输出到 ostream os，返回 os</td>
</tr>

<tr>
<td class="org-left">is.get()</td>
<td class="org-left">将 is 的下一个字节作为 int 返回</td>
</tr>

<tr>
<td class="org-left">is.putback(ch)</td>
<td class="org-left">将字符 ch 放回 is。返回 is</td>
</tr>

<tr>
<td class="org-left">is.unget()</td>
<td class="org-left">将 is 向后移动一个字节。返回 is</td>
</tr>

<tr>
<td class="org-left">is.peek()</td>
<td class="org-left">将下一个字节作为 int 返回，但不从流中删除它</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-orge047d25" class="outline-5">
<h5 id="orge047d25">将字符放回输入流</h5>
<div class="outline-text-5" id="text-orge047d25">
<p>
有时我们需要读取一个字符才能知道还未准备好处理它。在这种情况下，我们希望将字符放回流中。标准库提供了三种方法退会字符，它们有着细微的差别：
</p>
<ul class="org-ul">
<li>peek 返回输入流中下一个字符的副本，但不会将它从流中删除，peek 返回的值仍然在流中。</li>
<li>unget 使得输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以有调用 unget。</li>
<li>putback 是更特殊版本的 unget，它退回从流中读取的最后一个值，但它接受一个参数，此参数必须与最后读取的值想通</li>
</ul>

<p>
一般情况下，在读取下一个值之前，标准库保证我们可以退回最多一个值。即，标准库不保证在中间不进行读取操作的情况下能连续调用 pushback 或 unget。
</p>
</div>
</div>
<div id="outline-container-orga69b58e" class="outline-5">
<h5 id="orga69b58e">从输入操作返回的 int 值</h5>
<div class="outline-text-5" id="text-orga69b58e">
<p>
函数 peek 和无参的 get 版本都以 int 类型从输入流返回一个字符。这有些令人吃惊，可能这些函数返回一个 char 看起来会更自然。
</p>

<p>
这些函数返回一个 int 的原因是：可以返回文件尾标记。我们使用 char 范围中的每个值来表示一个真实字符，因此，取值范围中没有额外的值可以用来表示文件尾。
</p>

<p>
返回 int 的函数将它们要返回的字符先转换为 unsigned char，然后再将结果提升到 int。因此，即使字符集中有字符映射到负值，这些操作返回的 int 也是正值（参见 2.1.2 节）。而标准库使用负值表示文件尾，这样就可以保证与任何合法字符的值都不同。文件 cstdio 定义了一个名为 EOF 的 const，我们可以用它来检测从 get 返回的值是否是文件尾，而不必记忆表示文件尾的实际数值
</p>
</div>
</div>
<div id="outline-container-org1818289" class="outline-5">
<h5 id="org1818289">多字节操作</h5>
<div class="outline-text-5" id="text-org1818289">
<p>
一些未格式化 IO 操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，但类似其他低层操作，这些操作也容易出错。特别是，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。下表列出了多字节操作。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;20&nbsp;</span> 多字节底层 IO 操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">is.get(sink, size, delim)</td>
<td class="org-left">从 is 中读取最多 size 个字节，并保存在字符数组中，字符数组的起始地址由 sink 给出。读取过程直至遇到了字符 delim 或读取了 size 个字节或遇到文件尾时停止。</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">如果遇到了 delim，则将其留在输入流中，不读取出来存入 sink</td>
</tr>

<tr>
<td class="org-left">is.getline(sink, size, delim)</td>
<td class="org-left">与接受三个参数的 get 版本类似，但会读取并丢弃 delim</td>
</tr>

<tr>
<td class="org-left">is.read(sink, size)</td>
<td class="org-left">读取最多 size 个字节，存入字符数组 sink 中。返回 is</td>
</tr>

<tr>
<td class="org-left">is.gcount()</td>
<td class="org-left">返回上一个未格式化读取操作从 is 读取的字节数</td>
</tr>

<tr>
<td class="org-left">os.write(source, size)</td>
<td class="org-left">将字符数组 source 中的 size 个字节写入 os。返回 os</td>
</tr>

<tr>
<td class="org-left">is.ignore(size, delim)</td>
<td class="org-left">读取并忽略最多 size 个字符，包括 delim。与其他未格式化函数不同，ignore 有默认参数；size 的默认值为 1，delim 的默认值为文件尾</td>
</tr>
</tbody>
</table>

<p>
get 和 getiline 函数接受相同的参数，它们的行为类型但不相同。这两个函数中，sink 都是一个 char 数组，用来保存数据。两个函数都一直读取数据，直至下面条件之一发生：
</p>
<ul class="org-ul">
<li>已读取了 size-1 字符</li>
<li>遇到了文件尾</li>
<li>遇到了分隔符</li>
</ul>

<p>
两个函数的差别是处理分隔符的方式：get 将分隔符留作 istream 中的下一个字符，而 getline 则读取并丢弃分隔符。无论哪个函数都不会将分隔符保存在 sink 中。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
一个常见的错误是本想从流中删除分隔符，但却忘了做。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org95aa527" class="outline-5">
<h5 id="org95aa527">确定读取了多少个字符</h5>
<div class="outline-text-5" id="text-org95aa527">
<p>
某些操作从输入读取未知个数的字节。我们可以调用 gcount 来确定最后一个未格式化输入操作读取了多少个字符。应该在任何后续未格式化输入操作之前调用 gcount。特别是，将字符退回流的单字符操作也属于位格式化输入操作。如果在调用 gcount 之前调用了 peek、unget 或 puback，则 gcount 的返回值为 0。
</p>
</div>
</div>
</div>
<div id="outline-container-org262dd52" class="outline-4">
<h4 id="org262dd52">17.5.3 流随机访问</h4>
<div class="outline-text-4" id="text-org262dd52">
<p>
虽然标准库为所有流类型都定义了 seek 和 tell 函数，单它们是否会做有意义的事情依赖于流绑定到哪个设备。在大多数系统中，绑定到 cin、cout、cerr 和 clog 的流不支持随机访问——毕竟，当我们向 cout 直接输出数据时，类似向回跳十个尾值这种操作是没有意义的。对这些流我们可以调用 seek 和 tell 函数，单在运行时会出错，将流置于一个无效状态。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
由于 istream 和 ostream 类型通常不支持随机访问，所以本节剩余内容只用于 fstream 和 sstream 类型。
</p>
</blockquote>
</div>
<div id="outline-container-org2a5af93" class="outline-5">
<h5 id="org2a5af93">seek 和 tell 函数</h5>
<div class="outline-text-5" id="text-org2a5af93">
<p>
为了支持随机访问，IO 类型维护一个标记来确定下一个读写操作要在哪里进行。它们还提供了两个函数：一个函数通过将标记 seek 到一个给定位置来重新定位它；另一个函数 tell 我们标记的当前位置。标准库实际上定义了两对 seek 和 tell 函数，如下表所示。一对用于输入流，另一对用于输出流。输入和输出版本的差别在于名字的后缀是 g 还是 p。g 版本表示我们正在“获取”（读取）数据，而 p 版本表示我们正在“放置”（写入）数据。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;21&nbsp;</span> seek 和 tell 函数</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">tellg()</td>
<td class="org-left">返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置</td>
</tr>

<tr>
<td class="org-left">tellp()</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">seekg(pos)</td>
<td class="org-left">在一个输入流或输出流中将标记重定位到给定的绝对地址。pos 通常是前一个 tellg 或 tellp 返回的值</td>
</tr>

<tr>
<td class="org-left">seekp(pos)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">seekp(off, from)</td>
<td class="org-left">在一个输入流或输出流中将标记定位到 from 之前或之后 off 个字符，from 可能是下列值之一</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- beg，偏移量相对于流开始位置</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- cur，偏移量相对于流当前位置</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">- end，偏移量相对于流结尾位置</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-org8f09a66" class="outline-5">
<h5 id="org8f09a66">只有一个标记</h5>
<div class="outline-text-5" id="text-org8f09a66">
<p>
标准库区分 seek 和 tell 函数的“放置”和“获得”版本这一特性可能会导致误解，即使标准库进行了区分，但它在一个流中只维护单一的标记——并不存在独立的读标记和写标记。
</p>

<blockquote>
<p>
Note：
</p>

<p>
由于只有单一的标记，因此只要我们在读写操作间切换，就必须进行 seek 操作来重定位标记。
</p>
</blockquote>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdbe1dd7" class="outline-2">
<h2 id="orgdbe1dd7">第 18 章 用于大型程序的工具</h2>
<div class="outline-text-2" id="text-orgdbe1dd7">
<p>
与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括：
</p>
<ul class="org-ul">
<li>在独立开发的子系统之间协同处理错误的能力。</li>
<li>使用各种库（可能包含独立开发的库）进行协同开发的能力。</li>
<li>对比较复杂的应用概念建模的能力。</li>
</ul>

<p>
本章介绍的三种 C++语言特性正好满足上述要求，它们是：异常处理、命名空间和多重继承。
</p>
</div>
<div id="outline-container-org9cc074e" class="outline-3">
<h3 id="org9cc074e">18.1 异常处理</h3>
<div class="outline-text-3" id="text-org9cc074e">
<p>
<b>异常处理</b> 机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常时的我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无序知道问题处理模板的所以细节，反之亦然。
</p>
</div>
<div id="outline-container-orgb879785" class="outline-4">
<h4 id="orgb879785">18.1.1 抛出异常</h4>
<div class="outline-text-4" id="text-orgb879785">
<p>
在 C++语言中，我们通过 <b>抛出</b> 一条表达式来 <b>引发</b> 一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段 <b>处理代码</b> 将被用来处理该异常。被选中的处理代码是在调用链中 与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么错误。
</p>

<p>
当执行一个 throw 时，跟在 throw 后面的语句将不再被执行。相反，程序的控制权从 throw 转移到与之匹配的 catch 模块。该 catch 可能时同一个函数的局部 catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个重要的含义：
</p>
<ul class="org-ul">
<li>沿着调用链的函数可能会提早退出。</li>
<li>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁</li>
</ul>

<p>
因为跟在 throw 后面的语句将不再被执行，所以 throw 语句的用法有点类型于 return 语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。
</p>
</div>
<div id="outline-container-org127ca03" class="outline-5">
<h5 id="org127ca03">栈展开</h5>
<div class="outline-text-5" id="text-org127ca03">
<p>
当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的 catch 子句。当 throw 出现在一个 <b>try 语句块</b> 内时，检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch，就使用该 catch 处理异常。如果这一步没找到匹配的 catch 且该 try 语句嵌套在其他 try 块中，则继续检查与外层 try 匹配的 catch 语句。如果还是找不到匹配的 catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找。
</p>

<p>
如果对抛出异常的函数的调用语句位于一个 try 语句块内，则检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch，就使用该 catch 处理异常。否则，如果该 try 语句嵌套在其他 try 块中，则继续检查与外层 try 匹配的 catch 子句。如果仍然没有找到匹配的 catch，则退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。
</p>

<p>
上述过程被称为 <b>栈展开</b> 过程。栈展开过程沿着嵌套函数的调用链不断查找，知道找到了与异常匹配的 catch 子句为止；或者也可能一直没有找到匹配的 catch，则退出主函数后查找过程终止。
</p>

<p>
假设找到了一个匹配的 catch 子句，则程序进入该子句并执行其中的代码。当执行完这个 catch 子句后，找到与 try 块关联的最后一个 catch 子句之后的点，并从这里继续执行。
</p>

<blockquote>
<p>
Note：
</p>

<p>
一个异常如果没有被捕获，则它将终止当前的程序。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org3e7991b" class="outline-5">
<h5 id="org3e7991b">栈展开过程中对象被自动销毁</h5>
<div class="outline-text-5" id="text-org3e7991b">
<p>
在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下， 程序在这些块中创建了一些局部对象。我们已经知道，块退出后它的局部对象也随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。如果某个局部对象的类型是类类型，则该对象的析构函数函数被自动调用。与往常一样，编译器在销毁内置类型时不需要做任何事情。
</p>

<p>
如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始化了，而另外一些成员在异常发生前也许还有没有初始化。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。
</p>

<p>
类似的，异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似，如果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。
</p>
</div>
</div>
<div id="outline-container-org1e41187" class="outline-5">
<h5 id="org1e41187">析构函数与异常</h5>
<div class="outline-text-5" id="text-org1e41187">
<p>
析构函数总是会被执行的，但是函数中负责释放资源的代码却可能被跳过，这一特点对于我们如何组织程序结构有重要影响。如我们在 12.1.4 节介绍过的，如果一个块分配资源，并且在负责释放这些资源的代码前面发生了异常，则释放资源的代码将不会被执行。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们适用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。
</p>

<p>
析构函数在栈展开的过程中执行，这一事实影响着我们编写析构函数的方式。在栈展开的过程中，已经引发了异常但是我们还没有处理它。如果异常抛出后没有被正确捕获，则系统将调用 terminate 函数。因此，出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个 try 语句块当中，并且在析构函数内部得到处理。
</p>

<p>
在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所有标准库类型都能确保它们的析构函数不会引发异常。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org38bbdf1" class="outline-5">
<h5 id="org38bbdf1">异常对象</h5>
<div class="outline-text-5" id="text-org38bbdf1">
<p>
<b>异常对象</b> 是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，throw 语句中的表达式必须拥有完全类型（参见 7.3.3 节）。而且如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对象的指针类型。
</p>

<p>
异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个 catch 子句都能访问该空间。当异常处理完毕后，异常对象被销毁。
</p>

<p>
如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向局部对象的指针几乎肯定是一种错误的行为。出于同样的原因，从函数中返回指向局部对象的指针也是错误的（参见 6.3.2 节）。如果指针所指向的对象位于某个块中，而该块在 catch 语句之前就已经退出了，则意味着在执行 catch 语句之前局部对象已经被销毁了。
</p>

<p>
当我们抛出一条表达式时，该表达式的静态编译时类型（参见 15.2.3 节）决定了异常对象的类型。读者必须牢记这一点，因为很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条 throw 表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分（参见 15.2.3 节），只有基类部分被抛出。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
抛出指针要求在任何对应的处理代码存在的地方，指针所指向的对象都必须存在。
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgd51b263" class="outline-4">
<h4 id="orgd51b263">18.1.2 捕获异常</h4>
<div class="outline-text-4" id="text-orgd51b263">
<p>
<b>catch 子句</b> 中的 <b>异常声明</b> 看起来像是只包含一个形参的函数形参列表。像在形参列表中，如果 catch 无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。
</p>

<p>
声明的类型决定处理代码所能捕获的异常类型。这个类型必须是完全类型（参见 7.3.3 节），它可以是左值引用，但不能是右值引用（参见 13.6.1 节）。
</p>

<p>
当进入一个 catch 语句后，通过异常对象初始化异常声明中的参数。和函数的参数类型。如果 catch 的参数类型是非引用类型，则该参数是异常对象的一个副本，在 catch 语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。
</p>

<p>
catch 的参数还有一个特性也与函数的参数非常类似：如果 catch 的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果 catch 的参数是非引用类型，则异常对象将被切掉一部分（参见 15.2.3 节），这与将派生类对象以值传递的方式传给一个普通函数差不多。另一方面，如果 catch 的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。
</p>

<p>
最后一点需要注意的是，异常声明的静态类型将决定 catch 语句所能执行的操作。如果 catch 的参数是基类类型，则 catch 无法使用派生类特有的任何成员。
</p>

<blockquote>
<p>
Best Practies：
</p>

<p>
通常情况下，如果 catch 接受的异常与某个继承体系有关，则最好将该 catch 的参数定义成引用类型。
</p>
</blockquote>
</div>
<div id="outline-container-orgac0831d" class="outline-5">
<h5 id="orgac0831d">查找匹配的处理代码</h5>
<div class="outline-text-5" id="text-orgac0831d">
<p>
在搜寻 catch 语句的过程中，我们最终找到的 catch 未毕是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的 catch 语句。因此，越是专门的 catch 越应该置于整个 catch 列表的前端。
</p>

<p>
因为 catch 语句是按照出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对 catch 语句的顺序进行组织和管理，使得派生类异常的处理代码出现在基类异常的处理代码之前。
</p>

<p>
与实参和形参的匹配规则相比，异常和 catch 异常声明的规则受到更多显值。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和 catch 声明的类型时精确匹配的：
</p>
<ul class="org-ul">
<li>允许从非常量向常量的类型转换，也就是说，一条非常量对象的 throw 语句可以匹配一个接受常量引用的 catch 语句。</li>
<li>允许从派生类向基类的类型转换。</li>
<li>数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。</li>
</ul>

<p>
除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配 catch 的过程中使用。
</p>

<blockquote>
<p>
Note：
</p>

<p>
如果在多个 catch 语句的类型之间存在着继承关系，则我们应该把继承链最底端的类（most derived type）放在前面，而将继承链最顶端的类（least derived type）放在后面。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org9bb0dca" class="outline-5">
<h5 id="org9bb0dca">重新抛出</h5>
<div class="outline-text-5" id="text-org9bb0dca">
<p>
有时，一个断读的 catch 语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的 catch 可能会决定由调用链更上一层的函数接着处理异常。一条 catch 语句通过 <b>重新抛出</b> 的操作将异常传递给另外一个 catch 语句。这里的重新抛出仍然是一条 throw 语句，只不过不包含任何表达式：
</p>

<p>
<code>throw;</code>
</p>

<p>
空的 throw 语句只能出现在 catch 语句或 catch 语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空的 throw 一句，编译器将直接调用 terminate。
</p>

<p>
一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。
</p>

<p>
很多时候，catch 语句会改变其参数的内容。如果在改变了参数的内容后 catch 语句重新抛出异常，则只有当 catch 异常声明是引用类型时我们对参数所作的改变才会被保留并继续传播。
</p>
</div>
</div>
<div id="outline-container-org9491107" class="outline-5">
<h5 id="org9491107">捕获所有异常的处理代码</h5>
<div class="outline-text-5" id="text-org9491107">
<p>
有时我们希望不论抛出的异常时什么类型，程序都能统一捕获它们。要想捕获所有可能的异常时比较有难度的，毕竟有些情况下我们也不知道异常的类型到底是什么。即使我们知道所有的异常类型，也很难为所有类型提供唯一一个 catch 语句。为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为 <b>捕获所有异常</b> 的代码，行如 catch(&#x2026;)。一条捕获所有异常的语句可以与任意类型的异常匹配。
</p>

<p>
catch(&#x2026;)通常与重新抛出语句一起是一噢嗯，其中 catch 执行当前局部能完成的工作，随后重新抛出异常。
</p>

<p>
catch(&#x2026;)既能单独出现，也能与其他几个 catch 语句一起出现。
</p>

<blockquote>
<p>
Note：
</p>

<p>
如果 catch(&#x2026;)与其他几个 catch 语句一起出现，则 catch(&#x2026;)必须在最后的位置。出现在捕获所有异常语句后面的 catch 语句将永远不会被匹配。
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-org1512981" class="outline-4">
<h4 id="org1512981">18.1.3 函数 try 语句块和构造函数</h4>
<div class="outline-text-4" id="text-org1512981">
<p>
通常情况下，程序执行的任何时刻都可能发生异常，特别时异常可能发生在处理构造函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的 try 语句块还未生效，所以构造函数体内的 catch 语句无法处构造函数初始值列表抛出的异常。
</p>

<p>
要想处理构造函数初始值抛出的异常，我们必须将构造函数写成 <b>函数 try 语句块</b> （也称为函数测试块，function try block）的形式，函数 try 语句块使得一组 catch 语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。举个例子，我们可以把 Blob 的构造函数（参见 16.1.2 节）置于一个函数 try 语句块中：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">template</span> &lt;<span style="color: #51afef;">typename</span> <span style="color: #ECBE7B;">T</span>&gt;
<span style="color: #a9a1e1;">Blob</span>&lt;<span style="color: #ECBE7B;">T</span>&gt;::<span style="color: #c678dd;">Blob</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">initializer_list</span>&lt;<span style="color: #ECBE7B;">T</span>&gt; <span style="color: #dcaeea;">il</span>) <span style="color: #51afef;">try</span> :
  data(<span style="color: #a9a1e1;">std</span>::make_shared&lt;<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">vector</span>&lt;<span style="color: #ECBE7B;">T</span>&gt;&gt;(il)) {
    <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">&#31354;&#20989;&#25968;&#20307;</span><span style="color: #5B6268;"> */</span>
  } <span style="color: #51afef;">catch</span>(<span style="color: #51afef;">const</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">bad_alloc</span> &amp;<span style="color: #dcaeea;">e</span>) { handle_out_of_memory(e); }
</pre>
</div>

<p>
注意：关键字 try 出现在表示构造函数初始值列表的冒号以及表示构造函数体（此例为空）的花括号之前。这个 try 关联的 catch 既然处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。
</p>

<p>
还有一种情况值得读者注意，在初始化构造函数的参数时也可能发生异常，这样的异常不属于函数 try 语句块的一部分。函数 try 语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常，则该异常属于调用表达式的一部分，并在调用者所在的上下文中处理。
</p>

<blockquote>
<p>
Note：
</p>

<p>
处理构造函数初始值异常的唯一方法是将构造函数写成函数 try 语句块。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org8524cc0" class="outline-4">
<h4 id="org8524cc0">18.1.4 noexcept 异常说明</h4>
<div class="outline-text-4" id="text-org8524cc0">
<p>
对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。
</p>

<p>
在 C++11 新标准，我们可以通过提供 <b>noexcept 说明</b> 指定某个函数不会抛出异常。其形式是关键字 noexcept 紧跟在函数的参数列表后面，用以标识该函数不会抛出异常：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">recoup</span>(<span style="color: #ECBE7B;">int</span>) <span style="color: #51afef;">noexcept</span>;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#20250;&#25243;&#20986;&#24322;&#24120;</span>
<span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">alloc</span>(<span style="color: #ECBE7B;">int</span>);              <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21487;&#33021;&#25243;&#20986;&#24322;&#24120;</span>
</pre>
</div>

<p>
对于一个函数来说，noexcept 说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型（参见 6.3.3 节）之前。我们也可以在函数指针的声明和定义中指定 noexcept。在 typedef 或类型别名中则不能出现 noexcept。在成员函数中，noexcept 说明符需要跟在 const 及引用限定符之后，而在 final、override 或虚函数的=0 之前。
</p>
</div>
<div id="outline-container-orgc339f1d" class="outline-5">
<h5 id="orgc339f1d">违反异常说明</h5>
<div class="outline-text-5" id="text-orgc339f1d">
<p>
读者需要清楚的一个事实是编译器并不会在编译时检查 noexcept 说明。实际上，如果一个函数在说明了 noexcept 的同时又含有 throw 语句或者调用了可能抛出异常的其他函数，编译器将瞬息编译通过，并不会因为这种违反异常说明的情况而报错（不排除个别编译器会对这种用法提出警告）。
</p>

<p>
因此可能出现这样一种情况：尽管函数声明说明它不会抛出异常，但实际上还是抛出了。一旦一个 noexcept 函数抛出了异常，程序就会嗲用 terminate 以确保遵守不在运行时抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此 noexcept 可以用在两种情况下：一是我们确认函数不会抛出异常，而是我们根本不知道该如何处理异常。
</p>

<p>
指明某个函数不会抛出异常可以令函数的调用者不必再考虑如何处理异常。无论是函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
通常情况下，编译器不能也不必在编译时验证异常说明。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org807fb86" class="outline-5">
<h5 id="org807fb86">异常说明的实参</h5>
<div class="outline-text-5" id="text-org807fb86">
<p>
noexcept 说明符接受一个可选的实参，该实参必须能转换为 bool 类型；如果实参是 true，则函数不会抛出异常；如果实参是 false，则函数可能抛出异常：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">recoup</span>(<span style="color: #ECBE7B;">int</span>) <span style="color: #51afef;">noexcept</span>(<span style="color: #a9a1e1;">true</span>);    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">recoup&#19981;&#20250;&#25243;&#20986;&#24322;&#24120;</span>
<span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">alloc</span>(<span style="color: #ECBE7B;">int</span>) <span style="color: #51afef;">noexcept</span>(<span style="color: #a9a1e1;">false</span>);    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">alloc&#21487;&#33021;&#25243;&#20986;&#24322;&#24120;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org1d11789" class="outline-5">
<h5 id="org1d11789">noexcept 运算符</h5>
<div class="outline-text-5" id="text-org1d11789">
<p>
noexcept 说符命的实参常常与 <b>noexcept 运算符</b> 混合使用。noexcept 运算符是一个一元运算符，它的返回值是一个 bool 类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和 sizeof 类型，noexcept 也不会求其运算对象的值。
</p>

<p>
<code>noexcept(e)</code>
</p>

<p>
当 e 调用的所有函数都做了不抛出说明且 e 本身不含有 throw 语句时，上述表达式为 true；否则 noexcept(e)返回 false。
</p>

<p>
我们可以使用 noexcept 运算符得到如下的异常说明：
</p>

<p>
<code>void f() noexcept(noexcept(g()));  // f和g的异常说明一致</code>
</p>

<p>
如果函数 g 承诺了不会抛出异常，则 f 也不会抛出异常；如果 g 没有异常说明符，或者 g 虽然有异常说明符但是允许抛出异常，则 f 也可能抛出异常。
</p>

<blockquote>
<p>
Note：
</p>

<p>
noexcept 有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为 noexcept 异常说明的 bool 实参出现时，它是一个运算符。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orge5c9772" class="outline-5">
<h5 id="orge5c9772">异常说明与指针、虚函数和拷贝控制</h5>
<div class="outline-text-5" id="text-orge5c9772">
<p>
尽管 noexcept 说明符不属于函数类型的一部分，但是函数的异常说明仍然会影响函数的使用。
</p>

<p>
函数指针及该指针所指的函数必须具有一致的异常说明。也就说，如果我们为某个指针做出了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明指针可能抛出异常，则该指针可以指向任何函数，即使时承诺了不抛出异常的函数也可以：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">recoup&#21644;pf1&#37117;&#25215;&#35834;&#19981;&#20250;&#25243;&#20986;&#24322;&#24120;</span>
<span style="color: #ECBE7B;">void</span> (*<span style="color: #c678dd;">pf1</span>)(<span style="color: #ECBE7B;">int</span>) <span style="color: #51afef;">noexcept</span> = recoup;
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;recoup&#19981;&#20250;&#25243;&#20986;&#24322;&#24120;&#65292;pf2&#21487;&#33021;&#25243;&#20986;&#24322;&#24120;&#65292;&#20108;&#32773;&#20043;&#38388;&#20114;&#19981;&#24178;&#25200;</span>
<span style="color: #ECBE7B;">void</span> (*<span style="color: #c678dd;">pf2</span>)(<span style="color: #ECBE7B;">int</span>) = recoup;

pf1 = alloc;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;alloc&#21487;&#33021;&#25243;&#20986;&#19968;&#27425;&#26679;&#65292;&#20294;&#26159;pf1&#24050;&#32463;&#35828;&#26126;&#20102;&#23427;&#19981;&#20250;&#25243;&#20986;&#24322;&#24120;</span>
pf2 = alloc;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;pf2&#21644;alloc&#37117;&#21487;&#33021;&#25243;&#20986;&#24322;&#24120;</span>
</pre>
</div>

<p>
如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出一次样，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。
</p>

<p>
当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是 noexcept 的。如果合成成员调用的任意一个函数可能抛出异常，则合成的成员是 noexcept(false)。而且，如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。
</p>
</div>
</div>
</div>
<div id="outline-container-orga71046f" class="outline-4">
<h4 id="orga71046f">18.1.5 异常类层次</h4>
<div class="outline-text-4" id="text-orga71046f">
<p>
标准库异常类（参见 5.6.3 节）构成了图的继承体系。
</p>


<div class="figure">
<p><img src="../../../pics/C++/exception.png" alt="exception.png">
</p>
<p><span class="figure-number">&#22270;1&nbsp; </span>标准 exception 类层次</p>
</div>

<p>
类型 exception 仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为 what 的虚成员。其中 what 函数返回一个 const char*，该指针指向一个以 NULL 结尾的字符数组，并且确保不会抛出任何异常。
</p>

<p>
类 exception、bad_cast 和 bad_alloc 定义了默认构造函数。类 runtime_error 和 logic_error 没有默认构造函数，但是有一个可以接受 C 风格字符串或标准库 string 类型实参的构造函数，这些实参负责提供关于错误的更多信息。在这些类中，what 负责返回用于初始化异常对象的信息。因为 what 是虚函数，所以当我们捕获基类的引用时，对 what 函数的调用将执行与异常对象动态类型对应的版本。
</p>
</div>
</div>
</div>
<div id="outline-container-org8003ad3" class="outline-3">
<h3 id="org8003ad3">18.2 命名空间</h3>
<div class="outline-text-3" id="text-org8003ad3">
<p>
大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突地情况。多个库将名字放置在全局命名空间将引发 <b>命名空间污染</b> 。
</p>

<p>
<b>命名空间</b> 为防止名字冲突提供了更加可控地机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某搞个命名空间中定义库地名字，库的作者（以及用户）可以避免全局名字固有地限制。
</p>
</div>
<div id="outline-container-org04fc7aa" class="outline-4">
<h4 id="org04fc7aa">18.2.1 命名空间定义</h4>
<div class="outline-text-4" id="text-org04fc7aa">
<p>
一个命名空间地定义包含两部分：首先是关键字 namespace，随后是命名空间名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中地声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。
</p>

<p>
和其他名字一样，命名空间地名字也必须在定义它地作用域内保持唯一。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类地内部。
</p>

<blockquote>
<p>
Note：
</p>

<p>
命名空间作用域后无须分号。
</p>
</blockquote>
</div>
<div id="outline-container-org7b616db" class="outline-5">
<h5 id="org7b616db">每个命名空间都是一个作用域</h5>
<div class="outline-text-5" id="text-org7b616db">
<p>
和其他作用域类似，命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。
</p>

<p>
定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间。
</p>
</div>
</div>
<div id="outline-container-org00d5359" class="outline-5">
<h5 id="org00d5359">命名空间可以不是连续的</h5>
<div class="outline-text-5" id="text-org00d5359">
<p>
如我们在 16.5 节介绍过的，命名空间可以定义在几个不同的部分，这一点与其他作用域不太一样。编写如下的命名空间定义：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">nsp</span> {
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#30456;&#20851;&#22768;&#26126;</span>
}
</pre>
</div>

<p>
可能定义了一个名为 nsp 的新命名空间，也可能是为已经存在的命名空间添加一些新成员。如果之前没有名为 nsp 的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间并为其添加一些新成员的声明。
</p>

<p>
命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：
</p>
<ul class="org-ul">
<li>命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件被包含在在使用了这些成员的文件中。</li>
<li>命名空间成员的定义部分则置于另外的源文件中。</li>
</ul>

<p>
在程序中某些实体只能哪定义一次：如非内联函数、静态函数成员、变量等，命名空间中定义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他其名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明。
</p>

<blockquote>
<p>
Best Practies：
</p>

<p>
定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型（或关联类型构成的集合）。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgd47d623" class="outline-5">
<h5 id="orgd47d623">定义命名空间成员</h5>
<div class="outline-text-5" id="text-orgd47d623">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef; font-weight: bold;">#include</span> <span style="color: #98be65;">"Sales_data.h"</span>
<span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">cplusplus_primer</span> {  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#37325;&#26032;&#25171;&#24320;&#21629;&#21517;&#31354;&#38388;cplusplus_primer</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21629;&#21517;&#31354;&#38388;&#20013;&#23450;&#20041;&#30340;&#25104;&#21592;&#21487;&#20197;&#30452;&#25509;&#20351;&#29992;&#21517;&#23383;&#65292;&#27492;&#26102;&#26080;&#39035;qi&#21069;&#32512;</span>
  <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">istream</span>&amp; <span style="color: #51afef;">operator</span><span style="color: #c678dd;">&gt;&gt;</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">istream</span>&amp; <span style="color: #dcaeea;">in</span>, <span style="color: #ECBE7B;">Sales_data</span>&amp; <span style="color: #dcaeea;">s</span>) { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> }
}
</pre>
</div>

<p>
也可以在命名空间定义的外部定义该命名空间的成员。命名空间对于名字的声明必须在做作用域内，同时该名字的定义需要明确指出其所属的命名空间：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21629;&#21517;&#31354;&#38388;&#20043;&#22806;&#23450;&#20041;&#30340;&#25104;&#21592;&#24517;&#39035;&#20351;&#29992;&#21547;&#26377;&#21069;&#32512;&#30340;&#21517;&#23383;</span>
<span style="color: #a9a1e1;">cplusplus_primer</span>::<span style="color: #ECBE7B;">Sales_data</span>
<span style="color: #a9a1e1;">cplusplus_primer</span>::<span style="color: #51afef;">operator</span><span style="color: #c678dd;">+</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Sales_data</span>&amp; <span style="color: #dcaeea;">lhs</span>, <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Sales_data</span>&amp; <span style="color: #dcaeea;">rhs</span>) {
  <span style="color: #ECBE7B;">Sales_data</span> <span style="color: #dcaeea;">ret</span>(lhs);
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">...</span>
}
</pre>
</div>

<p>
和定义在类外部的类成员一样，一旦看到含有完整前缀的名字，我们就可以确定该名字位于命名空间的作用域内。
</p>

<p>
即宽命名空间的成员可以定义在命名空间外部，但这样的定义必须出现在所述命名空间的外层。
</p>
</div>
</div>
<div id="outline-container-orgc8569fd" class="outline-5">
<h5 id="orgc8569fd">模板特例化</h5>
<div class="outline-text-5" id="text-orgc8569fd">
<p>
模板特例化必须定义在原始模板所属的命名空间中（参见 16.5 节）。和其他其命名空间名字类似，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25105;&#20204;&#24517;&#39035;&#23558;&#27169;&#26495;&#29305;&#20363;&#21270;&#22768;&#26126;&#25104;std&#30340;&#25104;&#21592;</span>
<span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">std</span> {
  <span style="color: #51afef;">template</span> &lt;&gt; <span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">hash</span>&lt;Sales_data&gt;;
}
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22312;std&#20013;&#28155;&#21152;&#20102;&#27169;&#26495;&#29305;&#20363;&#21270;&#30340;&#22768;&#26126;&#21518;&#65292;&#23601;&#21487;&#20197;&#22312;&#21629;&#21517;&#31354;&#38388;std&#30340;&#22806;&#37096;&#23450;&#20041;&#23427;&#20102;</span>
<span style="color: #51afef;">template</span> &lt;&gt; <span style="color: #51afef;">struct</span>::<span style="color: #ECBE7B;">hash</span>&lt;Sales_data&gt; {
  <span style="color: #ECBE7B;">size_t</span> <span style="color: #51afef;">operator</span><span style="color: #c678dd;">()</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Sales_data</span>&amp; <span style="color: #dcaeea;">s</span>) <span style="color: #51afef;">const</span> {
    <span style="color: #51afef;">return</span> hash&lt;<span style="color: #ECBE7B;">string</span>&gt;()(s.bookNo) ^
           hash&lt;<span style="color: #ECBE7B;">unsigned</span>&gt;()(s.units_sold) ^
           hash&lt;<span style="color: #ECBE7B;">double</span>&gt;()(s.revenue);
    }
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20854;&#20182;&#25104;&#21592;&#19982;&#20043;&#21069;&#30340;&#29256;&#26412;&#19968;&#33268;</span>
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-org0301c07" class="outline-5">
<h5 id="org0301c07">全局命名空间</h5>
<div class="outline-text-5" id="text-org0301c07">
<p>
全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在 <b>全局命名空间</b> 中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。
</p>

<p>
作用域运算符同样可以用于全局作用域地成员，因为全局作用域是隐式地，所以它并没有名字。下面地形式
</p>

<p>
<code>::member_name</code>
</p>

<p>
表示全局命名空间中的一个成员。
</p>
</div>
</div>
<div id="outline-container-org443fbd0" class="outline-5">
<h5 id="org443fbd0">内联命名空间</h5>
<div class="outline-text-5" id="text-org443fbd0">
<p>
C++11 新标准引入了一种新的嵌套命名空间，称为 <b>内联命名空间</b> 和普通的嵌套命名空间不同。内联命名空间中的名字可以被外层命名空间直接使用。
</p>

<p>
定义内联命名空间的方式是在关键字 namespace 前添加关键字 inline。
</p>

<p>
关键字 inline 必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写 inline，也可以不写。
</p>

<p>
当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。例如，我们可以把本书当前的所有代码都放在一个内联命名空间中，而之前版本的代码都放在一个非内联命名空间中：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">FourthEd</span> {
  <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Item_base</span> { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> };
  <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Query_base</span> { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> };
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26412;&#20070;&#31532;4&#29256;&#29992;&#21040;&#30340;&#20854;&#20182;&#20195;&#30721;</span>
}
</pre>
</div>

<p>
命名空间 cplusplus_primer 将同时使用这两个命名空间。例如，假定每个命名空间都定义在同名的头文件中，则我们可以把命名空间 cplusplus_peimer 定义成如下形式：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">cplusplus_primer</span> {
<span style="color: #51afef; font-weight: bold;">  #include</span> <span style="color: #98be65;">"FifthEd.h"</span>
<span style="color: #51afef; font-weight: bold;">  #include</span> <span style="color: #98be65;">"FourthEd.h"</span>
}
</pre>
</div>

<p>
因为 FifthEd 是内联的，所以形如 cplusplus_primer::的代码可以直接获得 FifthEd 的成员。如果我们想使用早期版本的代码，则必须像其他其嵌套的命名空间一样加上完整的外层命名空间名字，比如 cplusplus_perimer::FourthEd::Query_base。
</p>
</div>
</div>
<div id="outline-container-orga6c743a" class="outline-5">
<h5 id="orga6c743a">未命名的命名空间</h5>
<div class="outline-text-5" id="text-orga6c743a">
<p>
<b>未命名的命名空间</b> 是指关键字 namespace 后紧跟花括号括起来的一些列 g 神明语句。未命名的命名空间中定义的变量拥有静态声明周期：它们在第一次使用前创建，并且直到程序结束才销毁。
</p>

<p>
一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该文件的文件中对应不同实体。
</p>

<blockquote>
<p>
Note：
</p>

<p>
和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。
</p>
</blockquote>

<p>
定义在未命名的命名空间中的名字可以直接使用，毕竟我们找不到什么命名空间的名字来限定它们；同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。
</p>

<p>
未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>;        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">i&#30340;&#20840;&#23616;&#22768;&#26126;</span>
<span style="color: #51afef;">namespace</span> {
  <span style="color: #ECBE7B;">ini</span> <span style="color: #dcaeea;">i</span>;
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20108;&#20041;&#24615;&#65306;i&#30340;&#23450;&#20041;&#26082;&#20986;&#29616;&#22312;&#20840;&#23616;&#20316;&#29992;&#22495;&#20013;&#65292;&#21448;&#20986;&#29616;&#22312;&#26410;&#23884;&#22871;&#30340;&#30340;&#26410;&#21629;&#21517;&#30340;&#21629;&#21517;&#31354;&#38388;&#20013;</span>
  i = <span style="color: #da8548; font-weight: bold;">10</span>;
}
</pre>
</div>

<p>
其他情况下，未命名的命名空间中的成员都属于正确的程序实体。和所有命名空间类似，一个未命名的命名空间也能嵌套在其他命名空间中。此时，未命名的 i 买嗯名空间中的成员可以通过外层命名空间的名字来访问：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">local</span> {
  <span style="color: #51afef;">namespace</span> {
    <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span>;
  }
}
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#23450;&#20041;&#22312;&#23884;&#22871;&#30340;&#26410;&#21629;&#21517;&#30340;&#21629;&#21517;&#31354;&#38388;&#20013;&#30340;i&#19982;&#20840;&#23616;&#20316;&#29992;&#22495;&#20013;&#30340;i&#19981;&#21516;</span>
<span style="color: #a9a1e1;">local</span>::i = <span style="color: #da8548; font-weight: bold;">42</span>;
</pre>
</div>

<blockquote>
<p>
未命名的命名空间取代文件中的静态声明
</p>

<p>
在标准 C++引入命名空间的概念之前，程序需要将名字声明成 static 的以使得其对于整个文件有效。在文件中进行 <b>静态声明</b> 的做法是从 C 语言继承过来的。在 C 语言中，声明未 static 的全局实体在其所在的文件外不可见。
</p>
</blockquote>

<blockquote>
<p>
WARNING：
</p>

<p>
在文件中进行静态声明的做法已经被 C++标准取消了，现在的做法是使用未命名的命名空间。
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgf19440b" class="outline-4">
<h4 id="orgf19440b">18.2.2 使用命名空间成员</h4>
<div class="outline-text-4" id="text-orgf19440b">
</div>
<div id="outline-container-org4c5e35a" class="outline-5">
<h5 id="org4c5e35a">命名空间的别名</h5>
<div class="outline-text-5" id="text-org4c5e35a">
<p>
<b>命名空间的别名</b> 使得我们可以为命名空间的名字设定一个短得多的同义词。例如，一个很多的命名空间的名字形如
</p>

<p>
<code>namespace cplusplus_primer { /* ... */ }</code>
</p>

<p>
我们可以为其设定一个短得多的同义词
</p>

<p>
<code>namespace primer = cplusplus_primer</code>
</p>

<p>
命名空间的别名声明以关键字 namespace 开始，后面是别名所用的名字，=符号、命名空间原来的名字以及一个分号。
</p>

<p>
命名空间的别名也可以指向一个嵌套的命名空间：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">Qlib</span> = <span style="color: #a9a1e1;">cplusplus_primer</span>::QueryLib;
<span style="color: #a9a1e1;">Qlib</span>::<span style="color: #ECBE7B;">Query</span> <span style="color: #dcaeea;">q</span>;
</pre>
</div>

<blockquote>
<p>
Note：
</p>

<p>
一个命名空间可以有好几个同义词或别名，所有别名与命名空间原来的名字等价。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org441905d" class="outline-5">
<h5 id="org441905d">using 声明：扼要概述</h5>
<div class="outline-text-5" id="text-org441905d">
<p>
一条 <b>using 声明</b> 语句一次只引入命名空间的一个成员。它使得我们可以清楚地直到程序中所用的到底是哪个名字。
</p>

<p>
using 声明引入的名字遵守与过去一样的作用域规则：它的有效范围从 using 声明的地方开始，一直到 using 声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。未加限定的名字只能在 using 声明所在的作用域以及其内层作用域中使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。
</p>

<p>
一条 using 声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类作用域中。在类的作用域中，这样的声明语句只能指向基类成员（参见 15.5 节）。
</p>
</div>
</div>
<div id="outline-container-org12f39be" class="outline-5">
<h5 id="org12f39be">using 指示</h5>
<div class="outline-text-5" id="text-org12f39be">
<p>
<b>using 指示</b> 和 using 声明类似的地方是，我们可以使用命名空间名字的简写形式：和 using 声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。
</p>

<p>
using 指示以关键字 using 开始，后面是关键 namespace 以及命名空间的名字。如果这里所用的名字不是一个已经定义好的命名空间的名字，则程序将发生错误。using 指示可以出现在全局作用域、局部作用域和命名空间作用域中，但时不能出现在类的作用域中。
</p>

<p>
using 指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从 using 指示开始，一直到 using 指示所在的作用结束都能使用。
</p>
</div>
</div>
<div id="outline-container-orgdfc869a" class="outline-5">
<h5 id="orgdfc869a">头文件与 using 声明或指示</h5>
<div class="outline-text-5" id="text-orgdfc869a">
<p>
头文件如果在其顶层作用域中含有 using 指示或 using 声明，则会将名字注入到所有包含了该头文件的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用 using 指示或 using 声明（参见 3.1 节）。
</p>

<blockquote>
<p>
Tip：
</p>

<p>
using 指示也并非一无是处，例如在命名空间本身的实现文件中就可以是一噢嗯 using 指示。
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-orgc7b05da" class="outline-4">
<h4 id="orgc7b05da">18.2.3 类、命名空间与作用域</h4>
<div class="outline-text-4" id="text-orgc7b05da">
</div>
<div id="outline-container-org79917d2" class="outline-5">
<h5 id="org79917d2">实参相关的查找与类类型参数</h5>
<div class="outline-text-5" id="text-org79917d2">
<p>
考虑西面这个简单的程序：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">strign</span> <span style="color: #dcaeea;">s</span>;
<span style="color: #a9a1e1;">std</span>::cin &gt;&gt; s;
</pre>
</div>

<p>
如我们所知，该调用等价于：
</p>

<p>
<code>operator&gt;&gt;(std::cin, s)</code>
</p>

<p>
operator&gt;&gt;函数定义在标准库 string 中，string 又定义在命名空间 std 中。但是我们不用 std::限定符和 using 声明就可以调用 operator&gt;&gt;。
</p>

<p>
对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以自号接访问输出运算符。这个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样有效。
</p>

<p>
在此例中，当编译器发现对 operator&gt;&gt;的调用时，首先在当前作用域中寻找合适的函数，接着查找输出语句的外层作用域作用域。随后，因为&gt;&gt;表达式的形参是类类型的，所以编译器还会查找 cin 和 s 的类所属的命名空间。也就是说，对于这个调用来说，编译器会查找定义了 istream 和 string 的命名空间 std。当在 std 中查找时，编译器找到了 string 的输出运算符函数。
</p>

<p>
查找规则的这个类外允许概念上作为类接口的一部分的非成员函数无须单独的 using 声明就能被程序使用。
</p>
</div>
</div>
<div id="outline-container-org15c1d7b" class="outline-5">
<h5 id="org15c1d7b">友元声明与实参相关的查找</h5>
<div class="outline-text-5" id="text-org15c1d7b">
<p>
回顾我们曾经讨论过的，当类声明了一个友元时，该有友元声明并没有使得友元本身可见（参见 7.2.1 节）。然而，一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员。这条规则与实参相关的查找规则结合在一起将产生意想不到的效果：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">A</span> {
  <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">C</span> {
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20004;&#20010;&#21451;&#20803;&#65292;&#22312;&#21451;&#20803;&#22768;&#26126;&#20043;&#22806;&#27809;&#26377;&#20854;&#20182;&#22768;&#26126;</span>
    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36825;&#20123;&#20989;&#25968;&#38544;&#24335;&#22320;&#25104;&#20026;&#21629;&#21517;&#31354;&#38388;A&#30340;&#25104;&#21592;</span>
    <span style="color: #51afef;">friend</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">f2</span>();          <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38500;&#38750;&#21478;&#26377;&#22768;&#26126;&#65292;&#21542;&#21017;&#19981;&#20250;&#34987;&#25214;&#21040;</span>
    <span style="color: #51afef;">friend</span> <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">f</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">C</span>&amp;);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26681;&#25454;&#23454;&#21442;&#30456;&#20851;&#30340;&#26597;&#25214;&#35268;&#21017;&#21487;&#20197;&#34987;&#25214;&#21040;</span>
  };
}
</pre>
</div>

<p>
此时，f和 f2 都是命名空间 A 的成员。即使 f 不存在其他声明，我们也能通过实参相关的查找规则调用 f：‘
</p>
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
  <span style="color: #a9a1e1;">A</span>::<span style="color: #ECBE7B;">C</span> <span style="color: #dcaeea;">cobj</span>;
  f(cobj);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#36890;&#36807;&#22312;A::C&#20013;&#30340;&#21451;&#20803;&#22768;&#26126;&#25214;&#21040;A;;f</span>
  f2();      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;A::f2&#27809;&#26377;&#34987;&#22768;&#26126;</span>
}
</pre>
</div>

<p>
因为 f 接受一个类类型的实参，而且 f 在 C 所属的命名空间进行了隐式的声明，所以 f 能被找到。相反，因为 f2 没有形参，所以它无法被找到。
</p>
</div>
</div>
</div>
<div id="outline-container-org04a9196" class="outline-4">
<h4 id="org04a9196">18.2.4 重载与命名空间</h4>
<div class="outline-text-4" id="text-org04a9196">
</div>
<div id="outline-container-orgb184047" class="outline-5">
<h5 id="orgb184047">与实参相关的查找与重载</h5>
<div class="outline-text-5" id="text-orgb184047">
<p>
在上一节中我们了解到，对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。我们将在每个实参类（以及实参类的基类）所属的命名空间中搜寻候选函数。在这些命名空间中所有被与调用函数同名的函数都将被添加到候选集中，即使其中某些函数在调用语句处不可见也是如此：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">namespace</span> <span style="color: #a9a1e1;">NS</span> {
  <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Quoto</span> { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> };
  <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">display</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">Quote</span>&amp;) { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> }
}
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Bulk_item&#30340;&#22522;&#31867;&#22768;&#26126;&#22312;&#21629;&#21517;&#31354;&#38388;NS&#20013;</span>
<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Bulk_iitem</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">NS</span>:Quote { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> };
<span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">main</span>() {
  <span style="color: #ECBE7B;">Bulk_iitem</span> <span style="color: #dcaeea;">book1</span>;
  display(book1);
  <span style="color: #51afef;">return</span> <span style="color: #da8548; font-weight: bold;">0</span>;
}
</pre>
</div>

<p>
命名空间 NS 中声明的 display(const Quote&amp;)也将被添加到候选函数集中。
</p>
</div>
</div>
<div id="outline-container-org00597fa" class="outline-5">
<h5 id="org00597fa">重载与 using 声明</h5>
<div class="outline-text-5" id="text-org00597fa">
<p>
要想理解 using 声明与重载之间的交互关系，必须首先明确一条：using 声明语句声明的是一个名字，而非一个特定的函数：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">using</span> <span style="color: #ECBE7B;">NS</span>:print(<span style="color: #ECBE7B;">int</span>);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;&#19981;&#33021;&#25351;&#23450;&#24418;&#21442;&#21015;&#34920;</span>
<span style="color: #51afef;">using</span> <span style="color: #ECBE7B;">NS</span>:print;        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;using&#22768;&#26126;&#21482;&#22768;&#26126;&#19968;&#20010;&#21517;&#23383;</span>
</pre>
</div>

<p>
当我们为函数书写 using 声明时，该函数的所有版本都被引入到当前作用域中。
</p>

<p>
一个 using 声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果 using 声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如果 using 声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如果 using 声明所在的作用域已经有一个函数与新引入的函数同名且形参列表相同，则该 using 声明将引发错误。除此之外，using 声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。
</p>
</div>
</div>
<div id="outline-container-orga998913" class="outline-5">
<h5 id="orga998913">重载与 using 指示</h5>
<div class="outline-text-5" id="text-orga998913">
<p>
与 using 声明不同的时，对于 using 指示，引入一个已有函数形参列表完全相同的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可。
</p>
</div>
</div>
<div id="outline-container-org4c5b532" class="outline-5">
<h5 id="org4c5b532">跨越多个 using 指针的重载</h5>
<div class="outline-text-5" id="text-org4c5b532">
<p>
如果存在多个 using 指示，则来自每个命名空间的名字都会称为候选函数集的一部分。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc49242e" class="outline-3">
<h3 id="orgc49242e">18.3 多重继承与虚继承</h3>
<div class="outline-text-3" id="text-orgc49242e">
<p>
<b>多重继承</b> 是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。
</p>
</div>
<div id="outline-container-org5eb1c0f" class="outline-4">
<h4 id="org5eb1c0f">18.3.1 多重继承</h4>
<div class="outline-text-4" id="text-org5eb1c0f">
</div>
<div id="outline-container-org5ec663b" class="outline-5">
<h5 id="org5ec663b">多重继承的派生类从每个基类中继承状态</h5>
<div class="outline-text-5" id="text-org5ec663b">

<div class="figure">
<p><img src="pics/C++/panda.png" alt="panda.png">
</p>
<p><span class="figure-number">&#22270;2&nbsp; </span>Panda 对象的概念结构</p>
</div>
</div>
</div>
<div id="outline-container-org9b45c6c" class="outline-5">
<h5 id="org9b45c6c">派生类初始化所有基类</h5>
<div class="outline-text-5" id="text-org9b45c6c">
<p>
构造一个派生类的对象将同时构造并初始化它的所有基类子对象。与从一个基类进行派生一样，多重继承的派生类的构造函数初始值也只能初始化它的直接基类。
</p>

<p>
派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生类中基类的出现顺序保持一致，而与派生类构造函数初始值中的基类顺序无关。一个 Panda 对象按照如下顺序进行初始化：
</p>
<ul class="org-ul">
<li>ZooAnimal 是整个继承体系的最终基类，Bear 是 Panda 的直接基类，ZooAnimal 是 Bear 的基类，所以首先初始化 ZooAnimal。</li>
<li>接下来初始化 Panda 的第一个直接基类 Bear。</li>
<li>然后初始化 Panda 的第二个直接基类 Endangered。</li>
<li>最后初始化 Panda。</li>
</ul>
</div>
</div>
<div id="outline-container-org3a4489a" class="outline-5">
<h5 id="org3a4489a">继承的构造函数与多重继承</h5>
<div class="outline-text-5" id="text-org3a4489a">
<p>
在 C++11 新标准中，允许派生类从它的一个或几个基类中继承构造函数（参见 15.7.4 节）。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同（），则程序产生错误：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Base1</span> {
  <span style="color: #c678dd;">Base1</span>() = <span style="color: #51afef;">default</span>;
  <span style="color: #c678dd;">Base1</span>(<span style="color: #51afef;">const</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">string</span>&amp;);
  <span style="color: #c678dd;">Base1</span>(<span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">shared_ptr</span>&lt;<span style="color: #ECBE7B;">int</span>&gt;);
};
<span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">Base2</span> {
  <span style="color: #c678dd;">Base2</span>() = <span style="color: #51afef;">default</span>;
  <span style="color: #c678dd;">Base2</span>(<span style="color: #51afef;">const</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">string</span>&amp;);
  <span style="color: #c678dd;">Base2</span>(<span style="color: #ECBE7B;">int</span>);
};
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;D1&#35797;&#22270;&#20174;&#20004;&#20010;&#22522;&#31867;&#20013;&#37117;&#32487;&#25215;D1::D1(const string&amp;)</span>
<span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">D1</span>: <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base1</span>, <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base2</span> {
  <span style="color: #51afef;">using</span> <span style="color: #a9a1e1;">Base1</span>::<span style="color: #ECBE7B;">Base1</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20174;Base1&#32487;&#25215;&#26500;&#36896;&#20989;&#25968;</span>
  <span style="color: #51afef;">using</span> <span style="color: #ECBE7B;">Base12</span>:Base2;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20174;Base2&#32487;&#25215;&#26500;&#36896;&#20989;&#25968;</span>
};
</pre>
</div>

<p>
如果一个类从它的多个基类中即成了相同的构造函数，则这个类必须为该构造函数定义自己的版本：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">struct</span> <span style="color: #ECBE7B;">D2</span>: <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base1</span>, <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Base2</span> {
  <span style="color: #51afef;">using</span> <span style="color: #a9a1e1;">Base1</span>::<span style="color: #ECBE7B;">Base1</span>;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20174;Base1&#32487;&#25215;&#26500;&#36896;&#20989;&#25968;</span>
  <span style="color: #51afef;">using</span> <span style="color: #a9a1e1;">Base2</span>::<span style="color: #ECBE7B;">base2</span>;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20174;Base2&#32487;&#25215;&#26500;&#36896;&#20989;&#25968;</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">D2&#24517;&#39035;&#33258;&#23450;&#20041;&#19968;&#20010;&#25509;&#21463;string&#30340;&#26500;&#36896;&#20989;&#25968;</span>
  <span style="color: #c678dd;">D2</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">string</span> &amp;<span style="color: #dcaeea;">s</span>) : Base1(s), Base2(s) {  }
  <span style="color: #c678dd;">D2</span>() = <span style="color: #51afef;">default</span>;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19968;&#26086;D2&#23450;&#20041;&#20102;&#23427;&#33258;&#24049;&#30340;&#26500;&#36896;&#20989;&#25968;&#65292;&#21017;&#24517;&#28982;&#20986;&#29616;</span>
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org8a49d6a" class="outline-5">
<h5 id="org8a49d6a">析构函数与多重继承</h5>
<div class="outline-text-5" id="text-org8a49d6a">
<p>
和往常一样，派生类的析构函数只负责清楚派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。
</p>

<p>
析构函数的调用顺序与构造函数相反，在我们的例子中，析构函数的调用顺序是~Panda、~Endangered、~Bear 和~ZooAnimal。
</p>
</div>
</div>
<div id="outline-container-org81f3ed1" class="outline-5">
<h5 id="org81f3ed1">多重继承和派生类的拷贝与移动操作</h5>
<div class="outline-text-5" id="text-org81f3ed1">
<p>
与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作（参见 15.7.2 节）。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作。在合成的拷贝控制成员中，买个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作。
</p>
</div>
</div>
</div>
<div id="outline-container-org4de0d3e" class="outline-4">
<h4 id="org4de0d3e">18.3.2 类型转换与多个基类</h4>
<div class="outline-text-4" id="text-org4de0d3e">
<p>
在只有一个基类的情况下，派生类的指针或引用能自动转换成一个可访问基类的指针或引用。多个基类的情况与之类似。我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。
</p>

<p>
编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任何一种基类都一样好。
</p>
</div>
<div id="outline-container-org0f3891e" class="outline-5">
<h5 id="org0f3891e">基类指针类型或引用类型的查找</h5>
<div class="outline-text-5" id="text-org0f3891e">
<p>
与只有一个基类的继承一样，对象、指针和引用的静态类型决定我们能够使用哪些成员。
</p>
</div>
</div>
</div>
<div id="outline-container-org2b72f42" class="outline-4">
<h4 id="org2b72f42">18.3.3 多重继承下的类作用域</h4>
<div class="outline-text-4" id="text-org2b72f42">
<p>
在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中（参见 15.6 节）。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。
</p>

<p>
在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。
</p>

<p>
对于一个派生类，从它的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出它的版本。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org5ec5612" class="outline-4">
<h4 id="org5ec5612">18.3.4 虚继承</h4>
<div class="outline-text-4" id="text-org5ec5612">
<p>
尽管在派生类列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过在它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。
</p>

<p>
在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。
</p>

<p>
在 C++语言中我们通过 <b>虚继承</b> 的机制解决上述问题。虚继承的目的是令某搞个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为 <b>虚基类</b> 。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。
</p>

<blockquote>
<p>
Note：
</p>

<p>
虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。
</p>
</blockquote>
</div>
<div id="outline-container-orga55b234" class="outline-5">
<h5 id="orga55b234">使用虚基类</h5>
<div class="outline-text-5" id="text-orga55b234">
<p>
我们指定虚基类的方式是在派生列表中添加关键字 virtual：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20851;&#38190;&#23383;public&#21644;virtual&#30340;&#39034;&#24207;&#38543;&#24847;</span>
<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Raccoon</span> : <span style="color: #51afef;">public</span> <span style="color: #51afef;">virtual</span> <span style="color: #ECBE7B;">ZoonAnimal</span> { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> };
<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Bear</span> : <span style="color: #51afef;">virtual</span> <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">ZooAnimal</span> { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> };
</pre>
</div>

<p>
通过上面的代码我们将 ZooAnimal 定义为 Raccoon 和 Bear 的虚基类。
</p>

<p>
virtual 说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。置于什么样的类能够作为虚基类并没有特殊规定。
</p>

<p>
如果某个类指定了虚基类，则该类的派生仍按常规方式进行：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Panda</span> : <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Bear</span>,
              <span style="color: #51afef;">public</span> <span style="color: #ECBE7B;">Raccoon</span>, <span style="color: #51afef;">public</span>  <span style="color: #ECBE7B;">Endangered</span> {
};
</pre>
</div>

<p>
Panda 通过 Raccoon 和 Bear 继承了 ZooAnimal，因为 Raccoon 和 Bear 继承 ZooAnimal 的方式都是虚继承，所以在 Panda 中只有一个 ZooAnimal 基类部分。
</p>
</div>
</div>
<div id="outline-container-org5c0fcbb" class="outline-5">
<h5 id="org5c0fcbb">支持向基类的常规类型转换</h5>
<div class="outline-text-5" id="text-org5c0fcbb">
<p>
不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。
</p>
</div>
</div>
<div id="outline-container-org6179efd" class="outline-5">
<h5 id="org6179efd">虚基类成员的可见行</h5>
<div class="outline-text-5" id="text-org6179efd">
<p>
因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径负该，则我们仍然可以直接访问这个被覆盖的成员。但是如果成员被多余一个虚类覆盖，则一半情况下派生类必须为该成员自定义一个新的版本。
</p>

<p>
例如，假定类 B 定义了一个名为 X 的成员，D1 和 D2 都是从 B 虚继承得到的，D继承了 D1 和 D2，则在 D 的作用域中，X通过 D 的两个基类都是可见的。如果我们通过 D 的对象使用了 X，有三种可能性：
</p>
<ul class="org-ul">
<li>如果在 D1 和 D2 中都没有 X 的定义，则 X 将被解析为 B 的成员，此时不存在二义性，一个 D 的对象只含有 X 的一个实例。</li>
<li>如果 X 是 B 的成员，同时是 D1 和 D2 中某一个的成员，则同样没有二义性，派生类的 X 比共享虚基类 B 和 X 的优先级更高。</li>
<li>如果在 D1 和 D2 中都有 X 的定义，则直接访问 X 将产生二义性问题。</li>
</ul>

<p>
与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自动以新的实例。
</p>
</div>
</div>
</div>
<div id="outline-container-orgf5edcdd" class="outline-4">
<h4 id="orgf5edcdd">18.3.5 构造函数与虚继承</h4>
<div class="outline-text-4" id="text-orgf5edcdd">
<p>
在虚派生中，虚基类是由最低层的派生类初始化的。以我们的程序为例，当创建 Panda 对象时，由 Panda 的构造函数独自控制 ZooAnimal 的初始化过程。
</p>

<p>
为了理解这一规则，我们不妨假设当以普通规则处理初始化任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以 ZooAnimal 为例，如果应用普通规则，则 Raccoon 和 Bear 都会试图初始化 Panda 对象的 ZooAnimal 部分。
</p>

<p>
当然，继承体系中的每个类都可能在某个时刻称为“最低层的派生类”。只要我们能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。
</p>
</div>
<div id="outline-container-orgcb7ce22" class="outline-5">
<h5 id="orgcb7ce22">虚继承的对象的构造方式</h5>
<div class="outline-text-5" id="text-orgcb7ce22">
<p>
含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接虚类在派生列表中出现的次序一次对其进行初始化。
</p>

<p>
例如，当我们创建一个 Panda 对象时：
</p>
<ul class="org-ul">
<li>首先使用 Panda 的构造函数初始值列表中提供的初始值构造虚基类 ZooAnimal 部分。</li>
<li>接下来构造 Bear 部分。</li>
<li>然后构造 Raccoon 部分。</li>
<li>然后构造第三个直接基类 Endangered。</li>
<li>最后构造 Panda 部分</li>
</ul>

<p>
如果 Panda 没有显示地初始化 ZooAnimal 基类，则 ZooAnimal 的默认构造函数被调用。如果 ZooAnimal 没有默认构造函数，则代码将发生错误。
</p>

<blockquote>
<p>
Note：
</p>

<p>
虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgac16f57" class="outline-5">
<h5 id="orgac16f57">构造函数与析构函数的次序</h5>
<div class="outline-text-5" id="text-orgac16f57">
<p>
一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。
</p>

<p>
编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。
</p>

<p>
合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象 d 额销毁顺序与构造顺序正好相反。
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org029fdef" class="outline-2">
<h2 id="org029fdef">第 19 章 特殊工具与技术</h2>
<div class="outline-text-2" id="text-org029fdef">
</div>
<div id="outline-container-org29a5b4d" class="outline-3">
<h3 id="org29a5b4d">19.1 控制内存分配</h3>
<div class="outline-text-3" id="text-org29a5b4d">
</div>
<div id="outline-container-org960b0c4" class="outline-4">
<h4 id="org960b0c4">19.1.1 重载 new 和 delete</h4>
<div class="outline-text-4" id="text-org960b0c4">
<p>
要想真正掌握 new 和 delete 的方法，首先要对 new 表达式和 delete 表达式的工作机理有更多了解。
</p>

<p>
当我们使用一条 new 表达式时，实际执行了三步操作。第一步，new 表达式调用一个名为 <b>operator new</b> （或者 <b>operator new[]</b> ）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。第二步，编译器运行相应的构造函数以构造这些对象，并为其传入初始值。第三步，对象被分配了空间并构造完成，返回一个指向该对象的指针。
</p>

<p>
当我们使用一个条 delete 表达式删除一个动态分配的对象时：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">delete</span> sp;      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38144;&#27585;*sp&#65292;&#28982;&#21518;&#37322;&#25918;sp&#25351;&#21521;&#30340;&#20869;&#23384;&#31354;&#38388;</span>
<span style="color: #51afef;">delete</span> [] arr;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38144;&#27585;&#25968;&#32452;&#20013;&#30340;&#20803;&#32032;&#65292;&#28982;&#21518;&#37322;&#25918;&#23545;&#24212;&#30340;&#20869;&#23384;&#31354;&#38388;</span>
</pre>
</div>

<p>
实际执行了两步操作。第一步，对 sp 所指的对象或者 arr 所指的数组中的元素执行对应的析构函数。第二部，编译器调用名为 <b>operator delete</b> （或者 <b>operator delete[]</b> ）的标准库函数释放内存空间。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
当自定义了全局的 operator new 函数和 operator delete 函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分。
</p>
</blockquote>

<p>
应用程序可以在全局作用域中定义 operator new 函数和 operator delete 函数，也可以将他们定义为成员函数。当编译器发现一条 new 表达式或 delete 表达式后，将在程序中查找可供调用了 operator 函数。如果被分配（释放）的对象是类类型，则编译器首先在类及其基类的作用域中查找。此时如果该类含有 operator new 成员或 operator delete 成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域查找匹配的函数。此时如果编译器找到了用户自定义的版本，则使用该版本执行 new 表达式或 delete 表达式；如果没有找到，则使用标准库函数定义的版本。
</p>
</div>
<div id="outline-container-orga10b138" class="outline-5">
<h5 id="orga10b138">operator new 接口和 operator delete 接口</h5>
<div class="outline-text-5" id="text-orga10b138">
<p>
标准库定义了 operator new 函数和 operator delete 函数的 8 个重载版本。其中前 4 个版本可能抛出 bad_alloc 异常，后 4 个版本则不会抛出异常：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36825;&#20123;&#29256;&#26412;&#21487;&#33021;&#25243;&#20986;&#24322;&#24120;</span>
<span style="color: #ECBE7B;">void</span> *<span style="color: #51afef;">operator</span> <span style="color: #51afef;">new</span>(<span style="color: #ECBE7B;">size_t</span>);                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20998;&#37197;&#19968;&#20010;&#23545;&#35937;</span>
<span style="color: #ECBE7B;">void</span> *<span style="color: #51afef;">operator</span> <span style="color: #51afef;">new</span>[](size_t);              <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20998;&#37197;&#19968;&#20010;&#25968;&#32452;</span>
<span style="color: #ECBE7B;">void</span> *<span style="color: #51afef;">operator</span> <span style="color: #51afef;">delete</span>(<span style="color: #ECBE7B;">void</span>*) <span style="color: #51afef;">noexcept</span>;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#37322;&#25918;&#19968;&#20010;&#23545;&#35937;</span>
<span style="color: #ECBE7B;">void</span> *<span style="color: #51afef;">operator</span> <span style="color: #51afef;">delete</span>[](<span style="color: #ECBE7B;">void</span>*) <span style="color: #51afef;">noexcept</span>;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#37322;&#25918;&#19968;&#20010;&#25968;&#32452;</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36825;&#20123;&#29256;&#26412;&#25215;&#35834;&#19981;&#20250;&#25243;&#20986;&#24322;&#24120;&#65292;&#21442;&#35265;12.1.2&#33410;</span>
<span style="color: #ECBE7B;">void</span> *<span style="color: #51afef;">operator</span> <span style="color: #51afef;">new</span>(size_t, <span style="color: #ECBE7B;">nothrow_t</span>&amp;) <span style="color: #51afef;">noexcept</span>;
<span style="color: #ECBE7B;">void</span> *<span style="color: #51afef;">operator</span> <span style="color: #51afef;">new</span>[](size_t, <span style="color: #ECBE7B;">nothrow_t</span>&amp;) <span style="color: #51afef;">noexcept</span>;
<span style="color: #ECBE7B;">void</span> *<span style="color: #51afef;">operator</span> <span style="color: #51afef;">delete</span>(<span style="color: #ECBE7B;">void</span>*, <span style="color: #ECBE7B;">nothrow_t</span>&amp;) <span style="color: #51afef;">noexcept</span>;
<span style="color: #ECBE7B;">void</span> *<span style="color: #51afef;">operator</span> <span style="color: #51afef;">delete</span>[](<span style="color: #ECBE7B;">void</span>*, <span style="color: #ECBE7B;">nothrow_t</span>&amp;) <span style="color: #51afef;">noexcept</span>;
</pre>
</div>

<p>
类型 nothrow_t 是定义在 new 头文件中的一个 struct，这个类型中不包含任何成员。new 头文件还定义了一个名为 nothrow 的 const 对象，用户可以通过这个对象请求 new 的非抛出版本（参见 12.1.2 节）。与析构函数类似，operator delete 也不允许抛出异常（参见 18.1.1 节）。当我们重载这些运算符时，必须是一噢嗯 noexcept 异常说明符（参见 18.1.4 节）指定其不抛出异常。
</p>

<p>
应用程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于全局作用域或类作用域中。当我们将上述运算符函数定义成类的成员时，它们时隐式静态的（参见 7.6 节）。我们无须显示地声明 static，当然这么做也不会引发错误。因为 operator new 用在对象构造之前而 operator delete 用在对象销毁之后，所以这两个成员（new 和 delete）必须时静态的，而且它们不能操纵类的任何数据成员。
</p>

<p>
如果我们想要自定义 operator new 函数，则可以为它提供额外的形参。此时，用到这些自定义函数的 new 表达式必须使用 new 的定位形式（参见 12.1.2 节）将实参传递给新增的形参。尽管在一般情况下我们可以自定义具有任何形参的 operator new，但是下面这个函数却无论如何不能被用户重载：
</p>

<p>
<code>void *operator new(size_t, void*);        // 不允许重新定义这个版本</code>
</p>

<p>
这种形式只供标准库使用，不能被用户重新定义。
</p>

<p>
当我们将 operator delete 或者 operator delete[]定义成类的成员时，该函数可以包含另外一个类型为 size_t 的形参。此时，该形参的初始值是第一个形参所指对象的字节数。size_t 形参可以用于删除继承体系中的对象。如果基类有一个虚析构函数（参见 15.7.1 节），则传递给 operator delete 的字节数将因待删除指针所指对象的动态类型不同而有所区别。而且，实际运行的 operator delete 函数版本也由对象的动态类型决定。
</p>
</div>
</div>
</div>
<div id="outline-container-orgd3ba628" class="outline-4">
<h4 id="orgd3ba628">19.1.2 定位 new 表达式</h4>
<div class="outline-text-4" id="text-orgd3ba628">
<p>
尽管 operator new 函数和 operator delete 函数一般用于 new 表达式，然而它们毕竟是标准库的两个普通函数，因此普通的代码也可以直接调用它们。
</p>

<p>
在 C++的早期版本中，allocator 类（参见 12.2.2 节）还不是标准库的一部分。应用程序如果想把内存分配与初始化分离开来的话，需要调用 operator new 和 operator delete。这两个函数的行为与 allocator 的 allocate 成员和 deallocate 成员非常类似，它们负责分配或释放内存空间，但是不会构造或销毁对象。
</p>

<p>
与 allocator 不同的是，对于 operator new 分配的内存空间来说我们无法使用 construct 函数构造对象。相反，我们应该使用 new 的 <b>定位 new</b> 形式（参见 12.1.2 节）构造对象。如我们所知，new 的这种形式为分配函数提供了额外的信息，我们可以使用定位 new 传递一个地址，此时定位 new 的形式如下所示：
</p>

<pre class="example">
new (place_address) type
new (place_address) type (initializers)
new (place_address) type [size]
new (place_address) type [size] { braced initializer list }
</pre>

<p>
其中 place_address 必须是一个指针，同时在 initializers 中提供一个（可能为空的）以逗号分配的初始值列表，该初始值列表将用于构造新分配的对象。
</p>

<p>
当仅通过一个地址值调用时，定位 new 使用 operator new(size_t, void*)“分配”它的内存。这是一个我们无法自定义的 operator new 版本（参见 19.1.1 节）。该函数不分配任何内存，它只是简单第返回指针实参；然后由 new 表达式负责在指定的地址初始化对象以完成整个工作。事实上，定位 new 允许我们在一个特定的、预先分配的内存地址上构造对象。
</p>

<blockquote>
<p>
Note：
</p>

<p>
当只传入一个指针类型的实参时，定位 new 表达式构造对象但是不分配内存。
</p>
</blockquote>

<p>
尽管在很多时候使用定位 new 与 allocator 的 construct 成员非常相似，但在它们之间也有一个重要的区别。我们传给 construct 的指针必须指向同一个 allocator 对象分配的空间，但是传给定位 new 的指针无须指向 operator new 分配的内存。实际上如我们将在 19.6 节介绍的，传给定位 new 表达式的指针甚至不需要指向动态内存。
</p>
</div>
<div id="outline-container-orgbb17ac1" class="outline-5">
<h5 id="orgbb17ac1">显示的析构函数调用</h5>
<div class="outline-text-5" id="text-orgbb17ac1">
<p>
和调用 destroy 类似，调用析构函数可以清楚给定的对象但是不会释放该对象所在的空间。如果需要的话，我们可以重新使用该空间。
</p>

<blockquote>
<p>
Note：
</p>

<p>
调用析构阿訇所农户会销毁对象，但是不会释放内存。
</p>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-orgca60bd1" class="outline-3">
<h3 id="orgca60bd1">19.2 运行时类型识别</h3>
<div class="outline-text-3" id="text-orgca60bd1">
<p>
<b>运行时类型识别（run-time type identification，RTTI）</b> 的功能由两个运算符实现：
</p>
<ul class="org-ul">
<li>typeid 运算符，用于返回表达式的类型。</li>
<li>dynamic_cast 运算符，用于将基类的指针或引用安全第转换成派生类的指针或引用。</li>
</ul>

<p>
这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某搞个派生类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量是一噢嗯虚函数。当操作被定义成虚函数时，编译器将根据对象的地噢地嗯太类型自动地选择正确的函数版本。
</p>

<p>
然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个 RTTI 运算符。另一方面，与虚成员函数相比，使用 RTTI 运算符蕴含着更多潜在的风险：程序员必须清楚地直到转换的目标类型并且检查类型转换是否被成功执行。
</p>
</div>
<div id="outline-container-orge4e348c" class="outline-4">
<h4 id="orge4e348c">19.2.1 dynamic_cast 运算符</h4>
<div class="outline-text-4" id="text-orge4e348c">
<p>
<b>dynamic_cast 运算符</b> 的使用形式如下所示：
</p>

<pre class="example">
dynamic_cast&lt;type*&gt;(e)
dynamic_cast&lt;type&amp;&gt;(e)
dynamic_cast&lt;type&amp;&amp;&gt;(e)
</pre>

<p>
其中，type 必须是一个类类型，并且通常情况下该类型应该含有虚函数。地一种形式中，e必须是一个有效的指针；在第二种形式中，e必须时一个左值；在第三种形式中，e不能是左值。
</p>

<p>
在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个：e的类型是目标 type 的公有派生类、e的目标类型是 type 的公有基类或者 e 的类型就是目标 type 的类型。如果符合，则类型转换可以成功。否则，转换失败。如果一条 dynamic_cast 语句的转换目标是指针类型并且失败了，则结果为 0。如果转换目标是引用类型并且失败了，则 dynamic_cast 运算符将抛出一个 bad_cast 异常。
</p>
</div>
<div id="outline-container-orga262467" class="outline-5">
<h5 id="orga262467">指针类型的 dynamic_cast</h5>
<div class="outline-text-5" id="text-orga262467">
<blockquote>
<p>
Note：
</p>

<p>
我们可以对一个空指针执行 dynamic_cast，结果是所需类型的空指针。
</p>
</blockquote>

<blockquote>
<p>
Best Practies：
</p>

<p>
在条件部分执行 dynmaic_cast 操作可以确保类型转换和结果检查在同一条表达式中完成。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgbe2083a" class="outline-5">
<h5 id="orgbe2083a">引用类型的 dynamic_cast</h5>
<div class="outline-text-5" id="text-orgbe2083a">
<p>
引用类型的 dynamic_cast 与指针类型的 dynamic_cast 在表示错误发生的地方上略有不同。因为不存在所谓的空引用，所以对于引用类型来说无法使用与指针类型完全相同的错误报告策略。当对引用的类型转换失败时，程序抛出一个名为 std::bad_cast 的异常，该异常定义在 typeinfo 标准库头文件中。
</p>
</div>
</div>
</div>
<div id="outline-container-orga3802c0" class="outline-4">
<h4 id="orga3802c0">19.2.2 typeid 运算符</h4>
<div class="outline-text-4" id="text-orga3802c0">
<p>
为 RTTI 提供的第二个运算符是 <b>typeid 运算符</b> ，它允许程序向表达式问：你的对象是什么类型？
</p>

<p>
typeid 表达式的形式是 typeid(e)，其中 e 可以是任意表达式或类型的名字。typeid 操作的结果是一个常量对象的引用，该对象的类型是标准库类型 type_info 或者 type_info 的公有派生类。type_info 类定义在 typeinfo 头文件中，19.2.4 节将介绍更多关于 type_info 的细节。
</p>

<p>
typeid 运算符可以作用于任意类型的表达式。和往常一样，顶层 const 被忽略，如果表达式是一个引用，则 typeid 返回该引用所引对象的类型。不过当 typeid 作用于数组或函数时，并不会执行向指针的标准类转换（参见 4.11.2 节）。也就是说，如果我们对数组 a 执行 typeid(a)，则所得到的结果是数组类型而非指针类型。
</p>

<p>
当运算符对象不属于类类型或者是一个不包含任何虚函数的类时，typeid 运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid 的结果直到运行时才会求得。
</p>
</div>
<div id="outline-container-orgc4b0546" class="outline-5">
<h5 id="orgc4b0546">使用 typeid 运算符</h5>
<div class="outline-text-5" id="text-orgc4b0546">
<blockquote>
<p>
WARNING：
</p>

<p>
当 typeid 作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。
</p>
</blockquote>

<p>
typeid 是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值。反之，如果类型不含有虚函数，则 typeid 返回表达式的静态类型；编译器无须对表达式求值也能直到表达式的静态类型。
</p>

<p>
如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返回的类型。这条规则适用于 typeid(*p)的情况。如果指针 p 所指的类型不含有虚函数，则 p 不必非得是一个有效的指针。否则，*p 将在运行时求值，此时 p 必须是一个有效的指针。如果 p 是一个空指针，则 typeid(*p)将抛出一个名为 bad_typeid 的异常。
</p>
</div>
</div>
</div>
<div id="outline-container-orga706d46" class="outline-4">
<h4 id="orga706d46">19.2.4 type_info 类</h4>
<div class="outline-text-4" id="text-orga706d46">
<p>
<b>type_info</b> 类的精确定义随着编译器的不同而略有差异。不过，C++标准规定 type_info 类必须定义在 typeinfo 头文件中，并且至少提供下表所列的操作。
</p>

<table>
<caption class="t-above"><span class="table-number">&#34920;22&nbsp;</span> type_info 的操作</caption>

<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">t1 == t2</td>
<td class="org-left">如果 type_info 对象 t1 和 t2 表示同一种类型，则返回 true；否则返回 false</td>
</tr>

<tr>
<td class="org-left">t1 != t2</td>
<td class="org-left">如果 type_info 对象 t1 和 t2 表示不同的类型，则返回 true；否则返回 false</td>
</tr>

<tr>
<td class="org-left">t.name()</td>
<td class="org-left">返回一个 C 风格字符串，表示类型名字的可打印形式。类型名字的生成方式因系统而异</td>
</tr>

<tr>
<td class="org-left">t1.before(t2)</td>
<td class="org-left">返回一个 bool 值，表示 t1 是否位于 t2 之前。before 所再用的顺序关系依赖于编译器的</td>
</tr>
</tbody>
</table>

<p>
除此之外，因为 type_info 类一般是作为一个基类出现的，所以它还应该提供一个公有的虚析构函数。当编译器希望提供额外的类型信息时，通常在 type_info 的派生类中完成。
</p>

<p>
type_info 类没有默认构造函数，而且它的拷贝和移动构造函以及赋值运算符都是被定义成删除的。因此，我们无法定义或拷贝 type_info 类型的对象，也不能为 type_info 类型的对象赋值。创建 type_info 对象的唯一途径是使用 typeid 运算符。
</p>

<p>
type_info 类的 name 成员函数返回一个 C 风格字符串，表示对象的类型名字。对于某种给定的类型来说，name 的返回值因编译器而异并且不一定于程序中使用的名字一致。对于 name 返回值的唯一要求是，类型不同则返回的字符串必须有所区别。
</p>
</div>
</div>
</div>
<div id="outline-container-org2198f02" class="outline-3">
<h3 id="org2198f02">19.3 枚举类型</h3>
<div class="outline-text-3" id="text-org2198f02">
<p>
<b>枚举类型</b> 使我们可以将一组整型常量组织在一起。和类一样，每个枚举类型定义了一种新的类型。枚举隶属于字面值常量类型（参见 7.5.6 节）。
</p>

<p>
C++包括两种枚举：限定作用域和不限定作用域的。C++11 新标准引入了 <b>限定作用域的枚举类型</b> 。定义限定作用域的枚举类型的一般形式是：首先是关键字 enum class（或者等价地使用 enum struct），随后是枚举类型名字以及用花括号括起来的以逗号分隔的 <b>枚举成员</b> 列表，最后是一个分号：
</p>

<p>
<code>enum class open_modes (input, output, append);</code>
</p>

<p>
定义 <b>不限于作用域的枚举类型</b> 时省略掉关键字 class（或 struct），枚举类型的名字是可选的：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">enum</span> <span style="color: #ECBE7B;">color</span> {<span style="color: #dcaeea;">red</span>, <span style="color: #dcaeea;">yellow</span>, <span style="color: #dcaeea;">green</span>};     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#38480;&#23450;&#20316;&#29992;&#22495;&#30340;&#26522;&#20030;&#31867;&#22411;</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26410;&#21629;&#21517;&#30340;&#65292;&#19981;&#38480;&#23450;&#20316;&#29992;&#22495;&#30340;&#26522;&#20030;&#31867;&#22411;</span>
<span style="color: #51afef;">enum</span> {<span style="color: #dcaeea;">floatPrec</span> = <span style="color: #da8548; font-weight: bold;">6</span>, <span style="color: #dcaeea;">doublePrec</span> = <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #dcaeea;">double_doublePrec</span> = <span style="color: #da8548; font-weight: bold;">10</span>};
</pre>
</div>

<p>
如果 enum 是未命名的，则我们只能在定义该 enum 时定义它的对象。和类的定义类似，我们需要在 enum 定义的右侧花括号和最后的分号之间提供逗号分隔的声明列表（参见 2.6.1 节）。
</p>
</div>
<div id="outline-container-org898f92d" class="outline-5">
<h5 id="org898f92d">枚举成员</h5>
<div class="outline-text-5" id="text-org898f92d">
<p>
在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域于枚举本身的作用域相同：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">enum</span> <span style="color: #ECBE7B;">color</span> {<span style="color: #dcaeea;">red</span>, <span style="color: #dcaeea;">yellow</span>, <span style="color: #dcaeea;">green</span>};                <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#38480;&#23450;&#20316;&#29992;&#22495;&#30340;&#26522;&#20030;&#31867;&#22411;</span>
<span style="color: #51afef;">enum</span> <span style="color: #ECBE7B;">stoplight</span> {<span style="color: #dcaeea;">red</span>, <span style="color: #dcaeea;">yellow</span>, <span style="color: #dcaeea;">green</span>};            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;&#37325;&#22797;&#23450;&#20041;&#20102;&#26522;&#20030;&#25104;&#21592;</span>
<span style="color: #51afef;">enum</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">peppers</span> {<span style="color: #dcaeea;">red</span>, <span style="color: #dcaeea;">yellow</span>, <span style="color: #dcaeea;">green</span>};        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#26522;&#20030;&#25104;&#21592;&#34987;&#38544;&#34255;&#20102;</span>
<span style="color: #ECBE7B;">color</span> <span style="color: #dcaeea;">eyes</span> = green;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#19981;&#38480;&#23450;&#20316;&#29992;&#22495;&#30340;&#26522;&#20030;&#31867;&#22411;&#30340;&#26522;&#20030;&#25104;&#21592;&#20301;&#20110;&#26377;&#25928;&#30340;&#20316;&#29992;&#22495;&#20013;</span>
<span style="color: #ECBE7B;">peppers</span> <span style="color: #dcaeea;">p</span> = green;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;preppers&#30340;&#26522;&#20030;&#25104;&#21592;&#19981;&#22312;&#26377;&#25928;&#30340;&#20316;&#29992;&#22495;&#20013;</span>
                       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">color::green&#22312;&#26377;&#25928;&#30340;&#20316;&#29992;&#22495;&#20013;&#65292;&#20294;&#26159;&#31867;&#22411;&#38169;&#35823;</span>
<span style="color: #ECBE7B;">color</span> <span style="color: #dcaeea;">hair</span> = <span style="color: #a9a1e1;">color</span>::red;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#20801;&#35768;&#26174;&#24335;&#22320;&#35775;&#38382;&#26522;&#20030;&#25104;&#21592;</span>
<span style="color: #ECBE7B;">peppers</span> <span style="color: #dcaeea;">p2</span> = <span style="color: #a9a1e1;">peppers</span>::red;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#20351;&#29992;pappers&#30340;red</span>
</pre>
</div>

<p>
默认情况下，枚举值从 0 开始，依次加 1。不过我们也能未一个或几个枚举成员指定专门的值：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">enum</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">intTypes</span> {
  <span style="color: #dcaeea;">charTyp</span> = <span style="color: #da8548; font-weight: bold;">8</span>, <span style="color: #dcaeea;">shortTyp</span> = <span style="color: #da8548; font-weight: bold;">16</span>, <span style="color: #dcaeea;">intTyp</span> = <span style="color: #da8548; font-weight: bold;">16</span>,
  <span style="color: #dcaeea;">longTyp</span> = <span style="color: #da8548; font-weight: bold;">32</span>, <span style="color: #dcaeea;">long_longTyp</span> = <span style="color: #da8548; font-weight: bold;">64</span>;
};
</pre>
</div>
<p>
由枚举成员 intTyp 和 shortTyp 可知，枚举值不一定唯一。如果我们没有显示地提供初始值，则当前枚举成员的值等于之前枚举成员的值加 1.
</p>

<p>
枚举成员是 const，因此在初始化枚举成员时提供的初始值必须是常量表达式（参见 2.4.4 节）。也就是说，每个枚举成员本身就是一条常量表达式，我们可以在任何需要常量表达式的地方使用枚举成员。例如，我们可以定义枚举类型的 constexpr 变量：
</p>

<p>
<code>constexpr intTypes charbits = intTypes::charTyp;</code>
</p>

<p>
类似的，我们也可以将一个 enum 作为 switch 语句的表达式，而将枚举值作为 case 标签。出于同样的原因，我们还能将枚举类型作为一个非类型模板形参使用（参见 16.1.1 节）；或者在类的定义中初始化枚举类型的静态数据成员（参见 7.6 节）。
</p>
</div>
</div>

<div id="outline-container-orgc5f70de" class="outline-5">
<h5 id="orgc5f70de">和类一样，枚举也定义新的类型</h5>
<div class="outline-text-5" id="text-orgc5f70de">
<p>
只要 enum 有名字，我们就能定义并初始化该类型的成员。要想初始化 enum 对象或者未 enum 对象赋值，必须使用该了西 ingde 一个枚举成员或者该类型的另一个对象：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">open_modes</span> <span style="color: #dcaeea;">om</span> = <span style="color: #da8548; font-weight: bold;">2</span>;       <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;2&#19981;&#23646;&#20110;&#31867;&#22411;open_modues</span>
om = <span style="color: #a9a1e1;">open_modes</span>::input;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;input&#26159;open_modes&#30340;&#19968;&#20010;&#26522;&#20030;&#25104;&#21592;</span>
</pre>
</div>

<p>
一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型。因此，我们可以在任何需要整型值的地方使用它们：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">i</span> = <span style="color: #a9a1e1;">color</span>::red;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#19981;&#38480;&#23450;&#20316;&#29992;&#22495;&#30340;&#26522;&#20030;&#31867;&#22411;&#30340;&#26522;&#20030;&#25104;&#21592;&#38544;&#24335;&#22320;&#36716;&#25442;&#25104;int</span>
<span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">j</span> = <span style="color: #a9a1e1;">peppers</span>::red;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;&#38480;&#23450;&#20316;&#29992;&#22495;&#22320;&#26522;&#20030;&#31867;&#22411;&#19981;&#20250;&#36827;&#34892;&#38544;&#24335;&#36716;&#25442;</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org9c1a71f" class="outline-5">
<h5 id="org9c1a71f">指定 enum 的大小</h5>
<div class="outline-text-5" id="text-org9c1a71f">
<p>
尽管每个 enum 都定义了唯一的类型，但实际上 enum 是由某种整数类型表示的。在 C++11 新标准中，我们可以在 enum 的名字后面加上冒号以及我们想在该 enum 中使用的类型：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">enum</span> <span style="color: #ECBE7B;">intValues</span> : <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">long</span> <span style="color: #ECBE7B;">long</span> {
  <span style="color: #dcaeea;">charTyp</span> = <span style="color: #da8548; font-weight: bold;">255</span>, <span style="color: #dcaeea;">shortType</span> = <span style="color: #da8548; font-weight: bold;">65535</span>, <span style="color: #dcaeea;">intTyp</span> = <span style="color: #da8548; font-weight: bold;">65535</span>,
  <span style="color: #dcaeea;">longTyp</span> = <span style="color: #da8548; font-weight: bold;">4294967295UL</span>,
  <span style="color: #dcaeea;">long_longTyp</span> = <span style="color: #da8548; font-weight: bold;">18446744073709551615ULL</span>
};
</pre>
</div>

<p>
如果我们没有指定 enum 的潜在类型，则默认情况下限定作用域的 enum 成员是 int，对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能容纳枚举值。如果我们指定了枚举值的潜在类型（包括对限定作用域的 enum 的隐式指定），则一旦某个枚举成员的值超出了该类型所能容纳的范围，将引发程序错误。
</p>

<p>
指定 enum 潜在类型的能力时的我们可以控制不同实现环境中使用的类型，我们将可以确保在一种实现环境中编译桶鼓噢的程序所生成的代码于其他实现环境中生成的代码一致。
</p>
</div>
</div>
<div id="outline-container-org38e71ee" class="outline-5">
<h5 id="org38e71ee">枚举类型的前置声明</h5>
<div class="outline-text-5" id="text-org38e71ee">
<p>
在 C++11 新标准中，我们可以提前声明 enum。enum 的前置声明（无论隐式地还是显示地）必须指定其成员的大小：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#38480;&#23450;&#20316;&#29992;&#22495;&#30340;&#26522;&#20030;&#31867;&#22411;intValues&#30340;&#21069;&#32622;&#22768;&#26126;</span>
<span style="color: #51afef;">enum</span> <span style="color: #ECBE7B;">intValues</span> : <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">long</span> <span style="color: #ECBE7B;">long</span>; <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#19981;&#38480;&#23450;&#20316;&#29992;&#22495;&#30340;&#65292;&#24517;&#39035;&#25351;&#23450;&#25104;&#21592;&#31867;&#22411;</span>
<span style="color: #51afef;">enum</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">open_modes</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38480;&#23450;&#20316;&#29992;&#22495;&#30340;&#26522;&#20030;&#31867;&#22411;&#21487;&#20197;&#20351;&#29992;&#40664;&#35748;&#25104;&#21592;&#31867;&#22411;int</span>
</pre>
</div>

<p>
因为不限定作用域的 enum 未指定成员的默认大小。因此每个声明必须指定成员的大小。对于限定作用域的 enum 来说，我们可以不指定其成员大小，这个值被隐式地定义成 int。
</p>

<p>
和其他声明语句一样，enum 地声明和定义必须匹配，这意味着在该 enum 的所有声明和定义中成员的大小必须一致。而且，我们不能在同一个上下文中先声明一个不限定作用域的 enum 名字，然后再声明一个同名的限定作用域的 enum。
</p>
</div>
</div>
<div id="outline-container-org5719b77" class="outline-5">
<h5 id="org5719b77">形参匹配与枚举类型</h5>
<div class="outline-text-5" id="text-org5719b77">
<p>
要想初始化一个 enum 对象，必须使用该 enum 类型的另一个对象或者它的一个枚举成员。因此，即使某个整型值恰好与枚举成员的值相等，它也不能作为函数的 enum 实参使用。
</p>
</div>
</div>
</div>
<div id="outline-container-org4c1863b" class="outline-3">
<h3 id="org4c1863b">19.4 类成员指针</h3>
<div class="outline-text-3" id="text-org4c1863b">
<p>
<b>成员指针</b> 是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象。类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有什么区别。
</p>

<p>
成员指针的类型囊括了类的类型以及成员的类型。当初始化一个这样的指针时，我们令其指向类的某个成员，但是不确定该成员所属的对象；知道使用成员指针时，才提供成员所属的对象。
</p>

<p>
为了解释成员指针的原理，不妨使用 7.3.1 节的 Screen 类：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Sceen</span> {
<span style="color: #51afef;">public</span>:
  <span style="color: #51afef;">typedef</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #a9a1e1;">string</span>::<span style="color: #ECBE7B;">size_type</span> <span style="color: #ECBE7B;">pos</span>;
  <span style="color: #ECBE7B;">char</span> <span style="color: #c678dd;">get_cursor</span>() <span style="color: #51afef;">const</span> { <span style="color: #51afef;">return</span> contents[cursor]; }
  <span style="color: #ECBE7B;">char</span> <span style="color: #c678dd;">get</span>() <span style="color: #51afef;">const</span>;
  <span style="color: #ECBE7B;">char</span> <span style="color: #c678dd;">get</span>(<span style="color: #ECBE7B;">pos</span> <span style="color: #dcaeea;">ht</span>, <span style="color: #ECBE7B;">pos</span> <span style="color: #dcaeea;">wd</span>) <span style="color: #51afef;">const</span>;
<span style="color: #51afef;">private</span>:
  <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">string</span> <span style="color: #dcaeea;">contents</span>;
  <span style="color: #ECBE7B;">pos</span> <span style="color: #dcaeea;">cursor</span>;
  <span style="color: #ECBE7B;">pos</span> <span style="color: #dcaeea;">height</span>, <span style="color: #dcaeea;">width</span>;
};
</pre>
</div>
</div>
<div id="outline-container-orgc660363" class="outline-4">
<h4 id="orgc660363">19.4.1 数据成员指针</h4>
<div class="outline-text-4" id="text-orgc660363">
<p>
和其他指针一样，在声明成员指针时我们也使用*来表示当前声明的名字是一个指针。与普通指针不同的是，成员指针还必须包括成员所属的类。因此，我们必须在*之前添加 classname::以表示当前定义的指针可以指向 classname 的成员。例如：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">pdata&#21487;&#20197;&#25351;&#21521;&#19968;&#20010;&#24120;&#37327;&#65288;&#38750;&#24120;&#37327;&#30340;&#65289;Screen&#23545;&#35937;&#30340;string&#25104;&#21592;</span>
<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">string</span> <span style="color: #a9a1e1;">Screen</span>::*<span style="color: #dcaeea;">pdata</span>;
</pre>
</div>

<p>
上述语句将 pdata 声明成“一个指向 Screen 类的 const string 成员的指针”。
</p>

<p>
当我们初始化一个成员指针（或者向它赋值）时，需指定它所指向的成员。例如，我们可以令 pdata 指向某个非特定 Screen 对象的 contents 成员：
</p>

<p>
<code>pdata = &amp;Screen::contents;</code>
</p>

<p>
其中，我们将取地址运算符作用于 Screen 类的成员而非内存种的一个该类对象。
</p>

<p>
当然，在 C++11 新标准中声明成员指针最简单的方法是使用 auto 或 decltype：
</p>

<p>
<code>auto pdata = &amp;Screen::contents;</code>
</p>
</div>
<div id="outline-container-org73ec9eb" class="outline-5">
<h5 id="org73ec9eb">使用数据成员指针</h5>
<div class="outline-text-5" id="text-org73ec9eb">
<p>
读者必须清楚的一点是，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针制定了成员而非该成员所属的对象，只有当解引用成员指针时我们才提供对象的信息。
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">Screen</span> <span style="color: #dcaeea;">myScreen</span>, *<span style="color: #dcaeea;">pScreen</span> = &amp;myScreen;
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">.*&#35299;&#24341;&#29992;pdata&#20197;&#33719;&#24471;myScreen&#23545;&#35937;&#30340;contents&#25104;&#21592;</span>
<span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">s</span> = myScreen.*pdata;
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">-&gt;*&#35299;&#24341;&#29992;*pdata&#20197;&#33719;&#24471;pScreen&#25152;&#25351;&#23545;&#35937;&#30340;contents&#25104;&#21592;</span>
s = pScreen-&gt;*pdata;
</pre>
</div>

<p>
从概念上来说，这些运算符执行两步操作：它们首先解引用成员指针以得到所需的成员；然后像成员访问运算符一样，通过对象（.*）或指针（-&gt;*）获取成员。
</p>
</div>
</div>
<div id="outline-container-orgc64fb5d" class="outline-5">
<h5 id="orgc64fb5d">返回数据成员指针的函数</h5>
<div class="outline-text-5" id="text-orgc64fb5d">
<p>
常规的访问控制规则对成员指针同样有效。例如，Screen 的 contents 成员是私有的，因此之前对于 pdata 的使用必须位于 Screen 类的成员或友元内部，否则程序将发生错误。
</p>

<p>
因为数据成员一般勤恳光下是私有的，所以我们通常不能直接获得数据成员地指针。如果一个像 Screen 这样的类希望我们可以访问它的 contents 成员，最好定义一个函数，令其返回值是指向该成员的指针：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Screen</span> {
<span style="color: #51afef;">public</span>:
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">data&#26159;&#19968;&#20010;&#38745;&#24577;&#25104;&#21592;&#65292;&#36820;&#22238;&#19968;&#20010;&#25104;&#21592;&#25351;&#38024;</span>
  <span style="color: #51afef;">static</span> <span style="color: #51afef;">const</span> <span style="color: #a9a1e1;">std</span>::<span style="color: #ECBE7B;">string</span> <span style="color: #a9a1e1;">Screen</span>::*<span style="color: #c678dd;">data</span>()
    { <span style="color: #51afef;">return</span> &amp;<span style="color: #a9a1e1;">Screen</span>::contents; }
};
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd279c91" class="outline-4">
<h4 id="orgd279c91">19.4.2 成员函数指针</h4>
<div class="outline-text-4" id="text-orgd279c91">
<p>
我们也可以定义指向类的成员函数的指针。与指向数据成员的指针类似 ，对于我们来说要想创建一个指向成员函数的指针，最简单的方法是使用 auto 来推断类型：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">mpf&#26159;&#19968;&#20010;&#25351;&#38024;&#65292;&#23427;&#21487;&#20197;&#25351;&#21521;Screen&#30340;&#26576;&#20010;&#24120;&#37327;&#20989;&#25968;</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21069;&#25552;&#26159;&#35813;&#20989;&#25968;&#19981;&#25509;&#21463;&#20219;&#20309;&#23454;&#21442;&#65292;&#24182;&#19988;&#36820;&#22238;&#19968;&#20010;char</span>
<span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">pmf</span> = &amp;<span style="color: #a9a1e1;">Screen</span>::get_cursor;
</pre>
</div>

<p>
和指向数据成员的指针一样，我们使用 classname::*的形式声明一个指向成员函数的指针。类似于任何其他函数指针（参见 6.7 节），指向成员函数的指针也需要指定目标函数和返回类型的形参列表。如果函数成员是 const 成员或引用成员，则我们必须将 const 限定符或引用限定符包含进来。
</p>

<p>
和普通的函数指针类似，如果成员函数存在重载的问题，则我们必须显式地声明函数类型以明确指出我们想要使用的是哪个函数（参见 6.7 节）。例如，我们可以声明一个指针，令其指向含有两个形参的 get：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">char</span> (<span style="color: #a9a1e1;">Screen</span>::*<span style="color: #c678dd;">pmf2</span>)(<span style="color: #a9a1e1;">Screen</span>::pos, <span style="color: #a9a1e1;">Screen</span>::pos) <span style="color: #51afef;">const</span>;
pmf2 = &amp;<span style="color: #a9a1e1;">Screen</span>::get;
</pre>
</div>

<p>
c 出于优先级的考虑，上述声明中的 Screen::*两端的括号必不可少。如果没有这对括号的话，编译器将认为该声明是一个（无效的）函数声明。
</p>

<p>
和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">pmf&#25351;&#21521;&#19968;&#20010;Screen&#25104;&#21592;&#65292;&#35813;&#25104;&#21592;&#19981;&#25509;&#21463;&#20219;&#20309;&#23454;&#21442;&#19988;&#36820;&#22238;&#31867;&#22411;&#26159;char</span>
pmf = &amp;<span style="color: #a9a1e1;">Screen</span>::get;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#24517;&#39035;&#26174;&#24335;&#22320;&#20351;&#29992;&#21462;&#22320;&#22336;&#36816;&#31639;&#31526;</span>
pmf = <span style="color: #a9a1e1;">Screen</span>::get;   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#38169;&#35823;&#65306;&#22312;&#25104;&#21592;&#20989;&#25968;&#21644;&#25351;&#38024;&#20043;&#38388;&#19981;&#23384;&#22312;&#33258;&#21160;&#36716;&#25442;&#35268;&#21017;</span>
</pre>
</div>
</div>
<div id="outline-container-orgaa71ce0" class="outline-5">
<h5 id="orgaa71ce0">使用成员函数指针</h5>
<div class="outline-text-5" id="text-orgaa71ce0">
<p>
和使用指向数据成员的指针一样，我们使用.*或者-&gt;*运算符作用于指向成员函数的指针，以调用类的成员函数：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">Screen</span> <span style="color: #dcaeea;">myScreen</span>, *<span style="color: #dcaeea;">pScreen</span> = &amp;myScreen;
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36890;&#36807;pScreen&#25152;&#25351;&#30340;&#23545;&#35937;&#35843;&#29992;pmf&#25152;&#25351;&#30340;&#20989;&#25968;</span>
<span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c1</span> = (pScreen-&gt;*pmf)();
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36890;&#36807;myScreen&#23545;&#35937;&#23558;&#23454;&#21442;0&#65292;0&#20256;&#32473;&#21547;&#26377;&#20004;&#20010;&#24418;&#21442;&#30340;get&#20989;&#25968;</span>
<span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">c2</span> = (myScreen.*pmf2)(<span style="color: #da8548; font-weight: bold;">0</span>, <span style="color: #da8548; font-weight: bold;">0</span>);
</pre>
</div>

<blockquote>
<p>
Note：
</p>

<p>
因为函数调用运算符的优先级较高，所以在声明指向成员函数的指针并使用这样的指针进行函数调用时，括号必不可少：(C::*p)(parms)和(ojb.*p)(args)。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-org494c911" class="outline-5">
<h5 id="org494c911">使用成员指针的类型别名</h5>
<div class="outline-text-5" id="text-org494c911">
<p>
使用类型别名或 typedef 可以让成员指针更容易理解。例如，下面的类型别名将 Action 定义为两参数 get 函数的同义词：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Action&#26159;&#19968;&#31181;&#21487;&#20197;&#25351;&#21521;Screen&#25104;&#21592;&#20989;&#25968;&#30340;&#25351;&#38024;&#65292;&#23427;&#25509;&#21463;&#20004;&#20010;post&#23454;&#21442;&#65292;&#36820;&#22238;&#19968;&#20010;char</span>
<span style="color: #51afef;">using</span> <span style="color: #ECBE7B;">Action</span> = <span style="color: #ECBE7B;">char</span> (<span style="color: #a9a1e1;">Screen</span>::*)(<span style="color: #a9a1e1;">Screen</span>::pos, <span style="color: #a9a1e1;">Screen</span>::pos) <span style="color: #51afef;">const</span>;

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36890;&#36807;&#20351;&#29992;Action&#65292;&#25105;&#20204;&#21487;&#20197;&#31616;&#21270;&#25351;&#21521;get&#30340;&#25351;&#38024;&#23450;&#20041;</span>
<span style="color: #ECBE7B;">Action</span> <span style="color: #dcaeea;">get</span> = &amp;<span style="color: #a9a1e1;">Screen</span>::get;
</pre>
</div>
</div>
</div>
<div id="outline-container-org0ab2ac9" class="outline-5">
<h5 id="org0ab2ac9">成员指针函数表</h5>
<div class="outline-text-5" id="text-org0ab2ac9">
<p>
对于普通函数指针和指向成员函数的指针来说，一种常用的用法是将其存入一个函数表当中（参见 14.8.3 节）。如果一个类含有几个相同类型的成员，则这样一张函数表可以帮助我们从这些成员中选择一个。假定 Screen 类含有几个成员函数，每个函数负责将光标指向的方向移动：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Screen</span> {
<span style="color: #51afef;">public</span>:
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20854;&#20182;&#25509;&#21475;&#21644;&#23454;&#29616;&#25104;&#21592;&#20043;&#21069;&#19968;&#33268;</span>
  <span style="color: #ECBE7B;">Screen</span>&amp; <span style="color: #c678dd;">home</span>();      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20809;&#26631;&#31227;&#21160;&#20989;&#25968;</span>
  <span style="color: #ECBE7B;">Screen</span>&amp; <span style="color: #c678dd;">forward</span>();
  <span style="color: #ECBE7B;">Screen</span>&amp; <span style="color: #c678dd;">back</span>();
  <span style="color: #ECBE7B;">Screen</span>&amp; <span style="color: #c678dd;">up</span>();
  <span style="color: #ECBE7B;">Screen</span>&amp; <span style="color: #c678dd;">down</span>();
};
</pre>
</div>

<p>
这几个新函数有一个共同点：它们都不接受任何参数，并且返回值是发生光标移动的 Screen 的引用。
</p>

<p>
我们希望定义个 move 函数，使其可以调用上面的任意一样函数并执行对应的操作。为了支持这个新函数，我们将在 Screen 中添加一个静态成员，该成员是指向光标移动函数的指针的数组：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Screen</span> {
<span style="color: #51afef;">public</span>:
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20854;&#20182;&#25509;&#21475;&#21644;&#23454;&#29616;&#25104;&#21592;&#20043;&#21069;&#19968;&#33268;</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Action&#26159;&#19968;&#20010;&#25351;&#38024;&#65292;&#21487;&#20197;&#29992;&#20219;&#24847;&#19968;&#20010;&#20809;&#26631;&#31227;&#21160;&#20989;&#25968;&#23545;&#20854;&#36171;&#20540;</span>
  <span style="color: #51afef;">using</span> <span style="color: #ECBE7B;">Action</span> = Screen&amp; (<span style="color: #a9a1e1;">Screen</span>::*)();
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#23450;&#20855;&#20307;&#35201;g&#19968;&#23545;&#21734;&#37027;&#30340;&#26041;&#21521;&#65292;&#20854;&#20013;enum&#21442;&#35265;19.3&#33410;</span>
  <span style="color: #51afef;">enum</span> <span style="color: #ECBE7B;">Directions</span> { <span style="color: #dcaeea;">HOME</span>, <span style="color: #dcaeea;">FORARD</span>, <span style="color: #dcaeea;">BACK</span>, <span style="color: #dcaeea;">UP</span>, <span style="color: #dcaeea;">DOWN</span> };
  <span style="color: #ECBE7B;">Screen</span>&amp; <span style="color: #c678dd;">move</span>(<span style="color: #ECBE7B;">Directions</span>);
<span style="color: #51afef;">private</span>:
  <span style="color: #51afef;">static</span> <span style="color: #ECBE7B;">Action</span> <span style="color: #c678dd;">Menu</span>();   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20989;&#25968;&#34920;</span>
};
</pre>
</div>

<p>
数组 Menu 依次保存每个光标移动函数的指针，这些函数按照 Directions 中枚举成员对应的偏移量存储。move 函数接受一个枚举成员并调用相应的函数：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">Screen</span>&amp; <span style="color: #a9a1e1;">Screen</span>::<span style="color: #c678dd;">move</span>(<span style="color: #ECBE7B;">Directions</span> <span style="color: #dcaeea;">cm</span>) {
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36816;&#34892;this&#23545;&#35937;&#20013;&#32034;&#24341;&#20540;&#20026;cm&#30340;&#20803;&#32032;</span>
  <span style="color: #51afef;">return</span> (<span style="color: #51afef;">this</span>-&gt;*Menu[cm])();   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">Menu[cm]&#25351;&#21521;&#19968;&#20010;&#25104;&#21592;&#20989;&#25968;</span>
}
</pre>
</div>

<p>
move 中的函数调用的原因里：首先获取索引值为 cm 的 Menu 元素，该元素指向 Screen 成员函数的指针，我们根据 this 所指的对象调用该元素所指的成员函数。
</p>

<p>
当我们调用 move 函数时，给它传入一个表示光标移动方向的枚举成员
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">Screen</span> <span style="color: #dcaeea;">myScreen</span>;
myScreen.move(<span style="color: #a9a1e1;">Screen</span>::HOME);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35843;&#29992;mySreen.home</span>
myScreen.move(<span style="color: #a9a1e1;">Screen</span>::DOWN);  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35843;&#29992;mySreen.down</span>
</pre>
</div>

<p>
剩下的工作就是定义并初始化函数表本身了：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a9a1e1;">Screen</span>::<span style="color: #ECBE7B;">Action</span> <span style="color: #a9a1e1;">Screen</span>::<span style="color: #dcaeea;">Menu</span>[] = { &amp;<span style="color: #a9a1e1;">Screen</span>::home,
                                  &amp;<span style="color: #a9a1e1;">Screen</span>::forward,
                                  &amp;<span style="color: #a9a1e1;">Screen</span>::back,
                                  &amp;<span style="color: #a9a1e1;">Screen</span>::up,
                                  &amp;<span style="color: #a9a1e1;">Screen</span>::down,
};
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga8caca9" class="outline-4">
<h4 id="orga8caca9">19.4.3 将成员函数用作可调用对象</h4>
<div class="outline-text-4" id="text-orga8caca9">
<p>
如我们所知，要想通过一个指向成员函数的指针进行函数调用，必须首先利用.*运算符或-&gt;*运算符将该指针绑定到特定的对象上。因此与普通的函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符（参见 10.3.2 节）。
</p>

<p>
因为成员指针不是可调用对象，所以我们不能直接将一个指向成员函数的指针传递给算符。
</p>
</div>
<div id="outline-container-orgf16a023" class="outline-5">
<h5 id="orgf16a023">使用 function 生成一个可调用对象</h5>
<div class="outline-text-5" id="text-orgf16a023">
<p>
从指向成员函数的指针获取可调用对象的一种方式是使用标准库模板 function（参见 14.8.3 节）：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">function</span>&lt;<span style="color: #ECBE7B;">bool</span> (<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">string</span>&amp;)&gt; <span style="color: #dcaeea;">fcn</span> = &amp;<span style="color: #a9a1e1;">string</span>::empty;
find_id(svec.begin(), svec,end(), fcn);
</pre>
</div>

<p>
我们告诉 function 一个事实：即 empty 是一个接受 string 参数并返回 bool 值的函数。通常情况下，执行成员函数的对象将被传给隐式的 this 形参。当我们想要使用 function 为成员函数生成一个可调用对象时，必须首先“翻译”该代码，使得隐式的形参编程显示的。
</p>

<p>
当一个 function 对象包含有一个指向成员函数的指针时，function 类知道它必须使用正确的指向成员的指针运算符来执行函数调用。也就是说，我们可以认为在 find_if 当中含有类似于如下形式的代码：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20551;&#35774;it&#26102;find_if&#20869;&#37096;&#30340;&#36845;&#20195;&#22120;&#65292;&#21017;*it&#26159;&#32473;&#23450;&#33539;&#22260;&#20869;&#30340;&#19968;&#20010;&#23545;&#35937;</span>
<span style="color: #51afef;">if</span> (fcn(*it))      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20551;&#35774;fcn&#26159;find_if&#20869;&#37096;&#30340;&#19968;&#20010;&#21487;&#35843;&#29992;&#23545;&#35937;&#30340;&#21517;&#23383;</span>
</pre>
</div>

<p>
其中，function 将使用正确的指向成员的指针运算符。从本质上来看，function 类将函数调用转换成了如下形式：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#20551;&#35774;it&#26159;find_if&#20869;&#37096;&#30340;&#36845;&#20195;&#22120;&#65292;&#21017;*it&#26159;&#32473;&#23450;&#33539;&#22260;&#20869;&#30340;&#19968;&#20010;&#23545;&#35937;</span>
<span style="color: #51afef;">if</span> (((*it).*P)())   <span style="color: #5B6268;">//</span><span style="color: #5B6268;">&#20551;&#35774;p&#26159;fcn&#20869;&#37096;&#30340;&#19968;&#20010;&#25351;&#21521;&#25104;&#21592;&#20989;&#25968;&#30340;&#25351;&#38024;</span>
</pre>
</div>

<p>
当我们定义一个 function 对象时，必须指定该对象所能表示的函数类型，即可调用对象的形式。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个（一般是隐式的）对象上执行的。同时，我们提供给 function 的形式中还必须指明对象是否是以指针或引用的形式传入的。
</p>
</div>
</div>
<div id="outline-container-org683d498" class="outline-5">
<h5 id="org683d498">使用 mem_fn 生成一个可调用对象</h5>
<div class="outline-text-5" id="text-org683d498">
<p>
可以采取另一种方法，通过使用标准库功能 <b>mem_fn</b> 来让编译器负责推断成员的类型。和 function 一样，mem_fn 也定在 functional 头文件中，并且可以从成员指针生成一个可调用对象；和 function 不同的是，mem_fn 可以根据成员指针的类型推断可调用对象的类型，而无须用户显示指定：
</p>

<p>
<code>find_if(svec.begin(), svec.end(), mem_fn(&amp;string::empty));</code>
</p>

<p>
我们使用 mem_fn(&amp;string::empty)生成一个可调用对象，该对象接受一个 string 实参，返回一个 bool 值。
</p>

<p>
mem_fn 生成的可调用对象可以通过对象调用，也可以通过指针调用：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">f</span> = mem_fn(&amp;<span style="color: #a9a1e1;">string</span>::empty);   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">f&#25509;&#21463;&#19968;&#20010;string&#25110;&#32773;&#19968;&#20010;string*</span>
f(*svec.begin());      <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#20256;&#20837;&#19968;&#20010;string&#23545;&#35937;&#65292;f&#20351;&#29992;.*&#35843;&#29992;empty</span>
f(&amp;sev[<span style="color: #da8548; font-weight: bold;">0</span>]);            <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#27491;&#30830;&#65306;&#20256;&#20837;&#19968;&#20010;string&#30340;&#25351;&#38024;&#65292;f&#20351;&#29992;-&gt;*&#35843;&#29992;empty</span>
</pre>
</div>

<p>
实际上，我们可以认为 mem_fn 生成的可调用对象含有一对重载的函数调用运算符：一个接受 string*，另一个接受 string&amp;。
</p>
</div>
</div>
<div id="outline-container-orgfa47c7e" class="outline-5">
<h5 id="orgfa47c7e">使用 bind 生成一个可调用对象</h5>
<div class="outline-text-5" id="text-orgfa47c7e">
<p>
出于完整性的考虑，我们还可以使用 bind（参见 10.3.4 节）从成员函数生成一个可调用对象：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#36873;&#25321;&#33539;&#22260;&#20013;&#30340;&#27599;&#20010;string&#65292;&#24182;&#23558;&#20854;bind&#21040;empty&#30340;&#31532;&#19968;&#20010;&#38544;&#24335;&#23454;&#21442;&#19978;</span>
<span style="color: #51afef;">auto</span> <span style="color: #dcaeea;">it</span> = find_if(svec.begin(), svec.end(), bind(&amp;<span style="color: #a9a1e1;">string</span>::empty, _1));
</pre>
</div>

<p>
和 functinon 类似的地方是，当我们使用 bind 时，必须将函数中用于表示执行对象的隐式形参转换成显式的。和 mem_fn 类似的地方是，bind 生成的可调用对象的第一个实参既可以时 string 的指针，也可以时 string 的引用。
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org20c4726" class="outline-3">
<h3 id="org20c4726">19.5 嵌套类</h3>
<div class="outline-text-3" id="text-org20c4726">
<p>
一个类可以定义在另一个类的内部，前着称为 <b>嵌套类</b> 或 <b>嵌套类型</b> 。嵌套类常用于定义作为实现部分的类。
</p>

<p>
嵌套类是一个独立的类，与外层类基本没什么关系。特别是，外层类的对象和嵌套的对象是互相独立的。在嵌套类的对象中不包含任何外层类定义的成员：类似的，在外层类的对象中也不包含任何嵌套类定义的成员。
</p>

<p>
嵌套类的名字在外层作用于是可见的，在外层作用域之外不可见。和其他嵌套的名字一样，嵌套类的名字不会和别的作用域中的同一个名字冲突。
</p>

<p>
嵌套类中成员的种类与非嵌套类是一样的。和其他类类似，嵌套类也使用访问限定符来控制外界成员对其成员的访问权限。外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限。
</p>

<p>
嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类决定。位于外层类 public 部分的嵌套类实际上定义了一种可以随处访问的类型：位于外层类 protected 部分的嵌套类定义的只能被外层类及其友元和派生类访问；位于外层类 private 部分的嵌套类定义的类型只能被外层的成员和友元访问。
</p>
</div>
<div id="outline-container-orgd07ea83" class="outline-5">
<h5 id="orgd07ea83">在外层类之外定义一个嵌套类</h5>
<div class="outline-text-5" id="text-orgd07ea83">
<p>
和成员函数一样，嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。
</p>

<p>
当我们在外层类之外定义一个嵌套类时，必须以外层的名字限定嵌套类的名字。
</p>
</div>
</div>
<div id="outline-container-org0393ff1" class="outline-5">
<h5 id="org0393ff1">嵌套类作用域中的名字查找</h5>
<div class="outline-text-5" id="text-org0393ff1">
<p>
名字查找的一般规则（参见 7.4.1 节）在嵌套类中同样使用。当然，因为嵌套类本身是一个嵌套组作用域，所以还必须查找嵌套类外层作用域。
</p>

<p>
如我们所知，嵌套类是其外层类的一个类型成员，因此外层类的成员可以像使用任何其他类型成员一样使用嵌套类的名字。
</p>
</div>
</div>
</div>
<div id="outline-container-orgc5844ba" class="outline-3">
<h3 id="orgc5844ba">19.6 union：一种节省空间的类</h3>
<div class="outline-text-3" id="text-orgc5844ba">
<p>
<b>联合（union）</b> 是一种特殊的类。一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给 union 的某个成员赋值之后，该 union 的其他成员就变成未定义的状态了。分配给一个 union 对象的存储空间至少要能容纳它的最大数据成员。和其他类一样，一个 union 定义了一种新类型。
</p>

<p>
类的某些特性对 union 同样使用，但并非所有特性都如此。union 不能含有引用类型的成员，除此之外，它的成员可以是绝大多数类型。在 C++11 新标准中，含有构造函数或析构函数的类类型也可以作为 union 的成员类 ixngunion 可以为其成员指定 public、protected 和 private 等保护标记。默认情况下，union 的成员都是公有的，这一点与 struct 相同。
</p>

<p>
union 可以定义包括构造函数和析构函数在内的成员函数。但是由于 union 既不能继承自其他类，也不能作为基类使用，所以在 union 中不能含有虚函数。
</p>
</div>
<div id="outline-container-org3f12765" class="outline-5">
<h5 id="org3f12765">定义 union</h5>
<div class="outline-text-5" id="text-org3f12765">
<p>
在定义一个 union 时，首先是关键字 union，随后是该 union 的（可选的）名字以及花括号内的一组成员声明。
</p>
</div>
</div>
<div id="outline-container-orgd1a34e3" class="outline-5">
<h5 id="orgd1a34e3">使用 union 类型</h5>
<div class="outline-text-5" id="text-orgd1a34e3">
<p>
union 的名字是一个类型名。和其他内置类型一样，默认情况下 union 是未初始化的。我们可以像显式的初始化聚合类（参见 7.5.5 节）一样使用一对花括号内的初始值显示地初始化一个 union：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #ECBE7B;">Token</span> <span style="color: #dcaeea;">first_token</span> = {<span style="color: #98be65;">'a'</span>};    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21021;&#22987;&#21270;cval&#25104;&#21592;</span>
<span style="color: #ECBE7B;">Token</span> <span style="color: #dcaeea;">last_token</span>;             <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26410;&#21021;&#22987;&#21270;&#30340;Token&#23545;&#35937;</span>
<span style="color: #ECBE7B;">Token</span> *<span style="color: #dcaeea;">pt</span> = <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Token</span>;        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25351;&#21521;&#19968;&#20010;&#26410;&#21021;&#22987;&#21270;&#30340;Token&#23545;&#35937;&#30340;&#25351;&#38024;</span>
</pre>
</div>

<p>
如果提供了初始值，则该初始值被用于初始化第一个成员。
</p>

<p>
我们使用通用的成员访问运算符访问一个 union 对象的成员：
</p>

<div class="org-src-container">
<pre class="src src-C++">last_token.cval = <span style="color: #98be65;">'z'</span>;
pt-&gt;ival = <span style="color: #da8548; font-weight: bold;">42</span>;
</pre>
</div>

<p>
为 union 的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，当我们使用 union 时，必须清楚地知道当前存储在 union 中的值到底时什么类型。如果我们使用错误的数据成员或者未错误的数据成员赋值，则程序可能崩溃或出现异常的行为，具体的情况根据成员的类型而有所不同。
</p>
</div>
</div>
<div id="outline-container-org0b249af" class="outline-5">
<h5 id="org0b249af">匿名 union</h5>
<div class="outline-text-5" id="text-org0b249af">
<p>
<b>匿名 union</b> 时一个未命名的 union，并且在右花括号和分号之间没有任何声明（参见 2.6.1 节）。一个我们定义了一个匿名 union，编译器就自动地未该 union 创建一个未命名对象：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">union</span> {   <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21311;&#21517;union</span>
  <span style="color: #ECBE7B;">char</span> <span style="color: #dcaeea;">cval</span>;
  <span style="color: #ECBE7B;">int</span> <span style="color: #dcaeea;">ival</span>;
  <span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">dval</span>;
};  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#23450;&#20041;&#19968;&#20010;&#26410;&#21629;&#21517;&#30340;&#23545;&#35937;&#65292;&#25105;&#20204;&#21487;&#20197;&#30452;&#25509;&#35775;&#38382;&#23427;&#30340;&#25104;&#21592;</span>
cval = <span style="color: #98be65;">'c'</span>;    <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#26410;&#21018;&#21018;&#23450;&#20041;&#30340;&#26410;&#21629;&#21517;&#30340;&#21311;&#21517;union&#23545;&#35937;&#36171;&#19968;&#20010;&#26032;&#20540;</span>
ival = <span style="color: #da8548; font-weight: bold;">42</span>;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#35813;&#23545;&#35937;&#24403;&#21069;&#20445;&#23384;&#30340;&#20540;&#26159;42</span>
</pre>
</div>

<p>
在匿名 union 的定义所在的作用域内该 union 的成员都是可以直接访问的。
</p>

<div class="org-src-container">
<pre class="src src-C++">&#21311;&#21517;union&#19981;&#33021;&#21253;&#21547;&#21463;&#20445;&#25252;&#30340;&#25104;&#21592;&#25110;&#31169;&#26377;&#25104;&#21592;&#65292;&#20063;&#19981;&#33021;&#23450;&#20041;&#25104;&#21592;&#20989;&#25968;&#12290;
</pre>
</div>
</div>
</div>
<div id="outline-container-orgabf4c2a" class="outline-5">
<h5 id="orgabf4c2a">含有类类型成员的 union</h5>
<div class="outline-text-5" id="text-orgabf4c2a">
<p>
C++早期版本规定，在 union 中不能含有定义了构造函数或拷贝控制成员的类类型成员。C++11 新标准取消了这一限制。不过，如果 union 的成员类型定义了自己的构造函数和/或空呗控制成员，则该 union 的用法要比只含有内置类型成员的 union 复杂的多。
</p>

<p>
当 union 包含的是内置类型的成员时，我们可以使用普通的赋值语句改变 union 保存的值。但是对于含有特殊类类型成员的 union 就没有这么简单了。如果我们想要将 union 的值改变未类类型成员对应的值，或者将类类型成员的值改为一个其他其值，则必须构造或析构该类类型的成员：当我们将 union 的值改为类类型成员对应的值时，必须运行该类型的构造函数；反之，当我们将类类型成员的值改为一个其他值时，必须运行该类型的析构函数。
</p>

<p>
当 union 包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员。但是如果 union 含有类类型的成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器将为 union 合成对应的版本并将其声明为删除的。
</p>
</div>
</div>
</div>
<div id="outline-container-orgcf0e399" class="outline-3">
<h3 id="orgcf0e399">19.7 局部类</h3>
<div class="outline-text-3" id="text-orgcf0e399">
<p>
类可以定义在某个函数的内部，我们称这样的类为 <b>局部类</b> 。局部类定义的类型只在定义它的作用域内可见。和嵌套类不同，局部类的成员受到严格限制。
</p>

<blockquote>
<p>
Note：
</p>

<p>
局部类的所有成员（包括函数在内）都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。
</p>
</blockquote>

<p>
在实际编程的过程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的复杂性不可能太高。局部类的成员函数一般只有几行，否则我们就很难读懂它了。
</p>

<p>
类似的，在局部类也不允许声明静态数据成员，因为我们没法定义这样的成员。
</p>
</div>
<div id="outline-container-org31f4e63" class="outline-5">
<h5 id="org31f4e63">局部类不能使用函数作用域中的变量</h5>
<div class="outline-text-5" id="text-org31f4e63">
<p>
局部类对其外层作用域中名字的访问权限受到很多限制，局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。如果局部类定义在某个函数内部，则该函数的普通局部变量不能被改局部类使用。
</p>
</div>
</div>
<div id="outline-container-org5abc9ad" class="outline-5">
<h5 id="org5abc9ad">常规的访问保护规则对局部类同样适用</h5>
<div class="outline-text-5" id="text-org5abc9ad">
<p>
外层函数对局部类的私有成员没有任何访问权限。当然，局部类可以将外层函数声明为友元；或者更常见的情况是局部类将其成员声明成公有的。在程序中有权访问局部类的代码非常有限。局部类已经封装在函数的作用域中，通过信息隐藏进一步封装就显得没什么必须了。
</p>
</div>
</div>
<div id="outline-container-orga80d450" class="outline-5">
<h5 id="orga80d450">局部类中的名字查找</h5>
<div class="outline-text-5" id="text-orga80d450">
<p>
局部类内部的名字查照次序与其他类相似。在声明类的成员时，必须显确保用到的名字位于作用域中，然后再使用该名字。定义成员时用到的名字可以出现在类的任意位置。如果某个名字不是局部类的成员，则继续在外层函数作用域中查找；如果还没有找到，则在外层函数所在的作用域中查找。
</p>
</div>
</div>
<div id="outline-container-orgab7341d" class="outline-5">
<h5 id="orgab7341d">嵌套的局部类</h5>
<div class="outline-text-5" id="text-orgab7341d">
<p>
可以在局部类的内部再嵌套一个类。此时，嵌套类的定义可以出现在局部类之外。不过，嵌套类必须定义在与局部类相同的作用域中。
</p>

<p>
局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。嵌套类的所有成员都必须定义在嵌套类的内部。
</p>
</div>
</div>
</div>
<div id="outline-container-orgcf72d49" class="outline-3">
<h3 id="orgcf72d49">19.8 固有的不移植的特性</h3>
<div class="outline-text-3" id="text-orgcf72d49">
<p>
为了支持低层编程，C++定义了一些固有的 <b>不可移植</b> 的特性。所谓不可移植的特性是指因机器而已的特性，当我们将含有不可移植特性的程序从一台及其转移到另一台机器上时，通常需要重新编写该程序。
</p>
</div>
<div id="outline-container-org0523f36" class="outline-4">
<h4 id="org0523f36">19.8.1 位域</h4>
<div class="outline-text-4" id="text-org0523f36">
<p>
类可以将其（非静态）数据成员定义成 <b>位域</b> ，在一个位域中含有一定数量的二进制位。当一个程序需要像其他程序或硬件设备传递二进制数据时，通常会使用到位域。
</p>

<blockquote>
<p>
Note：
</p>

<p>
位域在内存中的布局是与机器相关的。
</p>
</blockquote>

<p>
位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用无符号类型保存一个位域。位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #51afef;">typedef</span> <span style="color: #ECBE7B;">unsigned</span> <span style="color: #ECBE7B;">int</span> <span style="color: #ECBE7B;">Bit</span>;
<span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">File</span> {
  <span style="color: #ECBE7B;">Bit</span> <span style="color: #dcaeea;">mode</span>: <span style="color: #da8548; font-weight: bold;">2</span>;        <span style="color: #5B6268;">// </span><span style="color: #5B6268;">mode&#31449;2&#20301;</span>
  <span style="color: #ECBE7B;">Bit</span> <span style="color: #dcaeea;">modified</span>:<span style="color: #da8548; font-weight: bold;">1</span>;     <span style="color: #5B6268;">// </span><span style="color: #5B6268;">modified&#21344;1&#20301;</span>
  <span style="color: #ECBE7B;">Bit</span> <span style="color: #dcaeea;">prot_owner</span>: <span style="color: #da8548; font-weight: bold;">3</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">prot_owner&#21344;3&#20301;</span>
  <span style="color: #ECBE7B;">Bit</span> <span style="color: #dcaeea;">prot_group</span>: <span style="color: #da8548; font-weight: bold;">3</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">prot_group&#21344;3&#20301;</span>
  <span style="color: #ECBE7B;">Bit</span> <span style="color: #dcaeea;">prot_world</span>: <span style="color: #da8548; font-weight: bold;">3</span>;  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">prot_world&#21344;3&#20301;</span>
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">File&#30340;&#25805;&#20316;&#21644;&#25968;&#25454;&#25104;&#21592;</span>
<span style="color: #51afef;">public</span>:
  <span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#25991;&#20214;&#31867;&#22411;&#20197;&#20843;&#36827;&#21046;&#30340;&#24418;&#24335;&#34920;&#31034;</span>
  <span style="color: #51afef;">enum</span> <span style="color: #ECBE7B;">modes</span> { <span style="color: #dcaeea;">READ</span> = <span style="color: #da8548; font-weight: bold;">01</span>, <span style="color: #dcaeea;">WRITE</span> = <span style="color: #da8548; font-weight: bold;">02</span>, <span style="color: #dcaeea;">EXECUTE</span> = <span style="color: #da8548; font-weight: bold;">03</span> };
  <span style="color: #ECBE7B;">File</span> &amp;<span style="color: #c678dd;">open</span>(<span style="color: #ECBE7B;">modes</span>);
  <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">close</span>();
  <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">write</span>();
  <span style="color: #ECBE7B;">bool</span> <span style="color: #c678dd;">isRead</span>() <span style="color: #51afef;">const</span>;
  <span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">setWrite</span>();
};
</pre>
</div>
</div>
</div>
<div id="outline-container-org93f93af" class="outline-4">
<h4 id="org93f93af">19.8.2 volatile 限定符</h4>
<div class="outline-text-4" id="text-org93f93af">
<blockquote>
<p>
WARNING：
</p>

<p>
volatile 的确切含义与机器有关，只能通过阅读编译器文档来理解。要想让使用了 volatile 的程序在移植到新机器或新编一起后仍然有效，通常需要对该程序进行某些改变。
</p>
</blockquote>

<p>
直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 <b>volatile</b> 。关键字 volatile 告诉编译器不应该对这样的对象进行优化。
</p>

<p>
就像一个类可以定义 const 成员函数一样，它也可以将成员函数定义成 volatile 的。只有 volatile 的成员函数才能被 volatile 的对象调用。
</p>

<p>
2.4.2 节描述了 const 限定符和指针的互相作用，在 volatile 限定符和指针之间也存在类似的关系。我们可以声明 volatile 指针、指向 volatile 对象的指针以及指向 volatile 对象的 volatile 指针。
</p>

<p>
和 const 一样，我们只能将一个 volatile 对象的地址（或者拷贝一个指向 vloatile 类型的指针）赋给一个指向 volatile 的指针。同时，也只有当某个引用时 volatile 的时，我们才能使用一个 volatile 对象初始化给引用。
</p>
</div>
<div id="outline-container-org1e67342" class="outline-5">
<h5 id="org1e67342">合成的拷贝对 volatile 对象无效</h5>
<div class="outline-text-5" id="text-org1e67342">
<p>
const 和 volatile 的一个重要区别是我们不能使用合成的拷贝/移动构造函数及赋值运算符初始化 volatile 对象或从 volatile 对象赋值。合成的成员接受的形参列表是（非 volatile）常量引用，显然我们不能把一个非 volatile 引用绑定到一个 vloatile 对象上。
</p>

<p>
如果一个类希望拷贝、移动或赋值它的 volatile 对象，则该类必须自定义拷贝或移动操作。
</p>

<p>
尽管我们可以为 vloatile 对象定义拷贝和赋值操作，但是一个更深层次的问题是拷贝 volatile 对象是否有意义呢？不同程序使用 volatile 的目的各不相同，对上述问题的回答与具体的是一噢嗯目的密切相关。
</p>
</div>
</div>
</div>
<div id="outline-container-orgadc55cd" class="outline-4">
<h4 id="orgadc55cd">19.8.3 链接指示：extern "C"</h4>
<div class="outline-text-4" id="text-orgadc55cd">
<p>
C++程序有时需要调用其他语言编写的函数，最常见的是调用 C 语言编写的函数，像所有其他名字一样，其他语言中的函数名字也必须在 C++中进行声明，并且该声明必须指定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通 C++函数相同，但是生成的代码有所区别。C++使用 <b>链接指示</b> 指出任意非 C++函数所用的语言。
</p>

<blockquote>
<p>
Note：
</p>

<p>
要想把 C++代码和其他语言（包括 C 语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的 C++编译器是兼容的。
</p>
</blockquote>
</div>
<div id="outline-container-orge21dd2e" class="outline-5">
<h5 id="orge21dd2e">声明一个非 C++的函数</h5>
<div class="outline-text-5" id="text-orge21dd2e">
<p>
链接指示可以有两种方式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。
</p>

<p>
举个例子，接下来的声明显示了 cstring 头文件的某些 C 函数是如何声明的：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21487;&#33021;&#20986;&#29616;&#22312;C++&#22836;&#25991;&#20214;&lt;cstring&gt;&#20013;&#30340;&#38142;&#25509;&#25351;&#31034;</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#21333;&#21477;&#38142;&#25509;&#25351;&#31034;</span>
<span style="color: #51afef;">extern</span> <span style="color: #98be65;">"C"</span> <span style="color: #ECBE7B;">size_t</span> <span style="color: #c678dd;">strlen</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">char</span> *);
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">&#22797;&#21512;&#35821;&#21477;&#38142;&#25509;&#25351;&#31034;</span>
<span style="color: #51afef;">extern</span> <span style="color: #98be65;">"C"</span> {
  <span style="color: #ECBE7B;">int</span> <span style="color: #c678dd;">strcmp</span>(<span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">char</span>*, <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">char</span>*);
  <span style="color: #ECBE7B;">char</span> *<span style="color: #c678dd;">strcat</span>(<span style="color: #ECBE7B;">char</span>*, <span style="color: #51afef;">const</span> <span style="color: #ECBE7B;">char</span>*);
}
</pre>
</div>

<p>
链接指示的地一种形式包括一个关键字 extern，后面是一个字符串字面值常量以及一个“普通的”函数声明。
</p>

<p>
其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持 C 语言的链接指示。此外编译器也可能会支持其他语言的链接指示，如 extern "Ada"、extern "FORTRAN"等。
</p>
</div>
</div>
<div id="outline-container-org5ce813d" class="outline-5">
<h5 id="org5ce813d">链接指示与头文件</h5>
<div class="outline-text-5" id="text-org5ce813d">
<p>
当一个#include 指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。
</p>

<blockquote>
<p>
Note：
</p>

<p>
C++从 C 语言继承的标准库函数可以定成 C 函数，但并非必须：决定使用 C 还是 C++实现 C 标准库，是每个 C++实现的事情。
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org68adff6" class="outline-5">
<h5 id="org68adff6">指向 extern "C"函数的指针</h5>
<div class="outline-text-5" id="text-org68adff6">
<p>
编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">pf&#25351;&#21521;&#19968;&#20010;C&#20989;&#25968;&#65292;&#35813;&#20989;&#25968;&#25509;&#21463;&#19968;&#20010;int&#36820;&#22238;void</span>
<span style="color: #51afef;">extern</span> <span style="color: #98be65;">"C"</span> <span style="color: #ECBE7B;">void</span> (*<span style="color: #c678dd;">pf</span>)(<span style="color: #ECBE7B;">int</span>);
</pre>
</div>

<p>
当我们使用 pf 调用函数时，编译器认定当前调用的是一个 C 函数。
</p>

<p>
指向 C 函数的指针与指向 C++函数的指针是不一样的类型，一个指向 C 函数的指针不能用在执行初始化或赋值操作后指向 C++函数，反之亦然。就像其他类型不匹配的问题一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误。
</p>

<blockquote>
<p>
WARNING：
</p>

<p>
有的 C++编译器会接受之前的这种赋值操作并将其作为对语言的扩展，监管从严格意义上来看它是非法的。
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgfff78b9" class="outline-5">
<h5 id="orgfff78b9">链接指示对整个声明都有效</h5>
<div class="outline-text-5" id="text-orgfff78b9">
<p>
当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效。
</p>

<p>
因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给 C++函数传入一个指向 C 函数的指针，则必须使用类型别名：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">FC&#26159;&#19968;&#20010;&#25351;&#21521;C&#20989;&#25968;&#30340;&#25351;&#38024;</span>
<span style="color: #51afef;">extern</span> <span style="color: #98be65;">"C"</span> <span style="color: #51afef;">typedef</span> <span style="color: #ECBE7B;">void</span> <span style="color: #ECBE7B;">FC</span>(<span style="color: #ECBE7B;">int</span>);
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">f2&#26159;&#19968;&#20010;C++&#20989;&#25968;&#65292;&#35813;&#20989;&#25968;&#30340;&#24418;&#21442;&#26159;&#25351;&#21521;C&#20989;&#25968;&#30340;&#25351;&#38024;</span>
<span style="color: #ECBE7B;">void</span> <span style="color: #c678dd;">f2</span>(<span style="color: #ECBE7B;">FC</span> *);
</pre>
</div>
</div>
</div>
<div id="outline-container-org203ec94" class="outline-5">
<h5 id="org203ec94">导出 C++函数到其他语言</h5>
<div class="outline-text-5" id="text-org203ec94">
<p>
通过使用链接指示对函数进行定义，我们可以令一个 C++函数在其他语言编写的程序中可用：
</p>

<div class="org-src-container">
<pre class="src src-C++"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">calc&#20989;&#25968;&#21487;&#20197;&#34987;C&#31243;&#24207;&#35843;&#29992;</span>
<span style="color: #51afef;">extern</span> <span style="color: #98be65;">"C"</span> <span style="color: #ECBE7B;">double</span> <span style="color: #c678dd;">calc</span>(<span style="color: #ECBE7B;">double</span> <span style="color: #dcaeea;">dparm</span>) { <span style="color: #5B6268;">/* </span><span style="color: #5B6268;">...</span><span style="color: #5B6268;"> */</span> }
</pre>
</div>

<p>
编译器将为该函数生成适合于指定语言的代码。
</p>

<p>
值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。例如，我们不太可能把一个 C++类的对象传给 C 程序，因为 C 程序根本无法理解构造函数、析构函数以及其他其类特有的操作。
</p>

<blockquote>
<p>
对链接到 C 的预处理器的支持
</p>

<p>
有时候需要在 C 和 C++中编译同一个源文件，为了实现这一目的，在编译 C++版本的程序时预处理器定义__cplusplus（两个下划线）。利用这个变量，我们可以在编译 C++程序的时候有条件地包括进来一些代码：
</p>

<p>
#ifdef __cplusplus
// 正确：我们正在编译 C++程序
extern "C"
#endif
int strcmp(const char*, const char*);
</p>
</blockquote>
</div>
</div>
<div id="outline-container-orgf3a9977" class="outline-5">
<h5 id="orgf3a9977">重载函数与链接指示</h5>
<div class="outline-text-5" id="text-orgf3a9977">
<p>
链接指示与重载函数的互相作用依赖于目标语言。如果目标语言支持重载函数，则为该语言实现链接指示的编译器很可能也支持重载这些C++的函数。
</p>

<p>
C语言不支持函数重载，因此也就不难理解为什么一个C链接指示只能用于说明一组重载函数中的某一个了。
</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">&#20316;&#32773;: Petrus.Z</p>
<p class="date">Created: 2020-09-09 Wed 21:01</p>
</div>
</body>
</html>
