<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
<title>codeplayer</title>
<atom:link href="https://www.codeplayer.org/publish/feed.xml" rel="self" type="application/rss+xml" />
<link>https://www.codeplayer.org</link>
<description>codeplayer wiki</description>
    <item>
    <title><![CDATA[介词攻略]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e4%bb%8b%e8%af%8d%e6%94%bb%e7%95%a5.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e4%bb%8b%e8%af%8d%e6%94%bb%e7%95%a5.html</guid>
    <description><![CDATA[<p>#+TITLE: 介词攻略 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>介词的原理 介词，preposition。preposition 符合派生构词法：前缀 pre 表示“在…之前”，position 表示“位置”。所以，说白了英语介词，preposition，就是“放置在前面的”词，即“前置词”。</li>
</ul>
<p>不过，“前置词”的“前置”好像只表达了一半的意思。更进一步说，介词 preposition 就是通常放置在名词、代词等之前，哟 inglaigei 它们增添”附加信息“的词。其中附加信息包括，时间信息、空间信息、方式信息，逻辑信息（原因、目的、对象…）等等。</p>
<p>其实中文里也是一样，介词可以理解为”前置词“，用来提供补充信息。举个例子：</p>
<p>#+begin_example 兔子 <em>在8点前</em> 吃胡萝卜。 兔子 <em>在8点后</em> 吃胡萝卜。 兔子 <em>在8点时</em> 吃胡萝卜。</p>
<p>注：严格来说，以上中文语句里的介词是“在”。 #+end_example</p>
<p>因为介词不同，表达的附加意思都是不同的。</p>
<p>以上是时间信息，那换成空间信息的例子，就有：</p>
<p>#+begin_example 兔子 <em>在屋子里</em> 吃胡萝卜。 兔子 <em>在屋子上</em> 吃胡萝卜。 兔子 <em>在屋子下</em> 吃胡萝卜。</p>
<p>注：严格来说，以上中文语句里的介词是“在”。 #+end_example</p>
<p>介词也可以补充逻辑信息:</p>
<p>#+begin_example 兔子 <em>为了</em> 健康吃胡萝卜。 兔子 <em>除了</em> 胡萝卜什么都不吃。 #+end_example</p>
<p>刚才这些是中文的例子，英文中当然也有相似的介词表达：</p>
<p>#+begin_example before 8 o’clock 在8点前 after 8 o’clock 在8点后 at 8 o’clock 在8点时</p>
<p>in the room 在屋子里 on the roof 在屋顶上 under the table 在桌子下</p>
<p>for health (reasons) 为了健康 except (for) carrots 除了胡萝卜 #+end_example</p>
<p>这样的介词表达，归根结底，都是作为某个内容的“前置词”，通过与其之后的内容的关系，来表达某种信息。这便是介词的原理。</p>
<p>正因此，完整的信息必须要有介词之后的部分参与。如果仅仅只有介词，因为与之后的内容关系缺失，自然也表达不了完整的意思。这也就是为什么介词不能单独作为句子成分存在。 * 介词的构成形式 在我们理解了“所谓介词，不过就是‘前置词’而已”，那接下来就不难理解，为什么介词的构成形式多种多样。因为就是放在其他信息之前建立关系。 ** 简单介词 最常见的英文介词，是单个词，比如：</p>
<p>in，在…里（以及其他多重含义）；to，朝…（以及其他多重含义）；with，和…（以及其他多重含义）。这些都是所谓简单介词。 ** 短语介词 介词还可以和其他类的词共同构成短语介词，即一个短语充当介词的功能，比如：</p>
<p>#+begin_example by way of 通过…方式 &lt;- 介词 + 名词 + 介词 at the end of 在…的最后 &lt;- 介词 + the + 名词 + 介词 along with 和…一起 &lt;- 介词 + 介词 because of 因为… &lt;- 连词 + 介词 previous to …之前 &lt;- 形容词 + 介词 #+end_example</p>
<p>这样的短语构成也很多样。</p>
<p>特别注意，这里的“短语介词”和之后要说的“介词短语”是不同的概念。短语介词相当于介词，不能单独表示完整意思，而介词短语已经是完整的意思了，往往相当于副词。这个之后再说。 ** 合成介词 还有的介词可以互相合成，比如：</p>
<p>into，到…之内。onto，到…之上。within，在…之内 。notwithunderstanding，尽管…。 ** 分词介词 还有一类介词是由动词的分词充当的，比如：</p>
<p>including，包括…。regarding，关于…；至于…。considering，鉴于…；考虑到…。given，考虑到…；如果…。</p>
<p>也就说，这些原本是动词的词，“变个形”，就有了介词的功效。</p>
<p>还是那个道理，介词之所以这么多样，就是因为介词本质上不过是“前置词”，和后面的信息构成关系而已，所以以上这些结构形式都能满足这一点，所以都可以充当介词。 * 介词学习的误区 正因为介词是作为“前置词”，通过与之后内容的关系，来表达信息的，所以当这样的关系在中英文里的思维方式相似时，中英文介词有些对应程度很高，如：</p>
<p>until，直到；along，沿着；expect，除了。都只有一个或几个主要含义。这些介词相对好掌握。</p>
<p>反之，当介词使用时中英文思维方式不同时，就没有办法找到完全对应的介词翻译。这一点和名词、动词等实词往往能能够找到对应翻译很不同。</p>
<p>比如兔子和 rabbit 可以说是对应的。但英文中的某些介词，比如 in、on、with…恰恰因为常用，出现频率很高，所以引申义很多，导致有很多中文无法对应上的含义，无法用“里面”、“上面”、“和”，字面上对应：</p>
<p>#+begin_example in two days 两天后 on the left 在左边 angry with me 生我的气 #+end_example</p>
<p>注：字面上无法对应，但引申义可以帮助理解，之后会提到。</p>
<p>换句话说，学习英语介词，最忌讳的、最需要避免的，就是拼命去找个中文介词对号入座，因为那往往是不可能说的。</p>
<p>千万不要试图把中文介词和英文介词一一对应着生搬硬套。 * 介词学习的诀窍 学习介词有两个很大的麻烦：1.很多介词意义太多：同一介词出现在不同的分类里。也就是说，它们可以和之后的内容构成不同类别的关系，从而表达差别很大，甚至表达毫不想干的含义。2.很多介词相互之间容易混淆：在同一个类别里的介词有的时候看起来很像。比如 in、on、at 都可以表示时间或空间信息。这就导致非母语人士往往会觉得他们过于相似，从而弄混淆。</p>
<p>要解决，或者说缓解，这两个问题，往往要从介词的本义，以及引申义入手。具体说来，介词的本义，也就是根源意义，通常能表达明确的空间含义；而在这些空间含义的基础上，又引申出了许多非空间的“衍生含义”。 ** 介词意义太多 比如，about 这个介词，原来在古英语里是 onbutan（相当于 on by utan）。最后 utan 是 outside 的意思，所以 about 原意是 on the outside of，即“在…的外面（之处）”。这也是这个介词最源是，最根源的空间含义。</p>
<p>这个“在…外面（之处）”接着就引申出了以下一系列相关的含义，比如：</p>
<ul>
<li><p>关于：…的外围信息、涉及到（但往往不是核心关键，因为在外面嘛）</p>
<p>I know something about the rabbit. 我知道关于这个兔子的事。</p></li>
<li><p>大约：从外大范围（大致）数一数</p>
<p>There are about 20 carrots. 大约有 20 根胡萝卜。</p></li>
<li><p>针对：从外向内地解决</p>
<p>Let’s do something about the problem. 让我们做些事解决问题。</p></li>
<li><p>某人某事有某种特性</p>
<p>就像在外包了一层包装，有某种气质</p>
<p>There’s something dangerous about the wolf. 狼有点危险的特质。（狼感觉有点危险。）</p></li>
<li><p>到处：在…的外面来来回回</p>
<p>Stop running about! 别来来回回跑！</p></li>
</ul>
<p>再看 on 这个介词，它有以下用法：</p>
<p>Dinner is on me. 晚餐我付钱。</p>
<p>这里之所以用介词 on（在…之上），可以理解为“付账”的重任在我身上，即：</p>
<p>The burden of paying for dinner is on me. 为晚餐付钱的重任在我身上。</p>
<p>又比如介词 beyond：</p>
<p>It’s beyond me. 我无法理解。</p>
<p>这里之所以用介词 beyond（在…之外），可以理解为某件事在我“能理解的范围”之外，即：</p>
<p>It is beyond the things that I can understand. 这在我能理解的事情的范围之外。</p>
<p>甚至有些看似毫无道理的介词，往往也能用这种方式进行解释，即使介词的某些含义的确会和本源的空间含义差别较大：</p>
<p>比如 in 这个介词还有以下用法：</p>
<p>#+begin_example in the sun 在阳光下 dressed in white 穿白衣服 in English 用英语 #+end_example</p>
<p>看上去似乎毫无道理，不过，这里的 in the sun 可以用 in the sunlight，即包裹在阳光里来解释，dressed in white 自然可以用 in white clothes 来理解，in Enligsh 可以理解为说的话写得字都在一堆英语话语或文字中。</p>
<p>所以说，某些介词虽然看上去有着风马牛不相及的含义，但实际上往往都是从根源的，有着空间性的含义引申出来的。</p>
<p>不过，每个介词的每个含义都硬要从空间含义去推导也不太现实，或者说往往很牵强。有时候这种“推导”更像是记忆技巧。</p>
<p>以上说的是介词“多含义”这个难点。下面说“某些介词之间容易混淆”这个问题。 ** 介词相互之间容易混淆 它也可以用刚才这种追本溯源的方法来缓解。比如，in、on、at 都能前置于时间和空间，表达相关含义。但正因为这样，很多人老是记不住 hour、day、year、corner、street、city 到底哪个和哪个介词搭配。</p>
<p>但是如果从这个三个介词的空间含义入手，in 一般是在一堆东西中间，或者说，上下左右前后都能移动，说明是在一个大范围内；on 一般是指在…之上，说明有一面确定了，只能在这个平面上移动，自然范围小一点；而 at 通常只在很明确的一点上。</p>
<p>既然范围由大到小，就很好理解：</p>
<p>at the corner，at the shop，因为角落、商店很明确，不会到处移动</p>
<p>in the city，in the country，因为在城市和国家里可以大范围移动</p>
<p>那么，the street 前到底是 at、on 还是 in？这取决于要表达什么含义。如果要表达很明确的某处，比如两条街的交接，那就可以说：</p>
<p>Right now I’m <em>at</em> Carrot Street and Apple Street. 现在我在胡萝卜街和苹果街的交界处。</p>
<p>如果要表达在街道的表面上，就可以说：</p>
<p>There is some trash <em>on</em> the street. 街上有些垃圾。</p>
<p>如果要表达在某条街道的范围内移动，就可以说：</p>
<p>I’m walking <em>in</em> the street. 我在大街上走。</p>
<p>相当于 I’m walking in the area of the street.</p>
<p>这句话中其实 in the street 和 on the street 都能说得通，只有微妙的区别。更多美国人会说 on the street，而英国人往往会偏向于 in the street。</p>
<hr />
<p>相似地，把这个空间概念引申到时间上：</p>
<p>一年很久，所以 in a year 表示在“大范围的”一年内。这样的大范围也包括月份、星期，所以 in the month，in the week。</p>
<p>一天的话，就明确多了。如果把一天以上比作一个空间，那一天只是一个平面，所以 on that day，on Monday，on April 1st。</p>
<p>而一条中的时刻就非常明确了，相当于一个点，所以是 at 8 o’clock，at the moment。</p>
<p>但是千万不要生搬硬套，教条主义地认为，看见 hour 就一点要用 on。一定要想清楚，要表达的是一个范围，还是具体一个点。</p>
<p>比如说一个小时里有六十分钟。那肯定是把小时和分钟比较，即分钟是在小时的范围里。这里的 hour 显然不是一个点。所以是：</p>
<p>There are 60 minutes in an hour. 而不是 +There are 60 minutes on an hour.+</p>
<p>这样的的范围是相对的，所以再往下还是：</p>
<p>There are 60 seconds in a minute. 而不是 +There are 60 seconds on a minute.+</p>
<p>另外，很多人都会奇怪，为什么是 in the morning？morning 比 day 还小啊？</p>
<p>问题就出在，当我们使用 in the morning 这个短语时，通常是表达一个时间段的范围内，相当于刚才的：</p>
<p>There are many hours and minutes in a morning.</p>
<p>所以，当我说 I eat carrots in the morning 时，表达的意思是，我在早晨这个时间范围内吃胡萝卜。而如果你要表达的是一个相对明确的一个点，就要说 on the morning 了，比如说：</p>
<p>I saw the wolf on the morning of April 1st.</p>
<p>这里要表达的意思是，在四月一日早晨这个时间，和一天差不多的范围。所以既然是 on that day，那自然也有 on that morning。</p>
<p>那为什么是 at noon？因为这里的时间点很明确。noon 之前的上午和之后的下午都是相对的大范围。但 noon 相对来说是一个点，所以才和 at 搭配。 * 常见英语介词用法 ** 表示空间的介词 in 表示“在…里面”，表示在一个空间的内部。</p>
<hr />
<p>on 表示“在一个物体的表面上”。</p>
<p>其实 on 在古英语中里是 in 的另一个形式，所以往往和 in 的含义有交叉。只不过在现代英语中，on 做空间介词是有在某个面之上的含义。</p>
<p>在此注意一下 on the tree 和 in the tree 的区别，安装刚才的理解，on 表示与物体有接触，所以可以引申为长在树上的，是树本身所有的。而 in 只是在树里，外来的事物进入树里。所以可以这样说：</p>
<p>There are some apples on the tree. 树上结着一些苹果。</p>
<p>There are some birds in the tree. 树上有一些鸟。</p>
<hr />
<p>at 在表示地点的时候，指一个确定的具体的“点”。</p>
<hr />
<p>over，当 over 做空间介词时，表示“在…上方”。这个“在…上方”，有可能接触，也可能不接触。如果表示物体与物体接触的话，一般表示“覆盖、全部遮住”的意思，比如：</p>
<p>The mother put a blanket over the child. 妈妈把毯子盖在孩子身上。</p>
<p>如果不与物体接触的话，表示“在…的正上方”，比如：</p>
<p>#+begin_example the bridge over the river 在河上的桥 the lamp over the table 在桌上方的灯 #+end_example</p>
<p>而更常见的表达上空这个含义的 over，是表示一个动态的“越过上空”，比如：</p>
<p>#+begin_example The plane flew over the mountain. 飞机飞越过高山。 The rabbit climbed over the fence. 兔子爬过栅栏。 #+end_example</p>
<hr />
<p>above 表示“高于某个平面之上”。比如：</p>
<p>the sky above us 在我们上方的天空</p>
<p>这一含义和 over 的“静态含义”是很相似的。只不过 over 往往还特指正上方，而 above 一般只要“高出”就行。</p>
<p>虽然 on，over，above 这几个词都有表示“在…上面”的含义，但是是有区别的：on 表示物体与物体接触；over 和 above 在表示（不与物体接触的）上方时，除了 over 往往更加“正上方”，最大的区别是 over 可以描述动态，而 above 不行。</p>
<hr />
<p>under 表示“在…下面”。与 over 相对。</p>
<hr />
<p>below 表示“在…下方”。与 above 相对。</p>
<p>under 表示物体之间可以接触，也可以留有一定空间。指在某物的正下方，含垂直在下方的意思。</p>
<p>below 表示低于某个平面，可以是正下方，也可以不是。</p>
<hr />
<p>near 表示“在…附近，在…周边”。</p>
<p>by/beside 做空间介词时，两者都表示“在…旁边”，通常两者可以互换。</p>
<p>next to，靠近、紧挨着。</p>
<p>辨析：near、by、beside、next to 这几个介词都可以表示“在…旁边”。near 表示附近的，往往有些距离。by、beside 和 next to 都表示比较接近，往往可互换。其中 by 的词义最多，除了空间还有其他很多词义。beside 强调的是”在…边上“，可以引申为“非空间含义”的“和…比较”，如：My carrot looks bigger beside yours.（我的胡萝卜和你的一起看着更大。）；next to 强调的是“下一个、紧邻着”的“相邻”。</p>
<hr />
<p>across 一般指从表面穿过，与介词 on 那个”表面“相似，是在物体表面上发生的行为，所以会说：</p>
<p>#+begin_example go across the river 穿过马路 swim across the river 游过河 #+end_example</p>
<hr />
<p>throught 一般指从内部穿过，与介词 in 那个”内部“相似，是从物体内部发生的动作，所以会用：</p>
<p>#+begin_example go throught the tunnel 穿过隧道 walk throught the forest 穿过森林 look throught the window 透过窗户看 #+end_example</p>
<hr />
<p>past 表示”经过、路过“，比如：</p>
<p>The rabbit walked past the wolf without saying any words. 兔子从狼身边经过，没说一句话。</p>
<hr />
<p>in front of，表示”在…前方“，比如：</p>
<p>The rabbit is standing in front of the wolf. 兔子站在狼前面。</p>
<p>before，虽然 before 和 in front of 一般都翻译成”在…之前“，但是 before 其实不太用作空间介词，除非是表达”在众人/观众前“，比如：</p>
<p>She played the violin before the crowd. 她在众人前拉小提琴。</p>
<hr />
<p>behind，与 in front of 相对的是 behind，在…之后，比如：</p>
<p>The wolf is standing behind the rabbit. 狼站在兔子后面。</p>
<hr />
<p>between，一般来说，between 侧重在两者之间，有时会与 and 一起用，构成 between…and…的结构。比如：</p>
<p>The carrot is between the rabbit and the wolf. 胡萝卜在兔子和狼之间。</p>
<p>但千万不要以为它不可用于多者之间，在三者及以上之间分别两两比较时也可以用 between，比如：</p>
<p>You shouldn’t eat between meals. 你不应该在正餐之间吃东西。</p>
<hr />
<p>among 一般指在三者以更多人和物之间。</p>
<p>The rabbit is standing among the carrots. 兔子站在胡萝卜之间。</p>
<p>不过，在当代英语里，尤其是口语，往往很多母语人士也会用 between 来表示多数的”之间“（即取代 among）。</p>
<hr />
<p>round/around，表示”围绕、环绕“，二者作介词意思相近，可互换。</p>
<p>#+begin_example trees round/around the field 环绕田地四周的树 around the world 全世界 #+end_example</p>
<hr />
<p>along，沿着、顺着，比如：walk along this road 沿着这条路一直走。</p>
<hr />
<p>to，向、朝…，比如：go to school 去上学。</p>
<hr />
<p>toward/towards，朝着…的方向，根 to 在此意上意思相近，比如：walk toward home 朝家走。</p>
<hr />
<p>onto，到…上面，比如：The rabbit jumped onto the table. 兔子跳到桌子上。</p>
<hr />
<p>into，到…里面、到…内部，比如：walk into the house 走进房子。</p>
<hr />
<p>out of，从里向外，从里面出来，比如：get out of the car 从车里出来。</p>
<hr />
<p>opposite，在…对面，比如：Our school is opposite my house. 我们的学校在我家对面。</p>
<hr />
<p>against，与…相反，比如：We were rowing against the current. 我们逆水行舟。</p>
<p>还有一个常用的意思：倚、靠。比如：The rabbit was leaning against the tree. 兔子正倚着一棵树。</p>
<hr />
<p>以下几个词除了做副词，也可以做介词：</p>
<p>up，沿…向上，比如：up the hill 上山、up the river 沿河流逆流而上。</p>
<p>down，沿…向下，比如：walk down the road 沿着这条路走下去，roll down the hill 从山上滚下去。</p>
<p>off，离…有一些距离，比如：New Zealand lies off the easten coast of Australia. 新西兰离澳大利亚东海岸有一些距离。 ** 表示时间的介词 不少表示时间的介词，和它们表示空间的”本源“用法是对应的。之前讲过 in、on、at 表示的时间范围是由大到小的。我们再看一下：</p>
<p>in，本意是”在…里面”，在范围相对较大的时间内，比如：in 2030 在 2030 年，in winter 在冬季，in December 在 12 月。</p>
<p>on 的本意是“在…之上”，范围相对就小一些，一般表示在具体的某一天，on Monday 在星期一，on Christmas Day 在圣诞节。</p>
<p>at 因为空间范围很小，所以引导到时间上也类似，表示非常确定的时间点。一般说几点钟用 at，比如：at 6 o’clock 在六点。而下面这些时间也是明确的时间（点）：at noon 在中午，at sunset 在太阳落山时，at dawn 在黎明时分 ，at (the age of) 6 在 6 岁时。</p>
<p>during 本意就是“持续”，表示持续一段时间。during the past 2 days，持续了过去的两天，就表示“在过去的两天里”。同样，during the past two weeks 在过去的两周里，during the past two years 在过去的 2 年里。</p>
<p>for 在古英语里有“之前、由于”的意思，作“非时间介词”时一般和原因相关。这里用作时简介词，可以引申为“（因为…）持续”：I’ve been learning English for 2 years. 我持续学习英语两年时间。</p>
<p>since，自从。since last week 自从上周以来。</p>
<p>before 一般就是用于表示时间（以及次序）的“在…之前”：before Monday 星期一之前，before 2020 在 2020 年之前。注意 before 很少用于空间的“在…之前”。</p>
<p>after，after 和 before 相对，一般表示时间（以及次序）上的“在…之后”。after two years 两年之后。</p>
<hr />
<p>after 和 in 作为时间介词往往容易混淆。这是因为，in 作时间介词时，除了泛指在某个时间范围之内，也可以表示在“从现在算起之后的”某个时间范围内，如：</p>
<p>I’ll eat a carrot in 2 hours.</p>
<p>这句话一般翻译成“2 小时之后我会吃根胡萝卜”，但是说话人的言下之意是，从现在算起的两小时”里“，我会吃根胡萝卜，也许过一小时我就吃了。也就是说，这是不确定信息。</p>
<p>相比之下：</p>
<p>I’ll eat a carrot after 2 hours.</p>
<p>就明确表示，我只有在过了 2 小时之后才会吃，之前不会吃。另外，过去时间要使用 after，不能使用 in，因为已经是确定信息了：</p>
<p>I returned after two hours. 我两小时之后回来了。</p>
<hr />
<p>from…to…，从…（时候）到…（时候）。from 9:00 to 10:00 从九点到十点。</p>
<hr />
<p>by 的本意表示”在…附近/旁边“，引申为时间上的”不超过…的边“，即”不迟于…/在…之前“。by 2 o’clock 在两点之前。by tomorrow 在明天之前。</p>
<p>在表示时间点之前时，by 和 before 含义近似，但是 before 是泛指某个时间点之前，而 by 相当于限定了一条时间线，更侧重于”不超过、不迟于“这条时间线。所以：</p>
<p>Please finish your homework before 8PM.</p>
<p>Please finish your homework by 8PM.</p>
<p>都表示希望你在 8 点前做完作业，但是后者更强调了 8 点是截至时间，不能再迟了。</p>
<hr />
<p>until，直到…为止。until 8 o’clock 直到 8 点为止。 ** 表示方式的介词 in 有”方式“的含义，比如 in 后根语言，就是”用某种语言（的方式）…“。比如：New</p>
<p>Let’s talk in English. 让我们用英语对话。</p>
<p>in 的本意是”在…里面“，in English 可以引申为”我们说的话、写的字，都是在其他一堆英语话语里“，也就成了”我们说英语“的意思。</p>
<hr />
<p>throught 可以表示通过某种方式，如：</p>
<p>We succeed throught hard work. 我们通过努力工作而成功。</p>
<p>throught 的本意是”从中间穿过“，引申为”通过“某种方式或经理，也就不奇怪了。</p>
<hr />
<p>by 的本意是”在…旁边“，引申出”相关、离不开、依靠…“的含义。</p>
<p>We learn English by watching videos. 我们通过看视频学英语。</p>
<p>我们学英语是依靠”看视频“的，也就是”通过视频学英语“。再比如：</p>
<p>I go to work by car. 我开车去上班。</p>
<p>意思就是我”依靠汽车这个交通方式“去上班。</p>
<hr />
<p>这里要再次特别指出，介词的本源空间含义一般是很具体的。当这种具体的含义去引申抽象的含义，自然不会对应得十分完美，往往还会有些牵强。这里希望作到的是从介词的本意联想到引申义，从而更好理解记忆介词的各种不同含义，而并不是做学术上的词源研究。</p>
<hr />
<p>with 后一般加具体的有形工具。这是因为 with 本意有”和、一起“的意思，比如：New</p>
<p>We write with pens. 我们用笔写字。</p>
<p>这其实不就是”我们和笔一起，完成写字这个行为“的意思。</p>
<hr />
<p>on 后接电子通讯设备比较多。</p>
<p>We talk on the phone. 我们通过电话进行了交谈。</p>
<p>on 的本意是”在…上面“。 ** 表示原因的介词 for 本来就有”因为、由于“的含义，比如：</p>
<p>This rabbit is famous for being able to speak. 这只兔子因会说话出名。</p>
<hr />
<p>with 的本意是”和、一起“，这里引申为”…是和…分不开的原因“，如：</p>
<p>The rabbit is shaking with cold. 兔子冷得发抖。</p>
<p>这里的意思是说，”冷“和”发抖“对于兔子来说，是分不开的，也就是在阐述原因。”冷得发抖”其实就是在描述，“因为太冷了所以发抖”。</p>
<hr />
<p>because of，一提到 because of，一定会想起 because，因为二者都有“因为”的意思，because 做连词连接从句，because of 后接名词（或代词等）。</p>
<p>The rabbit didn’t go out beacuse of the rain. 因为下雨，兔子没出去。</p>
<p>另外 due to、owing to、on account of 都表示“由于、因为”之意，比如：</p>
<p>The rabbit didn’t go out due to / owing to / on account of the rain. 因为下雨，兔子没出去。</p>
<p>你可能注意到了，这几个都不是单独的一个介词，而是介词的所谓“固定搭配”。咱们之后还会提到。 ** 表示关于的介词 about，之前讲过 about 本意“在…外面”，关于某人或某事的一些情况，不就是“外围相关信息”吗？</p>
<p>Could you tell me something about your school? 你能给我讲一些关于你到学校的事情吗？</p>
<hr />
<p>of 在古英语中的本义是“离开”。“离开了的”在这里引申为“此外的、附加的”，即“相关”的信息。这一点和 about 有些像：</p>
<p>He thought of something import. 他想起来了一些重要的事情。</p>
<p>只不过 think about 是想到了“关于…的一些事”，而 think of 仅仅是“想起了…”。</p>
<hr />
<p>on 的本义是“在…上面”。把一个具体的事儿当成平面，其上的讨论也是“关于”的意思，比如：New</p>
<p>Would you like some advice on learning English? 你想要些学习英语的建议吗？</p>
<p>这里是在学习英语这件事“上”寻求建议，也就是“关于”学习英语的建议。 ** 表示数值的介词 at 可以表示价格、比率等数值点，如：at a high price 在一个高的价格（点），at a fast rate 以一个很快的速率（点）。这个用法自然是从 at 表示空间的某个点引申而来，因为以上这些都是数值的点嘛。</p>
<hr />
<p>by，之后可以接某种度量标准，如：</p>
<p>They get paid by hour. 他们按小时拿报酬。</p>
<p>by 的空间本义是旁边，这里可以引申为“相关、某种属性”的意思，进一步引申为使用某种标准。所以“按小时计算”就可以理解为“与每小时相关、按小时的属性”。</p>
<hr />
<p>for 可以表示“以…的加前”，如：</p>
<p>I bought these books for 100 Yuan. 我买这些书买了 100 元。</p>
<p>其实虽然这里的 for 被分到了表示数值的介词这个类别，但还是能把它理解为之前讲的表原因的 for，也就是“因为付了…钱，所以得到了…”。所以 I gought these books for 100 Yuan. 可以理解为，因为我付了 100 元，所以得到了这些书。 ** 表示状态的介词 in 表示在某个状态中，in process 在进行（状态）中，in a dilemma 处于进退两难的境地。</p>
<hr />
<p>on，空间本义为“在…之上”，可以引申理解为“受到之下的…的支持（这种状态）”，如：on a diet 在节食（在节食支持的状态），on drugs 吃药（在药物支持的状态）</p>
<hr />
<p>at 本意是在某个地点，可以引申为在某个状态。at work 在工作，at dinner 在吃晚饭。这里都是表示明确的某个“状态点”。at work 表示工作的地点/状态，at dinner 表示在吃饭的地点/状态。</p>
<hr />
<p>under 本意表示“在…下面”，这里引申为在一个“框架、前提”之下，如：under construction 在施工中，under discussion 在讨论中。工地上的施工，不就是在脚手架、吊车之类的施工器具之下。而 under discussion 一般也是在某个前提或者说共识之“下“。 ** 表示排除的介词 beside 表示”除了…还…“，比如：</p>
<p>I like many things besides carrots. 除了胡萝卜，我还喜欢很多东西。</p>
<p>严格来说，这并非”排除“的含义，只是中文译作”除了“…</p>
<hr />
<p>except 表示”除了…“，这也是最直接的”排除“的含义。</p>
<p>Everyone went to the party except the rabbit. 大家都去了聚会，除了兔子。</p>
<hr />
<p>except for 也翻译做”除了“，用法也和 expect 相似，但是往往用来对之前的内容进行反驳，如：</p>
<p>The party is great except for the loud music. 聚会很棒，除了嘈杂的音乐。</p>
<p>也就是说，except 通常表示从整体中剔除出去，所以之前那句表示兔子没去参加聚会。except for 这里是要给出与 the party is great 相反的原因，相当于”美中不足的是…“。 * 介词短语 介词后面也需要宾语，即介词宾语。介词宾语就和”通常“宾语一样，可以由多种词类充当，如：</p>
<p>#+begin_example 名词：in the room 代词：in it 数词：the age of 20 形容词：in general 副词：from here #+end_example</p>
<p>快速总结一下就是：介词就是”前置词“，而这个”前置“的对象，即承受者，就是之后的宾语。而介词和介词宾语合起来，就组成了介词短语，比如之前看到的：in the room，on the roof，under the table。</p>
<p>这显然和之前说到的短语介词不同。因为短语介词相当于介词，意思不完整，而这里的介词短语已经完整。实际上，这样的介词短语可以充当各种句子成分：</p>
<p>#+begin_example 主语：<em>Between 10 and 11</em> is a good time for me. 10点到11点间适合我。 主语补语（表语）：The meeting is <em>at 2 o’clock</em>. 会议在2点钟。 定语：This is the key <em>to the house</em>. 这是房子的钥匙。 宾语补语：I found the carrot <em>in good condition</em>. 我发那个胡萝卜保存完好。 #+end_example</p>
<p>而介词短语最常见的是充当状语，来修饰动词，描述动作的时间、地点、方式等等。这一点也是和介词分类一致的：</p>
<p>The rabbit ate a carrot <em>at noon</em>. 中午，兔子吃了一根胡萝卜。</p>
<p>The rabbit is eating a carrot <em>in the kitchen</em>. 兔子正在厨房里吃一根胡萝卜。</p>
<p>The rabbit likes traveling <em>by car</em>. 兔子喜欢乘车出游。 * 介词固定搭配 从介词的”空间含义“去推导”引申义”，并非百分之百适用。有些介词引申义很直接，很容易理解，有些则不然。所以说，也不必任何介词的任何含义，都去绞尽脑汁望空间含义上套。（不过用这种追本溯源的方法学习介词，一定能让你更好理解和记忆介词的多重含义）</p>
<p>这也就是为什么会在介词这一块儿提到所谓“固定搭配”。比如：</p>
<p>#+begin_example for example 比如 at ease 自在 in turn 依次 #+end_example</p>
<p>虽然也有可能去用空间含义推导，但是这样的例子算作“固定搭配”也未尝不可。更进一步说，很多名词、动词、形容词都是“约定俗成”地和某些介词搭配使用。比如：</p>
<p>#+begin_example the need for somethings 对…的需要 long for 渴望… ready for 准备… #+end_example</p>
<p>不过这些所谓“固定搭配”不是绝对的，具体的语境往往还会决定到底用哪个介词最合适。而这也恰恰说明了，从介词本源的空间含义去理解引申义的重要性。</p>
<p>但是，要特别指出，有一类“介词固定搭配”，即当动词和介词搭配在一起，往往会产生非常“神奇的变化”，营造出看似完全无关的含义。这就是所谓“短语动词”。开头提到的那些词组就属于这个范畴：</p>
<p>#+begin_example check out 退房 make out 分辨 put out 熄灭 pass out 晕倒 work out 健身 look out 小心 knock out 打晕 #+end_example</p>
<p>很多短语动词是需要去特别记忆，而不是很容易通过字面意思就能理解。短语动词是英语的一大难点。往往动词本身和之后的介词都明白什么意思，但凑到一起就是完全猜不到意思，相当于一个全新的单词。</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[被动语态]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e8%a2%ab%e5%8a%a8%e8%af%ad%e6%80%81.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e8%a2%ab%e5%8a%a8%e8%af%ad%e6%80%81.html</guid>
    <description><![CDATA[<p>#+TITLE: 被动语态 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>语态 英语语态分为两种：主动语态和被动语态。</li>
</ul>
<p>“兔子咬人了！”</p>
<p>”谁被兔子咬了？“</p>
<p>在一句话中，想要强调谁，谁就会充当主语。如果强调动作的执行者，譬如兔子做出咬人的举动，句子就会用主动语态。如果强调动作的承受者，譬如谁被咬，句子就倾向用被动语态。</p>
<p>被动语态的构成也是通过谓语动词的变化完成的，不妨通过五种基本句型来看看它们的被动语态是怎么演化的。 * 基本句型 ** 主 + 谓 The rabbit slept.</p>
<p>该剧 slept 是个不及物动词，没有宾语，不存在动作的承受者这个概念，自然就没有被动语态了。 ** 主 + 谓 + 宾 The rabbit ate the carrot.</p>
<p>主语 the rabbit 是动作 ate 的执行者，the carrot 是动作 ate 的承受者，如果变成被动语态，就是强调动作的承受者，让 the carrot 成为主语。其中被动语态的构成为“be + 动词过去分词”。如果需要表明动作的执行者是谁，就要借助“by + 动作执行者”。所以，我们得到：</p>
<p>Teh carrot was eaten by the rabbit.</p>
<p>很多情况下，无需表明“被谁…”这一概念，例如：</p>
<p>A carrot was eaten.</p>
<p>回想一下在非谓语动词里，过去分词作主语补语（表语）的句子：</p>
<p>The rabbit was frightened by the wolf.</p>
<p>所以，过去分词表被动的意义和被动语态脱不了关系。 ** 主 + 谓 + 宾 + 宾 The rabbit gave the carrot <em>to</em> the wolf.</p>
<p>在这个句子里有两个宾语，直接宾语 the carrot 和间接宾语 the wolf。如果强调间接宾语 the wolf：</p>
<p>The wolf was given the carrot by the rabbit.</p>
<p>如果强调直接宾语 the carrot：</p>
<p>The carrot was given to the wolf by the rabbit.</p>
<p>当然，如果都知道是兔子给狼胡萝卜，可以把 by + 动作执行者这部分去掉。所以上面两个句子可以简写成：</p>
<p>The wolf was given the carrot.</p>
<p>The carrot was given <em>to</em> the wolf.</p>
<p>如果这个句子主动形式写成“一语+谓语+间接宾语+直接宾语”的形式，那 to 就消失了。</p>
<p>The rabbit gave <em>the wolf</em> <em>the carrot</em>.</p>
<p>但在强调直接宾语 the carrot 变被动句时，可不能是：</p>
<p>+The carrot was given the wolf (by the rabbit).+</p>
<p>它和之前那句代介词 to 的主动句变被动语态是一样的，所以应该还是：</p>
<p>The carrot was given <em>to</em> the wolf (by the rabbit)+</p>
<p>千万不要漏掉 to。 ** 主 + 谓 + 宾 + 宾补 The wolf invited the rabbit to her party.</p>
<p>改为被动态：</p>
<p>The rabbit was invited to the party by the wolf.</p>
<p>有时需要特别注意，再看一个例子：</p>
<p>The rabbit <em>made</em> the wolf <em>laught</em>.</p>
<p>make 等后接的是省略了 to 的动词不定式，这种不带 to 的动词不定式也被成为裸不定式。</p>
<p>所以原句实际上相当于：</p>
<p>The rabbit made the wolf +to+ laught.</p>
<p><em>一旦省略了 to 的动词不定式作宾补，改成被动语态时要把 to 还原。</em> 所以改成被动语态应该是：</p>
<p>The wolf was made to laugh (by the rabbit). ** 主 + 系 + 表（主语补语） The rabbit is smart.</p>
<p>这种句型没有办法变成被动语态。 * 复杂用法 其实被动态可以更复杂，如果被动态和动态、语气、情态助词相结合的话，就会产生一系列“化学反应”，比如：</p>
<ul>
<li><p>The rabbit <em>has eaten</em> the carrot.</p>
<p>-&gt; The carrot <em>has been eaten</em> by the rabbit.</p>
<p>-&gt; The carrot <em>has not been eaten</em> by the rabbit.</p>
<p>-&gt; <em>Has</em> the carrot <em>been</em> eaten by the rabbit.</p></li>
<li><p>The rabbit <em>would have eaten</em> the carrot.h</p>
<p>-&gt; The carrot <em>would have been eaten</em> by the rabbit.</p>
<p>-&gt; The carrot <em>would not have been eaten</em> by the rabbit.</p>
<p>-&gt; <em>Would</em> the carrot <em>have been</em> eaten by the rabbit.</p></li>
<li><p>The rabbit <em>might eat</em> the carrot.</p>
<p>-&gt; The carrot <em>might be eaten</em> by the rabbit.</p>
<p>-&gt; The carrot <em>might not be eaten</em> by the rabbit.</p>
<p>-&gt; <em>Might</em> the carrot <em>be</em> eaten by the rabbit.</p>
<p>归根结底，这些变位主要是针对构成被动语态所需的 be 动词的变位。</p></li>
</ul>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[独立主格]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e7%8b%ac%e7%ab%8b%e4%b8%bb%e6%a0%bc.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e7%8b%ac%e7%ab%8b%e4%b8%bb%e6%a0%bc.html</guid>
    <description><![CDATA[<p>#+TITLE: 独立主格 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>独立主格结构 先回忆一下非谓语动词对从句的简化：</li>
</ul>
<p>Because he was invited by the wolf, the rabbit decided to go the party. 因为兔子被狼邀请了，所以兔子决定去参加聚会。</p>
<p>学过非谓语动词后，这个句子就可以改写成：</p>
<p><em>Invited</em> by the wolf, the rabbit decided to go to the party. （本句不包含独立主格结构）</p>
<p>invited 是过去分词，因为句子的主语是 the rabbit，它跟 invite 这个动作之间是一种被动的关系，所以使用过去分词 invited。</p>
<p>相比较上一个句孀，省略掉了 because he was 这一部分，却同样达到了表原因这一目的，从而使这个句子达到了简化的效果。再看：</p>
<p>Because the wolf invited him, the rabbit decided to go to the party. 因为狼邀请了兔子，所以兔子决定去参加聚会了。</p>
<p>后面的主句中 the rabbit，前面的原因状语从句中他是 the wolf。那怎么简化呢？是直接去掉 because 及后面的部分吗？又因为 wolf 邀请 rabbit，所以 wolf 不能省略：</p>
<p>The wolf invited him, the rabbit decided to go to the party.</p>
<p>但这样还是有问题。这样一来，逗号连接了前后两个意义完整的句子。而一个句子只能有一个谓语动词。所以前面 wolf 那里就不能用谓语动词了，得用非谓语动词。而这里 wolf 是邀请者，是主动而不是被动，所以就要用现在分词了。那再改一下：</p>
<p>The wolf inviting him, the rabbit decided to go to the party.</p>
<p>这就是独立主格结构的真面目。这个句子的主干是 the rabbit decided to go to the party，而前面 the wolf inviting him 中，invite 这个动作是由 the wolf 发出的，而不是真正的主语 the rabbit 发出的动作。所以语法上把 the wolf 称为动词 invite 的逻辑主语，而这就是“独立主格”中的“主格”。</p>
<p>那独立又如何理解呢？因为 the wolf 是游离真正主语 the rabbit 之外的，在 the wolf inviting him 中“自立门户”，“独立”了出来。不过这个独立的主语还是不能跟真正的主语相提并论，要不怎么说是“独立主格”，而不是“独立主语”呢？ * 独立主格结构对从句的简化 If the weather permits, the rabbit will go out. 如果天气允许，兔子就会出门。</p>
<p>这里是 if 引导的条件状语从句，因为从句中的 the weather 和主句中的 the rabbit 明显不同，那就使用独立主格来表达：</p>
<p>The weather permitting, the rabbit will go out. 如果天气允许，兔子就会出门　</p>
<p>继续看：</p>
<p>After the work was finished, the rabbit went home. 工作完成后，兔子回家了。</p>
<p>after 引导的是时间状语从句，从句中的主语 the work，与主句中的主句 the rabbit 显然也不一样，看看独立主格是怎么表达的：</p>
<p>The work finished, the rabbit went home.</p>
<p>再看一个：</p>
<p>The rabbit is lying in bed and a carrot is still held in his hand. 兔子正躺在床上，胡萝卜仍在他手中。</p>
<p>这是一个 and 引导的并列句，这两个句子两个主语，动作同时发生，相当于伴随的状况。看看独立主格是怎么表达的：</p>
<p>The rabbit is lying in bed, a carrot still held in his hand.</p>
<p>前面说了那么多，实际上只是独立主格的两种形式，“名词/代词 + 现在分词”，如：the wolf inviting him，“名词/代词 + 过分分词”，如：a carrot held in the hand。其实独立主格还有很多副面孔，看下面的例子：</p>
<p>The <em>rabbit</em> <em>to come</em>, the wolf is overjoyed. 兔子要来，狼乐翻天。</p>
<p>这是“名词/代词 + 动词不定式”，动词不定式一般表将要发生的动作。还有：</p>
<p>Many animals went to the party, <em>some</em> of them <em>rabbits and wolves</em>. 许多动物去了聚会，它们中的一些是兔子和狼。</p>
<p>这是“名词/代词 + 名词”。</p>
<p>Many animals went to party, <em>some</em> of them <em>happy</em>. 许多动物去了聚会，它们中的一些很开心。</p>
<p>这是“名词/代词 + 形容词”。再看：</p>
<p>The rabbit sat on a chair, <em>head</em> <em>down</em>. 兔子做在一张椅子上，头垂着。</p>
<p>这是“名词/代词 + 副词“。还有：</p>
<p>The rabbit came in, <em>carrot</em> <em>in hand</em>. 兔子近来了，手里拿着胡萝卜。</p>
<p>这是“名词/代词 + 介词短语“。</p>
<p>实际上它们更像是：包含 be 动词的独立主格——也就是”名词/代词 + be 动作的现在分词（being）“，然后再把 being 省略掉，比如：</p>
<p>Many animals went to the party, some of them +being+ rabbits and wolves.</p>
<p>Many animals went to party, some of them +being+ happy.</p>
<p>The rabbit sat on a chair, head +being+ down.</p>
<p>The rabbit came in, carrot +being+ in hand. * 总结 在学习独立主格的主要形式时，其实还是不能脱离非谓语动词这一概念， 过去分词表示逻辑主语和动作是一种被动、完成的关系；现在分词表示逻辑主语和动作是一种主动、进行的关系；动词不定式表示逻辑主语将要发生的动作。而其他的形式，更像是省略了现在分词 being 的一种简化形式。</p>
<p>你可能经常会见到”with + 宾语 + 宾语补语“这样的复合结构，其实这个 with 结构就是一个很重要的独立主格结构。</p>
<p>The work finished, the rabbit went home.</p>
<p>-&gt; <em>With</em> the work finished, the rabbit went home.</p>
<p>也就说，这个例子里，with 是可以省略掉的，兀他部分不变。但是通常英语独立主格省略 with 后，甚至也会进一步简化句子结构，比如：</p>
<p>The rabbit came in, with <em>a</em> carrot in <em>his</em> hand. 兔子进来了，手里拿着一根胡萝卜。</p>
<p>-&gt; The rabbit came in, carrot in hand.</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[倒装句]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e5%80%92%e8%a3%85%e5%8f%a5.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e5%80%92%e8%a3%85%e5%8f%a5.html</guid>
    <description><![CDATA[<p>#+TITLE: 倒装句 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>倒装句 所谓倒装句，就是为了强调某些信息而颠倒了原有语序的句式。比如：</li>
</ul>
<p>你 <em>吃</em> 胡萝卜了吗？</p>
<p>这个问题强调的是“吃”（或者“胡萝卜”），而：</p>
<p>吃胡萝卜了吗，你？</p>
<p>强调的是“你”。</p>
<p>汉语的倒装句多用于口语表达，而英语则常见于书面用语。</p>
<p>英语的语序是主语谓语，主语在谓语动词的前面。所以，倒装，通常就要把谓语动词提前。 * 完全倒装（谓语动词完全在主语前） 完全倒装的结构是谓语部分完全放在主语之前。佀不是什么句子都能“倒着说”。 ** 副词/介词短语在句首的倒装 - 地点副词在句首的倒装</p>
<p>以 here，there 为代表。</p>
<p><em>There</em> goes the last bus. 末班公共汽车开走了。</p>
<p>虽然正常语序是”The last bus goes.“。但是为了强调开走了，出现了地点副词 there，可以把地点副词置于句首。</p>
<ul>
<li><p>时间副词在句首的倒装</p>
<p>以 now、then 为代表，比如：</p>
<p>Now comes the wolf’s turn! 现在轮到大灰狼了。</p></li>
<li><p>表运动方向的副词在句首的倒装</p>
<p>有些副词表示动作的运动方式，如 in、out、up、down、away 等，把它们出现在句首时，句子要用完全倒装。</p>
<p>这种完全倒装句，可以使动作显得更加生动，容易让读者有一种画面感，比如：</p>
<p>Up went the carrots into air. 胡萝卜飞向空中。</p></li>
<li><p>介词短语在句首的倒装</p>
<p>At the table sat a rabbit. 桌边上坐着一只兔子。 ** 主语补语（表语）的倒装 主语补语，或者说表语，就是当我们使用系动词时，对主语进行补充说明的成分。比如：“A is B.”，A就是主语，B就是主语补语（表语）。</p></li>
</ul>
<p>英语中为了保持句子平衡或者强调表语部分，讲做表语的形容词、分词、介词短语、such 置于句首时，需要完全倒装。比如：</p>
<p>Seated on the grould is a group of rabbits. 席地而坐的是一群兔子们。</p>
<p>Such were the wolf’s tricks. 这就是大灰狼的把戏。 * 部分倒装（仅有助动词提前） 部分倒装的形式主要是讲助动词和谓语动词分离，助动词提前。这类句型主要有下面几种。 ** 句首有否定意义词时的倒装 Never before have I eaten such a delicious carrot. 我以前从未吃过如此美味的胡萝卜。</p>
<p>其实这个句子相当于：</p>
<p>I have never eaten such a delicious carrot. 我以前从未吃过如此美味的胡萝卜。</p>
<p>have eaten 里面，只有助动词 have 提到了主语之前。 ** 句首有“only”时的倒装 Only in this way <em>can</em> we grow delicious carrots. 只有用这种饭伽梵我们才能种出美味的胡萝卜。</p>
<p>情态动词 can 提到主语前面形成部分倒装。</p>
<p>Only then <em>did</em> the rabbit meet the wolf. 直到那时，兔子才遇见了狼。</p>
<p>同样，助动词 did 提到主语前形成部分倒装。 ** “if…should..”构成虚拟语气的倒装 If I should win the lottery, I would buy a huge pile of carrots. 如果我能赢得大奖，我就会买一大堆胡萝卜。</p>
<p>这是一个正常语序的虚拟语气，如果把 if 去掉，那条件句就要进行部分倒装， 所以就成了</p>
<p>Should I win the lottery, I would buy a huge pile of carrots. ** 固定句型中的倒装 Rabbits love eating carrots; so do wolves. 兔子喜欢吃胡萝卜，狼也是。</p>
<p>I was afraid. So was I. (= I was afraid, too.)</p>
<p>The rabbit can’t ride a bicycle; neither/nor can the wolf. 兔子不会骑自行车，狼也不会。 * 形式倒装（谓语动词不提前） 仅将强调内容提至句首；谓语动词不提前。 ** 感叹句中的倒装 What a delicious carrot it is! 多么美味的一根胡萝卜！ ** 比较级句型种的倒装（如“the more…, the more…”） The more carrots you eat, the healthier you become. 吃胡萝卜越多，你就越健康。</p>
<p>这句话其实相当于：</p>
<p>If you eat more carrots, you will become healthier. 如果你多吃些胡萝卜，你就会更健康。 ** “however”;“whatever”…引导让步状语从句时的倒装 However long this video is, you should watch it till the end. 不论这个视频多场，你都应该看完。 ** “as”;“thought”…引导让步状语从句时的倒装 Much as he likes the carrots, he doesn’t want to eat it. 尽管他非常喜欢胡萝卜，但他不想吃它。</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[非谓语动词详解]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e9%9d%9e%e8%b0%93%e8%af%ad%e5%8a%a8%e8%af%8d%e8%af%a6%e8%a7%a3.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e9%9d%9e%e8%b0%93%e8%af%ad%e5%8a%a8%e8%af%8d%e8%af%a6%e8%a7%a3.html</guid>
    <description><![CDATA[<p>#+TITLE: 非谓语动词详解 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>非谓语动词基础概念 ** 限定性动词 #+begin_example The rabbit <em>eats</em> a carrot. The rabbit <em>ate</em> a carrot. The rabbit <em>is eating</em> a carrot. The rabbit <em>has eaten</em> a carrot. #+end_example</li>
</ul>
<p>这些句子中，谓语动词 eat 受到了主语限制，出现了时间、状态和语气的变化，实际上是一种被限定了的动词。 所以谓语动词有另一个名字：限定性动词。</p>
<p>比如以上第一句中的 eats，已经被限定为之前的第三人称单数所用。 ** 非限定性动词 与之相对的，就是不受主语限制，不被限定的动词；而这样的动词也失去了表达时间和人称的本领。自然的，这样的动词就是“非限定性动词”。它的另一个名字，就是“非谓语动词”。</p>
<p>#+begin_example I like to eat carrots. I liked eating carrots. I am a talking rabbit. The rabbit likes minced carrots. #+end_example</p>
<p>上面句子中，like、like、am、likes 受主语限制，展现出时间、状态和语气变化本领，它们就是句中的谓语动词。而 to eat、eating、talking、minced 这些词却不受主语限制，不具备表达时间和人称的本领，是“非限定性动词”，也就是非谓语动词。</p>
<p>如果要用一句话总结谓语动词和非谓语动词的区别，那就是：谓语动词是句子的核心，而非谓语动词只可能出现在剩下的非核心部分中。</p>
<p>这也解释了为什么两个简单句不能仅仅用逗号连接：</p>
<p>+I <em>am</em> a rabbit, I <em>eat</em> carrots.+</p>
<p>这里出现了两个谓语动词，而一个简单句只能有一个谓语动词。所以要么把上句改写成并列句，用连接相连，这样我们至少知道有两个并列的句子，分别对应连个谓语动词。</p>
<p>I am a rabbit, so I eat carrots.</p>
<p>要么把它变成为一个从句，一个主句：</p>
<p>Because I am a rabbit, I eat carrots. * 动词不定式 首先来说非谓语动词中的“动词不定式”。</p>
<p>通常＀不定式的形式为：“to + 动词原形”。但有的时候 to 也会 shenglve，比如：</p>
<p>完全不定式：To be or not to be, that is the question.</p>
<p>裸不定式：You <em>helped</em> me (to) <em>cook</em> the carrot. 你帮我烧（做菜）了胡萝卜。</p>
<p>有的语法体系里会称第一种咱们常见的不定式为“完全不定式”，full infinitive，而称后一种为“裸不定式”，bare infinitive。</p>
<p><em>非谓语动词可以充当句子的主语、宾诀、宾语补语、主语补语（表语）、定语、状语等。再进一步说，一个动词，作为谓语动词，只能在句中充当核心的谓语动词，而不能充当其他句子成分。如果想要充当其他句子成分，必须把这个动词转换为非谓语动词，也就是不定式、过去分词、现在分词、动名词其中之一。</em></p>
<p>接下来具体看看不定式这个非谓语动词，怎么充当句子的，除谓语动词以外的其他成分。 ** 不定式作一语 <em>To eat</em> a carrot every day is good for the rabbit. 一天吃一根胡萝卜对兔子有好处。</p>
<p>很明显，在这里 to eat 是动词不定式，在句子中充当主语。这个不定式表示的意思是“一天吃一根胡萝卜”这个行为。那么，是谁一天吃一根胡萝卜，具体在过去吃还是讲来吃？光看到 to eat，咱们还不确定，所以才是“不定式”。这个不定式，或者说行为，不受具体的人和时间限制，就是单纯在说 一天吃一根胡萝卜“这个概念。</p>
<p>在英文表达中，常常借助 it 来替代主语，即所谓的形式注意，而把 to eat a carrot every day 放到谓语动词之后就是：</p>
<p>It is good for the rabbit to eat a carrot every day.</p>
<p>这种固定句型为 It is + 形容词 + for sb. + to do sth.，其实这个句型的核心是动词不定式，作主语时为避免”头重脚轻“的情况，借助 it 充当形式主语放在句首。这句话也相当于之前讲的带彀式主语的主语从句：</p>
<p><em>It</em> is good <em>that the rabbit eats a carrot every day</em>. ** 不定式作宾语 The rabbit likes to eat carrots. 兔子喜欢吃胡萝卜。</p>
<p>to eat 在这里就做了谓语动词 like 的宾语。但是，有的动词后面是不能接不定式做宾语的。 *** it 做形式宾语 I consider the rabbit smart. 我觉得这兔子是聪明的。</p>
<p>如果把这句话中的宾语改成形式宾语，就是：</p>
<p>I consider <em>it</em> import <em>to eat a carrot every day</em>. 我发现每天吃一个胡萝卜很重要。 ** 不定式做宾语补语 宾语补语加到宾语之后，对宾语起到补充说明作用</p>
<ol type="1">
<li><p>不定式可以和复杂及物动词一起使用</p>
<p>The rabbit expected the wolf <em>to eat a carrot</em>. 兔子指望狼吃一根胡萝卜。</p>
<p>to eat a carrot 是补充说明狼的动作，或者说兔子希望狼发出的动作。</p></li>
<li><p>有些谓语动词（如 see、find、watch 及 have、make、let 这类”使役“动词） 后面用不定式作宾语补语需要省略 to，也就是之前提到的裸不定式</p>
<p>Carrots make the rabbit feel happy. 胡萝卜使兔子感觉快乐。</p></li>
<li><p>还有谓语动词后接不定式作宾补时，省不省去 to 区别不大，都是正确的表达</p>
<p>The wolf helped the rabbit grow carrots.</p>
<p>The wolf helped the rabbit to grow carrots.</p>
<p>狼帮兔子种胡萝卜。</p></li>
</ol>
<p>再看以下句子：</p>
<p>The rabbit’s dream is <em>to eat</em> every kind of carrot in the world. 兔子的梦想就是吃掉世界上每一种胡萝卜。</p>
<p>is 在此相当于一个”=“，相当于把”兔子的梦想“与”去吃世界上每一根胡萝卜“联系起来。</p>
<p>The rabbit’s dream = to eat every kind of carrot in the world</p>
<p>这句话也相当于之前讲到的不定式做主语：</p>
<p><em>To eat</em> every kind of carrot in the world is the rabbit’s dream. 兔子的梦想就是吃掉世界上每一种胡萝卜。 ** 不定式作定语 The rabbit has a lot of carrots <em>to eat</em>. 兔子有很多胡萝卜要吃。</p>
<p>不定式 to eat 作后置定语修饰 carrots，表示这些胡萝卜是会被吃的，也就说它们之间是一种动宾关系。 ** 不定式作状语 不定式通过作状语来表达原因、目的和结果： *** 表原因 I was surprised <em>to get a thumbs-up</em>. 我很吃惊（因为）得到一个赞。</p>
<p>这句话相当于之前讲的原因状语从句：</p>
<p>I was surprised because I got a thumbs-ups. 我很吃惊，因为有人给我点赞了。 *** 表目的 I will do anything <em>to get a thumbs-up</em>. 我为了得到一个赞会做任何事。</p>
<p>这句话相当于之前讲的目的状语从句：</p>
<p>I will do anything in order that I get a thumbs-up. 为了点赞量我能作出任何事。 *** 表结果 I got enough thumbs-up <em>to make another video</em>. 我得到足够的赞，可以去做另一个视频。</p>
<p>这句话相当于之前讲的结果状语从句：</p>
<p>I got enought thumbs-up, so that I made another video. 我得到了很多点赞，于是我做了另一个视频。</p>
<p>所以像不定式这样的非谓语动词还有简化从句的功效。 ** 高级不定式 以上是最基础的不定式用法，更高级一点的用法，是把不定式和状态相结果，如：</p>
<p>#+begin_example “to be eating a carrot” “to have eaten a carrot” “to have been eating a carrot” #+end_example</p>
<p>虽然看上去似乎有点吓人，其实只不过是把简单的，”to + 动词原形“，中的动词原形增加了状态，后接助动词的原形，这里表达了状态，但实际还是”不受时间限制的“，比如：</p>
<p>The rabbit seemed to be eating a carrot. 这兔子之前似乎在吃一根胡萝卜（的过程中）。</p>
<p>The rabbit will appear to have eaten a carrot. 这兔子之后会看起来像是吃过了一根胡萝卜。 * 动名词 下面来讲非谓语动词中的动名词。你应该已经注意到了”动名词“中的”名词“了吧？其实这个名称本身就诠释了自己。在动词原形后加 ing，就能把动词转换为名词来用。也就说动名词的本质相当于名词。 ** 动名词作主语 Carrots are healthy for the rabbit. 胡萝卜对兔子来说很健康。</p>
<p>其中，carrots 是名词，做主语。如果用动名词（词组）来替换 carrots，可以这样说：</p>
<p><em>Eating carrots</em> is healthy for the rabbit.</p>
<p>Eating carrots 尀是个动名词短语，成功地把动词 eat 转成了名词的性质，表达了吃胡萝卜这个行为，相当于名词在句中作主语。 ** 动名词作主语补语（表语） The rabbit’s hobby is growing carrot. 兔子的爱好是种胡萝卜。</p>
<p>很显然，这里 the rabbit’s hobby 是主语，is 是系动词，动名词短语 growing carrots 是主语补语（表语）。</p>
<p>甚至有时候句中的主语和主语补语（表语）都可以是动名词，比如英语谚语：</p>
<p><em>Seeing</em> is <em>believing</em>. 眼见为实。 ** 动名词作定语 a <em>sleeping</em> pill</p>
<p>sleeping 作定语，说明药片 pill 的用途，是为了睡眠用的，也就是 for sleeping。</p>
<p>请注意，这里的 sleeping 是当名词用，意思可不是 pill 在睡觉。 ** 动名词作宾语 不定式作宾语：The rabbit likes <em>to eat</em> carrot.</p>
<p>动名词作宾语：The rabbit likes <em>eating</em> carrot.</p>
<p>有的动词后面是不可以用不定式的，比如我们不可以说：</p>
<p>+The rabbit enjoys to eat carrots.+</p>
<p>而必须说：</p>
<p>The rabbit enojys eating carrots.</p>
<p>这样的动词还有 avoid、advise、consider、escape、mind、practice 等，动词词组有 insist on、give up、feel like、put off 等。 ** 介词+宾语 另外，宾语除了在动词之后出现，也会在介词之后出现。既然是宾语，就不能直接用动词，而是要先把动词改成非谓语动词种的动名词。</p>
<p>The rabbit <em>is found of eating</em> carrots. 兔子喜欢吃胡萝卜。</p>
<p>有时候，也许会遇到 to 作介词的词组，这个时候千万不要把它当成动词不定式的 to，比如：</p>
<p>The rabbit is <em>looking forward to</em> seeing the wolf again. 兔子期望在此见到狼。</p>
<p>这里要特别注意，look forward to 是个动词短语，其中的 to 是个介词，后面跟动名词充当宾语。 ** 不定式作宾语与动名词作宾语的区别 The rabbit <em>stopped to eat</em> a carrot. 兔子停下（手里的活）去吃一根胡萝卜。</p>
<p>stop to do 表示停下（手中的事情），去做另一个件事。</p>
<p>The rabbit <em>stopped eating</em> a carrot. 兔子停止吃一根胡萝卜。</p>
<p>stop doing 表示停止正在做的事。</p>
<p>The wolf <em>forgot to invite</em> the rabbit to her party. 狼忘记邀请兔子去她的聚会。</p>
<p>The rabbit <em>forgot accepting</em> the wolf’s invitation. 兔子忘记接受过狼的邀请。</p>
<p>forget 后加动词不定式（即 forget to do）表示忘记去做……，表明事情还没有做。</p>
<p>forget 后加动名词（即 forget doing）表示忘记做过……，表明事情已经做过了。 * 现在分词 现在进行时 = be + 现在分词</p>
<p>由于现在分词一开始是在现在进行时中出现的，所以很多人有种误解，认为现在分词”顾名思义“就自带”现在时间“的属性。</p>
<p>这是一个非常大的误区，不能因为这个语法术语中有“现在 就认为它自带时间。非谓语动词（非限定性动词）恰恰是没有时间变化的，比如：</p>
<p>a talking rabbit 一只说话的兔子</p>
<p>我们基于 talking 只能判断出这只兔子是会说话的，但是这只兔子到底是过去在说话，还是将来在说话，则不得而知。所以说，现在分词不一定自带”现在“的属性。</p>
<p>现在分词基本上相当于一个形容词。那么，形容词在句中可以充当的成分，现在分词当然也可什。a talking rabbit 中的 talking 就是定语。</p>
<p>但是有个问题，之前说动名词时说过，动名词也可以做定语。可以，现在分词和动名词长得一模一样，到底怎么判断谁是谁呢？比如，我们看到一个句话或者一个短语中出现 sleeping，它到底是之前说的动名词呢，还是现在分词？前面我们说过：</p>
<p>a <em>sleeping</em> pill 一片安眠药</p>
<p>这里的 sleeping 是动名词，用来说明药片的性能、功能和用途。相当于：</p>
<p>a pill for <em>sleeping</em></p>
<p>但是再看一个例子：</p>
<p>a <em>sleeping</em> rabbit 一只沉睡的兔子</p>
<p>a sleeping rabbit 并不是 a rabbit for sleeping。这里的 sleeping 表示的是一只”在睡觉“的兔子，可不是个名词。它是个现在分词，相当于一个形容词，用来修饰兔子的状态，”在睡觉“。但是，像开头说的，我们只知道兔子的状态是在睡觉，至于他是昨天在睡觉还是明天在睡觉，并没有明确指出。 ** 现在分词作表语 形容词可以做表语（主语补语），比如：</p>
<p>The rabbit is <em>smart</em>.</p>
<p>可以把这里的形容词改成一个现在分词：</p>
<p>The rabbit is <em>charming</em>.</p>
<p>很多我们平时挂在嘴边的，用来形容人和物的词，其实都是现在分词，比如：</p>
<p>#+begin_example The story is <em>interesting</em>. 故事是有趣的。 THe game is <em>exciting</em>. 游戏是刺激的。 The news is <em>encouraging</em>. 新闻是鼓舞人心的。 #+end_example</p>
<p>我们平时都把 interesting 翻译成有趣的。但它实际上是从动词 interest 变过来的现在分词。现在分词相当于把动词转成了形容词。 ** 现在分词作宾语补语 The wolf saw the rabbit <em>eating</em> a carrot. 狼之前看到兔子正在吃一根胡萝卜。</p>
<p>现在分词 eating 作了宾语 rabbit 的宾语补语，表示”兔子在吃胡萝卜“。</p>
<p>之前讨论动词不定式的时候，提到迀不定式作宾语补语的用法，如：</p>
<p>The wolf saw the rabbit eat carrot. 狼之前看到兔子吃了根胡萝卜。</p>
<p>那两者有什么区别呢？动词不定式作宾语补语时，表示一个动作自始至终的过程，强调动作已经发生了。现在分词作宾语补语时，表示动作正在进行中，强调动作进行的状态。 ** 现在分词作状语 现在分词还可以作状语，表示时间、原因、条件、结果、让步、目的、方式和伴随情况等。</p>
<p><em>Hearing</em> the news, the rabbit became excited. 听到这个消息，兔子很激动。</p>
<p>Hearing the news 表示时间，其他它相当于一个时间状语从句：</p>
<p>When he heard the news, the rabbit became excited. 听到这个消息时，兔子很激动。</p>
<p><em>Not knowing</em> what to eat, the rabbit skipped lunch. 不知道吃什么，兔子没吃中饭。</p>
<p>Not knowing 表示原因，其他它相当于一个原因状语从句：</p>
<p>Because he didn’t know what to eat, the rabbit skipped lunch.</p>
<p>非谓语动词在很大程度上简化从句，使得句子言简意赅。 * 过去分词 根据之前的经验，不要再陷入”过去分词“表示过去的时间这一误区中了，过去分词是非谓语动词，它不能自带时间，不能表示过去的时间。</p>
<p>The rabbit will eat <em>minced carrot</em> next week. 兔子下周会吃绞碎的胡萝卜。</p>
<p>不能理解为”兔子下周要吃过去绞的胡萝卜“。minced 是不自带时间概念的，而只表示被绞的这个状态。</p>
<p>#+begin_example minced meat minced carrot #+end_example</p>
<p>在 minced meat 和 minced carrot 中，minced 作定语，可以把这个过去分词看做形容词。</p>
<p>通常的形容词，比如 big、small、smart 都是加在名词前的，单个的过去分词也是一样：</p>
<p>#+begin_example a big carrot 一根大胡萝卜 a small room 一个小房间 a smart rabbit 一只总名的兔子</p>
<p>a minced carrot 一根绞碎的胀萝卜 a painted room 一个漆过了的房间 an excited rabbit 一只激动的兔子 #+end_example</p>
<p>但是过去分词短语做定语，则要放到被修饰的名字之后，即很多语法书里说的”后置定语“，比如：</p>
<p>The carrot cake <em>eaten</em> by the rabbit is delicious. 被兔子吃了的胡萝卜蛋糕很美味。 ** 过去分词作主语补语（表语） 和现在分词一样，过去分词也可以充当主语补语（表语）。</p>
<p>The rabbit is <em>interested</em> in growing carrots. 兔子对种胡萝卜感兴趣。</p>
<p>这里的 interested 就是一个过去分词，表示”对…感兴趣的“。</p>
<p>没错，平时挂在嘴边的”sb. is interested in doing sth.“就是一个有着过去分词的主系表结构。</p>
<p>之前讲现在分词时，说到过现在分词也可以做主语补语（表语），比如：</p>
<p>主动：The story is <em>interesting</em>. 故事很有兴趣。</p>
<p>而刚刚说了，过去分词也可以做表语：</p>
<p>被动：The rabbit is <em>interested</em>. 兔子很有兴趣。</p>
<p>现在分词暗含主动关系，即被描述的是做出动作的人/物，the story is intersting 暗含的意义是故事让人感到有兴趣。而过去分词暗含被动关系，即被描述的是动作的接受者，the rabbit is interested 暗含的意义是，兔子被某事某物引起了兴趣。</p>
<p>The rabbit was frightened. 兔子感到害怕。</p>
<p>The rabbit was frightening. 兔子令人感到害怕。</p>
<p>兔子感到害怕，说明是被动的，被某事吓倒了，所以要用过去分词。如果真的是说兔子主动去吓人，才用现在分词，表示”令人害怕的“。</p>
<p>所以说，千万不要笼统的认为， +”过去分词修饰人，现在分词修饰物“+ 。你要搞清楚表达的意思是主动还是被动。</p>
<p>I am intersted 是被动，表示我被某人/某物引起了兴趣。而 I am interesting 是主动，表示我引起了某人的兴趣。 ** 过去分词作宾语补语 复杂及物动词后跟宾语和宾语补语，而这个宾语补语也可以由过去分词充当。比如：</p>
<p>The rabbit found his carrot <em>stolen</em>. 兔子发现他的胡萝卜被偷了。 ** 过去分词作状语 过去分词也可以作状语，这点跟现在分词有几分相似。</p>
<p>表地点： <em>Seen</em> from the hill, the <em>carrot field</em> looks beautiful. 从山上看，胡萝卜田看上去很美。</p>
<p>主语 carrot filed 是 seen 的逻辑主语，它什之间是一种被动的关系，所以使用过去分词。</p>
<p>表原因： <em>Born</em> in a rabbit family, the rabbit’s only work is growing carrots. 由于出生在一个兔子家庭里，兔子的唯一工作就是种胡萝卜。</p>
<p>表条件： <em>Given</em> another chance, the rabbit would go to the wolf’s party. 如果再给 兔子一次机会，他会去参加狼的聚会。</p>
<p>以上这些用法也容易和现在分词混淆。其实要弄清到底是该用过去分词还是现在分词，还是看句子中到底是主动的含义，还是被动的含义。</p>
<p>+Seeing from the hill, the carrot field looks beautiful.+</p>
<p>Seen from the hill, the carrot field looks beautiful.</p>
<p>这里的胡萝卜田是被看，所以是 seen from the hill，从山上被看。</p>
<p>如果是一只兔子主动去看什么东西，那才说：</p>
<p>Seeing the carrot field, the rabbit ran towards it. 看到胡萝卜田，兔子朝着它跑去。</p>
<p>这里是兔子主动看到了胡萀卜田，所以才用 seeing。</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Ebuild-defined Variables]]></title>
    <link>https://www.codeplayer.org/Wiki/Gentoo/Ebuild/Ebuild-defined%20Variables.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Gentoo/Ebuild/Ebuild-defined%20Variables.html</guid>
    <description><![CDATA[<p>#+TITLE: Ebuild-defined Variables #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>Ebuild-defined Variables The following variables may or must be defined by every ebuild.</li>
</ul>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>Variable</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EAPI</td>
<td>The EAPI. See EAPI Usage and Description.</td>
</tr>
<tr class="even">
<td>DESCRIPTION</td>
<td>A short (not more than 80 characters) description of the package’s purpose. Mandatory.</td>
</tr>
<tr class="odd">
<td>HOMEPAGE</td>
<td>Package’s homepage(s). Mandatory (except for virtuals), accepts multiple values. In some contexts, it is customary to provide package tracker and/or code hosting links besides the main homepage (e.g. PyPI link for Python packages, GitHub link when code can’t easily be found on homepage) for convenience. If no homepage for the package is available, please set it to https://wiki.gentoo.org/wiki/No_homepage. Never refer to a variable name in the string; include only raw text.</td>
</tr>
<tr class="even">
<td>SRC_URI</td>
<td>A list of source URIs for the package. Can contain USE-conditional parts, see SRC_URI.</td>
</tr>
<tr class="odd">
<td>LICENSE</td>
<td>The package’s license, corresponding exactly (including case) to a file in licenses/. Mandatory (except for virtuals). See LICENSE.</td>
</tr>
<tr class="even">
<td>SLOT</td>
<td>The package’s SLOT. Mandatory. See SLOT.</td>
</tr>
<tr class="odd">
<td>KEYWORDS</td>
<td>See KEYWORDS and Keywording and Stabilization.</td>
</tr>
<tr class="even">
<td>IUSE</td>
<td>A list of all USE flags (excluding arch flags, but including USE_EXPAND flags) used within the ebuild. See IUSE.</td>
</tr>
<tr class="odd">
<td>REQUIRED_USE</td>
<td>A list of assertions that must be met by the configuration of USE flags to be valid for this ebuild. See REQUIRED_USE.</td>
</tr>
<tr class="even">
<td>PROPERTIES</td>
<td>A space-delimited list of properties, with conditional syntax support. interactive is the only valid value for now.</td>
</tr>
<tr class="odd">
<td>RESTRICT</td>
<td>A space-delimited list of portage features to restrict. Valid values are fetch, mirror, strip, test and userpriv. See man 5 ebuild for details.</td>
</tr>
<tr class="even">
<td>DEPEND</td>
<td>A list of the package’s build dependencies. See Dependencies. Starting with EAPI-7, applies to CHOST only.</td>
</tr>
<tr class="odd">
<td>BDEPEND</td>
<td>(EAPI=7) A list of the package’s CBUILD build dependencies. See Dependencies.</td>
</tr>
<tr class="even">
<td>RDEPEND</td>
<td>A list of the package’s runtime dependencies. See Dependencies.</td>
</tr>
<tr class="odd">
<td>PDEPEND</td>
<td>A list of packages to be installed (if possible) after the package is merged. Use this only when RDEPEND would cause cyclic dependencies. See Dependencies.</td>
</tr>
<tr class="even">
<td>S</td>
<td>Path to the temporary build directory, used by src_compile and src_install. Default: “=<span class="math inline"><em>W</em><em>O</em><em>R</em><em>K</em><em>D</em><em>I</em><em>R</em>/</span>{P}=”. Ebuilds should not provide a value for this variable if it is the same as the default value.</td>
</tr>
<tr class="odd">
<td>DOCS</td>
<td>An array or whitespace-separated list of documentation files for the default src_install function to install using dodoc. If undefined, a reasonable default list is used. See the default src_install function.</td>
</tr>
<tr class="even">
<td>HTML_DOCS</td>
<td>An array or space-delimited list of documentation files or directories for the einstalldocs function to install recursively. (Requires EAPI&gt;=6.)</td>
</tr>
</tbody>
</table>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[英语从句]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e8%8b%b1%e8%af%ad%e4%bb%8e%e5%8f%a5.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e8%8b%b1%e8%af%ad%e4%bb%8e%e5%8f%a5.html</guid>
    <description><![CDATA[<p>#+TITLE: 英语从句 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>英语从句的原理 一个句子 A 可以成为一个整句的某种句子成分——你可以理解为——A 成了整句其余部分 B 的附属，服“从”B，同时也不能独立成句了；而 B 就成为了 A 的“主”人。这就是英语从句的原理。A就是所谓“从句”，B就是所谓“主句”。它们合在一起是一句“复杂句“。</li>
</ul>
<p>[[file:../../pics/English/从句.png]] ** 英语的三种句子 1. 简单句 Simple Sentences 不能再拆 2. 复合句 Compound Sentences 不分主次 3. 复杂句 Complex Sentences 主句 + 从句 * 英语从句的分类 一个从句可以充当句子成分，所以只要把所有句子成分列出来，咱们就知道有哪些从句了。一句话有可能有的句子成分为：主语、宾语、间接宾语、直接宾语、（宾语）补语、（主语）补语（表语）、定语、状语、同位语，除了其中最特殊的句子成分，谓语动词之外，每种句子成分祈使都可以由从句充当。</p>
<p>** 句子成分/句型 #+begin_example 主语+动词 主语从句 主语+动词+宾语 宾语从句 主语+动词+间接宾语+直接宾语 主语+动词+宾语+（宾语）补语 宾语补语从句 主语+动词+（主语）+补语（表语） 主语补语（表语）从句 定语、状语、同位语 定语从句、状语从句、同位语从句 #+end_example ** 词类 #+begin_example 动词 数词 名词 副词 代词 介词 冠词 叹词 形容词 连词 #+end_example *** 名词从句 #+begin_example 主语从句 宾语从句 主语补语（表语）从句 宾语补语从句 同位语从句 #+end_example *** 形容词从句 #+begin_example 定语从句 #+end_example *** 副词从句 #+begin_example 状语从句 - 时间状语从句 - 地点状语从句 - 条件、原因、方式、比较……状语从句 #+end_example * 形容词从句 ** 形容词从句的思维方式 在中文里，无论定语是单个形容词也好，又或是一句话充当的，都是放在被修饰的名词/代词之前：</p>
<p>#+begin_example <em>好吃的</em> 胡萝卜 <em>我买来的</em> 胡萝卜 <em>我昨夀在菜市场向刚从地里回来的乌龟那儿买来的</em> 胡萝卜 #+end_example</p>
<p>中文构成定语基本上就是“ <em>形容词/句子 + 的</em> ”。</p>
<p>但是，英语就不一样了。虽然单个形容词（或者多个形容词，或副词加形容词）作定语也是放在被修饰词之前，如：</p>
<p><em>a tasty</em> carrot <em>一根好吃的</em> 胡萝卜</p>
<p>但是如果定语要用一句话来描述时，就无法使用中文里“ <em>形容词/句子 + 的</em> ”的结构来实现了。</p>
<p>在英语里，一根 <em>我买来的</em> 胡萝卜要说成： a carrot <em>that I bought</em></p>
<p>这样的英语定语的思维方式，可以理解为：在被修饰的词之后，添加另一个和它有关系的词，然后再把这个新词放在另一个句子中进行补充说明/逻辑阐述。语法上，这个新词叫”关系词“，它之前的被修饰的词叫”先行词“；这里的”另一个句子“就是”定语从句/形容词从句“；而因为其中包含关系词的缘故，这样的从句也被成为”关系从句“。</p>
<p>[[file:../../pics/English/英语定语从句的思维方式.png]] *** 快速总结：中英思维方式不同 中文思维：</p>
<p>这兔子在吃一根我买来的胡萝卜</p>
<p>英文思维：</p>
<p>这兔子在吃一根 <em>胡萝卜</em> （[ <em>胡萝卜的关系词</em> ]我买）。</p>
<p>The rabbit is eating a <em>carrot</em> ([ <em>that</em> ] I bought).</p>
<p>再具体一点，中文句子的定语都是”前置“的：</p>
<p>#+begin_example 一根 <em>好吃的</em> 胡萝卜 一根 <em>兔子吃了的</em> 胡萝卜 一个 <em>是兔子的</em> 老师 一个 <em>我昨天看见的</em> 老师 <em>兔子吃胡萝卜的</em> 地方 <em>兔子吃胡萝卜的</em> 原因 #+end_example</p>
<p>而对应的英语是：</p>
<p>#+begin_example a <em>tasty</em> carrot a carrot <em>that the rabbit ate</em> a teacher <em>who is a rabbit</em> a teacher <em>whom I saw yeasterday</em> the place <em>where the rabbit ate the carrot</em> the reason <em>why the rabbit ate the carrot</em> #+end_example</p>
<p>从句做定语都是”后置“的。 ** 形容词从句的构成 *** 关系词 **** 关系代词 ***** 关系代词引导的形容词从句 #+begin_example The rabbit is eating a carrot <em><em>that</em> I bought</em>. The teacher <em><em>who</em> ate a carrot</em> is a rabbit. The teacher <em><em>whom</em> I saw yesterday</em> is a rabbit. The teacher <em><em>whose</em> favorite food is carrot</em> is a rabbit. The food <em><em>which</em> the teacher likes</em> a carrot. #+end_example</p>
<p>这些从句中，除去关系代词在开头作引导词，其他词的语序与对应的陈述的语序是一致的。 ****** 陈述句 #+begin_example I bought <em>the carrot</em> <em>the rabbit</em> ate a carrot I saw <em>the teacher</em> yesterday <em>the teacher’s</em> favorite food is carrot the teacher likes <em>the food</em> #+end_example ****** -&gt; 陈述句语序，含关系代词 先把对应的陈述句中需要替代的词变做相应的关系代词：</p>
<p>#+begin_example I bought <em>that</em> <em>who</em> ate a carrot I saw <em>whom</em> yesterday <em>whose</em> favorite food is carrot the teacher likes <em>which</em> #+end_example ****** -&gt; 从句 再把关系代词移到开头，就构成了从句</p>
<p>#+begin_example <em>that</em> I bought <em>who</em> ate a carrot <em>whom</em> I saw yesterday <em>whose</em> favorite food is carrot <em>which</em> the teacher likes #+end_example ***** that vs. which 刚才最后一个例句里的关系代词是 which，它代表之前的词 food，这里其实也可以用 that：</p>
<p>#+begin_example The rabbit is eating a carrot <em>that I bought</em>. The teacher who ate a carrot is a rabbit. The teacher whom I saw yesterday is a rabbit. The teacher whose favorite food is carrot is a rabbit. The food <em>which the teacher likes</em> a carrot. The food <em>that the teacher likes</em> a carrot. #+end_example</p>
<p>也就是说，关系代词 that 和 which 经常可以互换。</p>
<p>****** 先行词是 <em>唯一</em> 的：that 先行词明确、唯一，没有其他可能时，就要用 that。</p>
<p>#+begin_example The rabbit ate <em>the largest</em> carrot that I’ve ever seen. <em>all</em> the rabbit that ate a carrot <em>the only</em> rabbit that ate a carrot <em>the first</em> rabbit that ate a carrot #+end_example ****** 先行词是 <em>多选一</em> 的：which 而如果很多个同类事物中按限定条件选择，则不一定用 that，也可以用 which。</p>
<p>#+begin_example The rabbit ate a carrot <em>which</em> I bought. The rabbit ate a carrot <em>that</em> I bought. #+end_example</p>
<p>可提问：Which one are you talking about?</p>
<p>连提问都不用就知道的对象，就只能用 that，而如果还可以问 which one are talking about?那么就可以用 which 或者 that。 **** 关系副词 ***** 关系副词引导的形容词从句 #+begin_example This was the <em>place <em>where</em></em> the rabbit ate the carrot. This is the <em>reason <em>why</em></em> the rabbit ate the carrot. That was the <em>day <em>when</em></em> the rabbit ate the carrot for the first time. #+end_example</p>
<p>也可以把这些关系副词转为关系代词：</p>
<p>#+begin_example This was the <em>place <em>at which</em></em> the rabbit ate the carrot. This is the <em>reason <em>for which</em></em> the rabbit ate the carrot. That was the <em>day <em>on which</em></em> the rabbit ate the carrot for the first time. #+end_example</p>
<p>关系副词 = 介词 + which ** 形容词从句的限定性和非限定性 *** 限定性形容词从句 形容词从句/定语从句的主要功能即：限定范围。比如：</p>
<p>The rabbit ate the carrot <em>which was on the table</em>. 限定 carrot 的范围/性质 *** 非限定性形容词从句 就是没有限定作用的从句</p>
<p>The rabbit ate the carrot, <em>which</em> was on the table.</p>
<p>The rabbit ate the carrot, <em>the carrot</em> was on the table.</p>
<p>这样的从句没有限定作用，只不过是用了个代词”接着说话“而已。其实就是一前一后表达了两个信息：兔子吃胡萝卜和胡萝卜（再被吃之前）在桌上。言下之意是，完全可能只有一根胡萝卜，然后补充信息是，这根胡萝卜恰巧在桌上而已。 *** 限定性 vs. 非限定性 I have a head which is round.</p>
<p>I have a head, which is round.</p>
<p>第一句的言下之意是我有好几个头，其中一个是圆，其他的它头可能是方的扁的。第二叀就比较清楚，我有一个头，而我这个头是圆的。 *** 非限定性形容词从句作插入语 正因为非限定性形容从句的这种”非限定性的“，”接着补充“（而非限定）的特性，所以往往用来做句子的插入语，比如：</p>
<p>My head, <em>which is big</em>, is useful when it rains. 我有大头，下雨不愁。</p>
<p>The biggest carrot, <em>which the rabbit ate</em>, was on the table. 最大的那根胡萝卜曾在桌上，兔子吃了它。</p>
<p>这两个做插入语的形容词从句，都可以直接去掉都不影响句意。而且正因为只是补充信息用，所以前面加 the biggest 这样，”确定唯一“的限定词一点问题都没有。 *** 非限定性形容词从句指代整句话 非限定性形容词从句不一定是补充某个先行词，而是可以指代整句话，比如：</p>
<p><em>The rabbit ate the carrot</em>, <em>which</em> was not surprising. <em>兔子吃了胡萝卜</em> ， <em>这事儿</em> 不令人吃惊。 * 名词从句 ** 主语从句 *** 主语从句的原理 <em>The fact</em> is obvious. <em>这事实</em> 是明显的。</p>
<p>在这个简单句中，主语是名词 fact，把主语 fact（以及之前的定冠词 the）换成一个从句，就得到了一个作主语的从句，即主语从句，如：</p>
<p>That the rabbit ate a carrot. 就是引导词 that 引导的主语从句。</p>
<p>-&gt; <em>That</em> the rabbit ate a carrot is obvious. 兔子吃了胡萝卜，这是明显的。</p>
<p>我们已经知道 that 经常充当从句的引导词。再具体一点，这个引导词 that 在这里，是个“从属连词”。它也是一个信号，表示接下来从句开始了。</p>
<p>说白了，主语从句就是句子主语由从句充当。而其他成分，该怎么来就怎么来。</p>
<p>再看 That the rabbit ate a carrot is obvious 这句话，这个主语从句表达了一个很确定的信息，即“兔子吃了胡萝卜”。但其实不确定的信息也可以构成主语从句。</p>
<p>**** 确定信息 兔子吃了胡萝卜</p>
<p><em>That</em> the rabbit ate the carrot. **** 不确定信息 以下这些都可以当主语</p>
<p>#+begin_example 兔子 <em>是否</em> 吃了胡萝卜 兔子 <em>哪里</em> 吃的胡萝卜 兔子 <em>什么时候</em> 吃的胡萝卜 兔子 <em>怎样</em> 吃地胡萝卜 <em>谁</em> 吃了胡萝卜 兔子吃的 <em>什么</em> #+end_example</p>
<p>-&gt;</p>
<p>#+begin_example 兔子 <em>是否</em> 吃了胡萝卜 <em>是明显的</em> 兔子 <em>哪里</em> 吃的胡萝卜 <em>是明显的</em> 兔子 <em>什么时候</em> 吃的胡萝卜 <em>是明显的</em> 兔子 <em>怎样</em> 吃地胡萝卜 <em>是明显的</em> <em>谁</em> 吃了胡萝卜 <em>是明显的</em> 兔子吃的 <em>什么</em> <em>是明显的</em> #+end_example</p>
<p>-&gt; 其对应英语为：</p>
<p>#+begin_example <em>Whether</em> the rabbit ate the carrot <em>is obvious</em>. <em>Where</em> the rabbit ate the carrot <em>is obvious</em>. <em>When</em> the rabbit ate the carrot <em>is obvious</em>. <em>How</em> the rabbit ate the carrot <em>is obvious</em>. <em>Who</em> ate the carrot <em>is obvious</em>. <em>What</em> the rabbit ate <em>is obvious</em>. #+end_example</p>
<p>这几句中英翻译的最大区别是，主语从句是要以引导词开头的——这些引导词都是像 what、where、when 这样的代词/副词——它们如果出现在问句中，被叫做”疑问代词/疑问副词“；这里用来引导从句，也就是作从句的”引导词“，局于”连接代词/连接副词“。而从句去除引导词，剩下的词序和中文基本是一致的。 *** 形式主语 <em>That the hungry rabbit had already eaten a carrot for dinner this evening</em> is obvious.</p>
<p>-&gt; <em>It</em> is obvious <em>that the hungry rabbit had already eaten a carrot for dinner this evening</em>.</p>
<p>这里的 it 不是平时指代物体的代词”它“，而是指代后面的从句，本身没有实际意义，所以被成为”形式主语“——它代血的是之后的真正的主语，也就是之后的主语从句。也就是说，放在句子后面的从句才是真正的主语。</p>
<p>这样的形式主语 it 开头的句子构成很简单，就是用 it 把整句话用之前的语序说完，然后紧接着加上从句就可以了。</p>
<p>我们可以把几句话改写成带有形式主语的句子：</p>
<p>#+begin_example <em>That the rabbit ate a carrot</em> is a secret. <em>That the rabbit ate a carrot</em> was discussed. <em>That the rabbit ate a carrot</em> happed. #+end_example</p>
<p>-&gt;</p>
<p>#+begin_example It is a secret <em>that the rabbit ate a carrot</em>. It was discussed <em>that the rabbit ate a carrot</em>. It happened <em>that the rabbit ate a carrot</em>. #+end_example</p>
<p>同理，我们也可以把”不确定信息“的句子改写以下：</p>
<p>#+begin_example <em>Whether the rabbit ate the carrot</em> is obvious. <em>Where the rabbit ate the carrot</em> is obvious. <em>When the rabbit ate the carrot</em> is obvious. <em>How the rabbit ate the carrot</em> is obvious. <em>Who ate the carrot</em> is obvious. <em>What the rabbit ate</em> is obvious. #+end_example</p>
<p>-&gt;</p>
<p>#+begin_example It is obvious <em>whether the rabbit ate the carrot</em>. It is obvious <em>where the rabbit ate the carrot</em>. It is obvious <em>when the rabbit ate the carrot</em>. It is obvious <em>how the rabbit ate the carrot</em>. It is obvious <em>who ate the carrot</em>. It is obvious <em>what the rabbit ate</em>. #+end_example</p>
<p>在“It is + 形容词 + that“相似的结构中，一但谓语动词是 suggest、demand、insist、order……这样的词，从句中的动词就要使用动词的虚拟语气。</p>
<p>It is <em>suggested/demanded/insisted/ordered</em> <em>that you (should) eat a carrot</em>.</p>
<p>这几个动词被动态也可以换成某些形容词，照样使用动词虚拟语气，比如：</p>
<p>It is <em>important/essential/necessary</em> <em>that you (should) eat a carrot</em>. ** 宾语从句 宾语从句其实就是从句在整个复杂句中做宾语而已。这样的从句有可能包含确定信息，也可能包含不确定信息 *** 确定信息&amp;不确定信息 **** 确定信息作宾语从句 I saw <em>that the rabbit ate a carrot</em>. 我看见 <em>这兔子吃了根胡萝卜</em> **** 不确定信息作宾语从句 不确定的信息也可以作从句，充当句子的宾语，如：</p>
<p>#+begin_example I saw <em>whether</em> the rabbit ate the carrot. I saw <em>who</em> ate the carrot. I saw <em>what</em> the rabbit ate. I saw <em>where</em> the rabbit ate the carrot. I saw <em>when</em> the rabbit ate the carrot. I saw <em>how</em> the rabbit ate the carrot. #+end_example</p>
<p>有两点需要注意：1.除了某些介词参与的情况，从句的引导词基本都在从句的开头，而其他的词遵照正常的陈述语序，基本也和中文一致。2.千万不要看到 whether、where、when、how 这样的词就以为看到了包含疑问代词/疑问副词的问句， 于是圀之后错误地加上了助动词。以下句子是错误的：</p>
<p>#+begin_example You told me whether +does+ the rabbit eat the carrot. You told me where +does+ the rabbit eat the carrot. You told me when +does+ the rabbit eat the carrot. You told me how +does+ the rabbit eat the carrot. #+end_example *** 引导词 that 的省略 在口语或非正式书面语中，宾语从句的引导词 that 往往可以省略，比如：</p>
<p>I know <em>(that)</em> the rabbit ate a carrot.</p>
<p>也可以说 I konw the rabbit ate a carrot.</p>
<p>不过只有引导词 that 可以省略，而引导词 what、who、which、when、where、how 等，则不可以省略。</p>
<p>#+begin_example I saw <em>whether</em> the rabbit ate the carrot. I saw <em>who</em> ate the carrot. I saw <em>what</em> the rabbit ate. I saw <em>where</em> the rabbit ate the carrot. I saw <em>when</em> the rabbit ate the carrot. I saw <em>how</em> the rabbit ate the carrot. #+end_example **** 不可省略引导词 that 也有的时候引导词 that 不能省略，否则句子有歧义或语法错误，比如：</p>
<p>I didn’t know <em>that the rabbit ate the carrot</em> and <em>that you saw it</em>.</p>
<p>这句话实际是两个宾语，分别是两个宾语从句。意思是：1.我不知道兔子吃了胡萝卜，2.我不知道你看见了。第一个 that 去掉还好，但如果第二个 that 也去掉，那就可以这么断句：</p>
<p><em>I didn’t know the rabbit ate the carrot</em> and <em>you saw it</em>.</p>
<p>再比如插入语：</p>
<p>I know, just like you do, <em>that</em> the rabbit ate the carrot.</p>
<p>-&gt; I know, just like you do, the rabbit ate the carrot.</p>
<p>如果去掉 that，会让人一下子反应不过来后面是个从句，从而认为这句话有语病。 *** 某些词后的宾语从句的否定 表达某种意见时，经常会用到宾语从句，如：</p>
<p>I think <em>(that) the rabbit is smart</em>. 我认为这兔子很聪明。</p>
<p>在做否定时，否定往往是加在谓语动词前＀而不是在从句里，也就是：</p>
<p>I <em>don’t</em> think (that) the rabbit is smart.</p>
<p>而不是：</p>
<p>+I think (that) the rabbit <em>isn’t</em> smart.+ *** 主从时态一致 在大多数情况下，宾语从句和主句中的时态要保持一致，比如：</p>
<p>现在：I <em>don’t</em> think (that) you <em>are</em> right.</p>
<p>过去：I <em>didn’t</em> think (that) you <em>were</em> right.</p>
<p>再比如：</p>
<p>I <em>knew</em> (that) the rabbit <em>liked</em> carrots.</p>
<p>虽然 like 是一个”习惯性“的动作/行为，但是因为它所在的从句紧跟了过去时间的主句，所以也要用动词过去式 liked 而不是 like。</p>
<p>只有“不变”的客观现在才是例外，如：</p>
<p>I <em>knew</em> (that) the sun <em>rises</em> in the east.</p>
<p>如果用了 rise 的过去式 rose 反而很奇怪：</p>
<p>I <em>knew</em> (that) the sun +rose+ in the east.</p>
<p>这句话似乎在暗示，太阳过去从东边升级，可是之后就不一定了。 *** be + 形容词 + that… be + 形容词 + that 这种句型很常见，但是很有“归类争议”。比如：</p>
<p>#+begin_example I <em>am sure that</em> there’s a carrot on the table. I <em>am happy that</em> there’s a carrot on the table. I <em>am afraid that</em> there’s no carrot on the table. #+end_example</p>
<p>只所以说这样的句型归类有争议，是因为它往往被不同的老师/学者归类为：1.宾语从句，2.同位语从句，3.状语从句。</p>
<p>把这样的句子归类为宾语从句的理由是：其中的形容词通常都是表达某种看法/判断，而 that 引导的从句相当于看法/判断，尤其是在中文表达中，这样的用法，和动作后加承受者很相似。</p>
<p>这个句型还没有一个定论，但是这里稍稍偏向于宾语从句的归类。 ** 主语补语/表语从句 表语从句就是用一个从句充当系动词之后的那个表语。</p>
<p>*** 系动词：be 动词 表语从句中最常见的系动词就是 be 动词。</p>
<p>而表语从句的引导词，和之前一样，也有多种可能，比如：</p>
<p>#+begin_example The problem is <em>that</em> the rabbit is hungry. The reason is <em>that</em> there’s no more carrot. The question is <em>whether</em> the rabbit is hungry. The question is <em>what</em> the rabbit should eat. The question is <em>where/when/how</em> the rabbit should eat the carrot. #+end_example</p>
<p>和之前我们见过的从句一样，引导词开头，之后的语序和陈述句基本一致。</p>
<p>表语从句（主语补语从句）往往就是把之前讲到的主语从句，移到系动词之后去而已，比如之前的：</p>
<p>主语从句： <em>That the rabbit ate a carrot</em> is a <em>secret</em>.</p>
<p>-&gt; 表语从句： <em>The </em>secret* is <em>that the rabbit ate a carrot</em>.</p>
<p>这两句话意思大致相同，但是还是有些微妙区别的，主要体现在要强调的信息。 *** 系动词：非 be 动词 系动词不一定是 be 劀词，也有可能是 feel、seem、look、taste……这样的系动词。所以也能看到这样的表语从句：</p>
<p>It <em>seems</em> that the rabbit is hungry.</p>
<p>It <em>feels</em> that you’re not telling the truth.</p>
<p>这些句子中的 it 并不是某个物体“它”，而是个“形式主语”，没有实际意义。句子真正要表达的意思其实全部被涵盖在了后面的从句中。而后面的从句，在语法上来说，是的的确确的表语成分，所以是表语从句。 ** 同位语从句 所谓“同位语”，其实就是用不同的方式把一个概念再说一遍，用逗号隔开，比如：</p>
<p>My teacher, Papa Rabbit, likes carrots. 我的老师，兔老爹，喜欢胡萝卜。</p>
<p>Papa Rabbit 在这里是主语 teacher 的同位语。同样的道理：</p>
<p>I like my teacher, Papa Rabbit. 我喜欢我的老师，兔老爹。</p>
<p>这句话中，Papa Rabbit 是宾语 teacher 的同位语。</p>
<p>我们当然可以把同位语这个概念引申到从句，也就是， 当一个从句来充当同位语时，那么这个从句就是同位语从句。这样的从句常在句中修饰抽象的名词——因为抽象，所以才要“另一种方式来再说一遍”，比如：</p>
<p>The <em>fact</em> <em>that the rabbit ate the carrot</em> did not surprise me. <em>兔子吃了胡萝卜</em> 这个 <em>事实</em> 并没有让我吃惊。</p>
<p>这里的 The fact 和 that the rabbit ate the carrot 是同一个概念，一前一后用两种方开说出来而已——后者显然就是个由 that 这个引导词引导的同位语从句。注意这里因为有了引导词，很容易看出从句从哪里开始，所以也就不需要逗号隔开了。</p>
<p>刚才的同位语从句包含了已知信息。同位语从句当然也可以包含未知信息，比如：</p>
<p>The <em>question</em> <em>whether the rabbit will eat the carrot</em> is on all our minds. 兔子 <em>是否会吃胡萝卜</em> 这个问题萦绕在我们所有人心中。</p>
<p>这里的 whether the rabbit will eat the carrot 也是个同位语从句，把主语 question 又说了一遍。</p>
<p>I have no idea <em>who ate the carrot</em>. 我不知道 <em>谁吃了那胡萝卜</em> 。</p>
<p>其中，idea 是宾语，所以之后的 who ate the carrot，其实只是把这里的 idea 重新定义了一番，还是个同位语从句，是句中宾语 idea 的同位语。 ** 宾语补语从句 宾语补语从句，对应句型“主语+动词+宾语+（宾语）补语”，以及对应需要宾语补语的动词，比如 call、make、consider……等等。</p>
<p>You can call <em>me</em> <em>Papa Rabbit</em>. 你可以叫我兔老爹。</p>
<p>这句话中的 me，是复杂及物动词 call 的宾语，而 Papa Rabbit 就是宾语补语，对宾语 me 的补充。我们只要将 Papa Rabbit 这个充当宾语补语的专有名词，用从句替换，就能得到一个作宾语补语的从句，即宾语补语从句：</p>
<p>You can call <em>me</em> <em>what you like</em>. 你可以叫我你想叫我的（称号）。（你可以随便叫我什么。）</p>
<p>这里的 what you like 就是一个宾语补语从句。</p>
<p>My education made <em>me</em> <em>who I am today</em>. 我的教育造就了我今天是的（这个人）。（我的教育成就了今天的我。）</p>
<p>其中 who I am today 也是一个宾语补语从句。</p>
<p>另外，虽然把宾语补语从句放在“名词从句”里，但是宾语补语从句不见得一定有名词性质，也有可能是形容词的性质，但是如果把它放到形容词从句，也有点奇怪。 * 副词从句 副词从句在句中起到副词的作用，一般补充说明动词、形容词、副词等。从句子成分上说，它充当了句子的状语，所以副词从句也叫“状语从句”——两者是一回事。副词从句与之前两大类从句（即名词从句和形容词从句）相比，种类很多，因为“作状语”在句子中补充信息，有多种可能。</p>
<p>可以根据用途/意义技副词从句分类：</p>
<ol type="1">
<li>表时间 （如：在…前）</li>
<li>表地点 （如：在…地方）</li>
<li>表条件 （如：如果…）</li>
<li>表让步 （如：虽然…但是）</li>
<li>表方式 （如：就好像…）</li>
<li>表比较 （如：比…）</li>
<li>表原因 （如：因为…所以…）</li>
<li>表目的 （如：为了…）</li>
<li>表结果 （如：所以…） ** 时间副词从句 *** 在某一时间点之前 从句引导词：before，如：</li>
</ol>
<p>The rabbit ate a carrot at home <em>before</em> the wolf stopped by. 大灰狼串门 <em>之前</em> ，兔子吃了根胡萝卜。</p>
<p>这里，主句在从句之前。也可以把从句提前，写成：</p>
<p><em>Before</em> the wolf stopped by, the rabbit ate a carrot at home.</p>
<p>但是如果从句在主句之前，则要在从句后加上逗号，便于断句。 *** 在某一时间点之中（当时） 从句引导词：when、while、as，如：</p>
<p>The rabbit wa eating a carrot <em>when</em> I reached home. 我到家 <em>的时候</em> ，兔子在吃胡萝卜。</p>
<p>The rabbit wa eating a carrot <em>while</em> I making a video. 我做视频的 <em>过程中</em> ，兔子在吃胡萝卜。</p>
<p>I ate a carrot <em>as</em> I made the video. 我 <em>一边</em> 吃胡萝卜 <em>一边</em> 做视频。 **** 三者的不同点 1. When：时间点，“突然”</p>
<p>when 一般强调表示在某个时间点，如“当我回到家的那个时候”。实际上 when 有“突然”之意：</p>
<p>The rabbit was eating a carrot at home <em>when</em> the wolf stopped by. 兔子在家吃胡萝卜 <em>的时候（突然）</em> 大灰狼来串门了。</p>
<p>The rabbit was about to eat a carrot at home <em>when</em> the wolf stopped by. 兔子在家刚要吃胡萝卜 <em>的时候（突然）</em> 大灰狼来串门了。</p>
<ol start="2" type="1">
<li><p>While：时间段</p>
<p>While 一般强调一个时间段内，如“当我在做视频的这个时间段之内”。</p>
<p>The rabbit was eating a carrot <em>while</em> I was making a video. 我做视频的 <em>过程中</em> ，兔子在吃胡萝卜。</p></li>
<li><p>As：同时</p>
<p>As 一般强调同时进行两个动作，如“同时吃胡萝卜和做视频”。</p>
<p>I ate a carrot <em>as</em> I made the video. 我 <em>一边</em> 吃胡萝卜 <em>一边</em> 做视频。 *** 在某一时间点之后 从句引导词：after，如：</p></li>
</ol>
<p>The rabbit ate a carrot <em>after</em> the wolf stopped by 大灰狼串门 <em>之后</em> ，兔子吃了根胡萝卜。 *** 从之前某一个时间点开始酸 从句引导词：since。注意这里是从某时间点算起的时间段，往往暗示了对之后有影响。而我们在之前的时态文章里提到过，这样的情况下，一般要使用完成状态，比如：</p>
<p>The rabbit has shared three carrots <em>since</em> the wolf stopped by. <em>自从</em> 大灰狼来串门，兔子已经分享了三根胡萝卜了。</p>
<p>The rabbit has not stoped sharing carrots <em>since</em> the wolf stopped by. <em>自从</em> 大灰狼来串门，兔子就一直在分享胡萝卜。 *** 直到之后某一时间点 从句引导词：until。这个有点像 since 的对立面，即从某一时间点算起，直到之后的某一时间点。</p>
<p>The rabbit waited <em>until</em> the wolf stopped by. 兔子一直在等， <em>直到</em> 大灰狼来串门。</p>
<p>The rabbit did <em>not</em> eat any carrot <em>until</em> the wolf stopped by. 兔子 <em>直到</em> 大灰狼来串门 <em>才</em> 吃了胡萝卜。 *** 一…就… 从句引导词：as soon as，相当于一个动作紧跟着另一个动作发生。</p>
<p>The rabbit will eat a carrot <em>as soon as</em> the wolf leaves. 大灰狼 <em>一</em> 离开兔子 <em>就</em> 要吃一个胡萝卜。 *** 下次… 从句引导词：the next time。</p>
<p>The rabbit will share the biggest carrot <em>the next time</em> the wolf stops by. <em>下次</em> 大灰狼来串门，兔子会一起分享最大的胡萝卜。 ** 地点副词从句 引导词：where + “强调形式”（wherever、everywhere、anywhere）</p>
<p>主要引导词就是 where 以及它的“强调形式”，来表达“地点”，如：</p>
<p>The rabbit ate the carrot <em>where he found it</em>. 兔子在找到胡萝卜的地方吃了它。</p>
<p>光看见引导词 where，还不能确定该从句是哪种从句，得分别对待。</p>
<p>引导地点副词（状语）从句： The rabbit ate the carrot <em>where</em> he found it.</p>
<p>引导定语（形容词）从句： The rabbit ate the carrot at the place <em>where</em> he found it.</p>
<p>引导表语（主语补语）从句： This is <em>where</em> he found the carrot.</p>
<p>引导主语从句： <em>Where</em> he found the carrot is a sercet.</p>
<p>在开始提到 where 的强调形式，它有点近似于中文的“不管哪里、任何地方、所有地方”。这样的引导词包括 wherever、everywhere、anywhere，比如：</p>
<p>The rabbit will go <em>where</em> he can find a carrot.</p>
<p>The rabbit will go <em>wherever</em> he can find a carrot.</p>
<p>这两句很相似，只不过 wherever 强调了不管哪里，只要能发现胡萝卜，这兔子就会去。</p>
<p>The rabbit sees a carrot <em>everywhere</em> he goes.</p>
<p>The rabbit can eat a carrot <em>anywhere</em> he likes.</p>
<p>这两句的区别在于，前者强调“所有”地方，后者强调“任何”某一处地方。可以把他们理解为“等效、相应”的定语从句：</p>
<p>The rabbit sees a carrot <em>at every place where</em> he goes.</p>
<p>The rabbit can eat a carrot <em>at any place where</em> he likes. ** 比较副词从句 *** 英语形容词：比较极 #+begin_example smart, smarter big, bigger beautiful, more beautiful #+end_example</p>
<p>#+begin_example He is smarter than me. This carrot is bigger than that one. She is as beautiful as Snow White. #+end_example</p>
<p>以上这些常见的句子都可以算是省略句，或者口语化用法。它们完整的，正式的形式都是副词（状语）从句中的比较副词（状语）从句。 *** 比较副词从句：“更…” #+begin_example He is smarter <em>than me</em> He is smarter <em>than I am</em></p>
<p>This carrot is bigger <em>than that one</em>. This carrot is bigger <em>than that one is</em>.</p>
<p>She is more beautiful <em>than Snow White</em>. She is more beautiful <em>than Snow White is</em>. #+end_example</p>
<p>其中，than I am，than that one is，than Snow White is 实际上都是副词从句，用“比较”的方式对前面的主句进行补充说明。 *** 比较副词从句：“同样得…” 比较也不定非要“更”怎么样，也可能“同样得”怎样，如：</p>
<p>#+begin_example He is as smart as I am. This carrot is as big as that one is. She is as beautiful as Snow WHite is. #+end_example</p>
<p>以上也可以省略/口语化为：</p>
<p>#+begin_example He is as smart as me. This carrot is as big as that one. She is as beautiful as Snow WHite. #+end_example *** 毀较副词从句：“越…越…” 还有一种常见的比较副词从句是“the（比较极）, the（比较极）”的形式，比如：</p>
<p><em>The more</em> you practice English, <em>the more fluent</em> you become. 你 <em>越多</em> 练习英语， 你就 <em>越流利</em> 。 ** 条件副词从句 条件副词从句其实就是通常说的“条件句”，如：</p>
<p><em>If the rabbit sees a carrot</em>, he will eat it.</p>
<p>这个条件只是单纯的假设，属于“真实条件叀”。</p>
<p>而在虚拟语气中，有“虚拟条件句”，即和事实相反的假设，如：</p>
<p>If I <em>saw</em> a carrot, I <em>would eat</em> it.</p>
<p>If I <em>had seen</em> a carrot, I <em>would have eaten</em> it.</p>
<p>就是使用了动词虚拟语气的条件副词从句。 *** 国内说法：主将从现 “主将从现”就是主句用将来时态，而从句用现在时态，比如：</p>
<p>If the rabbit sees carrot, he will eat it.</p>
<p>这句话等于 The rabbit will eat the carrot if the rabbit sees it .</p>
<p>两句中，if 引导了从句，使用的是一般现在时态；之后是主句，用一般将来时态。 *** 然而… <em>If</em> I see a carrot…</p>
<p>英语的“将来”时态指的是非常确定会发生的事。</p>
<p>I will eat a carrot. 是我确定我将来会吃根胡萝卜。</p>
<p>问题是这么做的条件我不确定是否会形成。所以条件只能用一般状态，If I see a carrot，而不是 If I will see carrot.</p>
<p>我不确定我是否一定会看见一只胡萝卜，所以条件句中，只能“去掉时间信息”，表达一个“一般的、默认的、普通”的状态，使用一般现在时态，而不是用明确的会发生的“一般将来时态”。</p>
<p>但是，如果这个假设的条件成立，在这种情况下，我一定会明确地做“吃胡萝卜”这个动作，所以主句，也就是在这种条件成立的情况下，使用一般将来时态，表示明确在将来会发生的事。 *** 规律 进一步从规律上来说，条件句总是比主句在时态上落后一个时间段。这也可以用于虚拟语气：</p>
<p>If I saw a carrot , I wouild eat it.</p>
<p>If I had seen a carrot, I would have eaten it.</p>
<p>至于为什么虚拟语气的条件句有过去式或者过去分词，是因为虚拟语气条件句中的 saw 并不是在表达时间，而是表达与现实相反的条件。 *** 其他引导词 除了 if 可以引导条件从句，还有 unless，其实就是把 if 反着说。</p>
<p>If you like this video, you will give it a thumbs-up. 如果你喜欢这个视频，你会给它点赞。</p>
<p>-&gt; Unless you like this video, you will not give it a thumbs-up. 除非你喜欢这个视频，否则你不会给它点赞。</p>
<p>除了 if 和 unless 这两种最主要的，还有其他一些词/词组可以构成条件副词从句，比如 provided、as long as、in case：</p>
<p><em>Provided</em> that my video is excellent, you will give it a thumbs-up. 如果我的视频很棒＀你会给他点赞。</p>
<p><em>As long as</em> I make excellent videos, you will remain my follower. 只要我一致做高质量视频，你就会继续关注我。</p>
<p><em>In case</em> you don’t understand, please comment below. 如果你不明白，请在下方评论。 ** 让步副词从句 和条件副词从句有些相通的地方，都是阐述某种情况或做出某种假设，但接下来会更近一步做出一个“相反/相对”的阐述，最常见的就是“即是…也…”，所以才有“让步”这一说。</p>
<p>让步副词从句： <em>Event</em> if I see a carrot, I will not eat it. <em>即使</em> 我看到了一根胡萝卜，我也不会吃它。</p>
<p>条件副词从句： If I saw a carrot, I would eat it. 如果我看到了一根胡萝卜，我就会吃掉它。</p>
<p>“让步”的情况也不一定是假设，而可能就是事实，比如：</p>
<p><em>Although</em> I see a carrot, I will not eat it. <em>尽管</em> 我看见了一根胡萝卜，但我不会吃它。</p>
<p>引导词 although 也可以用 though 或 event though 来替代。</p>
<p>注意，虽然中文说”尽管/虽然…但是…“，英文可不能说”although/though/even though…but…“。因为 although 引导了从句，和主句构成了复杂句，但如果又用连词 but 就又构成了一个复合句。又用 although 又用 but，就混了复杂句和复合句，让人分辨不清。</p>
<p>还有一个很重要的让步副词从句用法是，”no matter + 疑问词“的形式。刚才的让步都是具体情况，而这里的让步是”未知情况“，但依旧“不管如何”…。</p>
<p>No matter what happens, I will not eat the carrot. 不管什么事会发生，我都不会吃这胡萝卜。</p>
<p>No matter who orders me, I will not eat the carrot. 不管谁命令我，我都不会吃这个胡萝卜。</p>
<p>No matter how hungry I am, I will not eat the carrot. 不管我有多饿，我都不会吃这个胡萝卜。</p>
<p>no matter 也可以用 regardless of 来取代。 ** 方式副词从句 最常见的是两种“方式”：</p>
<p>好像某事 <em>发生过</em> 的方式</p>
<p>好像某事 <em>正在发生</em> 的方式</p>
<p>方式副词从句： I feel good as if I just ate a carrot. 我感觉良好，就 <em>好像</em> 我刚吃了根胡萝卜一样。</p>
<p>这里的“好像”其实就是在做一个与现实相反的假设。和虚拟语气很像。</p>
<p>如果是虚拟语气的条件副词从句，可能会说：</p>
<p>条件副词从句（虚拟语气）： If I had eaten a carrot, I would feel good. <em>如果我刚才吃了</em> 根胡萝卜的话，我现在就会感觉良好。</p>
<p>在方式副词从句中，主句直接就交代了某种情况，然后用从句交代一个与事实相反的假设。但是不管怎么样，那种情况已经发生了——在这里，I feel good 是确认情况；而在虚拟语气中，因为假设的条件并非事实，所以 I feel good 也并不是确认的情况。</p>
<p>You spend (so much) money as if you were a millionaire.</p>
<p>一上来就交代了你花（很多）钱，然后再说这种情况（你花钱的效果），就和一个虚拟的与事实相反的假设的情况下一样（就好像你是百万富翁，但你并不是）。</p>
<p>If you were a millionaire, you would spend a lot of money.</p>
<p>再比较这句虚拟语气。意思是，如果你是百万富翁（但你并不是），你会把很多钱。言下之意是，因为你有钱是假想，所以你并不会花很多钱　</p>
<p>刚才的方式是假想，接下来不用假想，比如：</p>
<p>Eat the carrot as I do. <em>像我</em> 一样吃胡萝卜。</p>
<p>Leave the carrot as it is. 别动这胡萝卜。 -&gt; <em>像这</em> 胡萝卜原本那样，别碰它。</p>
<p>这样的方式副词从句中，虽然也描述了某种情况，但是并不是假设，而是某种事实的阐述。可以把它理解为“正在”发生的某种方式。</p>
<p>其实可以把之前的几个方式副词从句，真的用包含了“方式”这个词的形容词从句来表达，如：</p>
<p>You spend money the way (in which) millionaire do.</p>
<p>Eat the carrot the way (in which) I eat it.</p>
<p>所以，要表达一个意思往往可以使用不同类型的从句。只不过有些听上去更常用、更自然、更简洁。 ** 原因副词从句 最后三种副词从句，原因副词从句、目的副词从句、结果副词从句，都有相通之处。它们的共同点在于都 ishi“表达了某种因果”，即 A 导致 B 这样的情况。</p>
<p>先说原因副词从句，比如：</p>
<p>The rabbit ate the carrot <em>beacuse he was hungry</em>. 兔子吃了胡萝卜， <em>因为它饿了</em> 。</p>
<p>这里的 beacuse he was hungry 就是个原因副词从句。不过也要注意，中文说“因为…所以”，但英语却不能说：</p>
<p>Because the rabbit was hungry, +so+ he ate the carrot.</p>
<p>这和之前为什么不能用"although…but…“一个道理。because 引导从句，所以主句前什么也不用加，构成了一个复杂句。而 so 是一个用来搞偶成复合句的连词。如果 beacuse 和 so 都用，就分不清到底是复杂句还是复合句了。</p>
<p>除了 beacuse 这个引导词构成原因副词从句，还能用 since 和 as。 *** since <em>Since</em> you are hungry, you can eat the carrot. 既然你饿了，你可以吃这胡萝卜。</p>
<p>注意这里的 since 不是时间副词从句那个”从某个时间点开始“的意思，而是介绍某个原因。 *** as <em>As</em> you were not here, we ate the carrot without you. 因为你之前不在这，所以吃胡萝卜没带你。</p>
<p>这里的 as 也和之前说的方式副词从句中的”像…一样“有区别。这里也是表原因。 *** because/since/as 的区别 有两大区别：第一，从因果或说语气的程度上说，because &gt; since &gt; as。Because 引出的是实实在在的因果关系，since 引出的是大家都已经知道的情况，as 引出的是显而易见的事实。</p>
<p>Because：Beacuse this video is excellent, you should give it a thumbs-up. 因为这视频很棒，所以要点赞。</p>
<p>Since：Since all my videos are excellent, you should give this video a thumbs-up. 众所周知，我的视频都很棒，所以要点赞。</p>
<p>As：As I have thick skin, I’m begging you for a thumbs-up. 显而易见我脸皮很厚，所以求你点赞。</p>
<p>第二，就是语序的区别。Beacuse 引导的从句在主句前后都可以，而 Since 和 as 引导的从句一般只能放在主句之前。 *** because vs for 其实 for 这个词也可以表示一定的因果关系，比如：</p>
<p>You must really like me, <em>for</em> you have given all my videos a thumbs-up. 你肯定很喜欢我，因为你给我所有视频都点赞了。</p>
<p>但是，请特别注意，for 构成的不是原因状语从句。for 在这里构成复合句，而不是复杂句。</p>
<p>也就说”for you have given all my videos a thumbs-up.“可不是从句。”You must really like me”和"you have given all my videos a thumbs-up“是有着同等地方的句子，前者是个推测，而后者补充了推测的原因。</p>
<p>仔细体会以下两句的区别：</p>
<p>Because you like me, you have given all my videos a thumbs-up. 因为你喜欢我，所以你给所有英语兔视频都点赞了。</p>
<p>原因：你喜欢我（because you like me），结果：你给我的所有视频都点赞了（you have given all my videos a thumbs-up）。</p>
<p>You must really like me, for you have given all my videos a thumbs-up. 你一定喜欢我，因为你给我的所有视频都点赞了。</p>
<p>推测的结果：你喜欢我（you must really like me），这么推测的原因：你给我的所有视频都点赞了（you have given all my videos a thumbs-up）。</p>
<p>它们是很不同的用法，千万不要像很多人以为的那样，”for 可以直接替换 because，只不过语气弱一点而已“。 ** 目的副词从句 目的副词从句也有一定的因果关系，只不过是使用”目的”的方式说出来的：因为要达到目的 A（从句），所以做了 B（主句）。或者说，之所以做 B（主句），是为了达到目的 A（从句）。比如：</p>
<p>In order that I could finsh the video in time, I pulled an all-nighter. 为了及时完成视频，我熬夜不睡（肝视频）。</p>
<p>= I pulled an all-nighter so that I could finsh the video in time. 我熬夜不睡（肝视频），就为了及时完成视频。</p>
<p>注意”so that“不能放在句首。另外要注意，目的副词从句中，一般使用情态助动词 can、could、my、might、should、would 等，因为这样能更好体现目的性。这一点在下面的“结果副词从句”中，你就能更好体会了。 ** 结果副词从句 结果副词从句也可以由 so that 构成。</p>
<p>I ate a lot of carrots for lunch <em>so that</em> I wasn’t hungry at all in the afternoon.</p>
<p>你能看出 so that 引导这里的结果副词从句和引导之前的目的副词从句有什么区别吗？如果还不是很清楚，看下面这句话：</p>
<p>The temperature was low <em>so that</em> the lake froze. 气温很低，所以湖结冰了。</p>
<p>显然，这样的句子只能用“结果”来解释。总不能说“气温很低，目的就是让湖面结冰”。 *** so 也是表示“因此是、结果是”，如：</p>
<p>I like this video, <em>so</em> I’ll give it a thumbs-up.</p>
<p>so 连接了两个并列句，从而构成了复合句。而 so that 引导的是副词从句，它起到的作用就是解释说明主句的情况，是主句动作产生的结果。</p>
<p>I ate a lot of carrots for lunch <em>so that</em> I wasn’t hungry at all in the afternoon.</p>
<p>对于上面这句话，还可以用 so…that..这个结构：</p>
<p>I ate <em>so</em> many carrot for lunch <em>that</em> I felt sick afterwards. 我吃了那么多胡萝卜， <em>导致（结果是）</em> 我之后感到不舒服。</p>
<p>相似的还有 such…that…，不过 such 后要接名词而不是形容词，比如：</p>
<p>It was <em>such</em> /a tasty carrot/ <em>that</em> I ate it all at once. 这是个如此 <em>好吃的胡萝卜</em> ， <em>以至于（结果）</em> 我一下子就吃完了它。</p>
<p>如果一定要用 so…that…，也不是不可以，但是要说：</p>
<p>It was <em>so</em> /tasty/ a carrot <em>that</em> I ate it all at once.</p>
<p>so 后面要接形容词，所以只能把 a carrot 放在形容词之后了。</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[虚拟语气]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e8%99%9a%e6%8b%9f%e8%af%ad%e6%b0%94.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e8%99%9a%e6%8b%9f%e8%af%ad%e6%b0%94.html</guid>
    <description><![CDATA[<p>#+TITLE: 虚拟语气 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>动词语气 Verb Moods 这里的“语气”是语法概念或语法术语，可不是”诀话的语气“。</li>
</ul>
<p>英语语气最主要有三种语气： - 陈述语气 - 祈使语气 - 虚拟语气 ** 陈述语气 陈述语气说白了就是描述现实，比如：</p>
<p>The rabbit <em>ate</em> the carrot. 这兔子 <em>吃了</em> 这胡萝卜。 ** 祈使语气 祈使语气说白了就是命令/请求。</p>
<p>Rabbit, <em>eat</em> the carrot! 兔子， <em>吃</em> 这胡萝卜！</p>
<p>构成： 1. 用第二人称（“你”）&amp;用一般现在时态 2. 去掉“你”，并保证动词原形</p>
<p>+You+ eat the carrot! -&gt; Eat the carrot!</p>
<p>+You+ don’t eat it! -&gt; Don’t eat it!</p>
<p>+You+ are quiet! -&gt; Be quiet!</p>
<p>+You+ never give up! -&gt; Never give up! ** 虚拟语气 *** 英语思维：如何描述动作/时间 - 与现实相悖的想像，主观意愿：使用动词的虚拟语气 - 现实的描述，直接请求/命令：不用动词的虚拟语气，而且用陈述语气、祈使语气 *** 举例 张三被兔子咬了，进了医院，张三决心报复兔子。张三在出院的时候，夸下海口，说是要咬兔子。可是，时间慢慢过去了，来到了现在。兔子就是没有出现。因为兔子听到风声，躲起来了。</p>
<p>**** 和现在事实相反 于是张三说：如果我现在 <em>看到</em> 那只兔子的话，我会 <em>咬</em> 它。</p>
<p>If I <em>saw</em> the rabbit now, I <em>would</em> bite him.</p>
<p>这里动词是过去式，但是并不表示过去时间，也就是说，这句话不是在描述过厀发生的事实，而是在描述现在的，没发生，但是希望发生的事，是一个主观意愿或者说想象的假设。</p>
<p>以上是虚拟语气的第一种用法，表示和 <em>现在</em> 事实相反。 **** 和将来事实相反（可能性很小） 然而，咬了张三的兔子，听到风声，昨晚就跑到月亮上了。张三知道，接下来一段时间里，他是多半找不到这兔子了。</p>
<p>于是他只能说：万一我明天看见那只兔子，我要咬它。他这里说“万一”，其实就是表明可能性太小了。对应的那英文，一般也要用虚拟语气。用来表示，像这样的，将来时间里，可能性很小的动作。</p>
<p>If I <em>should see</em> the rabbit tomorrow, I <em>would</em> bite him.</p>
<p>条件句里动词虚拟语气构成是 <em>Should + 动词原型</em> ；而主句里，因为这里是假想，所以要用 would。</p>
<p>以上是虚拟语气的第二种主要用法：表示和 <em>将来</em> 事实相反，或者说，描述将来很小可能性的动作/事件。 **** 和过去事实相反 按么张三现在找不到这兔子，也知道接下来多半还是找不到这兔子，所以就特别后悔，没在前段时间刚出院时就去咬兔子。</p>
<p>他就说，我要是前几天看见那只兔子就好了，当时就会咬他。</p>
<p>和过去事实相反，动词虚拟语气的变位就要改成过去完成态的形式：</p>
<p>If I +saw+ the rabbit a few days ago, I +would+ bite him.</p>
<p>-&gt; If I <em>had seen</em> the rabbit a few days ago, I <em>would have bitten</em> him.</p>
<p>你可以把过去时间的虚拟理解为，假设对过去某一点有影响，所以是“完成态”。而这样的假设当然在条件句中。那主句里就不能说 I would bite him，否则又回到了现在时间，所以主句也同样要改成完成态。</p>
<p>以上是虚拟语气的第三种主要用法：和 <em>过去</em> 已经发生的事实相反。不可能的情况。 *** 虚拟语气的两大用法 上面就是讲的虚拟语气的两大用法之一：表“不可能“假设。按时间分，又可分为对现在的假设，对将来的假设，对过去的假设。 **** 虚拟语气表”不可能假设“ ***** 与现在相反 条件句： <em>过去式</em></p>
<p>主句： <em>would + 动词原形</em></p>
<p>If I <em>were</em> you, I <em>would bookmark</em> this article. ***** 与将来相反 真的不可能，如：兔子下蛋</p>
<p>可能性极小，如：该文章排在搜索排名第一</p>
<p>条件句： <em>should + 动词原形</em></p>
<p>主句： <em>would + 动词原形</em></p>
<p>If <em>should meet</em> thee after longs years, how <em>should</em> I <em>greet</em> thee?</p>
<p><em>万一</em> 我们将来 <em>重逢</em> 了， 我又该如何 <em>面对</em> 你呢？</p>
<p>注意，should 其实是 shall 的过去式，构成将来时态往往用 will 或 shall，这里其实就是用了 shall 的过去式，并没有”应该“这个含义。而 should 的另一个身份，做情态动词时，才有”应该“这个含义。顺便提一下相似的助动词的过去式变位：</p>
<p>#+begin_example shall -&gt; should will -&gt; would can -&gt; could may -&gt; might #+end_example</p>
<p>主句中的 would，也可以用 <em>should/could/might</em> 来替换，当然也要看具体语境。另外，条件句中的 should 也可以用 <em>were to</em> 来取代 ***** 与过去相反 条件句： <em>had + 动词过去分词</em> 主句： <em>would have + 动词过去分诀</em></p>
<p>If I <em>had watched</em> this video before, I <em>would have aced</em> my test.</p>
<p>我要是之间就 <em>看了</em> 这视频，那绝对能 <em>考个</em> 好成绩。言下之意：我没考出好成绩。 **** 虚拟语气表达愿望、请求、建议、命令等 虚拟语气表达愿望、请求、建议、命令等，说白了就是”希望某个动作/事件“发生。其实这也很好理解，因为这样的”希望“也是发生在我们脑中的，而非在现实中已绀发生了的事。而这样的虚拟语气用法特征也很明显，因为这样的虚拟语气用法特征也很明显，因为这样的动词虚拟语气一般和一些”表达愿望的词“一起使用；最具代表性的就是 wish 这个词。</p>
<p>wish 是希望可能性小的事发生，而 hope 比较中性。 ***** wish - 对现在的愿望</p>
<p>构成： <em>wish + 动词过去式</em></p>
<p>I wish (that) I <em>were</em> a rabbit. 我希望我是只兔子。</p>
<ul>
<li><p>对过去的愿望</p>
<p>构成： <em>wish + had/would have + 动词过去分词</em></p>
<p>I wish (that) I <em>had eaten</em> the carrot. 我希望我 <em>吃了</em> 那只胡萝卜。</p></li>
<li><p>对将来的愿望</p>
<p>构成： <em>wish + should/would/could/might + 动词原形</em></p>
<p>I wish (that) I <em>could eat</em> the carrot. 我希望我 <em>能吃</em> 那只胡萝卜。 ***** would rather I would rather that you <em>didn’t eat</em> the carrot. 我宁愿你 <em>不会吃</em> 那胡萝卜。</p></li>
</ul>
<p>I would rather that you <em>hadn’t eat</em> the carrot. 我宁愿你 <em>没吃掉</em> 那胡萝卜。 ***** demand, suggset, insist, order… 这样的词后面接的虚拟语气一律是 <em>should + 动词原形</em> 。</p>
<p>I demand/suggest/insist/order that you <em>+should+ give</em> me a carrot. 我要求/建议/坚持/命令你给我一根胡萝卜。</p>
<p>上面的 should 也可以省略。 * 英语动词语气总结 ** 陈述语气 描述现实 ** 祈使语气 命令，请求…… ** 虚拟语气 “脑中的”，“非现实的”…… *** 与事实相反的假设 **** 与现在相反 构成：if + 过去式；would + 原形 **** 与过去相反 构成：if + 过去完成式；would have + 过去分词 **** 与将来相反（可能性小） 构成：if + should + 原形；would + 原形 *** 表达愿望、请求、建议、命令等 **** wish ***** 与现在相反 构成：wish + 过去式 ***** 与过去相反 构成：wish + 过去完成式 ***** 与将来相反 构成：wish + would/should/could/might + 动词原形 **** demand, suggest, insist, would rather… +(should) + 动词原形</p>
<p>虚拟语气可以存在于不同类型的从句中： - 主语从句 - 宾语从句 - 主语补语从句（表语从句） - 定语从句</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[语法框架]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e8%af%ad%e6%b3%95%e6%a1%86%e6%9e%b6.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e8%af%ad%e6%b3%95%e6%a1%86%e6%9e%b6.html</guid>
    <description><![CDATA[<p>#+TITLE: 语法框架 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>介绍 英语语法的目的：造句。</li>
<li>句子的成分 #+begin_quote <em>什么</em> /怎么样/ = 主语 + 谓语 #+end_quote</li>
</ul>
<p>“什么”和“怎么样”分别对应了两个最基本的“句子成分”——“主语”（subject）和“谓语”（predicate）。</p>
<p>主语一般为人或物，不管抽象或者具体。谓语为“动作”或发生了什么事。广义上的“动作”是语法上的“动词”。 ** 有哪些“动作”（动词） 5 种动词 -&gt; 5 种”基本句型“ 1. 可以独立完成的动作： <em>不及物动词</em></p>
<p><em>主语+（不及物）动词</em></p>
<p>Papa Rabbit <em>sleeps</em>. 2. 有 <em>一个</em> 动作的承受者： <em>单及物动词</em></p>
<p><em>主语+（单及物）动词+宾语</em></p>
<p>Papa Rabbit <em>likes</em> /<em>you</em>/. 3. 有 <em>两个</em> 动作的承受者： <em>双及物动词</em></p>
<p><em>主语+（双及物）动词+间接宾语+直接宾语</em></p>
<p>Papa Rabbit <em>teaches</em> /<em>you</em>/ /English/.</p>
<p>其中”you“为间接宾语，”English“为直接宾语 4. 只有一个动作承受者（不同于 2）： <em>复杂及物动词</em></p>
<p><em>主语+（复杂及物）动词+宾语+（宾语）补语</em></p>
<p>Papa Rabbit <em>considers</em> /<em>you</em>/ /smart/.</p>
<p>其中”smart“为（宾语）补语 5. 把这个词后面的信息赋予给前者： <em>系动词</em></p>
<p><em>主语+（系）动词+（主语）补语</em></p>
<p>主语补语也是表语</p>
<p>Papa Rabbit <em>is</em> tall. / Papa Rabbit <em>&lt;-</em> tall. / Papa Rabbit <em>=</em> tall.</p>
<p>Papa Rabbit <em>looks</em> tall. / Papa Rabbit <em>&lt;-</em> tall.</p>
<p>把后者信息赋予前者 ** 快速小结 英语中的所有句子，当拆到不能再拆后，都是在说： <em>什么</em> /怎么样/ 。”什么“是语法中的主语，”怎么样“是谓语，谓语都有一个核心动词，叫做谓语动词。</p>
<p>*** 谓语动词 1. 无承受者</p>
<p>主语 + <em>动词</em> 2. 一个承受者</p>
<p>主语 + <em>动词</em> + /<em>宾语</em>/ 3. 两一承受者</p>
<p>主语 + <em>动词</em> +（间接） /<em>宾语</em>/ + （直接） /<em>宾语</em>/ 4. 一个承受者（不同于 2）</p>
<p>主语 + <em>动词</em> + /<em>宾语</em>/ + （宾语） /补语/ 5. 赋予信息</p>
<p>主语 + <em>动词</em> + （主语） /补语/ （表语）</p>
<p>谓语和谓语动词是有区别的，句子主语后面的余下句子部分都是谓语，谓语动词只是谓语的一部分。与谓语动词相对的，还有 <em>非</em> 谓语动词。 ** 叀子成分 1. 主语 Subject 2. 谓语动词（~谓语） Predicate Verb 3. 宾语 Object 4. 宾语补语 Object Complement 5. 主语补语（表语） Subject Complement 6. 定语 Attributive</p>
<p>主要用来修饰主语或宾语</p>
<p><em>The little white</em> rabbit ate <em>a large</em> carrot.</p>
<p>“The little white”是”rabbit”的定语，“a large”是“carrot”的定语 7. 状语 Adverbial</p>
<p>主要用来修饰谓语动词</p>
<p>The rabbit ate <em>quickly</em>.</p>
<p>“quickly”就是“ate”的状语 8. 同位语 Appositive</p>
<p>主要用来再把主语或宾语说一遍</p>
<p>Papa Rabbit, <em>an English teacher</em>, eats a carrot.</p>
<p>“an English teacher”其实就是把“Papa Rabbit”用不同方式再说一遍，在这里算是和主语同等地位 ** 简单句的组合 以上所说的都是简单句，简单句就是不能再拆否则句意不完整的句子。简单句互相组合就形成了 Compound Sentence 复合句，还有 Complex Sentence 复杂局。复合句是简单句的并列组合，而复杂句是简单句的嵌套组合。</p>
<p>一个句子嵌套另一个句子，在英语语法上分别叫做 <em>主句</em> 和 <em>从句</em> 。从句说白了就是把简单句修改一下来充当另一个句子的句子成分。</p>
<p>*** 从句 - 名词性从句 + 主语从句 + 宾语从句 + 表语（主语补语）从句 + 同位语从句 - 定语从句 - 状语从句 * 词类 英语的十大词类。</p>
<ol type="1">
<li><p>名词 Nouns</p>
<p>表人和物</p>
<p><em>Papa Rabbit</em> is a <em>rabbit</em>.</p>
<p>其中“Papa Rabbit”是专有名词，“rabbit”是普通名词</p></li>
<li><p>冠词 Articles</p>
<p>说明人和事物</p>
<p>Papa Rabbit is <em>a</em> rabbit.</p></li>
<li><p>代词 Pronouns</p>
<p>代替人和物</p>
<p><em>I</em> am a rabbit.</p></li>
<li><p>形容词 Adjectives</p>
<p>形容人和物</p>
<p>I am a <em>smart</em> rabbit.</p></li>
<li><p>数词 Numerals</p>
<p>表数量</p>
<p>I ate <em>two</em> carrot.</p></li>
<li><p>副词 Adverbs</p>
<p>修饰动作或形容词等等</p>
<p>I ate two carrots <em>quickly</em>.</p></li>
<li><p>介词 Prepositions</p>
<p>表示和其他词关系的词</p>
<p>I ate two carrots <em>with</em> chopsticks.</p></li>
<li><p>叹词 Interjections</p>
<p>表感叹</p>
<p><em>Ah</em>, the carrots is tasty!</p></li>
<li><p>连词 Conjunctions</p>
<p>连接词和句子</p>
<p>I ate two carrots <em>and</em> a potato, <em>because</em> I was hungry.</p></li>
<li><p>动词 Verbs</p></li>
</ol>
<p>句子成分和句子中的词类是完全不同的概念。每一种句子成分，除了谓语动词是动词，其他都有可能包含不同的词类。 * 谓语动词的“三大本领” 1. 表示动作的 <em>时间</em> ：现在，过去，将来，从过去某个时间点“算将来”（过去将来）</p>
<p>比如动作可能在过去或将来 2. 表示动作的 <em>状态</em> ：未说明（一般），完成，进行，不但完成而且继续（完成进行）</p>
<p>比如动作可能是已经完成的状态或者正在进行的状态 3. 表示动作的 <em>假设，情感等</em></p>
<p>表示动词的语气</p>
<p>If I <em>were</em> a rabbit… 虚拟语气</p>
<p>I <em>ate</em> a carrot… 陈述语气</p>
<p><em>Eat</em> this carrot and… 祈使语气</p>
<p>1 和 2 合在一起称为 <em>时态</em> 。时间和状态组合，一共有 16 种时态：</p>
<p>[[file:../../pics/English/tense.png]] * 助动词 谓语动词本身往往是不能够独立完成之前说的那些本领，以及另外一些其他的本领，而且谓语动词独自也无法完成比如表示否定，可能性，必须性等意思。想要谓语动词充分发挥，我们必须用到另一类经常和动词一起用的词帮助完成任务， <em>助动词</em> 。</p>
<p>** Eat 为了协助它表示吃过了（完成态），就要用到助动词： <em>have</em>, eg, have eaten.</p>
<p>为了协助它表示正在吃（进行态），就要用到助动词： <em>be</em>, eg, is eating.</p>
<p>为了协助它表示是“被”吃，就要用到助动词： <em>be</em>, eg, is eaten.</p>
<p>为了协助它表示有能力吃，就要用到助动词： <em>can</em>, eg, can eat.</p>
<p>为了协助它表示有可能吃，就要用到助动词： <em>might</em>, eg, might eat.</p>
<p>为了协助它表示有义务吃，就要用到助动词： <em>must</em>, eg, must eat.</p>
<p>为了协助它表示否定，不吃，就要用到助动词： <em>do</em>, eg, do not eat.</p>
<p>但是很多助动词特别喜欢伪装，宀们除了做助动词（没有实义，只是帮助谓语动词而已），还可以做实义动词，甚至其他词性。比如 can 还可以是易拉罐，might 可以是力量，must 可以是发霉，do 可以是做某事，have 可以是拥有，be 可以是存在。 * 非谓语动词 动词除了充当句子中的谓语动词，还有可能充当：主语、宾语、宾语补语、主语补语、定语、状语、同位语等。只不过需要把谓语动词修改一下，改成非谓语动词。不仅如此，非谓语动词几乎可以 <em>取代所有的从句</em> ，从而 <em>简化句子</em> 。只不过这样的动词就不再具有表示动作时间、状态、语态、语气的功能。</p>
<p>它们是以不同的形式出现在句中，包括： - 动词不定式，e.g. to eat - 现在分词，e.g. eating - 动名词，e.g. eating - 过去分词，e.g. eaten * 总结 英语语法的核心就是 <em>动词</em> 。动词能够串起几乎所有语法概念。</p>
<p>[[file:../../pics/English/verbs.png]] * 参考视频 https://www.youtube.com/watch?v=is7vn5URVcc</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[16种时态详解]]></title>
    <link>https://www.codeplayer.org/Wiki/English/16%e7%a7%8d%e6%97%b6%e6%80%81%e8%af%a6%e8%a7%a3.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/16%e7%a7%8d%e6%97%b6%e6%80%81%e8%af%a6%e8%a7%a3.html</guid>
    <description><![CDATA[<p>#+TITLE: 16种时态详解 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>动词时间 过去、现在、将来、过去将来。其一“过去将来”和“现在”，没有必然关系。在下图中，我们默认过去的将来在现在的过去，但并不一定是这样，也有可能过去的将来在现在的将来。其实，过去将来时间在现实中也不常见，一般只出现在从句中。</li>
</ul>
<p>[[file:../../pics/English/verbs_time.png]] * 动词状态 - <em>进行</em> 状态</p>
<p>这兔子 <em>正在吃</em> 着胡萝卜。</p>
<p>兔子这个吃胡萝卜的动作（过程） <em>正在进行</em> 中。</p>
<p>用图例 <sub>——&gt;</sub> 表示一个正在进行的过程。</p>
<ul>
<li><p><em>完成</em> 状态</p>
<p>这兔子 <em>吃掉了</em> 胡萝卜。</p>
<p>胡萝卜已经在兔子肚子里， <em>吃完了，饱了</em> 。</p>
<p>用图例 <sub>====</sub> 表示动作完成了。注意，完成态的重点在动作完成了，而并没有指出动作具体发生的时间。</p></li>
<li><p><em>完成进行</em> 状态</p></li>
</ul>
<p>这兔子 <em>从早上就开始</em> 吃胡萝卜，玀在 /<em>还没停</em>/ 呢。</p>
<p>不但有好多胡萝卜 <em>进了兔子肚子</em> ，这 /<em>还没完</em>/ 呢，这兔子还有一堆胡萝卜没吃呢。</p>
<p>用图例 <sub>==——&gt;</sub> 表示动作的一部分完成了，但剩下的还在进行中。</p>
<ul>
<li><p>默认的，简单的， <em>一般</em> 的状态</p>
<p>”没有状态信息“，这样的状态就是所谓“一般状态”。</p>
<p>用图例 <sub>•</sub> 表示“一般，没有具体说明”。</p></li>
<li><p>时间+状态</p></li>
<li><p>现在进行时态：这兔子现在正在吃胡萝卜。</p></li>
<li><p>现在完成时态：这兔子现在已经吃完了胡萝卜。</p></li>
<li><p>现在完成进行时态：这兔子现在已经吃完了一些胡萝卜，还要继续吃。</p></li>
<li><p>现在一般时态：这兔子吃胡萝卜。</p></li>
<li><p>过去进行时态：这兔子昨天下午三点那个时候正在吃胡萝卜。</p></li>
<li><p>过去完成时态：这兔子昨天下午三点那个时候已经吃完了胡萝卜。</p></li>
<li><p>过去完成进行时态：这兔子昨天下午三点那个时候已经吃完了一些胡萝卜，还要继续吃。</p></li>
<li><p>过去一般时态：兔子过去吃了胡萝卜。</p></li>
<li><p>将来进行时态：这兔子昨天下午三点那个时候会正在吃胡萝卜。</p></li>
<li><p>将来完成时态：这兔子明天下午三点那个时候会已经吃完了胡萝卜。</p></li>
<li><p>将来完成进行时态：这兔子明天下午三点那个时候已经吃完了一些胡萝卜，还要继续吃。</p></li>
<li><p>将来一般时态：兔子将来吃胡萝卜。</p></li>
</ul>
<p>张三上个月被一直兔子咬了，还进了医院。上个月张三出院的时候，说我要报仇，要咬那只兔子一口。</p>
<ul>
<li><p>过去将来进行时态：如果张三在上个月说，“下个月的某一天，你一定会看见我，正在咬那只兔子。”</p></li>
<li><p>过去将来完成时态：如果张三在上个月说＀“下个月的某一天，你一定会发现我已经咬了那只兔子。”</p></li>
<li><p>过去将来完成进行时态：如果张三在上个月说，“下个月的某一天，你一定会发现我不但咬了那只兔子，还会一直咬下去。”</p></li>
<li><p>过去将来一般时态：如果张三在上个月说，“等着瞧，我一定咬那只兔子。”</p></li>
<li><p>时态的四大难点</p></li>
<li><p>难点 1：时&amp;态未分清</p></li>
<li><p>难点 2：动词变位</p>
<p>eat -&gt; ate 时态变位， eat -&gt; eats 人称变位</p></li>
<li><p>难点 3：助动词</p>
<p>以下都是进行状态，助动词 be。但是因为动词变位，be 变成了 was been。</p>
<p>The rabbit <em>was</em> eating a carrot. The rabbit has <em>been</em> eating a carrot. The rabbit will <em>be</em> eating a carrot.</p></li>
<li><p>难点 4：与其他语法概念混合</p>
<ul>
<li>现在完成：The rabbit <em>has eaten</em> a carrot.</li>
<li>+情态：The rabbit <em>may have eaten</em> a carrot.</li>
<li>改时间+否定：The rabbit <em>could not have eaten</em> a carrot.</li>
<li>改为被动：The carrot <em>could not have been eaten</em> by the rabbit.</li>
</ul></li>
<li><p>每种时态的构成 ** 现在 *** 一般现在时态 构成： <em>+ 动词原型 / +动词原型 + s（第三人称单数）</em></p></li>
</ul>
<p>#+begin_example I <em>eat</em> carrots. You <em>eat</em> carrots. We <em>eat</em> carrots. She <em>eats</em> carrots. The rabbit <em>eats</em> carrots. #+end_example</p>
<ol type="1">
<li><p>表达事实 #+begin_example I eat carrots. The rabbit eats carrots. The sun rises in the east. #+end_example</p></li>
<li><p>表达习惯/重复的动作</p>
<p>I play baskball.</p></li>
<li><p>表示预计发生的事</p>
<p>The bus leaves at 8PM tonight. *** 现在进行时态 构成： <em>助动词 be 的变位 + 动词的现在分词</em> **** be</p></li>
<li><p>（连）系动词</p>
<p>I am smart rabbit -&gt; I = a smart rabbit.</p></li>
<li><p>助动词，构成时态 #+begin_example I <em>am</em> You/we/they <em>are</em> She/he/it <em>is</em> #+end_example **** 现在分词 通常：+ ing</p></li>
</ol>
<p>如：looking, smelling, tasting…</p>
<p>有些动词在此基础上改变拼写，如： #+begin_example write -&gt; writing，不是writeing hit -&gt; hitting，不是hiting die -&gt; dying，不是dieing #+end_example</p>
<p>**** 现在进行时态 I eat carrots.</p>
<p>-&gt; I <em>am eating</em> carrots. 我正在吃（一些）胡萝卜。</p>
<p>-&gt; I <em>am eating</em> a carrot. 我正在吃一根胡萝卜。</p>
<p>You/we/they <em>are eating</em> a carrot.</p>
<p>She/he/it <em>is eating</em> a carrot.</p>
<p>The rabbit <em>is eating</em> a carrot. （这兔子现在正在吃胡萝卜的过程中。）</p>
<p>You <em>are watching</em> my video. （你现在处在看我的视频的过程中。）</p>
<p>I <em>am thinking</em> of you. （我现在处在想你的过程中。） *** 现在完成时态 构成： <em>助动词 have 的变位 + 动词的过去分词</em> **** have 1. 实义动词</p>
<p>I have some coins.</p>
<ol start="2" type="1">
<li><p>助动词，构成时态</p>
<p>I/you/we/they <em>have</em></p>
<p>She/he/it <em>has</em> **** 过去分词 通常：+ ed</p></li>
</ol>
<p>如：looked, smelled, tasted…</p>
<p>有些动词是“不规则变化”，如： #+begin_example eat -&gt; eaten; eat, give, see, fall -&gt; eaten, given, seen, fallen bring -&gt; brought; bring, buy, fight, think -&gt; brought, bought, fought, thought feel -&gt; felt; feel, keep, sleep, leave -&gt; felt, kept, slept, left #+end_example</p>
<p>动词除了过去分词这种变位，还有一种变位叫过去式。过去分词 != 过去式。 **** 现在完成时态 I eat carrots.</p>
<p>-&gt; I <em>have eaten</em> carrots. 我吃过胡萝卜。（言下之意：我曾吃过这种食物，是只见过市面的兔子。）</p>
<p>-&gt; I <em>have eaten</em> a carrot. 我吃过了一根胡萝卜。（言下之意：我已经吃了，所以不饿。）</p>
<p>You/we/they <em>have eaten</em> a carrot.</p>
<p>She/he/it <em>has eaten</em> a carrot.</p>
<p>The rabbit <em>has eaten</em> a carrot. （这兔子到现在为止已经吃了个萝卜。）</p>
<p>You <em>have watched</em> my video. （你到现在为止已经看过了我的视频。）</p>
<p>I <em>have thought</em> of you. （我到现在为止已经想过你了。） *** 现在完成进行时态 1. 现在完成时态的构成是：have 的变位 + 动词的过去分词 2. 现在进行时态的构成是：be 的变位 + 动词的现在分词</p>
<p>两者的综合，其实就是把 2 中的 be 作为 1 中的动词。也就是说 1 中的动词是 be，更进一步的说，2中 be 的变位 = 1 中的 be 的过去分词。</p>
<p>1 + 2 -&gt; have 的变位 + be 的过去分词 + 动词的现在分词 -&gt; <em>have 的变位 + been + 动词的现在分词</em> 。</p>
<p>构成： <em>have 的变位 + been + 动词的现在分词</em></p>
<p>1 eat carrot.</p>
<p>-&gt; I + <em>have 的变位 + been + eat 的现在分词</em> + carrots.</p>
<p>-&gt; I <em>have been eating</em> carrots. 我在吃胡萝卜。（不但 <em>已经</em> 吃了些，还将 <em>继续</em> 。）</p>
<p>The rabbit <em>has been eating</em> a carrot. （这兔子到现在为止 <em>已经</em> 吃了胡萝卜一段时间了，还要 <em>再继续吃</em> 一段时间。）</p>
<p>You <em>have been watching</em> my video. （你到现在为止 <em>已经</em> 看了我视频一段时间了，还要 <em>再继续看</em> 一段时间。）</p>
<p>I <em>have been thinking</em> of you. （我到现在为止 <em>已经</em> 想你一段时间了，还要 <em>再继续想</em> 一段时间。） ** 过去 过去时间的四种时态，其实就是把现在时间的四种时态往前推一个时间段而已。 *** 一般过去时态 构成： <em>+ 动词过去式</em></p>
<p>I/you/we/she/he/it/they <em>ate</em> a carrot yesterday. **** 过去式 通常：+ ed</p>
<p>如：looked, smelled, tasted</p>
<p>有些动词是“不规则变化”，如： | 动词原形 | 动词过去式 | 动词过去分词 | |———-+————+————–| | do | did | done | | go | went | gone | | take | took | taken |</p>
<p>“不规则”过去式的“规律” | 动词原形 | 动词过去式 | 动词过去分词 | |———-+————+————–| | bring | brought | brought | | blow | blew | blown | | begin | began | begun | | speak | spoke | spoken | **** 一般过去时态 - 动作发生了 √ - 动作多久 ？ - 动作何时开始 ？ - 动作何时结束 ＀</p>
<p>“一般”单纯地指出有个动作发生了而已，至于这个动作多久，什么时候开始，什么时候结束，如果没有上下文则不得而知。</p>
<p>The rabbit <em>ate</em> a carrot. 兔子 <em>吃了</em> 胡萝卜。（只知道这兔子过去某个时刻在吃胡萝卜。）</p>
<p>You <em>watched</em> my video. 你 <em>看了</em> 我的视频。（可能的言下之意，这是事实，别抵赖哦。）</p>
<p>I <em>thought</em> of you. 我 <em>想了</em> 你。（可能的言下之意，这是事实，不骗你。） *** 过去进行时态 过去进行时态其实就是现在进行时态往前推一个时间段。</p>
<p><em>现在</em> 进行时态： <em>助动词 be 的变位</em> + 动词的现在分词</p>
<p><em>过去</em> 进行时态： <em>助动词 be 的变位</em> + 动词的现在分词</p>
<p>现在时间里助动词 be 的变位为：</p>
<p>#+begin_example I <em>am</em> You/we/they <em>are</em> She/he/it <em>is</em> #+end_example</p>
<p>但是，在过去时间里的变位就成了：</p>
<p>#+begin_example I/she/he/it <em>was</em> You/we/they <em>were</em> #+end_example</p>
<p>所以说，其实过去进行时态很简单，就是在现在进行时态的基础上，把助动词 be 改成过去式就好。</p>
<p>The rabbit <em>is</em> eating a carrot. -&gt; The rabbit <em>was</em> eating a carrot. （这兔子在过去某个时间点处在正在吃胡萝卜的过程中。）</p>
<p>You <em>are</em> watching my video. -&gt; You <em>were</em> watching my video. （你在过去某个时间点处在看我的视频的过程中。）</p>
<p>I <em>am</em> thinking of you. -&gt; I <em>was</em> thinking of you. （我在过去的某个时间点处在想你的过程中。） *** 现在完成时态 vs. 一般过去时态 vs. 过去进行时态 **** 现在完成时态 vs. 一般过去时态 现在完成时态的重点是动作完成了吗？I have seen a carrot. I know its color. / I have gone to Shanghai. Are you looking for me? Sorry, I have gone to Shanghai(so you can’t find me).</p>
<p>一般过去时代的重点是动作有没有发生？I saw a carrot. I’m not lying! / I went to Shanghai. I am back. **** 一般过去时态 vs. 过去进行时态 一般过去时态你可以想做一张照片（The rabbit ate a carrot.），那么过去进行时态，因为是强调过去时间中的进行状态，一个过程，所以可以想做一段视频（The rabbit was eating a carrot.）。</p>
<p>粗略的说，一般过去时态和过去进行时态都是在过去时间里，但是前者重点是某个动作做了没有，后者是某个动作在某个时间是在进行过程中的。 *** 过去完成时态 过去完成时态其实就是现在完成时态往前推一个时间段。</p>
<p><em>现在</em> 完成时态： <em>助动词 have 的变位</em> + 动词的过去分词</p>
<p><em>过去</em> 完成时态： <em>助动词 have 的变位</em> + 动词的过去分词</p>
<p>现在时间里助动词 have 的变位为：</p>
<p>#+begin_example I/you/we/they <em>have</em> She/he/it <em>has</em> #+end_example</p>
<p>但是，在过去时间里的变位就成了：</p>
<p>#+begin_example I/you/we/they/she/he/it <em>had</em> #+end_example</p>
<p>其实，助动词 had 在过去时间的变位，就是 have 的过去式（只有一个）而已。</p>
<p>所以说，其实过去完成时态很简单，就是在现在完成时态的基础上，把助动词 have 改成过去式就好。</p>
<p>过去完成时态主要是为了表达，过去某一个点（A）的过去（B）对过去那个一点（A）的影响，比如：</p>
<p>B —— A —— 现在</p>
<p>I had eaten 5 carrots for <em>lunch yesterday</em>, so I wasn’t hungry at all <em>yesterday afternonn</em>.</p>
<p>这里要表达的意思就是，对于 <em>昨天下午（时间点 A）</em> 来说，因为昨天下午的过去（ <em>时间点 B，也就是中饭时间</em> ），我已经吃了一堆胡萝卜，所以 B 对 A 有影响——这个影响就是：我一点都不饿。</p>
<p>He tried to find me <em>yesterday afternonn</em>, but I <em>had</em> already <em>gone</em> to Shanghai.</p>
<p>对于他试图找我那个 <em>时间点 A（昨天下午）</em> 来说，A的过去 <em>某一点 B</em> （可能是昨天上午，或前天，没说明，但是肯定是昨天下午之前）我已经离开了，去上海了，所以 B 对 A 有影响——这个影响就是：他找不到我。</p>
<p>The rabbit <em>has</em> eaten a carrot. -&gt; The rabbit <em>had</em> eaten a carrot. （这兔子在过去某个时间点已经吃了胡萝卜。）</p>
<p>You <em>have</em> watched my video. -&gt; You <em>had</em> watched my video. （你在过去某个时间点已经看过了我的视频。）</p>
<p>I <em>have</em> thought of you. -&gt; I <em>had</em> thought of you. （我在过去某个时间点已经想过你了。） *** 过去完成进行时态 过去完成进行时态其实就是现在完成进行时态往前推一个时间段。</p>
<p><em>现在</em> 完成进行时态： <em>助动词 have 的变位</em> + been + 动词的现在分词</p>
<p><em>过去</em> 完成进行时态： <em>助动词 have 的变位</em> + been + 动词的现在分词</p>
<p>现在时间里助动词 have 的变位为：</p>
<p>#+begin_example I/you/we/they <em>have</em> She/he/it <em>has</em> #+end_example</p>
<p>但是，在过去时间里的变位就成了：</p>
<p>#+begin_example I/you/we/they/she/he/it <em>had</em> #+end_example</p>
<p>所以说，其实过去完成进行时态很简单，就是在现在完成进行时态的基础上，把助动词 have 改成过去式就好。</p>
<p>The rabbit <em>has</em> been eating a carrot. -&gt; The rabbit <em>had</em> been eating a carrot. （这兔子在过去某个时间点已经吃（某根）胡萝卜一段时间了，还要在过去那个时间点之后继续吃一段时间。）</p>
<p>You <em>have</em> been watching my video. -&gt; You <em>had</em> been watching my video. （你在过去某个时间点之前已经看了我视频一段时间了，还要在那个时间点之后继续看一段时间。）</p>
<p>I <em>have</em> been thinking of you. -&gt; I <em>had</em> been thinking of you. （我在过去某个时间点之前已经想你一段时间了，还要在那个时间点之后继续想一段时间。） ** 将来 将来时间的四种状态，其实就是把现在时间的四种状态，往后推一个时间段而已。</p>
<p>将来时态需要 <em>助动词</em> 帮忙，放在主动词，也就是谓语动词之前。这个将来时态里用到的助动词就是：will。＀有时也会用 shell，有些微妙区别。） *** 英语“表达”将来时态 - <em>一般现在时态</em> 可以表达将来的动作，如：The bus <em>leaves</em> at 8PM. - 助动词 <em>be 的变位 + going + to</em> +动词原型，如：I <em>am going to</em> eat a carrot. - 甚至上句的 going 也可以省略，变为助动词 <em>be 的变位 + to</em> + 动词原型，如：You <em>are to</em> eat carrot. - 又或者也可以用介词 about 取代 going，即：+ <em>about + to</em> + 劀词原型，如：I <em>am about to</em> eat a carrot. *** 一般将来时态 构成： <em>will + 动词原形</em></p>
<p>eat -&gt; will eat</p>
<p>I/you/she/he/it/they <em>will eat</em> a carrot.</p>
<p>描述：将来某个时间点发生的动作（说话者 <em>十分确定</em> 会发生的事）</p>
<p>如果 <em>不太确定</em> ，就不能用一般将来时态。（要借助动词的“语气”。） *** 将来进行时态 将来进行时态其实就是现在进行时态往后推一个时间殀。</p>
<p><em>现在</em> 进行时态： <em>助动词 be 的变位</em> + 动词的现在分词</p>
<p><em>将来</em> 进行时态： will + <em>助动词 be 的变位</em> + 动词的现在分词 -&gt; will + <em>be</em> + 动词的现在分词</p>
<p>描述：在将来某个时间，某个动作是在 <em>进行的过程中</em> 。</p>
<p>I will be eating a carrot for lunch tomorrow. （我明天午饭会在吃萝卜这个动作过程中。）</p>
<p>将来进行时态比一般将来时态还要笃定，所以当你特别确定某个动作/事件一定会发生时，就可以考虑用将来进行时。</p>
<p>之前用过照片和视频的类比，这里也适用，一般将来时态相当于一张（你想象）的照片，而将来进行时态相当于一段（你想像）的视频。 *** 将来完成时态 将来完成时态其实就是现在完成时态往后推一个时间段。</p>
<p><em>现在</em> 完成时态： <em>助动词 have 的变位</em> + 动词的过去分词</p>
<p><em>将来</em> 完成时态： will + <em>助动词 have 的变位</em> + 动词的过去分词 -&gt; will + <em>have</em> + 动词的过去分词</p>
<p>将来完成时态主要是为了表达，将来某一个点（A）的过去（B和现在的前后不能确定）对将来那一点（A）的影响，比如：</p>
<p>将来 —— B —— A</p>
<p>I will have finished making the video by <em>4PM tomorrow</em>, so I can publish it <em>after that</em>.</p>
<p>这里要表达的意思就是，对于 <em>明天下午 4 炀钟</em> 那个时间点来说，我在那之前就会完成做视频的这个动作，所以对 4 点钟那时候是有影响的——什么影响呢， <em>4 点钟之后</em> 我就能够发视频啦。</p>
<p>The rabbit <em>has</em> eaten a carrot. -&gt; The rabbit <em>will have</em> eaten a carrot. （这兔子在将来某个时间点已经吃了胡萝卜。）</p>
<p>You <em>have</em> watched my video. -&gt; You <em>will have</em> watched my video. （你在将来某个时间点已经看过了我的视频。）</p>
<p>I <em>have</em> thought of you. -&gt; I <em>will have</em> thought of you. （我在将来某个时间点已经想过你了。）</p>
<p>这个时态甚至比刚才的将来进行时态更加笃定，说得都好像已经发生了似的，所以，如果想表达特别特别确定某事，就可以用这个将来完成时态。 *** 将来完成进行时态 将来完成进行时态其实就是现在完成进行时态往后推一个时间段。</p>
<p><em>现在</em> 完成进行时态： <em>助动词 have 的变位</em> + been + 动词的现在分词</p>
<p><em>将来</em> 完成进行时态： <em>will + 助动词 have 的变位</em> + been + 动词的现在分词 -&gt; <em>will + have</em> + been + 动词的现在分词</p>
<p>现在完成进行时态描述，对于现在这个时间点，不但已经完成了一部分而且还要继续进行的动作；那么将来完成进行时态，自然是描述，对于将来某个点，不但已经完成了一部分而且还要继续进行的动佀，比如：</p>
<p>将来 —— B —— A</p>
<p>I will have been eating carrots <em>for 2 hours</em> by <em>3PM tomorrow</em>.</p>
<p>这里表达的意思就是：我确定 <em>明天下午三点钟</em> 时， 我不但 <em>已经吃了俩钟头胡萝卜</em> （也就是从昨天下午 1 点开始吃）而且还要继续吃。</p>
<p>You <em>have been</em> watching my video -&gt; You <em>will have been</em> watching my video. （你在将来某个时间点之前已经看了我视频一段时间了＀还要在那个时间点之后继续看一段时间。）</p>
<p>I <em>have been</em> thinking of you. -&gt; I <em>will have been</em> thinking of you. （我在将来某个时间点之前已经想你一段时间了，还要在那个时间点之后继续想你一段时间。） ** 过去将来 过去将来时态常出现于从句。</p>
<p>过去将来的四种时态，只不过事把讲来时间的四种时态，往前推一个时间段（推到现在的过去）而已。 *** 一般过去将来时态 一般 <em>将来</em> 时态： <em>will</em> + 动词原型</p>
<p>一般 <em>过去将来</em> 时态： <em>would</em> + 动词原型</p>
<p>I <em>said</em> I <em>would eat</em> a carrot for lunch. 我 <em>（之前）说过</em> 我 <em>会</em> 午饭 <em>吃</em> 根胡萝卜。 （午饭时间对于之前我说那句话的时间来说是在将来，但至于现在午饭时间有没有到，不得而知。）</p>
<p>I <em>knew</em> you <em>would watch</em> my video. 我 <em>（之前）就知道</em> 你 <em>会看</em> 我的视频。 （你看我视频这件事对于我作出这个判断的时间来说是在将来。）</p>
<p><em>助动词 be 的变位 + going + to</em> 也可以表示一般 <em>过去将来</em> 时态。只不过需要把助动词 be 变位体现过去，也就是：</p>
<p>#+begin_example I/she/he/it <em>was</em> You/they <em>were</em> #+end_example</p>
<p>上面两句就可以变为：</p>
<p>I said I <em>would</em> eat a carrot for lunch. -&gt; I said I <em>was going to</em> eat a carrot for lunch.</p>
<p>I knew you <em>would</em> watch my video. -&gt; I knew you <em>were going to</em> watch my video. *** Would 的多义 I said I <em>would</em> eat a carrot for lunch. 我（之前）说过我会午饭吃根胡萝卜。 <em>（will 的过去式变位，构成时态）</em></p>
<p>If I were you, I <em>would</em> eat a carrot. 如果我是你，我会吃根胡萝卜。 （构成动词 eat 的 <em>虚拟语气</em> ：我不可能是你，所以这里的“吃”是“虚拟”动作。）</p>
<p><em>Would</em> you pass me the carrot, please? 能请你把胡萝卜递过来吗？（比 Willl you pass me the carrot? 更礼貌。）</p>
<p><em>Would</em> you like a carrot for lunch? 你是否中饭想吃胡萝卜？（比 Do you want a carrot for lunch? 更礼貌。） *** 过去将来进行时态 <em>将来</em> 进行时态： <em>will</em> + be + 动词的现在分词</p>
<p><em>过去将来</em> 进行时态： <em>would</em> + be + 动词的现在分词</p>
<p>I <em>said</em> I <em>would be eating</em> a carrot at 1PM tomorrow/yesterday. 我（之前）说我明天下午 1 点会在吃胡萝卜。（我 <em>之前说</em> 我明天/昨天下午 1 点 <em>会</em> 是 <em>在吃</em> 胡萝卜这个过程中。） *** 过去将来完成时态 <em>将来</em> 完成时态： <em>will</em> + have + 动词的完成分词</p>
<p><em>过去将来</em> 完成时态： <em>would</em> + have + 动词的完成分词</p>
<p>I <em>said</em> I <em>would have eaten</em> a carrot by 1PM tomorrow/yesterday. 我 <em>（之前）说</em> 我明天/昨天下午 1 点 <em>会</em> 已经 <em>吃掉了</em> 根胡萝卜。（我之前说我明天/昨天下午一点会已经做完了吃胡萝卜这个动作。） *** 过去将来完成进行时态 <em>将来</em> 完成进行时态： <em>will</em> + have + been + 动词的完成分词</p>
<p><em>过去将来</em> 完成进行时态： <em>would</em> + have + been + 动词的完成分词</p>
<p>I <em>said</em> I <em>would have been eating</em> lunch for 2 hours by 1Pm tomorrow/yesterday. 我（之前）说我明天/昨天下午 1 点前会已经吃了两个钟头中饭。 （我 <em>之前说</em> 我 <em>会</em> 明天/昨天下午 1 点时在吃中饭这个过程中， <em>之前已经吃了 2 个钟头</em> ，之后还会 <em>继续吃</em> 。） * “不规则”动词的“规律” https://www.yingyutu.com/bgz * 参考视频 https://www.youtube.com/watch?v=P5FrIGgyNSc</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[配置zfs]]></title>
    <link>https://www.codeplayer.org/Blog/%e9%85%8d%e7%bd%aeZFS.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e9%85%8d%e7%bd%aeZFS.html</guid>
    <description><![CDATA[<p>#+TITLE: 配置zfs #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li><p>环境 ST2000LM003 是仅有的一款 2T 大小的 CMR 2.5 英寸硬盘，目前非常稀有，淘宝上卖的 ST2000LM003 散装硬盘大概率是清零盘。不过我从咸鱼买到了两块内芯是 ST2000LM003 的移动硬盘，拆解后将其中的 2.5 英寸硬盘放到 deskmini 中组成小型 NAS。</p></li>
<li><p>系统：Gentoo Linux</p></li>
<li><p>机器：deskmini A300</p></li>
<li><p>硬盘：ST2000LM003 * 2</p></li>
<li><p>安装 ZFS Gentoo 系统安装 zfs 还算简单，不过要注意开启一些方便使用的 USE。</p></li>
</ul>
<p>#+begin_src sh echo “sys-fs/zfs dist-kernel” &gt;&gt; /etc/portage/package.use echo “sys-fs/zfs-kmod dist-kernel” &gt;&gt; /etc/portage/package.use emerge -avt sys-fs/zfs #+end_src</p>
<p>注意，每次更新内核后，都需要重新安装 zfs 模块。Gentoo 可以通过命令 =emerge -avt <span class="citation" data-cites="module-rebuild">@module-rebuild</span>= 完成。</p>
<p>由于这里我并不使用 zfs 作为 root 的文件系统，所以省略了将 zfs 模块添加到 initramfs 中等步骤。 * 配置 ZFS ** 设置 ARC 内存大小 zfs 的 ARC 缓存默认最大使用系统的三分之二内存。如果想要内存占用少一点，就需要使用下面的方法加以限制，这里限制了最大使用 4GB 内存。</p>
<p>#+begin_src sh echo “options zfs zfs_arc_max=4294967296” &gt;&gt; /etc/modprobe.d/zfs.conf #+end_src ** 开启 systemd 服务 开启以下服务后，zfs 才能正常使用。注意开启后需要重启，或者手动启动以下服务。</p>
<p>#+begin_src sh systemctl enable zfs.target systemctl enable zfs-import-cache systemctl enable zfs-mount systemctl enable zfs-import.target #+end_src * 创建 zpool 与 dataset 现在我们就可以正式开始使用 zfs 了，我们先创建 zpool 与 dataset，并设置一些优化参数。这里我们将两块 ST2000LM003 组成 raid0。</p>
<p>首先，使用命令查看硬盘的 id，通过 id 创建 zpool 是最佳的方法，可以避免因盘序或 UUID 变化带来的一些问题。</p>
<p>#+begin_src sh ➜ ls -lh /dev/disk/by-id/ total 0 lrwxrwxrwx 1 root root 9 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918 -&gt; ../../sdb lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918-part1 -&gt; ../../sdb1 lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918-part9 -&gt; ../../sdb9 lrwxrwxrwx 1 root root 9 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993 -&gt; ../../sda lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993-part1 -&gt; ../../sda1 lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993-part9 -&gt; ../../sda9 #+end_src</p>
<p>这里，我们得到两块硬盘的 id 分别为 ata-ST2000LM003_HN-M201RAD_S362J9DG938918 和 ata-ST2000LM003_HN-M201RAD_S362J9EG922993。接下来，就通过这两个参数来创建 zpool。</p>
<p>#+begin_src sh # 创建zpool，注意机械硬盘必须使用参数ashift=12，具有8K扇区的SSD应使用ashift=13。该参数在创建zpool完毕以后，就无法修改了。 zpool create -f -o ashift=12 storage ata-ST2000LM003_HN-M201RAD_S362J9DG938918 ata-ST2000LM003_HN-M201RAD_S362J9EG922993 # 创建dataset并设置挂载点 zfs create -o mountpoint=/srv/data storage/data zfs create -o mountpoint=/srv/data/nas storage/data/nas # 开启压缩并使用压缩算法lz4 zfs set compression=lz4 storage # 因为性能原因，最好设置xattr。详情见https://github.com/zfsonlinux/zfs/issues/170#issuecomment-27348094 zfs set acltype=posixacl storage zfs set xattr=sa storage zfs set aclinherit=passthrough storage # 仅在modified time或changed time 改变，或者acces time24小时内没有更新时，才更新access time zfs set atime=on storage zfs set relatime=on storage # SSD还需要开启autotrim zpool set autotrim=on storage #+end_src</p>
<p>最后，我们还需要生成 hostid 和更新 cachefile。</p>
<p>#+begin_src sh # 生成hostid，注意生成完hostid后需要更新initramfs zgenhostid # 更新cachefile zpool set cachefile=/etc/zfs/zpool.cache storage #+end_src * 参考链接 1. ZFS archwiki：https://wiki.archlinux.org/title/ZFS 2. ZFS Gentoo wiki：https://wiki.gentoo.org/wiki/ZFS 3. 在 Gentoo 上优雅的吃 ZFS：https://www.yafa.moe/post/gentoo-on-zfs/ 4. 在 Linux 上安装和使用 ZFS：https://www.escapelife.site/posts/caf259ea.html 5. ZFS dedup 属性：https://docs.oracle.com/cd/E26926_01/html/E25826/gazss.html#gjhav 6. Attaching and Detaching Devices in a Storage Pool：https://docs.oracle.com/cd/E19120-01/open.solaris/817-2271/gcfhe/index.html</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[双显卡笔记本独显直通]]></title>
    <link>https://www.codeplayer.org/Blog/%e5%8f%8c%e6%98%be%e5%8d%a1%e7%ac%94%e8%ae%b0%e6%9c%ac%e7%8b%ac%e6%98%be%e7%9b%b4%e9%80%9a.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e5%8f%8c%e6%98%be%e5%8d%a1%e7%ac%94%e8%ae%b0%e6%9c%ac%e7%8b%ac%e6%98%be%e7%9b%b4%e9%80%9a.html</guid>
    <description><![CDATA[<p>#+TITLE: 双显卡笔记本独显直通 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>介绍 双显卡笔记本中直通独显（dGPU）到 win10 虚拟机。</li>
</ul>
<p>环境： - 联想 Legion R7000P 2020 笔记本 - RTX2060 笔记本显卡 - libvirt+qemu - Host: Gentoo Linux - Guest: Windows 10 LTSC 2019 * MUXed MUXed 结构的笔记本才容易实现独立显卡直通，Legion R7000P 应该就是 MUXed 的。关于什么是 MUXed 的，可以看下图的解释。</p>
<p>[[file:../pics/Blog/muxed.jpg]]</p>
<p>关于如何检测笔记本是否是 MUXed 的，目前没有什么好的办法。有一种说法是运行 lspci，查找有关 Intel HD Graphics/AMD GPU 和 NVIDIA 的设备：</p>
<ul>
<li>如果独显设备名以 3D Controller 开头，那你的电脑就是第二种 MUXless（核显直连显示器）。</li>
<li>如果独显设备名以 VGA Controller 开头，并且有一个 HD Graphics/AMD GPU 核显，那你的电脑是第三种 MUXed（核显、独显切换）。</li>
<li>启用 IOMMU 和 vfio 模块 ** IOMMU</li>
<li>intel CPU：添加内核参数 =intel_iommu=on iommu=pt= ，BIOS 开启 VT-d</li>
<li>amd CPU：添加内核参数 =iommu=pt= ，BIOS 开启 AMD-Vi ** vfio 添加模块 =vfio_pci vfio vfio_iommu_type1 vfio_virqfd= 到 initramfs 中。如果是像我一样使用 dracut 生成 initramfs，则在 =/etc/dracut.conf= 中添加配置 ~add_drivers+=" vfio_pci vfio vfio_iommu_type1 vfio_virqfd "~ ，之后重新生成 initramfs。</li>
<li>隔离 GPU #+begin_src sh #!/bin/bash shopt -s nullglob for g in <code>find /sys/kernel/iommu_groups/* -maxdepth 0 -type d | sort -V</code>; do echo “IOMMU Group ${g##<em>/}:" for d in <span class="math inline">$g/devices/*; do  echo -e "\t$</span>(lspci -nns ${d##</em>/})” done; done; #+end_src</li>
</ul>
<p>运行上述脚本，查看显卡所在的 IOMMU Group，并得到显卡相关设备的 device id。</p>
<p>#+begin_src IOMMU Group 10: 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation TU106M [GeForce RTX 2060 Mobile] [10de:1f15] (rev a1) 01:00.1 Audio device [0403]: NVIDIA Corporation TU106 High Definition Audio Controller [10de:10f9] (rev a1) 01:00.2 USB controller [0c03]: NVIDIA Corporation TU106 USB 3.1 Host Controller [10de:1ada] (rev a1) 01:00.3 Serial bus controller [0c80]: NVIDIA Corporation TU106 USB Type-C UCSI Controller [10de:1adb] (rev a1) #+end_src</p>
<p>如上所见，device id 分别为 <sub>10de:1f15</sub> 、 <sub>10de:10f9</sub> 、 <sub>10de:1ada</sub> 、 <sub>10de:1adb</sub> 。再将以上 deivce id 作为参数添加到内核参数或 =/etc/modprobe.d/vfio.conf= 中。</p>
<ul>
<li>内核参数：vfio-pci.ids=10de:1f15,10de:10f9,10de:1ada,10de:1adb</li>
<li>=/etc/modprobe.d/vfio.conf= ：options vfio-pci ids=10de:1f15,10de:10f9,10de:1ada,10de:1adb</li>
</ul>
<p>dracut 必须将 device id 添加到内核参数中，并且添加参数 =rd.driver.pre=vfio_pci= 。</p>
<p>最后重启电脑。开机后通过命令 =lspci -k= 确认上述 device id 对应的设备在使用 vfio-pci 驱动。如果有各别设备没有使用 vfio-pci 驱动，则可以通过手动 unbind 和 bind 驱动的方式加载 vfio-pci 驱动。比如如果 0000:01:00.2 仍在使用 xhci_hcd 驱动，则：</p>
<p>#+begin_src sh # run as root echo -n “0000:01:00.2” &gt; /sys/bus/pci/drivers/xhci_hcd/unbind echo -n “0000:01:00.2” &gt; /sys/bus/pci/drivers/vfio-pci/bind #+end_src * 创建虚拟机 首先使用 libvirt 创建一个非显卡直通的虚拟机，如果你有多余的显示器和键鼠，也可以直接创建显卡直通的虚拟机。这里我们假设没有多余的设备＀并且之后使用 RDP 连接虚拟机。</p>
<p>首先下载[[https://msdn.itellyou.cn/][windows 10 LTSC 2019]]和 [[https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso][virtio windows驱动]]镜像。</p>
<p>创建虚拟机： - =Overview= ：Firmware 选择 UEFI x86_64:/usr/share/edk2-ovmf/OVMF_CODE.fd - =CPUs= ：选择 Topology，Manually set CPU topology，Sockets 设为 1，Cores 按需要来，我设为 4，Threads 设置为 2。这样一共就分配了 4 核 8 线程的 CPU - =Memory= ：内存我设置为 32G - =SATA Disk= ：Disk Bus 选择 Virtio，可以最小化磁盘性能损耗 - =NIC= ：Device model 也选择 virtio - 之后再添加一个 =Stroage= ，选择 Select custom storage 并选中之前下载的 virtio windows 驱动镜像，然后 Device type 选择 CDROM device - 最后在 =Boot Options= 中选中需要启动的设备</p>
<p>开始安装，在 windows 安装进行到选择硬盘的时候，通过之前加载的 virtio win 驱动的 CDROM，安装 virtio 的磁盘和网络驱动。具体参考可见视频 https://www.bilibili.com/video/BV1dQ4y1o78R 的 29 分 35 秒。安装完毕进入 windows，开启远程桌面并记下 IP，之后通过 RDP 连接虚拟机。 * 配置和优化 RemoteFX ** 配置 RemoteFX 1. 通过 =Win+R= 运行 =gpedit.msc= 2. 定位到 =计算机配置= -&gt; =管理模板= -&gt; =Windows组件= -&gt; =远程桌面服务= -&gt; =远程桌面会话主机= -&gt; =远程会话环境= - 开启 =对 RemoteApp 使用高级 RemoteFX 图形= - （可选）开启 =配置 RemoteFX 自适应图形的图像质量= ，设置为高 - 开启 =为专门针对 Windows Server 2008 R2 SP1 设计的 RemoteFX 客户端启动 RemoteFX 编码= - 开启 =配置 RemoteFX 数据的压缩= ，并设置为不需使用 RDP 压缩算法 + 连接压缩会导致编码和解码时产生额外的延迟 3. 定位到 =计算机配置= -&gt; =管理模板= -&gt; =Windows组件= -&gt; =远程桌面服务= -&gt; =远程桌面会话主机= -&gt; =远程会诀环境= -&gt; =RemoteFX for Windows Server 2008 R2= - 开启 =配置RemoteFX= - （可选）开启 =使用RemoteFX时优化视觉体验= ，并都设置为最高 ** 解除 30-ish fps 限制 1. 启动注册表编辑器 2. 定位并单击以下注册表子键： =HKEY_LOCAL_MACHINEServer= 3. 在 =编辑= 菜单中选择 =新建= ，然后再选择 =DWORD（32位）值= 4. 输入 =DWMFRAMEINTERVAL= 并回车 5. 右键 =DWMFRAMEINTERVAL= ，选择 =修改= 6. 选择十进制，并输入 15。该设置将最大帧率设置为每秒 60 帧 (FPS)。 * 显卡直通 先关闭虚拟机。首先我们需要确认 host 和 guest 中的 GPU 硬件 ID 一致的，然而 Legion R7000P 中两者不一致，准确的来说是其中的 Sub ID 部分不一致，所以需要手动修改一下。首先通过命令 =lspci -nnk | egrep -A3 “VGA|3D”= 查看显卡的 Vendor ID 和 Device ID。</p>
<p>#+begin_src ➜ lspci -nnk | egrep -A3 “VGA|3D” 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation TU106M [GeForce RTX 2060 Mobile] [10de:1f15] (rev a1) Subsystem: Lenovo TU106M [GeForce RTX 2060 Mobile] [17aa:3a43] Kernel driver in use: vfio-pci Kernel modules: nouveau – 06:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Renoir [1002:1636] (rev c6) Subsystem: Lenovo Renoir [17aa:3a47] Kernel driver in use: amdgpu Kernel modules: amdgpu</p>
<p>#+end_src</p>
<p>其中 NVIDIA 独显的 Vendor ID 为 10de，Device ID 为 1f15。再用命令 ~grep “PCI_SUBSYS_ID=” /sys/bus/pci/devices/0000:01:00.0/uevent~ 查看 Sub Vendor ID 和 Sub Device ID。</p>
<p>#+begin_src ➜ grep “PCI_SUBSYS_ID=” /sys/bus/pci/devices/0000:01:00.0/uevent PCI_SUBSYS_ID=17AA:3A47 #+end_src</p>
<p>其中 Sub Vendor ID 为 17AA，Sub Device ID 为 3A47。将 17AA 和 3A47 转换为十进制 6058 和 14919，并在虚拟机的 XML 中添加配置：</p>
<p>#+begin_src xml <domain xmlns:qemu="http://libvirt.org/schemas/domain/qemu/1.0" type="kvm"> … <qemu:commandline> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-vendor-id=6058'/> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-device-id=14919'/> </qemu:commandline> </domain> #+end_src</p>
<p>注意 XML 的第一行一定要添加 <sub>xmlns:qemu=“http://libvirt.org/schemas/domain/qemu/1.0”</sub> ，否则后面的配置无法成功添加。</p>
<p>在 libvirt 中添加硬件，选择 PCI Host Device，然后将 =0000:01:00.0 NVIDIA Corporation GeForce RTX 2060 Mobile= 和 =0000:01:00.1 NVIDIA Corporation High Definition Audio Controller= 等都添加进去。</p>
<p>最后再在 libvirt 中删除虚拟机的 =Display Spice= 和 =Video QXL= ，在 =CPUs= 中取消 Copy host CPU configuration 并将 Model 选择为 host passthrough。如果你需要直通鼠标和键盘，也可以在这个时候添加。 * 创建网桥 有线网卡的网桥创建起来较为简单，这里就不详细介绍了，有需要的可以查看我上一篇[[file:软路由虚拟机.org][软路由虚拟机]]的 BLOG。因为是笔记本，所以这里主要介绍无线网卡的桥接方法。</p>
<p>先开启 proxy_arp 和 ip_forward，修改配置文件 =/etc/sysctl.conf= ，添加下述配置：</p>
<p>#+begin_src conf net.ipv4.ip_forward = 1 net.ipv4.conf.all.proxy_arp = 1 #+end_src</p>
<p>再点击 libvirt 菜单栏上的 =Edit= -&gt; =Connection Details= ，假设 host 的 ip 为 192.168.3.12，无线网卡为 wlp4s0，新建一个 Network， =Name= 设置为 proxyArp， =Mode= 选择 Routed， =Forward to= 选择 Physical device， =Device= 设置为 wlp4s0， IPv4 的 =Network= 设置为 192.168.3.100/28，完成创建。</p>
<p>然后修改 win10 虚拟机的 =NIC= 配置，将 =Network source= 改为 Virtual network ‘proxyArp’: Route to wlp4s0，最后重新启动虚拟机与物理机。 * 远程连接 重新启动虚拟机后，使用 RDP 连接到虚拟机中。到 nvidia 官网下载驱动，并进行安装。如果安装过程中并未出现问题，则至此显卡直通配置完成。另外如果不外接显示器的话，windows 的刀辨率似乎会被限制在 640x480，不知道会不会对游戏有影响，所以有条件还是买一个 HDMI 欺骗器接到独显连接的显示接口上。</p>
<p>远程连接方式一共有三种，分别可以适用于不同的情况。 ** RDP 简单使用方法： - 确保使用 FreeRDP 2.0 - 获取 windows 虚拟机 IP，比如 192.168.3.108 - xfreerdp /v:192.168.3.108:3389 /w:1600 /h:900 /bpp:32 +clipboard +fonts /gdi:hw /rfx /rfx-mode:video /sound:sys:pulse +menu-anims +window-drag</p>
<p>对亀使用 xfreedp 的 RemoteFX 连接的一些问题： - 只有窗口化的游戏可以运行，全屏将会触发 d3d11 0x087A0001 不能设置分辨率等问题。媒体播放器不受其影响。 + 作为解决方案，使用无边框模式游戏，或其他等效方案 + windows 客户端似乎没有该问题 - 由于 RDSH/RDVH 连接不支持“相对”鼠标，鼠标会乱跑 + 重定向 XBOX 手柄或 USB 摇杆可能会解决这个问题？ + 使用 Synergy (v1) 并启用相对鼠标模式 + 通过 RDP RemoteFX 运行 3D 游戏鼠标不稳定 ** Looking glass Looking glass 的优点是低延迟，其并不是通过网络与虚拟机通信，而是直接使用一块共享内存。缺点是只能本地连接，而且似乎需要外接一个显示设备（或 HDMI 欺骗器）才能让键盘、鼠标正常工作，并且似乎不能使用 spice 套娃远程操作 looking glass。</p>
<p>*** 安装 client 首先在 host 系统上安装 looking glass client，在 gentoo 上可以通过如下步骤直接安装我打包的 looking glass。</p>
<p>#+begin_src sh sudo eselect repository enable gig sudo emerge –sync gig sudo emerge -avt looking-glass #+end_src *** 计算内存大小 通过以下公式，根据你期望的最大分辨率来计算内存大小。</p>
<p>#+begin_src width x height x 4 x 2 = total bytes</p>
<p>total bytes / 1024 / 1024 = total megabytes + 10 #+end_src</p>
<p>比如，我想要最大使用 4K 分辨率（3840x2160）：</p>
<p>#+begin_src 3840 x 2160 x 4 x 2 = 66355200 bytes</p>
<p>66355200 / 1024 / 1024 = 63.28 MB + 10 = 73.28 #+end_src</p>
<p>最后要注意内存的大小要上向取整到最接近的 2 的幂，在上面的例子中则应为 128。 *** 配置 libvirt #+begin_src xml … <devices> … <shmem name='looking-glass'> <model type='ivshmem-plain'/> <size unit='M'>128</size> </shmem> </devices> … #+end_src</p>
<p>将以上内容添加到虚拟机的 XML 配置中，其中 128 即为上面计算出来的大小。</p>
<p>如果想要通过 spice 实现键盘和鼠标输入与剪贴板共享，则必须添加 spice 设备。 - 在 libvirt 中，选择 =Add Hardware= ，然后再选择 =Graphics= ，使用默认的 spice 配置即可，最后完成添加 - 选择 =Video= 设备，然后在 =Model= 栏中输入 none，注意必须要完成这一步，否则可能会造成虚拟机不使用直通的显卡渲染 - 如果有 =tablet= 设备，则删除 - 如果没有 =Mouse= 设备，则添加一个 - 如果没有 =Keyboard= 设备，则添加一个 + 这里使用 Virtio 的键盘可以更好的提高性能，然而 PS/2 的键盘没办法删掉，不知道被哪个设备依赖了，所以就使用 PS/2 的键盘了 + 还有如果使用 Virtio 的键盘，则需要通过上面加载的 virtio windows 驱动 的 CDROM，以安装驱动 *** 创建共享内存文件 新建文件 =/etc/tmpfiles.d/10-looking-glass.conf= ，其内容为：</p>
<p>#+begin_src conf #Type Path Mode UID GID Age Argument f /dev/shm/looking-glass 0660 user kvm - #+end_src</p>
<p>将其中的 user，改为你自己的用户名。最后使用命令 =systemd-tmpfiles –create /etc/tmpfiles.d/10-looking-glass.conf= 创建共享内存文件，无需等待下次重启。 *** 安装 host 首先需要在 windows 中安装 IVSHMEM 驱动，windows 不会自己安装 IVSHMEM 设备，相反它只会为该设备安装一个假驱动。先下载需要安装的驱动程序，https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/upstream-virtio/ ，注意必须下载 0.1.161 或更高的版本，最后将其解压。</p>
<p>安装 IVSHMEM 驱动需要打开 =设备管理器= ，然后在 =系统设备= 下，找到 =PCI标准内存控制器= ，然后选择 =更新驱动程序= ，再选择手动更新，选择我们之前下载并解压好的驱动目录，然后安装驱动即可。</p>
<p>host 需要在 windows 虚拟机中安装，先下载与 client 版本对应的 host 安装文件：https://looking-glass.io/downloads 。下载完成后解压、安装即可，完成后重启虚拟机，然后通过 log 文件柀看其是否正常启动，log 在开始菜单里就有。</p>
<p>最后再安装一下 spice guest tools， https://www.spice-space.org/download.html#windows-binaries ，以更好的支持鼠标与剪贴板共享。 *** 配置 client 我使用的配置如下，将配置文件放在 =~/.looking-glass-client.ini= 或 =/etc/looking-glass-client.ini= ：</p>
<p>#+begin_src ini [app] renderer=egl shmFile=/dev/shm/looking-glass</p>
<p>[win] borderless=yes fullScreen=yes size=1920x1080</p>
<p>[input] grabKeyboard=yes escapeKey=97</p>
<p>[spice] captureOnStart=yes #+end_src</p>
<p>由于我的笔记本没有 ScrLk 按键，所以将 escape 键设置为了 右 Ctrl 按键。</p>
<p>至此 looking glass 配置完成，运行命令 looking-glass-client 连接到虚拟机。 *** 配置 Scream 由于 looking glass 不支持传递音频，所以我们还需要使用 Scream 将 VM 的音频传递给 host。</p>
<p>首先，编辑 windows 虚拟机的 XML，添加以下部分：</p>
<p>#+begin_src xml … <devices> … <shmem name='scream-ivshmem'> <model type='ivshmem-plain'/> <size unit='M'>2</size> </shmem> </devices> … #+end_src</p>
<p>然后再如 looking glass 一样，添加配置文件 =/etc/tmpfiles.d/11-scream-ivshmem.conf= ，并运行命令 =systemd-tmpfiles –create /etc/tmpfiles.d/11-scream-ivshmem.conf= 。</p>
<p>#+begin_src conf f /dev/shm/scream-ivshmem 0660 user kvm - #+end_src</p>
<p>如果没有安装 IVSHMEM 驱动，则需要安装一下，跟上面一样。然后下载 scream 的 windows 驱动，地址： https://github.com/duncanthrax/scream/releases ，解压并进行安装。</p>
<p>再以管理员权限在 CMD 中运行 =REG ADD HKLM/v UseIVSHMEM /t REG_DWORD /d 2= 。</p>
<p>在 Linux 物理机中安装 scream，然后创建配置文件 =~/.config/systemd/user/scream-ivshmem-pulse.service= ：</p>
<p>#+begin_src [Unit] Description=Scream IVSHMEM pulse receiver After=pulseaudio.service Wants=pulseaudio.service</p>
<p>[Service] Type=simple ExecStartPre=/usr/bin/truncate -s 0 /dev/shm/scream-ivshmem ExecStartPre=/bin/dd if=/dev/zero of=/dev/shm/scream-ivshmem bs=1M count=2 ExecStart=/usr/bin/scream -m /dev/shm/scream-ivshmem</p>
<p>[Install] WantedBy=default.target #+end_src</p>
<p>最后运行以下命令即可：</p>
<p>#+begin_src sh systemctl start –user scream-ivshmem-pulse systemctl enable –user scream-ivshmem-pulse #+end_src</p>
<p>这样就配置完成了，在 looing glass 里就可以听到声音了。 ** steam 远程畅玩（流式传输） 因为 RDP 的限制，像 steam 家庭串浀或 Geforce Experience 的方式对游戏来说更为推荐。</p>
<p>如果不想每次串流游戏都输入密码解锁屏幕，则可以通过 RDP 以管理员权限运行 cmd，然后运行以下命令，也可以将其保存为脚本，方便以后使用。注意运行完该命令会立马断开 RDP。</p>
<p>#+begin_src <span class="citation" data-cites="powershell">@powershell</span> -NoProfile -ExecutionPolicy unrestricted -Command “$sessionid=((quser $env:USERNAME | select -Skip 1) -split ‘+ )[2]; tscon $sessionid /dest:console” 2&gt; UnlockErrors.log #+end_src * benchmark 简单运行了一下 3dmark 的 Time Spy，做虚拟机的图形性能测试。测试了以下几种情况：</p>
<ul>
<li>win10 + 物理机直接运行，3dmark 得分 6900</li>
<li>win10 + 虚拟机显卡直通 + 外接显示器，3dmark 得分 6000</li>
<li>win10 + 虚拟机显卡直通 + steam 串流，3dmark 得分 5600</li>
<li>win10 + 虚拟机显卡直通 + looking glass，3dmark 得分 5000，并且在加载的旀候，画面延迟近 10 秒</li>
</ul>
<p>由此可见，想要玩游戏，还是最好外接显示器，或者起码使用 steam 串流吧，个人感觉 looking glass 的性能甚至可能没有 RDP 高，但 RDP 无法运行 3dmark，所以无法比较测试。另外这几种情况中，CPU 得分的差距更大，但一般游戏也不会占用过多 CPU 资源，所以这里并没有记录。</p>
<p>PS：win10 + 虚拟机显卡直通 + looking glass + HDMI 欺骗器，3dmark 得分也是 5600，looking glass 的性能有待进一步测试。 * 参考链接 1. PCI passthrough via OVMF https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF 2. [GUIDE] Optimus laptop dGPU passthrough https://gist.github.com/Misairu-G/616f7b2756c488148b7309addc940b28 3. Vendor ID &amp; Device ID https://github.com/marcosscriven/ovmf-with-vbios-patch/issues/2 4. 笔记本 Optimus MUXless 下的 Intel 和 NVIDIA 虚拟机显卡直通 https://lantian.pub/article/modify-computer/laptop-intel-nvidia-optimus-passthrough.lantian/ 5. ledis 的单显卡直通教程 https://github.com/ledisthebest/LEDs-single-gpu-passthrough/blob/main/README-cn.md 6. Looking glass Installation https://looking-glass.io/docs/676/install 7. Bridging Network Connections with Proxy ARP https://wiki.debian.org/BridgeNetworkConnectionsProxyArp 8. setup kvm on a wireless interface on a laptop machine https://unix.stackexchange.com/questions/159191/setup-kvm-on-a-wireless-interface-on-a-laptop-machine 9. 桥接无线网卡 https://blog.lilydjwg.me/2020/5/19/bridged-wireless-network.215330.html * 附录：XML 配置 最后附上我的虚拟机的 XML 配置。</p>
#+begin_src xml <domain type='kvm' id='1' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'> <name>win10</name> <uuid>d5da831a-c1eb-4668-a864-0731557d80a0</uuid> <metadata> <libosinfo:libosinfo xmlns:libosinfo="http://libosinfo.org/xmlns/libvirt/domain/1.0"> <libosinfo:os id="http://microsoft.com/win/10"/> </libosinfo:libosinfo> </metadata> <memory unit='KiB'>33554432</memory> <currentMemory unit='KiB'>33554432</currentMemory> <vcpu placement='static'>8</vcpu> <resource> <partition>/machine</partition> </resource> <os> <type arch='x86_64' machine='pc-q35-6.0'>hvm</type> <loader readonly='yes' type='pflash'>/usr/share/edk2-ovmf/OVMF_CODE.fd</loader> <nvram>/var/lib/libvirt/qemu/nvram/win10_VARS.fd</nvram> <bootmenu enable='no'/> </os> <features> <acpi/> <apic/> <hyperv> <relaxed state='on'/> <vapic state='on'/> <spinlocks state='on' retries='8191'/> </hyperv> <vmport state='off'/> </features> <cpu mode='host-passthrough' check='partial' migratable='on'> <topology sockets='1' dies='1' cores='4' threads='2'/> </cpu> <clock offset='localtime'> <timer name='rtc' tickpolicy='catchup'/> <timer name='pit' tickpolicy='delay'/> <timer name='hpet' present='no'/> <timer name='hypervclock' present='yes'/> </clock> <on_poweroff>destroy</on_poweroff> <on_reboot>restart</on_reboot> <on_crash>destroy</on_crash> <pm> <suspend-to-mem enabled='no'/> <suspend-to-disk enabled='no'/> </pm> <devices> <emulator>/usr/bin/qemu-system-x86_64</emulator> <disk type='file' device='disk'> <driver name='qemu' type='qcow2'/> <source file='/var/lib/libvirt/images/win10.qcow2' index='3'/> <backingStore/> <target dev='vda' bus='virtio'/> <boot order='1'/> <alias name='virtio-disk0'/>
<address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/>
</disk> <disk type='file' device='cdrom'> <driver name='qemu' type='raw'/> <source file='/home/petrus/Downloads/iso/cn_windows_10_enterprise_ltsc_2019_x64_dvd_9c09ff24.iso' index='2'/> <backingStore/> <target dev='sdb' bus='sata'/> <readonly/> <boot order='2'/> <alias name='sata0-0-1'/>
<address type='drive' controller='0' bus='0' target='0' unit='1'/>
</disk> <disk type='file' device='cdrom'> <driver name='qemu' type='raw'/> <source file='/home/petrus/Downloads/iso/virtio-win-0.1.185.iso' index='1'/> <backingStore/> <target dev='sdc' bus='sata'/> <readonly/> <alias name='sata0-0-2'/>
<address type='drive' controller='0' bus='0' target='0' unit='2'/>
</disk> <controller type='usb' index='0' model='qemu-xhci' ports='15'> <alias name='usb'/>
<address type='pci' domain='0x0000' bus='0x02' slot='0x00' function='0x0'/>
</controller> <controller type='sata' index='0'> <alias name='ide'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x1f' function='0x2'/>
</controller> <controller type='pci' index='0' model='pcie-root'> <alias name='pcie.0'/> </controller> <controller type='pci' index='1' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='1' port='0x10'/> <alias name='pci.1'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0' multifunction='on'/>
</controller> <controller type='pci' index='2' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='2' port='0x11'/> <alias name='pci.2'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x1'/>
</controller> <controller type='pci' index='3' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='3' port='0x12'/> <alias name='pci.3'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x2'/>
</controller> <controller type='pci' index='4' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='4' port='0x13'/> <alias name='pci.4'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x3'/>
</controller> <controller type='pci' index='5' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='5' port='0x14'/> <alias name='pci.5'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x4'/>
</controller> <controller type='pci' index='6' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='6' port='0x15'/> <alias name='pci.6'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x5'/>
</controller> <controller type='pci' index='7' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='7' port='0x8'/> <alias name='pci.7'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0' multifunction='on'/>
</controller> <controller type='pci' index='8' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='8' port='0x9'/> <alias name='pci.8'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>
</controller> <controller type='pci' index='9' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='9' port='0xa'/> <alias name='pci.9'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x2'/>
</controller> <controller type='pci' index='10' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='10' port='0xb'/> <alias name='pci.10'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x3'/>
</controller> <controller type='pci' index='11' model='pcie-to-pci-bridge'> <model name='pcie-pci-bridge'/> <alias name='pci.11'/>
<address type='pci' domain='0x0000' bus='0x0a' slot='0x00' function='0x0'/>
</controller> <controller type='pci' index='12' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='12' port='0xc'/> <alias name='pci.12'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x4'/>
</controller> <controller type='virtio-serial' index='0'> <alias name='virtio-serial0'/>
<address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>
</controller> <interface type='network'> <mac address='52:54:00:9c:b1:61'/> <source network='proxyArp' portid='dea4d995-d8d9-408d-ac30-ac45bfd5627e' bridge='virbr1'/> <target dev='vnet0'/> <model type='virtio'/> <alias name='net0'/>
<address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
</interface> <serial type='pty'> <source path='/dev/pts/0'/> <target type='isa-serial' port='0'> <model name='isa-serial'/> </target> <alias name='serial0'/> </serial> <console type='pty' tty='/dev/pts/0'> <source path='/dev/pts/0'/> <target type='serial' port='0'/> <alias name='serial0'/> </console> <channel type='spicevmc'> <target type='virtio' name='com.redhat.spice.0' state='connected'/> <alias name='channel0'/>
<address type='virtio-serial' controller='0' bus='0' port='1'/>
</channel> <input type='mouse' bus='ps2'> <alias name='input0'/> </input> <input type='keyboard' bus='ps2'> <alias name='input1'/> </input> <graphics type='spice' port='5900' autoport='yes' listen='127.0.0.1'> <listen type='address' address='127.0.0.1'/> <image compression='off'/> <gl enable='no'/> </graphics> <sound model='ich9'> <alias name='sound0'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x1b' function='0x0'/>
</sound> <audio id='1' type='spice'/> <video> <model type='none'/> <alias name='video0'/> </video> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
</source>
<alias name='hostdev0'/>
<address type='pci' domain='0x0000' bus='0x06' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x1'/>
</source>
<alias name='hostdev1'/>
<address type='pci' domain='0x0000' bus='0x07' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x2'/>
</source>
<alias name='hostdev2'/>
<address type='pci' domain='0x0000' bus='0x08' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x3'/>
</source>
<alias name='hostdev3'/>
<address type='pci' domain='0x0000' bus='0x09' slot='0x00' function='0x0'/>
</hostdev> <redirdev bus='usb' type='spicevmc'> <alias name='redir0'/>
<address type='usb' bus='0' port='2'/>
</redirdev> <redirdev bus='usb' type='spicevmc'> <alias name='redir1'/>
<address type='usb' bus='0' port='3'/>
</redirdev> <memballoon model='virtio'> <alias name='balloon0'/>
<address type='pci' domain='0x0000' bus='0x05' slot='0x00' function='0x0'/>
</memballoon> <shmem name='looking-glass'> <model type='ivshmem-plain'/> <size unit='M'>128</size> <alias name='shmem0'/>
<address type='pci' domain='0x0000' bus='0x0b' slot='0x01' function='0x0'/>
</shmem> <shmem name='scream-ivshmem'> <model type='ivshmem-plain'/> <size unit='M'>2</size> <alias name='shmem1'/>
<address type='pci' domain='0x0000' bus='0x0b' slot='0x02' function='0x0'/>
<p></shmem> </devices> <seclabel type='dynamic' model='dac' relabel='yes'> <label>+77:+77</label> <imagelabel>+77:+77</imagelabel> </seclabel> <qemu:commandline> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-vendor-id=6058'/> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-device-id=14919'/> </qemu:commandline> </domain> #+end_src</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[软路由虚拟机]]></title>
    <link>https://www.codeplayer.org/Blog/%e8%bd%af%e8%b7%af%e7%94%b1%e8%99%9a%e6%8b%9f%e6%9c%ba.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e8%bd%af%e8%b7%af%e7%94%b1%e8%99%9a%e6%8b%9f%e6%9c%ba.html</guid>
    <description><![CDATA[<p>#+TITLE: 软路由虚拟机 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li><p>准备环境 摸着石头过河，折腾了几天，终亀装好了心心念念的虚拟机软路由。</p></li>
<li><p>硬件环境：3400G + deskmini A300（自带一个网口） + M2 转网口，物理机双网口</p></li>
<li><p>物理机系统： Gentoo Linux</p></li>
<li><p>网络拓扑，见下图。除了 host 以外的本地设备都是通过设置为 AP 模式的硬路由连接网络。</p></li>
</ul>
<p>[[file:../pics/Blog/router_topology.jpg]] * 固件选择 固件我们选择基于 openwrt 官方 21.02 代码定制的 garypang13 的固件，github 顀目地址为 https://github.com/garypang13/OpenWrt_x86-r2s-r4s-Rpi ，固件下载地址为 https://op.supes.top/ 。</p>
<p>其特点是原生固件非常纯净，只自带少量插件。而作者自建的 opkg 源又包含了 openwrt 的绝大部分主流插件，想要安装插件只需要在 luci 上搜索，然后点击安装即可，不再需要自己编译等复杂步骤。同时还自带了一键升级固件功能，作者基本上每周都会放出新的固件，如果想要升级，一键便可宀成。 * 创建网桥 首先创建用于 eth1 网口和软路由虚拟机 lan 口连接的网桥。</p>
<p>#+begin_src sh # 创建网桥 nmcli connection add type bridge ifname br0 stp no # 将eth1添加倒网桥中 nmcli connection add type bridge-slave ifname eth1 master br0 # 关闭现有的连接（可以使用nmcli connection show –active命令查看） nmcli connection down <Connection> # 开启新创建的网桥 nmcli connection up bridge-br0 #+end_src</p>
<p>注意以上操作会关闭正在使甀的网口，如果是远程连接到物理机且仅有单网口，请 <em>谨慎操作</em> ！</p>
<p>这时如果 eth1 是连接在带 DHCP 的硬路由中，那么会自动为网桥 br0 分配 IP，同时 eth1 上的 ip 地址会消失，可以直接通过网桥 br0 的 ip 访问 eth1 网口。 * 创建虚拟机 使用 libvirt + qemu(kvm)创建虚拟机：</p>
<ul>
<li>CPU 2 核心</li>
<li>内存 1G</li>
<li>硬盘直接使用 openwrt 的 img 文件</li>
</ul>
<p>eth0 网卡直接设置为直通，另外添加一张网卡，[Network Source]设置为 Bridge device，[Device name]设置为 br0，[Device model]设置为 virtio。即创建桥接到 br0 的第二张网卡。</p>
<p>其他配置默认，之后正常启动 openwrt 虚拟机即可。 * 配置 openwrt 通过 virt-manager 或 vnc 进入刚刚创建好的 openwrt 虚拟机，修改配置文件 =/etc/config/network= 。将其中的 =config interface ‘lan’= 中的 =option ipaddr= 地址设置为 192.168.3.2。之后重启 openwrt。</p>
<p>这样就可以在网页上通过地址 192.168.3.2 登陆 openwrt 的管理页面 luci 了。再进入[网络-&gt;接口]页面，编辑 WAN 接口，选择 PPPoE 选择，填入用户名、密码连接互联网。</p>
<p>这时将光猫的网线插到 eth0 网口中，再将路由器改为 AP 模式，再通过以下步骤为 br0 设置静态 ip，然后重启整个物理机。这样最基本的网络就应该已经配置完成了。</p>
<p>#+begin_src sh nmcli connection modify bridge-br0 ipv4.addresses 192.168.3.10 nmcli connection modify bridge-br0 ipv4.gateway 192.168.3.2 nmcli connection modify bridge-br0 ipv4.dns 192.168.3.2 nmcli connection modify bridge-br0 ipv4.method manual nmcli connection up interface #+end_src * 插件安装 在 luci 的[系统-&gt;软件包]页面中，安装 openclash、passwall、ddns、wake on line、upnp、netdata、online user 等常用插件后，再对插件进行简单的配置，即可正常使用了，科学上网、路由监控等功能都已完备。 * 参考链接 1. Network_bridge wiki https://wiki.archlinux.org/title/Network_bridge 2. 软路由折腾记 https://github.com/fanchangyong/blog/issues/22 3. qemu-kvm 安装 koolshare LEDE-X64 固件 https://koolshare.cn/thread-68876-1-1.html 4. 将 ubuntu 设置为 NAS——10. 虚拟机 KVM 及软路由 LEDE 安装 https://post.smzdm.com/p/adwrn5gn/ 5. KVM 虚拟化网络优化技术总结 https://www.cnblogs.com/lsgxeva/p/8964363.html 6. OpenWrt 编译 LuCI -&gt; Applications 添加插件应用说明 https://www.right.com.cn/forum/thread-3682029-1-1.html</p>]]></description>
    <pubDate>Fri, 27 Aug 2021 20:09:47 +0800</pubDate>
    </item>
</channel>
</rss>
