<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
<title>codeplayer wiki</title>
<atom:link href="https://www.codeplayer.org/publish/feed.xml" rel="self" type="application/rss+xml" />
<link>https://www.codeplayer.org</link>
<description>www.codeplayer.org</description>
    <item>
    <title><![CDATA[test]]></title>
    <link>https://www.codeplayer.org/Blog/test.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/test.html</guid>
    <description><![CDATA[<p>#+TITLE: test #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<p>挑了一些 C 语言中的容易被人忽略的细微之处，C语言的新手常常在这些问题上想当然，其结果自然是 BUG。</p>
<ul>
<li>test testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest</li>
</ul>
<p>testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest</p>
<p>testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest</p>
<p>testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest</p>
<p>testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest</p>
<p>testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest</p>
<p>testtesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttesttest</p>]]></description>
    <pubDate>Wed, 7 Apr 2021 14:34:21 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Dbus Send与dbus Monitor命令的使用]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/Linux/dbus-send%e4%b8%8edbus-monitor%e5%91%bd%e4%bb%a4%e7%9a%84%e4%bd%bf%e7%94%a8.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/Linux/dbus-send%e4%b8%8edbus-monitor%e5%91%bd%e4%bb%a4%e7%9a%84%e4%bd%bf%e7%94%a8.html</guid>
    <description><![CDATA[<p>#+TITLE: Dbus Send与dbus Monitor命令的使用 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>dbus-send ** 获取属性值 ~dbus-send –print-reply –type=method_call –session –dest=com.deepin.daemon.Display /com/deepin/daemon/Display org.freedesktop.DBus.Properties.Get string:com.deepin.daemon.Display string:Primary~ ** 调用方法</li>
</ul>
<ol type="1">
<li>不带参数 ~dbus-send –session –print-reply –type=method_call –dest=com.deepin.daemon.Display /com/deepin/daemon/Display com.deepin.daemon.Display.CanRotate~</li>
<li>带参数 ~dbus-send –session –print-reply –type=method_call –dest=com.deepin.daemon.Display /com/deepin/daemon/Display com.deepin.daemon.Display.SetBrightness string:Virtual-1 double:1.0~ ** 参考</li>
<li>https://wikidev.uniontech.com/index.php?title=Dbus-send</li>
<li>https://note.youdao.com/ynoteshare1/index.html?id=94b62364769faff9eb92cc82cf5aced4&amp;type=note</li>
</ol>
<ul>
<li>dbus-monitor ~dbus-monitor [–system | –session | –address ADDRESS] [–profile | –monitor | –pcap | –binary] [watch expressions]~ ** 使用手册 dbus-monitor 具有两种不同的文本输出模式：“经典”风格的监视模式和配置文件模式</li>
</ul>
<p>配置文件模式：一种紧凑格式，每条消息只有一行，并且具有微秒分辨率的定时信息</p>
<p>dbus-monitor 也有两种特殊的二进制输出模式：–binary 和–pcap #+begin_src –binary：二进制模式将输出整个二进制消息流 –pcap：将PCAP文件头添加到输出的开头，并为每个消息添加PCAP消息头 #+end_src</p>
<p>如果未指定任何模式，则 dbus-monitor 将使用监视输出格式。 #+begin_src –system 和 –session表示系统总线和会话总线，默认为–session –address ADDRESS：监视在ADDRESS处给定的任意消息总线 –profile：使用配置文件模式打印 –monitor：使用dbus-monitor模式打印 #+end_src</p>
<p>输出概要： #+begin_src type：分为signal和method_call sender：消息或方法调用者 dest：消息接收或方法拥有者 interface：接口名 path：服务路径 member：方法名或属性名 replay：方法调用的返回值 #+end_src</p>
<p>监视某些系统级接口时，需要加上 sudo 权限，如监视 lastore 更新模块 ~sudo dbus-monitor –system “interface=com.deepin.lastore.Manager”~ ** 监视信号 ~dbus-monitor type=‘signal’,sender=‘org.gnome.TypingMonitor’,interface=‘org.gnome.TypingMonitor’~ ** 监视方法 ~dbus-monitor –session “interface=com.deepin.daemon.Display”~ ** TODO 监视属性 ** 参考 1. https://wikidev.uniontech.com/index.php?title=Dbus-monitor</p>]]></description>
    <pubDate>Wed, 7 Apr 2021 14:34:21 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[go中使用dbus和gsettings]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/go/%e5%9c%a8go%e4%b8%ad%e4%bd%bf%e7%94%a8dbus%e5%92%8cgsettings.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/go/%e5%9c%a8go%e4%b8%ad%e4%bd%bf%e7%94%a8dbus%e5%92%8cgsettings.html</guid>
    <description><![CDATA[<p>#+TITLE: go中使用dbus和gsettings #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>dbus in go ** 使用 dbus 包 *** 连接 dbus</li>
</ul>
<p>#+BEGIN_SRC go dbus.SessionBus() dbus.SystemBus() #+END_SRC *** 调用方法</p>
<p>比如调用 dbus-daemon 提供的对象的一个方法，服务名： =org.freedesktop.DBus=, 路径： =/org/freedesktop/DBus= ，接口名： =org.freedesktop.DBus= ， 方法名： =GetNameOwner= , 此方法输入参数是一个字符串，返回参数也是一个字符串。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) var ret string err = obj.Call(“org.freedesktop.DBus.GetNameOwner”, 0, “com.deepin.dde.daemon.Dock”).Store(&amp;ret) #+END_SRC</p>
<p>需要注意传给 =obj.Call= 方法的第一个参数 =method= 的值是接口名 + “.” + 方法名。</p>
<p>在处理没有返回值的方法时，可以不调用 =Store= 方法，而直接检查 =Err= 字段。 *** 获取和设置属性</p>
<p>属性的获取和设置本质也是方法调用。 **** 获取属性 获取单个属性是调用对象的 =org.freedesktop.DBus.Properties= 接口的 =Get= 方法，此方法传入参数是接口名和属性名，返回值是属性值，类型为 =dbus.Variant= 。</p>
<p>下面的代码是要获取 =org.freedesktop.DBus= 接口的 =Features= 属性，此属性的类型是 =[]string= 。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) var ret dbus.Variant err = obj.Call(“org.freedesktop.DBus.Properties.Get”, 0, “org.freedesktop.DBus”, “Features”).Store(&amp;ret) v := ret.Value().([]string) #+END_SRC</p>
<p>从 =ret= 中获取内部的值，需要调用 =Value= 方法，获取 =interface{}= 类型的内部值，再使用类型断言 =.([]string)= 。</p>
<p>一次获取对象在某个接口下的全部属性，可调用 =Get= 方法旁边的 =GetAll= 方法。 **** 设置属性 设置属性是调用对象的 =org.freedesktop.DBus.Properties= 接口的 =Set= 方法，此方法的传入参数是接口名、属性名、属性值，没有返回值。</p>
<p>下面的代码是要设置 =org.freedesktop.DBus= 接口的 =Features= 属性。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) propVal := dbus.MakeVariant([]string{“abc”}) err = obj.Call(“org.freedesktop.DBus.Properties.Set”, 0, “org.freedesktop.DBus”, “Features”, propVal).Err #+END_SRC</p>
<p>传入参数中属性值是 =dbus.Variant= 类型，制造这种类型可用 =dbus.MakeVariant= 方法。 *** 监控信号 调用 =AddMatch= 方法添加监控规则，如果不需要监控了，就调用 =RemoveMatch= 方法去掉监控规则。</p>
<p>go 的 dbus 库提供了方便的方法： =AddMatchSignal= 和 =RemoveMatchSignal= 。</p>
<p>下面的代码是要监控 =Session Bus= 上的 =/org/freedesktop/Bus= 对象的 =org.freedesktop.DBus= 接口的 =NameOwnerChanged= 信号。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() err = sessionBus.BusObject().AddMatchSignal(“org.freedesktop.DBus”, “NameOwnerChanged”, dbus.WithMatchObjectPath(“/org/freedesktop/DBus”)).Err</p>
<p>signalCh := make(chan *dbus.Signal, 10) sessionBus.Signal(signalCh) go func() { for { select { case sig := &lt;-signalCh: log.Printf(“sig: %#v”, sig) if sig.Path == “/org/freedesktop/DBus” &amp;&amp; sig.Name == “org.freedesktop.DBus.NameOwnerChanged” { var name string var oldOwner string var newOwner string err = dbus.Store(sig.Body, &amp;name, &amp;oldOwner, &amp;newOwner) log.Printf(“%s %s %s”, name, oldOwner, newOwner) } } } }()</p>
<p>time.Sleep(100*time.Second) err = sessionBus.BusObject().RemoveMatchSignal(“org.freedesktop.DBus”, “NameOwnerChanged”, dbus.WithMatchObjectPath(“/org/freedesktop/Bus”)).Err sessionBus.RemoveSignal(signalCh) #+END_SRC</p>
<p>将调用 =sessionBus.Signal= 方法注册 =signalCh= 通道，以此来通过该通道接收信号， =go func ()= 中的代码是循环接收 =signalCh= 通道传来的数据并处理。如果不需要再从这个通道接收信号了，可以调用 =sessionBus.RemoveSignal= 取消注册 =signalCh= 通道，这样信号就不会再被发送到 =signalCh= 通道中了。</p>
<p>在处理信号时，可以先验证信号（ =<em>dbus.Signal= 类型）的 =Path= 和 =Name= 字段，不必验证 =Sender= 字段。 处理信号的 =Body= 字段，它是 =[]interface{}= 类型，就可以用 =dbus.Store= 方法了。 </em>** 导出对象 将自己代码中的一个变量作为对象的一个接口导出在 DBus 上，然后供其他人调用。</p>
<p>下面的代码是要把类型为 =Obj= 结构的 =obj= 变量作为对象的一个接口导出，它有一个 =GetString= 方法，路径 =/p1/p2/p3= ，接口名 =p1.p2.p3= 。</p>
<p>#+BEGIN_SRC go type Obj struct { }</p>
<p>func (o <em>Obj) GetString() (string, </em>dbus.Error) { return “object”, nil }</p>
<p>func main() { sessionBus, err := dbus.SessionBus() obj := &amp;Obj{} err = sessionBus.Export(obj, “/p1/p2/p3”, “p1.p2.p3”) log.Print(“names:”, sessionBus.Names()) select { } } #+END_SRC</p>
<p>程序运行后会打印类似的输出：</p>
<p>=names:[:1.4239 :1.4239]=</p>
<p>这是此程序目前在 DBus 上的名字，冒号 =:= 开头的是唯一名。</p>
<p>导出对象接口，可以调用 =sessionBus.Export= 方法，要停止导出，并没有一个专门的的方法，依旧要使用 =Export= 方法， 但是第一个参数（之前放 =obj= 的位置）要换成 =nil= 。</p>
<p>自动导出的方法有如下要求：</p>
<ol type="1">
<li>公开的，方法名第一字母是大写的。</li>
<li>最后一个返回值是 <em>dbus.Error 类型。 </em>*** 注册服务名 下面的代码是要申请一个服务名 =p1.p2.p3=, 不是完整代码，可以插在前一份代码的 =sessionBus.Export= 方法调用之后。现有的各个项目里也一般是先导出主要对象，然后再申请服务名。</li>
</ol>
<p>~_, err = sessionBus.RequestName(“p1.p2.p3”, 0)~</p>
<p>*** 发送信号 下面的代码是要发送信号，路径 =/p1/p2/p3=, 接口名 =p1.p2.p3=, 信号名 =Signal1= ， 参数是字符串和数字。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() for { err = sessionBus.Emit(“/p1/p2/p3”, “p1.p2.p3.Signal1”, “arg1”, 2) time.Sleep(2*time.Second) } #+END_SRC</p>
<p>程序每 2 秒发送一次信号，发送信号时，不要求对象是否已经导出。 ** 使用 go-dbus-factory 项目 此项目实现了根据 dbus 服务的自省 XML 文件和一点配置文件，自动生成访问 dbus 服务的 go 代码。</p>
<p>项目地址：https://gitlab.deepin.io/dde-v20/go-dbus-factory ，可以打成 deb 包，软件包名 =golang-github-linuxdeepin-go-dbus-factory-dev= ，每个服务放在不同的包中，包名的前缀是 =github.com/linuxdeepin/go-dbus-factory/= 。 *** 方法调用 下面的代码要调用 =com.deepin.dde.daemon.Dock= 服务的 =/com/deepin/dde/daemon/Dock= 对象的 =RequestDock= 方法。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() dockObj := dock.NewDock(sessionBus) ok, err := dockObj.RequestDock(0, “/usr/share/applications/deepin-editor.desktop”, -1) log.Println(“ok:”, ok) #+END_SRC</p>
<p>需要注意传给 =obj.Call= 方法的第一个参数 =method= 的值是接口名 + “.” + 方法名。</p>
<p>在处理没有返回值的方法时，可以不调用 =Store= 方法，而直接检查 =Err= 字段。 *** 获取和设置属性</p>
<p>属性的获取和设置本质也是方法调用。 **** 获取属性 获取单个属性是调用对象的 =org.freedesktop.DBus.Properties= 接口的 =Get= 方法，此方法传入参数是接口名和属性名，返回值是属性值，类型为 =dbus.Variant= 。</p>
<p>下面的代码是要获取 =org.freedesktop.DBus= 接口的 =Features= 属性，此属性的类型是 =[]string= 。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) var ret dbus.Variant err = obj.Call(“org.freedesktop.DBus.Properties.Get”, 0, “org.freedesktop.DBus”, “Features”).Store(&amp;ret) v := ret.Value().([]string) log.Println(v) #+END_SRC</p>
<p>从 =ret= 中获取内部的值，需要调用 =Value= 方法，获取 =interface{}= 类型的内部值，再使用类型断言 =.([]string)= 。</p>
<p>一次获取对象在某个接口下的全部属性，可调用 =Get= 方法旁边的 =GetAll= 方法。 **** 设置属性 设置属性是调用对象的 =org.freedesktop.DBus.Properties= 接口的 =Set= 方法，此方法的传入参数是接口名、属性名、属性值，没有返回值。</p>
<p>下面的代码是要设置 =org.freedesktop.DBus= 接口的 =Features= 属性。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) propVal := dbus.MakeVariant([]string{“abc”}) err = obj.Call(“org.freedesktop.DBus.Properties.Set”, 0, “org.freedesktop.DBus”, “Features”, propVal).Err #+END_SRC **** 监控信号 下面的代码是要监控之前说过的 =Dock= 对象的 =EntryAdded= 信号。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() dockObj := dock.NewDock(sessionBus) sigLoop := dbusutil.NewSignalLoop(sessionBus, 10) sigLoop.Start() dockObj.InitSignalExt(sigLoop, true) sigHid, err := dockObj.ConnectEntryAdded(func(entryPath dbus.ObjectPath, index int32) { log.Println(entryPath, index) })</p>
<p>time.Sleep(100*time.Second) sigLoop.Stop() dockObj.RemoveHandler(sigHid) #+END_SRC</p>
<p>程序运行后，从启动器打开一个任务栏上之前没有的应用，然后程序就能收到 =EntryAdded= 信号并打印参数值出来。</p>
<p>这部分代码用到了新的包 =pkg.deepin.io/lib/dbusutil= 包，使用它的 =SignalLoop= 功能来处理信号。调用 =dbusutil.NewSignalLoop= 创建一个信号循环，然后调用 =Start= 方法开始，当不需要时调用 =Stop= 结束。 =dockObj= 默认是不支持监听信号的，直接调用 =dockObj.ConnectXXX= 方法会崩溃，必须先调用 =InitSignalExt= 方法，传入 SignalLoop。 ** 使用 dbusutil 包 之前介绍了使用 dbus1 包，现在介绍使用更多的 dbusutil 包，它是对 dbus1 包的功能的一次包装，更加偏向于导出服务。</p>
<p>*** 导出对象 #+BEGIN_SRC go type Obj struct { methods *struct { GetString func() <code>out:"result"</code> } }</p>
<p>func (o <em>Obj) GetString() (string, </em>dbus.Error) { return “object”, nil }</p>
<p>func (o *Obj) GetInterfaceName() string { return “p1.p2.p3” }</p>
<p>func main() { service, err := dbusutil.NewSessionService() obj := &amp;Obj{ } err = service.Export(“/p1/p2/p3”, obj) err = service.RequestName(“p1.p2.p3”) service.Wait() } #+END_SRC</p>
<p>在 =main= 方法中，使用 =dbusutil.NewSessionService= 创建 =<em>dbusutil.Service= 类型的变量 =service= ，然后调用 =service.Export= 方法导出 =obj= 变量。要导出 =obj= 变量，就得让它的类型 =</em>Obj= 实现 =GetInterfaceName= 方法，此方法要返回接口名。 *** 定义属性 定义一个属性的简单方式是，给导出的结构增加公开字段，比如想要导出 =Obj= 结构，导出的接口 =p1.p2.p3= 中会有一个 =Name= 属性，类型为字符串，就要有如下定义：</p>
<p>#+BEGIN_SRC go type Obj struct { Name string } #+END_SRC</p>
<p>这个 =Name= 属性是只读的，如果要让它可以写、设置，就要给 =Name= 字段加上结构字段 =tag= : =prop:“access:rw”= ， 如下：</p>
<p>#+BEGIN_SRC go type Obj struct { Name string <code>prop:"access:rw"</code> } #+END_SRC *** 发送信号 下面的代码是要发送信号，路径 =/p1/p2/p3=, 接口名 =p1.p2.p3=, 信号名 =Signal1= ， 参数是字符串和数字。</p>
<p>#+BEGIN_SRC go</p>
<p>type Obj struct { signals *struct { Added struct { arg0 string arg1 int32 } } }</p>
<p>func (o *Obj) GetInterfaceName() string { return “p1.p2.p3” }</p>
<p>func main() { service, err := dbusutil.NewSessionService() obj := &amp;Obj{ } err = service.Export(“/p1/p2/p3”, obj) err = service.RequestName(“p1.p2.p3”) for { err = service.Emit(obj, “Added”, “val0”, 11) time.Sleep(2*time.Second) } } #+END_SRC</p>
<p>要点是在定义 Obj 结构时，加上 =signals= 字段，并在 =signals= 字段类型定义结构中加上 =Added= 字段 ，然后调用 =service.Emit= 方法发送信号。 *** 发送属性改变信号 下面的代码是要发送属性改变信号，路径 =/p1/p2/p3=, 接口名 =p1.p2.p3=, 属性名 =Name= ，类型字符串。</p>
<p>#+BEGIN_SRC go type Obj struct { Name string }</p>
<p>func (o *Obj) GetInterfaceName() string { return “p1.p2.p3” }</p>
<p>func main() { service, err := dbusutil.NewSessionService() obj := &amp;Obj{ } err = service.Export(“/p1/p2/p3”, obj) err = service.RequestName(“p1.p2.p3”) for { err = service.EmitPropertyChanged(obj, “Name”, “name1”) time.Sleep(2*time.Second) } } #+END_SRC</p>
<p>要点是先在 Obj 结构中定义一个属性 =Name= ，然后调用 =service.EmitPropertyChanged= 方法发送属性改变信号。</p>
<ul>
<li>gsettings in go gsettings 是 gio 提供的功能，go 语言要用就得用 cgo 包装一下，这部分代码是由 =go-gir-generator= 工具自动生成的，软件包 =golang-gir-gio-2.0-dev= 提供了源码文件，安装之后放在 =/usr/share/gocode/src/pkg.deepin.io/gir/gio-2.0= 文件夹下。</li>
</ul>
<p>项目地址： https://gitlab.deepin.io/github-linuxdeepin-mirror/go-gir-generator</p>
<p>** 简单使用 下面的代码是要获取和设置 gsettings =ca.desrt.dconf-editor.Demo= 的几个设置项。</p>
<p>#+BEGIN_SRC go gs := gio.NewSettings(“ca.desrt.dconf-editor.Demo”) str := gs.GetString(“string”)</p>
<p>gs.SetString(“string”, str)</p>
<p>int0 := gs.GetInt(“integer-32-signed”)</p>
<p>gs.SetInt(“integer-32-signed”, int0) gs.Unref() #+END_SRC</p>
<p>=NewSettings= 方法，创建 Settings 对象。 =GetString= 方法获取字符串类型的设置项的值，=SetString= 方法设置字符串类型的设置项的值。 =GetInt= 方法获取整数 int32 类型的设置项的值，=SetInt= 方法设置整数 int32 类型的设置项的值。 =Unref= 方法，在不再需要 gs 对象时，减少引用计数的值。 ** 监听改变信号（原生） 下面的代码是要监听 gsettings =ca.desrt.dconf-editor.Demo= 的 =boolean= 设置项的值改变事件。</p>
<p>#+BEGIN_SRC go gs := gio.NewSettings(“ca.desrt.dconf-editor.Demo”) gs.Connect(“changed::boolean”, func(gs *gio.Settings, key string) { boolean := gs.GetBoolean(key) log.Println(boolean) }) glib.StartLoop() #+END_SRC</p>
<p>调用 =Connect= 方法注册事件监听处理函数，第一个参数为事件名，第二个参数为事件处理函数。</p>
<p>=glib.StartLoop()= 开始一个 Main Loop 事件循环。 ** 监听改变信号（dbus 实现） 由于原生的信号监听方式之前在一种特殊架构上偶尔出现发生了改变事件但不触发处理函数的问题，于是写了另外一种信号监听方式，来规避这种问题。</p>
<p>下面的代码使用了另外一个包 =pkg.deepin.io/lib/gsettings= 也实现了监听 =boolean= 设置项的值改变事件。</p>
<p>#+BEGIN_SRC go gs := gio.NewSettings(“ca.desrt.dconf-editor.Demo”) gsettings.ConnectChanged(“ca.desrt.dconf-editor.Demo”, “boolean”, func(key string) { boolean := gs.GetBoolean(key) log.Println(boolean) }) err := gsettings.StartMonitor() select { } #+END_SRC</p>
<p>=ConnectChanged= 方法注册改变事件的处理函数，第一个参数是 =schema id= ， 第二个参数是设置项名，第三个参数是事件处理函数。</p>
<p>=StartMonitor= 方法开始监听循环。 ** dbus 服务中作为属性 下面的代码是要导出 DBus 服务，服务名 =p1.p2.p3=, 对象路径 =/p1/p2/p3=, 接口名 =p1.p2.p3= ，把 gsettings =ca.desrt.dconf-editor.Demo= 的 =boolean= 设置项当作接口的属性。</p>
<p>#+BEGIN_SRC go type Obj struct { Boolean gsprop.Bool <code>prop:"access:rw"</code> }</p>
<p>func (o *Obj) GetInterfaceName() string { return “p1.p2.p3” }</p>
<p>func main() { gs := gio.NewSettings(“ca.desrt.dconf-editor.Demo”)</p>
<pre><code>service, err := dbusutil.NewSessionService()

obj := &amp;Obj{}
obj.Boolean.Bind(gs, &quot;boolean&quot;)
log.Println(&quot;get result:&quot;, obj.Boolean.Get())

err = service.Export(&quot;/p1/p2/p3&quot;, obj)
err = service.RequestName(&quot;p1.p2.p3&quot;)
err = gsettings.StartMonitor()
service.Wait()</code></pre>
<p>} #+END_SRC</p>
<p>这算是 gsettings 与 dbusutil 包知识相结合的内容。</p>
<p>要点是 Obj 结构定义了一个公开字段 =Name= ，类型为 =gsprop.Bool= ，然后调用 =Bind= 方法绑定了 =gs= 的 =boolean= 设置项和 =obj= 的 =Name= 属性的关联，使得对 =Name= 属性的读写即是对 =gs= 的 =boolean= 设置项的读写， 如果 =gs= 的 =boolean= 设置项的值改变会自动发出 =Name= 属性改变信号。</p>
<p>gsprop 包中还有其他的类型，来支持各种数据类型，比如 =String=，=Int=，=Uint= 等。</p>
<p>同样要记得调用 =StartMonitor= 方法开始监听循环。</p>]]></description>
    <pubDate>Wed, 7 Apr 2021 14:34:21 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[搭建VNC服务器]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/Linux/%e6%90%ad%e5%bb%baVNC%e6%9c%8d%e5%8a%a1%e5%99%a8.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/Linux/%e6%90%ad%e5%bb%baVNC%e6%9c%8d%e5%8a%a1%e5%99%a8.html</guid>
    <description><![CDATA[<p>#+TITLE: 搭建VNC服务器 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>搭建 VNC 服务器 服务器上安装 x11vnc，构建 vnc 的服务端：</li>
</ul>
<p>~sudo apt-get install x11vnc~</p>
<p>设置并存储 vnc 连接密码</p>
<p>~sudo x11vnc -storepasswd <password> /etc/x11vnc.pass~</p>
<p>启动 x11vnc 服务端</p>
<p>~sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -shared -noxdamage -xrandr “resize” -rfbport 5900~</p>
<p>无密码启动 vnc</p>
<p>~sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -noxdamage -xrandr “resize” -rfbport 5900~</p>]]></description>
    <pubDate>Wed, 7 Apr 2021 14:34:21 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[性能分析]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/C++/%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/C++/%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90.html</guid>
    <description><![CDATA[<p>#+TITLE: 性能分析 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>google-perftools ** 介绍 性能分析通过抽样方法完成，默认是 1 秒 100 个样本，一个样本是 10 毫秒，即时间单位是 10 毫秒；可以通过环境变量 CPUPROFILE_FREQUENCY 设置采样频率。</li>
</ul>
<p>CPU profiler 是基于采样工作的。所以采样次数影响着性能报告的准确性。如果采样次数过少，则你会发现同样的程序同样的数据，每次输出的性能报告中的热点都不一样。 ** 使用方法 *** 直接调用 API 在代码中调用 <sub>ProfilerStart</sub> 和 <sub>ProfilerStop</sub> 这两个函数。 *** 链接静态库 在代码 link 过程中添加参数 –lprofiler</p>
<p>~gcc […] -o helloworld –lprofiler~</p>
<p>运行程序： ~CPUPROFILE=./helloworld.prof ./helloworld~</p>
<p>指定要 profile 的程序为 helloworld，并且指定产生的分析结果文件的路径为./helloworld.prof *** 链接动态库 这种方式和静态库的方式差不多，但不用重新编译或重新链接，所以使用非常方便。只需要在运行时添加 LD_PRELOAD 变量。</p>
<p>~LD_PRELOAD=“/usr/lib/libprofiler.so” CPUPROFILE=./helloworld.prof ./helloworld~ *** 使用信号触发 profile **** 手动设置信号 由于我们的程序有可能是服务程序，而服务程序不会自动执行完退出，如果以 =ctrl+c= 退出也不是正常的 =exit(0)= 的方式退出，而这会导致我们在 profile 的时候，收集到的数据不全甚至是空的，采用如下解决办法：</p>
<p>将 <sub>ProfilerStart</sub> 和 <sub>ProfilerStop</sub> 这 2 个函数封装到两个信号处理函数中，给服务程序发信号 SIGUSR1，就开始 profile，给服务程序发信号 SIGUSR2，就停止 profile。这样我们可以随时对程序进行 profiling，并获得数据。代码如下：</p>
<p>#+BEGIN_SRC C #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;google/profiler.h&gt;</p>
<p>//SIGUSR1: start profiling //SIGUSR2: stop profiling</p>
<p>static void gprof_callback(int signum) { if (signum == SIGUSR1) { printf(“Catch the signal ProfilerStart”); ProfilerStart(“bs.prof”); } else if (signum == SIGUSR2) { printf(“Catch the signal ProfilerStop”); ProfilerStop(); } }</p>
<p>static void setup_signal() { struct sigaction profstat; profstat.sa_handler = gprof_callback; profstat.sa_flags = 0; sigemptyset(&amp;profstat.sa_mask); sigaddset(&amp;profstat.sa_mask, SIGUSR1); sigaddset(&amp;profstat.sa_mask, SIGUSR2);</p>
<p>if ( sigaction(SIGUSR1, &amp;profstat,NULL) &lt; 0 ) { fprintf(stderr, “Fail to connect signal SIGUSR1 with start profiling”); } if ( sigaction(SIGUSR2, &amp;profstat,NULL) &lt; 0 ) { fprintf(stderr, “Fail to connect signal SIGUSR2 with stop profiling”); } }</p>
<p>int main(int argc,char** argv) { // // … //</p>
<p>setup_signal();</p>
<p>// // … //</p>
<p>return 0; } #+END_SRC</p>
<p>启动程序后，可以采用 kill -s SIGUSR1 <pid> 和 kill -s SIGUSR2 <pid> 来开始采样和停止采样。 **** 使用 CPUPROFILESIGNAL 设置信号 设置的信号必须是正常情况下未被程序使用的。</p>
<p>~CPUPROFILE=./helloworld.prof CPUPROFILESIGNAL=12 ./helloworld~</p>
<p>可以使用 ~killall -12 hellworld~ 触发 profile 开始，然后过一段时间后再次使用 ~killall -12 hellworld~ 触发 profile 结束并生成文件。 ** 数据分析 *** 生成数据 1. 生成文字数据 ~google-pprof <bin path> <profile path> –text~ 2. 生成网页数据 ~google-pprof <bin path> <profile path> –web~ *** 数据含义 每一列的数据解释：</p>
<ol type="1">
<li>该函数中的采样数量</li>
<li>该函数中的采样百分比</li>
<li>到目前为止打印的函数中的采样百分比</li>
<li>该函数和被其调用的函数中的采样数量</li>
<li>该函数和被其调用的函数中的采样百分比</li>
</ol>
<ul>
<li>gprof ** 介绍 grof 可以获取 C 程序运行期间的统计数据，如每个函数的耗时，调用次数及各个函数的调用关系，（gprof 统计的是 CPU 占用时间，I/O 时间不计算在内。通常 gprof 的采样周期是 0.01s，统计项越接近这个值误差可能越大。若函数的运行时间低于 0.01S，统计值会显示为 0。</li>
</ul>
<p>类似于 gdb，gprof 需要对待分析的程序做一些改动，因此在程序编译的时候需要加上“-pg”选项，如果程序的某个模块在编译的时候没有加上“-pg”，则该模块的函数会被排除在统计范围之外。比如想要查看库函数的 profiling，则需在链接库函数的时候用“-lc_p”代替”-lc“（gprof 是各个类 UNIX 的标准工具，系统自带的链接库通常有两个版本，它们的区别在于编译的时候是否加上了”-pg“。用-lc_p 等于告诉编译器选择加上了”-pg“的那个版本）。 加上”-pg"选项后，程序的入口会于 main()之前调用 monstartup()，主要是申请内存存储接下来获取的统计信息。</p>
<p>在每个函数中会调用_mcount()，主要是在函数的堆栈中查询父函数和子函数的地址并保存下来。最后会在程序退出前调用_mcleanup()，将统计结果保存到 gmon.out 中，并完成清除工作。</p>
<p>gprof 统计各个函数的运行时间是采用的抽样的方法，周期性的查看 Programcounter 指向哪一个函数的地址段，并把结果以直方图的形式保存下来。 ** 使用方法 1. 编译时添加选项 =-pg= 2. 运行程序，生成 gmonf.out 文件 3. 使用 gprof 进行分析， ~gprof <bin path> <gmonf path>~ ** 数据分析 *** Flat Profile 示例图 | 标注 | 释义 | |——————–+———————————————————–| | %time | 每个函数占用的时间比例，所有函数占比和为 100% | | cumulative seconds | 函数及其调用函数执行累计占用时间 | | self seconds | 单独函数执行累计占用时间 | | calls | 函数调用次数 | | self ms/call | 每次调用函数花费的时间,单位毫秒, 不包含调用函数运行的时间 | | total ms/call | 每次调用函数花费的时间,单位毫秒,包括调用函数运行的时间 | | name | 函数名称 | *** Call Graph 示例图 | 标注 | 释义 | |———-+————————————————————————–| | index | 每个函数第一次出现时分配一个编号，根据编号可以方便查找函数的具体分析数据 | | %time | 函数以及调用子函数所占用的总运行时间的百分比 | | self | 函数的总运行时间 | | children | 子函数执行的总时间 | | called | 函数被调用的次数，不包括递归调用 | | name | 函数名称, name 列中，可查看函数之间的调用关系 |</p>]]></description>
    <pubDate>Wed, 7 Apr 2021 14:34:21 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[self-host mail]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/self-host%20mail.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/self-host%20mail.html</guid>
    <description><![CDATA[<p>#+TITLE: self-host mail #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li><p>DNS record ** SPF 全名 Sender Policy Framework，用来鉴别发送邮件的服务器或者 IP，是否为该域允许的范围。 这需要在发送邮件的域名下添加一条 TXT 记录，举个例子： =example.net. TXT “v=spf1 mx a:pluto.example.net include:aspmx.googlemail.com -all” v=spf1= 做开头为必须，spf1 说明这是第一版 spf 协议 SPF 规定有 6 种机制：</p></li>
<li><p>ALL 匹配所有的结果，一般放在最后</p></li>
<li><p>A 匹配所有该域的 A 记录</p></li>
<li><p>MX 匹配所有该域的 MX 记录</p></li>
<li><p>IP4 所有之后的 IPv4 地址，可以用 mask 匹配多项，比如：192.168.0.0/24</p></li>
<li><p>IP6 所有之后的 IPv6 地址，同 IPv4</p></li>
<li><p>INCLUDE 去之后对应地址查找，比如 INCLUDE:spf.34nm.com，就是去 spf.34nm.com 继续查找 TXT/SPF 记录</p></li>
</ul>
<p>还有四种修饰符分别意义是：</p>
<ul>
<li>“+“：允许，默认记录都是允许</li>
<li>“-“：不允许</li>
<li>“~“：中立，也就是没有相关策略</li>
<li>“?“：同样是中立，但是为 debug</li>
</ul>
<p>这样例子中 =example.net. TXT “v=spf1 mx a:pluto.example.net include:aspmx.googlemail.com -all”= 的意思是</p>
<table>
<thead>
<tr class="header">
<th>mx</th>
<th>允许所有 MX 记录</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a:pluto.example.net</td>
<td>pluto.example.net 的 A 记录也允许</td>
</tr>
<tr class="even">
<td>include:aspmx.googlemail.com</td>
<td>其余记录参考 aspmx.googlemail.com</td>
</tr>
<tr class="odd">
<td>-all</td>
<td>拒绝所有其他记录</td>
</tr>
</tbody>
</table>
<p>** DKIM 由于 SPF 天生只验证是否可以发信, 不保证这个发信人是验证的,因此,SPF 验证通过的仍然可能是伪造的邮件. 这就需要 DKIM 来进一步保证这封邮件不是伪造的. 在特殊的子域名”_domainkey”(例如:_domainkey.example.com)的 TXT 记录中插入一对 RSA 密钥中的公钥, 而 RSA 的私钥用来加密邮件的部分字段. 收到邮件的服务器发现有 DKIM-SIGNATURE 字段时,会自动校验 DKIM 的公钥, 按照匹配程度进行处理. 这样就完成了验证.</p>
<p>#+BEGIN_EXAMPLE +—————+ +—————–+ | SenderServer | | ReceiverServer | +—————+ +—————–+ | —————–  | |-| Calculate DKIM | | | |—————-| | | | | Send singed mail | |—————————&gt;| | | | Check DKIM record | |&lt; ————————–| | | —————————<br />
| |-| OK, found key and verify | | | |————————–| | | #+END_EXAMPLE</p>
<p>还可以在特殊子域名之上,再建立一堆域名,例如 authmail._domainkey.example.com,这样在校验邮件时还可以选择不同的密钥. 协议的内容相对来说就简单很多了,只有三种值:</p>
<ul>
<li>v=DKIM1; 使用 DKIM 第一版协议</li>
<li>k=rsa; 使用 RSA 加密</li>
<li>p=长长的一段公钥</li>
</ul>
<p>** DMARC</p>
<p>该验证的都验证了,还有个 DMARC 是干吗的呢? 这是为了给域名邮件的拥有者报告垃圾邮件的状况而设定的规则. 和之前的方法一样,在_dmarc.example.com 下面设定自己的 DMARC 规则, 具体就参考 Google 提供的文档吧.</p>
<p>https://support.google.com/a/answer/2466580?hl=zh-Hans&amp;ref_topic=2759254</p>
<ul>
<li><p>self-host service</p></li>
<li><p>Poste.io</p>
<ul>
<li>https://poste.io</li>
<li>Demo: https://demo.poste.io/admin/login#admin@poste.io;admin</li>
<li>1 GiB RAM</li>
</ul></li>
<li><p>Mailu</p>
<ul>
<li>https://mailu.io/1.7/index.html</li>
<li>Github: https://github.com/Mailu/Mailu</li>
<li>Demo: https://test.mailu.io/admin admin@test.mailu.io/letmein</li>
<li>at least 2GB of total memory and 1GB of free memory</li>
</ul></li>
<li><p>docker-mailserver</p>
<ul>
<li>Github: https://github.com/tomav/docker-mailserver</li>
<li>Recommended: 1-2GB RAM, Minimum 512MB RAM</li>
<li>NO webpanel</li>
</ul></li>
<li><p>mailcow</p>
<ul>
<li>https://mailcow.email/</li>
<li>Github: https://github.com/mailcow/mailcow-dockerized</li>
<li>Demo: https://demo.modoboa.org admin/moohoo</li>
<li>3 GiB RAM</li>
</ul></li>
<li><p>modoboa</p>
<ul>
<li>https://modoboa.org/en/</li>
<li>Demo: https://demo.modoboa.org/</li>
<li>2 GB RAM</li>
</ul></li>
<li><p>Mail-in-a-Box</p></li>
<li><p>Zarafa</p></li>
<li><p>Kopano</p></li>
<li><p>IRedMail</p></li>
<li><p>EwoMail</p></li>
<li><p>https://www.reddit.com/r/selfhosted/comments/bmsum7/selfhosted_email_setup_howto/</p></li>
<li><p>Links</p></li>
</ul>
<ol type="1">
<li>[[https://wiki.archlinux.org/index.php/Mail_server][Mail server/archwiki]]</li>
<li>[[https://newpants.top/2019/11/14/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8Poste%E4%BA%94%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA/][邮件服务器 Poste 五分钟搭建]]</li>
</ol>]]></description>
    <pubDate>Wed, 7 Apr 2021 14:34:21 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[酒吧圣经笔记]]></title>
    <link>https://www.codeplayer.org/Wiki/Others/%e9%85%92%e5%90%a7%e5%9c%a3%e7%bb%8f%e7%ac%94%e8%ae%b0.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Others/%e9%85%92%e5%90%a7%e5%9c%a3%e7%bb%8f%e7%ac%94%e8%ae%b0.html</guid>
    <description><![CDATA[<p>#+TITLE: 酒吧圣经笔记 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>开胃酒 Aperitifs 我们将苦酒、味美思、金鸡纳酒和茴香酒都归为开胃酒。开胃酒有许多共性。第一，它们有相同的起源，在黑暗时代都是用作药。这使得开胃酒同利口酒很近似；第二，开胃酒在生产中具有许多共同点；最后，开胃酒的最大相似点——每种酒都各有特色各不相同。如果这些酒的口味和颜色没有区别，那酒吧会变得非常枯燥无聊。</li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th>苦艾酒</th>
<th>茴香酒</th>
<th>苦酒</th>
<th>味美思</th>
<th>金鸡纳酒</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>酒基</td>
<td>酒精</td>
<td>酒精</td>
<td>酒精</td>
<td>白葡萄酒</td>
<td>葡萄酒</td>
</tr>
<tr class="even">
<td>香料</td>
<td>艾草和</td>
<td>绿大茴香，</td>
<td>龙胆，陈皮，</td>
<td>艾草，</td>
<td>金鸡纳树皮，</td>
</tr>
<tr class="odd">
<td></td>
<td>其他药草</td>
<td>八角，茴香…</td>
<td>其他香料</td>
<td>金鸡纳树皮，龙胆…</td>
<td>陈皮和药草</td>
</tr>
<tr class="even">
<td>酒度</td>
<td>达 72 度</td>
<td>25-51 度</td>
<td>6-50 度</td>
<td>15-23 度</td>
<td>15-23 度</td>
</tr>
<tr class="odd">
<td>用途</td>
<td>开胃酒</td>
<td>开胃酒</td>
<td>开胃酒，消化酒</td>
<td>开胃酒，任何时候可饮</td>
<td>开胃酒</td>
</tr>
<tr class="even">
<td>最好的混合用料</td>
<td>水和糖</td>
<td>水、</td>
<td>酒、果汁等</td>
<td>苏打水，柠檬，</td>
<td>苏打水，</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>甜薄荷汁和甜柠檬汁</td>
<td></td>
<td>奎宁水，果汁，酒</td>
<td>果汁，酒</td>
</tr>
<tr class="even">
<td>著名的鸡尾酒</td>
<td>下午死去</td>
<td>鹦鹉</td>
<td>美国佬</td>
<td>干马天尼</td>
<td>杜本内鸡尾酒</td>
</tr>
<tr class="odd">
<td></td>
<td>飞翔的荷兰人</td>
<td></td>
<td>尼格罗尼</td>
<td>曼哈顿</td>
<td></td>
</tr>
</tbody>
</table>
<p>** 苦艾酒 Absinthe 苦艾酒的历史源于瑞士。18 世界奥尔基内尔医生用当前的植物——星形大茴香及 Artemisia Absinthium（一种艾草）制成药酒，他将这种药酒用于改善自己病人的脑力活动。这种淡绿色苦味的药酒疗效显著。 *** 现代苦艾酒 不久前欧洲法律放宽了对含有艾草酒的限制，规定根据酒精浓度的高低不同每升酒含 5-10 毫升侧卜酮。此后，商标上注有 Absinthe（苦艾酒）的许多款酒问世了。 ** 茴香酒 Anises *** 茴香酒的历史 茴香酒源于地中海地区。这里的人们自古以来就知道大茴香可入药。茴香酒获得巨大成功还是在欧洲禁止生产苦艾酒以后。当然茴香酒的生产商达成了如下协议： - 具有迷幻成分的侧柏酮存在于艾草皮中。因此，要用艾草的根和叶来酿酒。 - 各种大茴香和茴香可为酿酒提供必须的跟水接触能产生结晶的茴香脑。 - 一些甘草和其他的香草叶已列入茴香酒的配方中，应保持原料成分的统一。 - 这样酿制的酒同真正的茴香酒口味差别不大，略带苦味。 *** 茴香酒的生产 欧洲的法规规定：茴香酒的独特芬香应出自于绿色的大茴香，星形大茴香或者茴香这些香料。实际上生产中经常使用的就是这三种香料。星形大茴香，又叫八角，产于越南北部。它能使酒口味强烈，而绿色大茴香使酒口味绵长，略带甜味。再添加各种香草和少量甘草，可增酒酒的香气。 将以上各种植物连根放在酒精中泡软，然后浸酒蒸馏。最后在馏出物中添加水和少量的糖。 这样酿好的茴香酒的浓度在 25-51 度之间。 ** 味美思 Vermouth *** 酿造史 味美思有着悠久的历史。公元前 4 世纪在有关希波克拉底（Hippocrat）的穿梭中最早提及到味美思的“祖先”——Vinum Absinthiatum。含有药草、松脂的有色葡萄酒在古代被广为接受。后来威尼斯的商人从世界各地往意大利带回很多种调料：豆蔻、甘菊、丁香、生姜和其他香料。这些香料为完善当时用于医学目的的葡萄酒的香型注入了新的动力。“味美思”（wermut wein）这个词本身产生于巴伐利亚的宫廷，使意大利的草药医生阿列西奥创造的。 17 世纪味美思的生产开始真正发展起来，意大利皮埃蒙特大取的都灵市成为味美思的发展中心。这里可以生产干葡萄酒和甜白葡萄酒。这个地区的阿尔卑斯山山坡上可以采到富含香味的植物。 *** 味美思的生产 每个公司都按各自的秘方生产味美思，但仍可找到一些共同点。通常是以从一些区域运来的各种白葡萄酒为基酒。有时基酒混合物要陈化一段时间，通常在大橡木桶中储存一年。 主要香料有：艾草——味美思因其而得名（wermut 德语“艾草”）；金鸡纳树树皮、桂皮、龙胆、柯拉子、生姜、当归、甘菊、调料丁香、苦橘子皮、香草荚等等，有时香料数量能达到 40 种。这些植物的萃取物是通过酒精浸泡或者蒸馏获得的。再将植物萃取液、适量的糖和纯酒精加入葡萄酒中混合。 红色味美思使用胭脂红和焦糖上色的。所用成分和比例决定了每种产品和类型的味美思的口味。 酿制的味美思有时需陈化，再经过滤、巴氏消毒后分瓶包装。 *** 种类 1. 意大利 味美思产于都灵地区。口味通常略甜些。其中最普及的是： - Vermouth Extra Dry 干味美思，每升酒含糖量不超过 40 毫升。 - Vermouth Bianco 白味美思，每升含糖 100-150 毫升。 - Vermouth Rose 桃红味美思。 - Vermouth Rosso 红味美思，它的琥珀色是焦糖产生的。每升含糖 150 毫升。</p>
<p>著名生产商：马天尼（Martini &amp; Rossi）、仙山路（Cinzano），卡帕诺（Carpano，Barbero），利开多诺（Riccadonna）。 2. 法国 味美思使以固定品种的葡萄酿成的干白味基酒酿造的。酒呈金黄色，口味通常更为干醇。 著名生产商：诺利·普拉 Noilly Prat（最好的干型味美思），里丽 Lillet，以及萨瓦省（曾属意大利）的尚贝里地区的一些企业。 * 威士忌 Whisky *** 无休止的争论 爱尔兰人和苏格兰人一直就威士忌酒的发明权争论不休。但无论哪一方，都没有足够确凿的证据。 ** 苏格兰威士忌 Scotch Whisky *** 曲折的经历 早在 15 世纪，蒸馏酒在苏格兰流行起来。但在当时，蒸馏还比较原始，并且只能生产粗糙的酒。</p>
<p>在 16 世纪和 17 世纪，苏格兰人在蒸馏领域进行了大胆的技术改进。第一次改进发生在修道院被关闭之后。僧侣们掌握了比任何人都多的蒸馏技术，它们把这些几个世纪秘密积累在修道院高墙之内的经验与酿酒师们分享。技术的进步表现在蒸馏中。酿酒师们逐渐学会了利用冰水来冷却蛇形管。在 16 世纪中叶，蒸馏釜就具有了今天的葱头形状。 *** 苏格兰威士忌的种类 苏格兰威士忌在使用的原料、蒸馏和陈年的方式上各不相同。可以分成四大类：</p>
<p><em>单一麦芽威士忌（Single Malt）</em> 以发芽的大麦为原料酿造。</p>
<p><em>纯麦芽威士忌（Pure Malt）</em> 它使各种单一麦芽威士忌的混合物</p>
<p><em>调和型威士忌（Blend）</em> 它使麦芽威士忌和谷物威士忌的混合物</p>
<p><em>谷物威士忌（Grain Whisky）</em> 谷物威士忌主要用来生产调和型威士忌，偶尔也单独出售。 *** 爱尔兰威士忌与苏格兰威士忌的法规 1909 年颁布的不列颠法律调节了威士忌的生产。它规定了在如下条件下，通过蒸馏混合谷物的方式获得的蒸馏酒称做威士忌 Whisky（或者为 Whiskey）。</p>
<ul>
<li>谷物中的糖通过麦芽中含有的淀粉酶分解出来，不适用管理部门禁止使用的其他种类的酶。</li>
<li>在酵母的作用下进行发酵。</li>
<li>为使馏出物保持有使用的原料的芬香，蒸馏结束时酒的浓度不超过 94.8%。</li>
<li>酒在木桶中贮藏不低于 3 年。</li>
</ul>]]></description>
    <pubDate>Wed, 7 Apr 2021 14:34:21 +0800</pubDate>
    </item>
</channel>
</rss>
