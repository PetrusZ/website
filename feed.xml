<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
<title>codeplayer</title>
<atom:link href="https://www.codeplayer.org/publish/feed.xml" rel="self" type="application/rss+xml" />
<link>https://www.codeplayer.org</link>
<description>codeplayer wiki</description>
    <item>
    <title><![CDATA[语法框架]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e8%af%ad%e6%b3%95%e6%a1%86%e6%9e%b6.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e8%af%ad%e6%b3%95%e6%a1%86%e6%9e%b6.html</guid>
    <description><![CDATA[<p>#+TITLE: 语法框架 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>介绍 英语语法的目的：造句。</li>
<li>句子的成分 #+begin_quote <em>什么</em> /怎么样/ = 主语 + 谓语 #+end_quote</li>
</ul>
<p>“什么”和“怎么样”分别对应了两个最基本的“句子成分”——“主语”（subject）和“谓语”（predicate）。</p>
<p>主语一般为人或物，不管抽象或者具体。谓语为“动作”或发生了什么事。广义上的“动作”是语法上的“动词”。 ** 有哪些“动作”（动词） 5 种动词 -&gt; 5 种”基本句型“ 1. 可以独立完成的动作： <em>不及物动词</em></p>
<p><em>主语+（不及物）动词</em></p>
<p>Papa Rabbit <em>sleeps</em>. 2. 有 <em>一个</em> 动作的承受者： <em>单及物动词</em></p>
<p><em>主语+（单及物）动词+宾语</em></p>
<p>Papa Rabbit <em>likes</em> /<em>you</em>/. 3. 有 <em>两个</em> 动作的承受者： <em>双及物动词</em></p>
<p><em>主语+（双及物）动词+间接宾语+直接宾语</em></p>
<p>Papa Rabbit <em>teaches</em> /<em>you</em>/ /English/.</p>
<p>其中”you“为间接宾语，”English“为直接宾语 4. 只有一个动作承受者（不同于 2）： <em>复杂及物动词</em></p>
<p><em>主语+（复杂及物）动词+宾语+（宾语）补语</em></p>
<p>Papa Rabbit <em>considers</em> /<em>you</em>/ /smart/.</p>
<p>其中”smart“为（宾语）补语 5. 把这个词后面的信息赋予给前者： <em>系动词</em></p>
<p><em>主语+（系）动词+（主语）补语</em></p>
<p>主语补语也是表语</p>
<p>Papa Rabbit <em>is</em> tall. / Papa Rabbit <em>&lt;-</em> tall. / Papa Rabbit <em>=</em> tall.</p>
<p>Papa Rabbit <em>looks</em> tall. / Papa Rabbit <em>&lt;-</em> tall.</p>
<p>把后者信息赋予前者 ** 快速小结 英语中的所有句子，当拆到不能再拆后，都是在说： <em>什么</em> /怎么样/ 。”什么“是语法中的主语，”怎么样“是谓语，谓语都有一个核心动词，叫做谓语动词。</p>
<p>*** 谓语动词 1. 无承受者</p>
<p>主语 + <em>动词</em> 2. 一个承受者</p>
<p>主语 + <em>动词</em> + /<em>宾语</em>/ 3. 两个承受者</p>
<p>主语 + <em>动词</em> +（间接） /<em>宾语</em>/ + （直接） /<em>宾语</em>/ 4. 一个承受者（不同于 2）</p>
<p>主语 + <em>动词</em> + /<em>宾语</em>/ + （宾语） /补语/ 5. 赋予信息</p>
<p>主语 + <em>动词</em> + （主语） /补语/ （表语）</p>
<p>谓语和谓语动词是有区别的，句子主语后面的余下句子部分都是谓语，谓语动词只是谓语的一部分。与谓语动词相对的，还有 <em>非</em> 谓语动词。 ** 句子成分 1. 主语 Subject 2. 谓语动词（~谓语） Predicate Verb 3. 宾语 Object 4. 宾语补语 Object Complement 5. 主语补语（表语） Subject Complement 6. 定语 Attributive</p>
<p>主要用来修饰主语或宾语</p>
<p><em>The little white</em> rabbit ate <em>a large</em> carrot.</p>
<p>“The little white”是”rabbit”的定语，“a large”是“carrot”的定语 7. 状语 Adverbial</p>
<p>主要用来修饰谓语动词</p>
<p>The rabbit ate <em>quickly</em>.</p>
<p>“quickly”就是“ate”的状语 8. 同位语 Appositive</p>
<p>主要用来再把主语或宾语说一遍</p>
<p>Papa Rabbit, <em>an English teacher</em>, eats a carrot.</p>
<p>“an English teacher”其实就是把“Papa Rabbit”用不同方式再说一遍，在这里算是和主语同等地位 ** 简单句的组合 以上所说的都是简单句，简单句互相组合就形成了 Compound Sentence 复合句，还有 Complex Sentence 复杂局。复合句是简单句的并列组合，而复杂句是简单句的嵌套组合。</p>
<p>一个句子嵌套另一个句子，在英语语法上分别叫做 <em>主句</em> 和 <em>从句</em> 。从句说白了就是把简单句修改一下来充当另一个句子的句子成分。</p>
<p>*** 从句 - 名词性从句 + 主语从句 + 宾语从句 + 表语（主语补语）从句 + 同位语从句 - 定语从句 - 状语从句 * 词类 英语的十大词类。</p>
<ol type="1">
<li><p>名词 Nouns</p>
<p>表人和物</p>
<p><em>Papa Rabbit</em> is a <em>rabbit</em>.</p>
<p>其中“Papa Rabbit”是专有名词，“rabbit”是普通名词</p></li>
<li><p>冠词 Articles</p>
<p>说明人和事物</p>
<p>Papa Rabbit is <em>a</em> rabbit.</p></li>
<li><p>代词 Pronouns</p>
<p>代替人和物</p>
<p><em>I</em> am a rabbit.</p></li>
<li><p>形容词 Adjectives</p>
<p>形容人和物</p>
<p>I am a <em>smart</em> rabbit.</p></li>
<li><p>数词 Numerals</p>
<p>表数量</p>
<p>I ate <em>two</em> carrot.</p></li>
<li><p>副词 Adverbs</p>
<p>修饰动作或形容词等等</p>
<p>I ate two carrots <em>quickly</em>.</p></li>
<li><p>介词 Prepositions</p>
<p>表示和其他词关系的词</p>
<p>I ate two carrots <em>with</em> chopsticks.</p></li>
<li><p>叹词 Interjections</p>
<p>表感叹</p>
<p><em>Ah</em>, the carrots is tasty!</p></li>
<li><p>连词 Conjunctions</p>
<p>连接词和句子</p>
<p>I ate two carrots <em>and</em> a potato, <em>because</em> I was hungry.</p></li>
<li><p>动词 Verbs</p></li>
</ol>
<p>句子成分和句子中的词类是完全不同的概念。每一种句子成分，除了谓语动词是动词，其他都有可能包含不同的词类。 * 谓语动词的“三大本领” 1. 表示动作的 <em>时间</em> ：现在，过去，将来，从过去某个时间点“算将来”（过去将来）</p>
<p>比如动作可能在过去或将来 2. 表示动作的 <em>状态</em> ：未说明（一般），完成，进行，不但完成而且继续（完成进行）</p>
<p>比如动作可能是已经完成的状态或者正在进行的状态 3. 表示动作的 <em>假设，情感等</em></p>
<p>表示动词的语气</p>
<p>If I <em>were</em> a rabbit… 虚拟语气</p>
<p>I <em>ate</em> a carrot… 陈述语气</p>
<p><em>Eat</em> this carrot and… 祈使语气</p>
<p>1 和 2 合在一起称为 <em>时态</em> 。时间和状态组合，一共有 16 种时态：</p>
<p>file:../../pics/English/tense.png * 助动词 谓语动词本身往往是不能够独立完成之前说的那些本领，以及另外一些其他的本领，而且谓语动词独自也无法完成比如表示否定，可能性，必须性等意思。想要谓语动词充分发挥，我们必须用到另一类经常和动词一起用的词帮助完成任务， <em>助动词</em> 。</p>
<p>** Eat 为了协助它表示吃过了（完成态），就要用到助动词： <em>have</em>, eg, have eaten.</p>
<p>为了协助它表示正在吃（进行态），就要用到助动词： <em>be</em>, eg, is eating.</p>
<p>为了协助它表示是“被”吃，就要用到助动词： <em>be</em>, eg, is eaten.</p>
<p>为了协助它表示有能力吃，就要用到助动词： <em>can</em>, eg, can eat.</p>
<p>为了协助它表示有可能吃，就要用到助动词： <em>might</em>, eg, might eat.</p>
<p>为了协助它表示有义务吃，就要用到助动词： <em>must</em>, eg, must eat.</p>
<p>为了协助它表示否定，不吃，就要用到助动词： <em>do</em>, eg, do not eat.</p>
<p>但是很多助动词特别喜欢伪装，它们除了做助动词（没有实义，只是帮助谓语动词而已），还可以做实义动词，甚至其他词性。比如 can 还可以是易拉罐，might 可以是力量，must 可以是发霉，do 可以是做某事，have 可以是拥有，be 可以是存在。 * 非谓语动词 动词除了充当句子中的谓语动词，还有可能充当：主语、宾语、宾语补语、主语补语、定语、状语、同位语等。只不过需要把谓语动词修改一下，改成非谓语动词。不仅如此，非谓语动词几乎可以 <em>取代所有的从句</em> ，从而 <em>简化句子</em> 。只不过这样的动词就不再具有表示动作时间、状态、语态、语气的功能。</p>
<p>它们是以不同的形式出现在句中，包括： - 动词不定式，e.g. to eat - 现在分词，e.g. eating - 动名词，e.g. eating - 过去分词，e.g. eaten * 总结 英语语法的核心就是 <em>动词</em> 。动词能够串起几乎所有语法概念。</p>
<p>file:../../pics/English/verbs.png</p>]]></description>
    <pubDate>Wed, 4 Aug 2021 00:17:06 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[配置zfs]]></title>
    <link>https://www.codeplayer.org/Blog/%e9%85%8d%e7%bd%aeZFS.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e9%85%8d%e7%bd%aeZFS.html</guid>
    <description><![CDATA[<p>#+TITLE: 配置zfs #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li><p>环境 ST2000LM003 是仅有的一款 2T 大小的 CMR 2.5 英寸硬盘，目前非常稀有，淘宝上卖的 ST2000LM003 散装硬盘大概率是清零盘。不过我从咸鱼买到了两块内芯是 ST2000LM003 的移动硬盘，拆解后将其中的 2.5 英寸硬盘放到 deskmini 中组成小型 NAS。</p></li>
<li><p>系统：Gentoo Linux</p></li>
<li><p>机器：deskmini A300</p></li>
<li><p>硬盘：ST2000LM003 * 2</p></li>
<li><p>安装 ZFS Gentoo 系统安装 zfs 还算简单，不过要注意开启一些方便使用的 USE。</p></li>
</ul>
<p>#+begin_src sh echo “sys-fs/zfs dist-kernel” &gt;&gt; /etc/portage/package.use echo “sys-fs/zfs-kmod dist-kernel” &gt;&gt; /etc/portage/package.use emerge -avt sys-fs/zfs #+end_src</p>
<p>注意，每次更新内核后，都需要重新安装 zfs 模块。Gentoo 可以通过命令 =emerge -avt <span class="citation" data-cites="module-rebuild">@module-rebuild</span>= 完成。</p>
<p>由于这里我并不使用 zfs 作为 root 的文件系统，所以省略了将 zfs 模块添加到 initramfs 中等步骤。 * 配置 ZFS ** 设置 ARC 内存大小 zfs 的 ARC 缓存默认最大使用系统的三分之二内存。如果想要内存占用少一点，就需要使用下面的方法加以限制，这里限制了最大使用 4GB 内存。</p>
<p>#+begin_src sh echo “options zfs zfs_arc_max=4294967296” &gt;&gt; /etc/modprobe.d/zfs.conf #+end_src ** 开启 systemd 服务 开启以下服务后，zfs 才能正常使用。注意开启后需要重启，或者手动启动以下服务。</p>
<p>#+begin_src sh systemctl enable zfs.target systemctl enable zfs-import-cache systemctl enable zfs-mount systemctl enable zfs-import.target #+end_src * 创建 zpool 与 dataset 现在我们就可以正式开始使用 zfs 了，我们先创建 zpool 与 dataset，并设置一些优化参数。这里我们将两块 ST2000LM003 组成 raid0。</p>
<p>首先，使用命令查看硬盘的 id，通过 id 创建 zpool 是最佳的方法，可以避免因盘序或 UUID 变化带来的一些问题。</p>
<p>#+begin_src sh ➜ ls -lh /dev/disk/by-id/ total 0 lrwxrwxrwx 1 root root 9 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918 -&gt; ../../sdb lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918-part1 -&gt; ../../sdb1 lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918-part9 -&gt; ../../sdb9 lrwxrwxrwx 1 root root 9 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993 -&gt; ../../sda lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993-part1 -&gt; ../../sda1 lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993-part9 -&gt; ../../sda9 #+end_src</p>
<p>这里，我们得到两块硬盘的 id 分别为 ata-ST2000LM003_HN-M201RAD_S362J9DG938918 和 ata-ST2000LM003_HN-M201RAD_S362J9EG922993。接下来，就通过这两个参数来创建 zpool。</p>
<p>#+begin_src sh # 创建zpool，注意机械硬盘必须使用参数ashift=12，具有8K扇区的SSD应使用ashift=13。该参数在创建zpool完毕以后，就无法修改了。 zpool create -f -o ashift=12 storage ata-ST2000LM003_HN-M201RAD_S362J9DG938918 ata-ST2000LM003_HN-M201RAD_S362J9EG922993 # 创建dataset并设置挂载点 zfs create -o mountpoint=/srv/data storage/data zfs create -o mountpoint=/srv/data/nas storage/data/nas # 开启压缩并使用压缩算法lz4 zfs set compression=lz4 storage # 因为性能原因，最好设置xattr。详情见https://github.com/zfsonlinux/zfs/issues/170#issuecomment-27348094 zfs set acltype=posixacl storage zfs set xattr=sa storage zfs set aclinherit=passthrough storage # 仅在modified time或changed time 改变，或者acces time24小时内没有更新时，才更新access time zfs set atime=on storage zfs set relatime=on storage # SSD还需要开启autotrim zpool set autotrim=on storage #+end_src</p>
<p>最后，我们还需要生成 hostid 和更新 cachefile。</p>
<p>#+begin_src sh # 生成hostid，注意生成完hostid后需要更新initramfs zgenhostid # 更新cachefile zpool set cachefile=/etc/zfs/zpool.cache storage #+end_src * 参考链接 1. ZFS archwiki：https://wiki.archlinux.org/title/ZFS 2. ZFS Gentoo wiki：https://wiki.gentoo.org/wiki/ZFS 3. 在 Gentoo 上优雅的吃 ZFS：https://www.yafa.moe/post/gentoo-on-zfs/ 4. 在 Linux 上安装和使用 ZFS：https://www.escapelife.site/posts/caf259ea.html 5. ZFS dedup 属性：https://docs.oracle.com/cd/E26926_01/html/E25826/gazss.html#gjhav 6. Attaching and Detaching Devices in a Storage Pool：https://docs.oracle.com/cd/E19120-01/open.solaris/817-2271/gcfhe/index.html</p>]]></description>
    <pubDate>Wed, 4 Aug 2021 00:17:06 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[双显卡笔记本独显直通]]></title>
    <link>https://www.codeplayer.org/Blog/%e5%8f%8c%e6%98%be%e5%8d%a1%e7%ac%94%e8%ae%b0%e6%9c%ac%e7%8b%ac%e6%98%be%e7%9b%b4%e9%80%9a.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e5%8f%8c%e6%98%be%e5%8d%a1%e7%ac%94%e8%ae%b0%e6%9c%ac%e7%8b%ac%e6%98%be%e7%9b%b4%e9%80%9a.html</guid>
    <description><![CDATA[<p>#+TITLE: 双显卡笔记本独显直通 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>介绍 双显卡笔记本中直通独显（dGPU）到 win10 虚拟机。</li>
</ul>
<p>环境： - 联想 Legion R7000P 2020 笔记本 - RTX2060 笔记本显卡 - libvirt+qemu - Host: Gentoo Linux - Guest: Windows 10 LTSC 2019 * MUXed MUXed 结构的笔记本才容易实现独立显卡直通，Legion R7000P 应该就是 MUXed 的。关于什么是 MUXed 的，可以看下图的解释。</p>
<p>[[file:../pics/Blog/muxed.jpg]]</p>
<p>关于如何检测笔记本是否是 MUXed 的，目前没有什么好的办法。有一种说法是运行 lspci，查找有关 Intel HD Graphics/AMD GPU 和 NVIDIA 的设备：</p>
<ul>
<li>如果独显设备名以 3D Controller 开头，那你的电脑就是第二种 MUXless（核显直连显示器）。</li>
<li>如果独显设备名以 VGA Controller 开头，并且有一个 HD Graphics/AMD GPU 核显，那你的电脑是第三种 MUXed（核显、独显切换）。</li>
<li>启用 IOMMU 和 vfio 模块 ** IOMMU</li>
<li>intel CPU：添加内核参数 =intel_iommu=on iommu=pt= ，BIOS 开启 VT-d</li>
<li>amd CPU：添加内核参数 =iommu=pt= ，BIOS 开启 AMD-Vi ** vfio 添加模块 =vfio_pci vfio vfio_iommu_type1 vfio_virqfd= 到 initramfs 中。如果是像我一样使用 dracut 生成 initramfs，则在 =/etc/dracut.conf= 中添加配置 ~add_drivers+=" vfio_pci vfio vfio_iommu_type1 vfio_virqfd "~ ，之后重新生成 initramfs。</li>
<li>隔离 GPU #+begin_src sh #!/bin/bash shopt -s nullglob for g in <code>find /sys/kernel/iommu_groups/* -maxdepth 0 -type d | sort -V</code>; do echo “IOMMU Group ${g##<em>/}:" for d in <span class="math inline">$g/devices/*; do  echo -e "\t$</span>(lspci -nns ${d##</em>/})” done; done; #+end_src</li>
</ul>
<p>运行上述脚本，查看显卡所在的 IOMMU Group，并得到显卡相关设备的 device id。</p>
<p>#+begin_src IOMMU Group 10: 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation TU106M [GeForce RTX 2060 Mobile] [10de:1f15] (rev a1) 01:00.1 Audio device [0403]: NVIDIA Corporation TU106 High Definition Audio Controller [10de:10f9] (rev a1) 01:00.2 USB controller [0c03]: NVIDIA Corporation TU106 USB 3.1 Host Controller [10de:1ada] (rev a1) 01:00.3 Serial bus controller [0c80]: NVIDIA Corporation TU106 USB Type-C UCSI Controller [10de:1adb] (rev a1) #+end_src</p>
<p>如上所见，device id 分别为 <sub>10de:1f15</sub> 、 <sub>10de:10f9</sub> 、 <sub>10de:1ada</sub> 、 <sub>10de:1adb</sub> 。再将以上 deivce id 作为参数添加到内核参数或 =/etc/modprobe.d/vfio.conf= 中。</p>
<ul>
<li>内核参数：vfio-pci.ids=10de:1f15,10de:10f9,10de:1ada,10de:1adb</li>
<li>=/etc/modprobe.d/vfio.conf= ：options vfio-pci ids=10de:1f15,10de:10f9,10de:1ada,10de:1adb</li>
</ul>
<p>dracut 必须将 device id 添加到内核参数中，并且添加参数 =rd.driver.pre=vfio_pci= 。</p>
<p>最后重启电脑。开机后通过命令 =lspci -k= 确认上述 device id 对应的设备在使用 vfio-pci 驱动。如果有各别设备没有使用 vfio-pci 驱动，则可以通过手动 unbind 和 bind 驱动的方式加载 vfio-pci 驱动。比如如果 0000:01:00.2 仍在使用 xhci_hcd 驱动，则：</p>
<p>#+begin_src sh # run as root echo -n “0000:01:00.2” &gt; /sys/bus/pci/drivers/xhci_hcd/unbind echo -n “0000:01:00.2” &gt; /sys/bus/pci/drivers/vfio-pci/bind #+end_src * 创建虚拟机 首先使用 libvirt 创建一个非显卡直通的虚拟机，如果你有多余的显示器和键鼠，也可以直接创建显卡直通的虚拟机。这里我们假设没有多余的设备，并且之后使用 RDP 连接虚拟机。</p>
<p>首先下载[[https://msdn.itellyou.cn/][windows 10 LTSC 2019]]和 [[https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso][virtio windows驱动]]镜像。</p>
<p>创建虚拟机： - =Overview= ：Firmware 选择 UEFI x86_64:/usr/share/edk2-ovmf/OVMF_CODE.fd - =CPUs= ：选择 Topology，Manually set CPU topology，Sockets 设为 1，Cores 按需要来，我设为 4，Threads 设置为 2。这样一共就分配了 4 核 8 线程的 CPU - =Memory= ：内存我设置为 32G - =SATA Disk= ：Disk Bus 选择 Virtio，可以最小化磁盘性能损耗 - =NIC= ：Device model 也选择 virtio - 之后再添加一个 =Stroage= ，选择 Select custom storage 并选中之前下载的 virtio windows 驱动镜像，然后 Device type 选择 CDROM device - 最后在 =Boot Options= 中选中需要启动的设备</p>
<p>开始安装，在 windows 安装进行到选择硬盘的时候，通过之前加载的 virtio win 驱动的 CDROM，安装 virtio 的磁盘和网络驱动。具体参考可见视频 https://www.bilibili.com/video/BV1dQ4y1o78R 的 29 分 35 秒。安装完毕进入 windows，开启远程桌面并记下 IP，之后通过 RDP 连接虚拟机。 * 配置和优化 RemoteFX ** 配置 RemoteFX 1. 通过 =Win+R= 运行 =gpedit.msc= 2. 定位到 =计算机配置= -&gt; =管理模板= -&gt; =Windows组件= -&gt; =远程桌面服务= -&gt; =远程桌面会话主机= -&gt; =远程会话环境= - 开启 =对 RemoteApp 使用高级 RemoteFX 图形= - （可选）开启 =配置 RemoteFX 自适应图形的图像质量= ，设置为高 - 开启 =为专门针对 Windows Server 2008 R2 SP1 设计的 RemoteFX 客户端启动 RemoteFX 编码= - 开启 =配置 RemoteFX 数据的压缩= ，并设置为不需使用 RDP 压缩算法 + 连接压缩会导致编码和解码时产生额外的延迟 3. 定位到 =计算机配置= -&gt; =管理模板= -&gt; =Windows组件= -&gt; =远程桌面服务= -&gt; =远程桌面会话主机= -&gt; =远程会话环境= -&gt; =RemoteFX for Windows Server 2008 R2= - 开启 =配置RemoteFX= - （可选）开启 =使用RemoteFX时优化视觉体验= ，并都设置为最高 ** 解除 30-ish fps 限制 1. 启动注册表编辑器 2. 定位并单击以下注册表子键： =HKEY_LOCAL_MACHINEServer= 3. 在 =编辑= 菜单中选择 =新建= ，然后再选择 =DWORD（32位）值= 4. 输入 =DWMFRAMEINTERVAL= 并回车 5. 右键 =DWMFRAMEINTERVAL= ，选择 =修改= 6. 选择十进制，并输入 15。该设置将最大帧率设置为每秒 60 帧 (FPS)。 * 显卡直通 先关闭虚拟机。首先我们需要确认 host 和 guest 中的 GPU 硬件 ID 一致的，然而 Legion R7000P 中两者不一致，准确的来说是其中的 Sub ID 部分不一致，所以需要手动修改一下。首先通过命令 =lspci -nnk | egrep -A3 “VGA|3D”= 查看显卡的 Vendor ID 和 Device ID。</p>
<p>#+begin_src ➜ lspci -nnk | egrep -A3 “VGA|3D” 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation TU106M [GeForce RTX 2060 Mobile] [10de:1f15] (rev a1) Subsystem: Lenovo TU106M [GeForce RTX 2060 Mobile] [17aa:3a43] Kernel driver in use: vfio-pci Kernel modules: nouveau – 06:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Renoir [1002:1636] (rev c6) Subsystem: Lenovo Renoir [17aa:3a47] Kernel driver in use: amdgpu Kernel modules: amdgpu</p>
<p>#+end_src</p>
<p>其中 NVIDIA 独显的 Vendor ID 为 10de，Device ID 为 1f15。再用命令 ~grep “PCI_SUBSYS_ID=” /sys/bus/pci/devices/0000:01:00.0/uevent~ 查看 Sub Vendor ID 和 Sub Device ID。</p>
<p>#+begin_src ➜ grep “PCI_SUBSYS_ID=” /sys/bus/pci/devices/0000:01:00.0/uevent PCI_SUBSYS_ID=17AA:3A47 #+end_src</p>
<p>其中 Sub Vendor ID 为 17AA，Sub Device ID 为 3A47。将 17AA 和 3A47 转换为十进制 6058 和 14919，并在虚拟机的 XML 中添加配置：</p>
<p>#+begin_src xml <domain xmlns:qemu="http://libvirt.org/schemas/domain/qemu/1.0" type="kvm"> … <qemu:commandline> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-vendor-id=6058'/> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-device-id=14919'/> </qemu:commandline> </domain> #+end_src</p>
<p>注意 XML 的第一行一定要添加 <sub>xmlns:qemu=“http://libvirt.org/schemas/domain/qemu/1.0”</sub> ，否则后面的配置无法成功添加。</p>
<p>在 libvirt 中添加硬件，选择 PCI Host Device，然后将 =0000:01:00.0 NVIDIA Corporation GeForce RTX 2060 Mobile= 和 =0000:01:00.1 NVIDIA Corporation High Definition Audio Controller= 等都添加进去。</p>
<p>最后再在 libvirt 中删除虚拟机的 =Display Spice= 和 =Video QXL= ，在 =CPUs= 中取消 Copy host CPU configuration 并将 Model 选择为 host passthrough。如果你需要直通鼠标和键盘，也可以在这个时候添加。 * 创建网桥 有线网卡的网桥创建起来较为简单，这里就不详细介绍了，有需要的可以查看我上一篇[[file:软路由虚拟机.org][软路由虚拟机]]的 BLOG。因为是笔记本，所以这里主要介绍无线网卡的桥接方法。</p>
<p>先开启 proxy_arp 和 ip_forward，修改配置文件 =/etc/sysctl.conf= ，添加下述配置：</p>
<p>#+begin_src conf net.ipv4.ip_forward = 1 net.ipv4.conf.all.proxy_arp = 1 #+end_src</p>
<p>再点击 libvirt 菜单栏上的 =Edit= -&gt; =Connection Details= ，假设 host 的 ip 为 192.168.3.12，无线网卡为 wlp4s0，新建一个 Network， =Name= 设置为 proxyArp， =Mode= 选择 Routed， =Forward to= 选择 Physical device， =Device= 设置为 wlp4s0， IPv4 的 =Network= 设置为 192.168.3.100/28，完成创建。</p>
<p>然后修改 win10 虚拟机的 =NIC= 配置，将 =Network source= 改为 Virtual network ‘proxyArp’: Route to wlp4s0，最后重新启动虚拟机与物理机。 * 远程连接 重新启动虚拟机后，使用 RDP 连接到虚拟机中。到 nvidia 官网下载驱动，并进行安装。如果安装过程中并未出现问题，则至此显卡直通配置完成。另外如果不外接显示器的话，windows 的分辨率似乎会被限制在 640x480，不知道会不会对游戏有影响，所以有条件还是买一个 HDMI 欺骗器接到独显连接的显示接口上。</p>
<p>远程连接方式一共有三种，分别可以适用于不同的情况。 ** RDP 简单使用方法： - 确保使用 FreeRDP 2.0 - 获取 windows 虚拟机 IP，比如 192.168.3.108 - xfreerdp /v:192.168.3.108:3389 /w:1600 /h:900 /bpp:32 +clipboard +fonts /gdi:hw /rfx /rfx-mode:video /sound:sys:pulse +menu-anims +window-drag</p>
<p>对于使用 xfreedp 的 RemoteFX 连接的一些问题： - 只有窗口化的游戏可以运行，全屏将会触发 d3d11 0x087A0001 不能设置分辨率等问题。媒体播放器不受其影响。 + 作为解决方案，使用无边框模式游戏，或其他等效方案 + windows 客户端似乎没有该问题 - 由于 RDSH/RDVH 连接不支持“相对”鼠标，鼠标会乱跑 + 重定向 XBOX 手柄或 USB 摇杆可能会解决这个问题？ + 使用 Synergy (v1) 并启用相对鼠标模式 + 通过 RDP RemoteFX 运行 3D 游戏鼠标不稳定 ** Looking glass Looking glass 的优点是低延迟，其并不是通过网络与虚拟机通信，而是直接使用一块共享内存。缺点是只能本地连接，而且似乎需要外接一个显示设备（或 HDMI 欺骗器）才能让键盘、鼠标正常工作，并且似乎不能使用 spice 套娃远程操作 looking glass。</p>
<p>*** 安装 client 首先在 host 系统上安装 looking glass client，在 gentoo 上可以通过如下步骤直接安装我打包的 looking glass。</p>
<p>#+begin_src sh sudo eselect repository enable gig sudo emerge –sync gig sudo emerge -avt looking-glass #+end_src *** 计算内存大小 通过以下公式，根据你期望的最大分辨率来计算内存大小。</p>
<p>#+begin_src width x height x 4 x 2 = total bytes</p>
<p>total bytes / 1024 / 1024 = total megabytes + 10 #+end_src</p>
<p>比如，我想要最大使用 4K 分辨率（3840x2160）：</p>
<p>#+begin_src 3840 x 2160 x 4 x 2 = 66355200 bytes</p>
<p>66355200 / 1024 / 1024 = 63.28 MB + 10 = 73.28 #+end_src</p>
<p>最后要注意内存的大小要上向取整到最接近的 2 的幂，在上面的例子中则应为 128。 *** 配置 libvirt #+begin_src xml … <devices> … <shmem name='looking-glass'> <model type='ivshmem-plain'/> <size unit='M'>128</size> </shmem> </devices> … #+end_src</p>
<p>将以上内容添加到虚拟机的 XML 配置中，其中 128 即为上面计算出来的大小。</p>
<p>如果想要通过 spice 实现键盘和鼠标输入与剪贴板共享，则必须添加 spice 设备。 - 在 libvirt 中，选择 =Add Hardware= ，然后再选择 =Graphics= ，使用默认的 spice 配置即可，最后完成添加 - 选择 =Video= 设备，然后在 =Model= 栏中输入 none，注意必须要完成这一步，否则可能会造成虚拟机不使用直通的显卡渲染 - 如果有 =tablet= 设备，则删除 - 如果没有 =Mouse= 设备，则添加一个 - 如果没有 =Keyboard= 设备，则添加一个 + 这里使用 Virtio 的键盘可以更好的提高性能，然而 PS/2 的键盘没办法删掉，不知道被哪个设备依赖了，所以就使用 PS/2 的键盘了 + 还有如果使用 Virtio 的键盘，则需要通过上面加载的 virtio windows 驱动 的 CDROM，以安装驱动 *** 创建共享内存文件 新建文件 =/etc/tmpfiles.d/10-looking-glass.conf= ，其内容为：</p>
<p>#+begin_src conf #Type Path Mode UID GID Age Argument f /dev/shm/looking-glass 0660 user kvm - #+end_src</p>
<p>将其中的 user，改为你自己的用户名。最后使用命令 =systemd-tmpfiles –create /etc/tmpfiles.d/10-looking-glass.conf= 创建共享内存文件，无需等待下次重启。 *** 安装 host 首先需要在 windows 中安装 IVSHMEM 驱动，windows 不会自己安装 IVSHMEM 设备，相反它只会为该设备安装一个假驱动。先下载需要安装的驱动程序，https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/upstream-virtio/ ，注意必须下载 0.1.161 或更高的版本，最后将其解压。</p>
<p>安装 IVSHMEM 驱动需要打开 =设备管理器= ，然后在 =系统设备= 下，找到 =PCI标准内存控制器= ，然后选择 =更新驱动程序= ，再选择手动更新，选择我们之前下载并解压好的驱动目录，然后安装驱动即可。</p>
<p>host 需要在 windows 虚拟机中安装，先下载与 client 版本对应的 host 安装文件：https://looking-glass.io/downloads 。下载完成后解压、安装即可，完成后重启虚拟机，然后通过 log 文件查看其是否正常启动，log 在开始菜单里就有。</p>
<p>最后再安装一下 spice guest tools， https://www.spice-space.org/download.html#windows-binaries ，以更好的支持鼠标与剪贴板共享。 *** 配置 client 我使用的配置如下，将配置文件放在 =~/.looking-glass-client.ini= 或 =/etc/looking-glass-client.ini= ：</p>
<p>#+begin_src ini [app] renderer=egl shmFile=/dev/shm/looking-glass</p>
<p>[win] borderless=yes fullScreen=yes size=1920x1080</p>
<p>[input] grabKeyboard=yes escapeKey=97</p>
<p>[spice] captureOnStart=yes #+end_src</p>
<p>由于我的笔记本没有 ScrLk 按键，所以将 escape 键设置为了 右 Ctrl 按键。</p>
<p>至此 looking glass 配置完成，运行命令 looking-glass-client 连接到虚拟机。 *** 配置 Scream 由于 looking glass 不支持传递音频，所以我们还需要使用 Scream 将 VM 的音频传递给 host。</p>
<p>首先，编辑 windows 虚拟机的 XML，添加以下部分：</p>
<p>#+begin_src xml … <devices> … <shmem name='scream-ivshmem'> <model type='ivshmem-plain'/> <size unit='M'>2</size> </shmem> </devices> … #+end_src</p>
<p>然后再如 looking glass 一样，添加配置文件 =/etc/tmpfiles.d/11-scream-ivshmem.conf= ，并运行命令 =systemd-tmpfiles –create /etc/tmpfiles.d/11-scream-ivshmem.conf= 。</p>
<p>#+begin_src conf f /dev/shm/scream-ivshmem 0660 user kvm - #+end_src</p>
<p>如果没有安装 IVSHMEM 驱动，则需要安装一下，跟上面一样。然后下载 scream 的 windows 驱动，地址： https://github.com/duncanthrax/scream/releases ，解压并进行安装。</p>
<p>再以管理员权限在 CMD 中运行 =REG ADD HKLM/v UseIVSHMEM /t REG_DWORD /d 2= 。</p>
<p>在 Linux 物理机中安装 scream，然后创建配置文件 =~/.config/systemd/user/scream-ivshmem-pulse.service= ：</p>
<p>#+begin_src [Unit] Description=Scream IVSHMEM pulse receiver After=pulseaudio.service Wants=pulseaudio.service</p>
<p>[Service] Type=simple ExecStartPre=/usr/bin/truncate -s 0 /dev/shm/scream-ivshmem ExecStartPre=/bin/dd if=/dev/zero of=/dev/shm/scream-ivshmem bs=1M count=2 ExecStart=/usr/bin/scream -m /dev/shm/scream-ivshmem</p>
<p>[Install] WantedBy=default.target #+end_src</p>
<p>最后运行以下命令即可：</p>
<p>#+begin_src sh systemctl start –user scream-ivshmem-pulse systemctl enable –user scream-ivshmem-pulse #+end_src</p>
<p>这样就配置完成了，在 looing glass 里就可以听到声音了。 ** steam 远程畅玩（流式传输） 因为 RDP 的限制，像 steam 家庭串流或 Geforce Experience 的方式对游戏来说更为推荐。</p>
<p>如果不想每次串流游戏都输入密码解锁屏幕，则可以通过 RDP 以管理员权限运行 cmd，然后运行以下命令，也可以将其保存为脚本，方便以后使用。注意运行完该命令会立马断开 RDP。</p>
<p>#+begin_src <span class="citation" data-cites="powershell">@powershell</span> -NoProfile -ExecutionPolicy unrestricted -Command “$sessionid=((quser $env:USERNAME | select -Skip 1) -split ‘+’)[2]; tscon $sessionid /dest:console” 2&gt; UnlockErrors.log #+end_src * benchmark 简单运行了一下 3dmark 的 Time Spy，做虚拟机的图形性能测试。测试了以下几种情况：</p>
<ul>
<li>win10 + 物理机直接运行，3dmark 得分 6900</li>
<li>win10 + 虚拟机显卡直通 + 外接显示器，3dmark 得分 6000</li>
<li>win10 + 虚拟机显卡直通 + steam 串流，3dmark 得分 5600</li>
<li>win10 + 虚拟机显卡直通 + looking glass，3dmark 得分 5000，并且在加载的时候，画面延迟近 10 秒</li>
</ul>
<p>由此可见，想要玩游戏，还是最好外接显示器，或者起码使用 steam 串流吧，个人感觉 looking glass 的性能甚至可能没有 RDP 高，但 RDP 无法运行 3dmark，所以无法比较测试。另外这几种情况中，CPU 得分的差距更大，但一般游戏也不会占用过多 CPU 资源，所以这里并没有记录。</p>
<p>PS：win10 + 虚拟机显卡直通 + looking glass + HDMI 欺骗器，3dmark 得分也是 5600，looking glass 的性能有待进一步测试。 * 参考链接 1. PCI passthrough via OVMF https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF 2. [GUIDE] Optimus laptop dGPU passthrough https://gist.github.com/Misairu-G/616f7b2756c488148b7309addc940b28 3. Vendor ID &amp; Device ID https://github.com/marcosscriven/ovmf-with-vbios-patch/issues/2 4. 笔记本 Optimus MUXless 下的 Intel 和 NVIDIA 虚拟机显卡直通 https://lantian.pub/article/modify-computer/laptop-intel-nvidia-optimus-passthrough.lantian/ 5. ledis 的单显卡直通教程 https://github.com/ledisthebest/LEDs-single-gpu-passthrough/blob/main/README-cn.md 6. Looking glass Installation https://looking-glass.io/docs/676/install 7. Bridging Network Connections with Proxy ARP https://wiki.debian.org/BridgeNetworkConnectionsProxyArp 8. setup kvm on a wireless interface on a laptop machine https://unix.stackexchange.com/questions/159191/setup-kvm-on-a-wireless-interface-on-a-laptop-machine 9. 桥接无线网卡 https://blog.lilydjwg.me/2020/5/19/bridged-wireless-network.215330.html * 附录：XML 配置 最后附上我的虚拟机的 XML 配置。</p>
#+begin_src xml <domain type='kvm' id='1' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'> <name>win10</name> <uuid>d5da831a-c1eb-4668-a864-0731557d80a0</uuid> <metadata> <libosinfo:libosinfo xmlns:libosinfo="http://libosinfo.org/xmlns/libvirt/domain/1.0"> <libosinfo:os id="http://microsoft.com/win/10"/> </libosinfo:libosinfo> </metadata> <memory unit='KiB'>33554432</memory> <currentMemory unit='KiB'>33554432</currentMemory> <vcpu placement='static'>8</vcpu> <resource> <partition>/machine</partition> </resource> <os> <type arch='x86_64' machine='pc-q35-6.0'>hvm</type> <loader readonly='yes' type='pflash'>/usr/share/edk2-ovmf/OVMF_CODE.fd</loader> <nvram>/var/lib/libvirt/qemu/nvram/win10_VARS.fd</nvram> <bootmenu enable='no'/> </os> <features> <acpi/> <apic/> <hyperv> <relaxed state='on'/> <vapic state='on'/> <spinlocks state='on' retries='8191'/> </hyperv> <vmport state='off'/> </features> <cpu mode='host-passthrough' check='partial' migratable='on'> <topology sockets='1' dies='1' cores='4' threads='2'/> </cpu> <clock offset='localtime'> <timer name='rtc' tickpolicy='catchup'/> <timer name='pit' tickpolicy='delay'/> <timer name='hpet' present='no'/> <timer name='hypervclock' present='yes'/> </clock> <on_poweroff>destroy</on_poweroff> <on_reboot>restart</on_reboot> <on_crash>destroy</on_crash> <pm> <suspend-to-mem enabled='no'/> <suspend-to-disk enabled='no'/> </pm> <devices> <emulator>/usr/bin/qemu-system-x86_64</emulator> <disk type='file' device='disk'> <driver name='qemu' type='qcow2'/> <source file='/var/lib/libvirt/images/win10.qcow2' index='3'/> <backingStore/> <target dev='vda' bus='virtio'/> <boot order='1'/> <alias name='virtio-disk0'/>
<address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/>
</disk> <disk type='file' device='cdrom'> <driver name='qemu' type='raw'/> <source file='/home/petrus/Downloads/iso/cn_windows_10_enterprise_ltsc_2019_x64_dvd_9c09ff24.iso' index='2'/> <backingStore/> <target dev='sdb' bus='sata'/> <readonly/> <boot order='2'/> <alias name='sata0-0-1'/>
<address type='drive' controller='0' bus='0' target='0' unit='1'/>
</disk> <disk type='file' device='cdrom'> <driver name='qemu' type='raw'/> <source file='/home/petrus/Downloads/iso/virtio-win-0.1.185.iso' index='1'/> <backingStore/> <target dev='sdc' bus='sata'/> <readonly/> <alias name='sata0-0-2'/>
<address type='drive' controller='0' bus='0' target='0' unit='2'/>
</disk> <controller type='usb' index='0' model='qemu-xhci' ports='15'> <alias name='usb'/>
<address type='pci' domain='0x0000' bus='0x02' slot='0x00' function='0x0'/>
</controller> <controller type='sata' index='0'> <alias name='ide'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x1f' function='0x2'/>
</controller> <controller type='pci' index='0' model='pcie-root'> <alias name='pcie.0'/> </controller> <controller type='pci' index='1' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='1' port='0x10'/> <alias name='pci.1'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0' multifunction='on'/>
</controller> <controller type='pci' index='2' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='2' port='0x11'/> <alias name='pci.2'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x1'/>
</controller> <controller type='pci' index='3' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='3' port='0x12'/> <alias name='pci.3'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x2'/>
</controller> <controller type='pci' index='4' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='4' port='0x13'/> <alias name='pci.4'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x3'/>
</controller> <controller type='pci' index='5' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='5' port='0x14'/> <alias name='pci.5'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x4'/>
</controller> <controller type='pci' index='6' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='6' port='0x15'/> <alias name='pci.6'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x5'/>
</controller> <controller type='pci' index='7' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='7' port='0x8'/> <alias name='pci.7'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0' multifunction='on'/>
</controller> <controller type='pci' index='8' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='8' port='0x9'/> <alias name='pci.8'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>
</controller> <controller type='pci' index='9' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='9' port='0xa'/> <alias name='pci.9'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x2'/>
</controller> <controller type='pci' index='10' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='10' port='0xb'/> <alias name='pci.10'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x3'/>
</controller> <controller type='pci' index='11' model='pcie-to-pci-bridge'> <model name='pcie-pci-bridge'/> <alias name='pci.11'/>
<address type='pci' domain='0x0000' bus='0x0a' slot='0x00' function='0x0'/>
</controller> <controller type='pci' index='12' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='12' port='0xc'/> <alias name='pci.12'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x4'/>
</controller> <controller type='virtio-serial' index='0'> <alias name='virtio-serial0'/>
<address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>
</controller> <interface type='network'> <mac address='52:54:00:9c:b1:61'/> <source network='proxyArp' portid='dea4d995-d8d9-408d-ac30-ac45bfd5627e' bridge='virbr1'/> <target dev='vnet0'/> <model type='virtio'/> <alias name='net0'/>
<address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
</interface> <serial type='pty'> <source path='/dev/pts/0'/> <target type='isa-serial' port='0'> <model name='isa-serial'/> </target> <alias name='serial0'/> </serial> <console type='pty' tty='/dev/pts/0'> <source path='/dev/pts/0'/> <target type='serial' port='0'/> <alias name='serial0'/> </console> <channel type='spicevmc'> <target type='virtio' name='com.redhat.spice.0' state='connected'/> <alias name='channel0'/>
<address type='virtio-serial' controller='0' bus='0' port='1'/>
</channel> <input type='mouse' bus='ps2'> <alias name='input0'/> </input> <input type='keyboard' bus='ps2'> <alias name='input1'/> </input> <graphics type='spice' port='5900' autoport='yes' listen='127.0.0.1'> <listen type='address' address='127.0.0.1'/> <image compression='off'/> <gl enable='no'/> </graphics> <sound model='ich9'> <alias name='sound0'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x1b' function='0x0'/>
</sound> <audio id='1' type='spice'/> <video> <model type='none'/> <alias name='video0'/> </video> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
</source>
<alias name='hostdev0'/>
<address type='pci' domain='0x0000' bus='0x06' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x1'/>
</source>
<alias name='hostdev1'/>
<address type='pci' domain='0x0000' bus='0x07' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x2'/>
</source>
<alias name='hostdev2'/>
<address type='pci' domain='0x0000' bus='0x08' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x3'/>
</source>
<alias name='hostdev3'/>
<address type='pci' domain='0x0000' bus='0x09' slot='0x00' function='0x0'/>
</hostdev> <redirdev bus='usb' type='spicevmc'> <alias name='redir0'/>
<address type='usb' bus='0' port='2'/>
</redirdev> <redirdev bus='usb' type='spicevmc'> <alias name='redir1'/>
<address type='usb' bus='0' port='3'/>
</redirdev> <memballoon model='virtio'> <alias name='balloon0'/>
<address type='pci' domain='0x0000' bus='0x05' slot='0x00' function='0x0'/>
</memballoon> <shmem name='looking-glass'> <model type='ivshmem-plain'/> <size unit='M'>128</size> <alias name='shmem0'/>
<address type='pci' domain='0x0000' bus='0x0b' slot='0x01' function='0x0'/>
</shmem> <shmem name='scream-ivshmem'> <model type='ivshmem-plain'/> <size unit='M'>2</size> <alias name='shmem1'/>
<address type='pci' domain='0x0000' bus='0x0b' slot='0x02' function='0x0'/>
<p></shmem> </devices> <seclabel type='dynamic' model='dac' relabel='yes'> <label>+77:+77</label> <imagelabel>+77:+77</imagelabel> </seclabel> <qemu:commandline> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-vendor-id=6058'/> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-device-id=14919'/> </qemu:commandline> </domain> #+end_src</p>]]></description>
    <pubDate>Wed, 4 Aug 2021 00:17:06 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[软路由虚拟机]]></title>
    <link>https://www.codeplayer.org/Blog/%e8%bd%af%e8%b7%af%e7%94%b1%e8%99%9a%e6%8b%9f%e6%9c%ba.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e8%bd%af%e8%b7%af%e7%94%b1%e8%99%9a%e6%8b%9f%e6%9c%ba.html</guid>
    <description><![CDATA[<p>#+TITLE: 软路由虚拟机 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li><p>准备环境 摸着石头过河，折腾了几天，终于装好了心心念念的虚拟机软路由。</p></li>
<li><p>硬件环境：3400G + deskmini A300（自带一个网口） + M2 转网口，物理机双网口</p></li>
<li><p>物理机系统： Gentoo Linux</p></li>
<li><p>网络拓扑，见下图。除了 host 以外的本地设备都是通过设置为 AP 模式的硬路由连接网络。</p></li>
</ul>
<p>[[file:../pics/Blog/router_topology.jpg]] * 固件选择 固件我们选择基于 openwrt 官方 21.02 代码定制的 garypang13 的固件，github 项目地址为 https://github.com/garypang13/OpenWrt_x86-r2s-r4s-Rpi ，固件下载地址为 https://op.supes.top/ 。</p>
<p>其特点是原生固件非常纯净，只自带少量插件。而作者自建的 opkg 源又包含了 openwrt 的绝大部分主流插件，想要安装插件只需要在 luci 上搜索，然后点击安装即可，不再需要自己编译等复杂步骤。同时还自带了一键升级固件功能，作者基本上每周都会放出新的固件，如果想要升级，一键便可完成。 * 创建网桥 首先创建用于 eth1 网口和软路由虚拟机 lan 口连接的网桥。</p>
<p>#+begin_src sh # 创建网桥 nmcli connection add type bridge ifname br0 stp no # 将eth1添加倒网桥中 nmcli connection add type bridge-slave ifname eth1 master br0 # 关闭现有的连接（可以使用nmcli connection show –active命令查看） nmcli connection down <Connection> # 开启新创建的网桥 nmcli connection up bridge-br0 #+end_src</p>
<p>注意以上操作会关闭正在使用的网口，如果是远程连接到物理机且仅有单网口，请 <em>谨慎操作</em> ！</p>
<p>这时如果 eth1 是连接在带 DHCP 的硬路由中，那么会自动为网桥 br0 分配 IP，同时 eth1 上的 ip 地址会消失，可以直接通过网桥 br0 的 ip 访问 eth1 网口。 * 创建虚拟机 使用 libvirt + qemu(kvm)创建虚拟机：</p>
<ul>
<li>CPU 2 核心</li>
<li>内存 1G</li>
<li>硬盘直接使用 openwrt 的 img 文件</li>
</ul>
<p>eth0 网卡直接设置为直通，另外添加一张网卡，[Network Source]设置为 Bridge device，[Device name]设置为 br0，[Device model]设置为 virtio。即创建桥接到 br0 的第二张网卡。</p>
<p>其他配置默认，之后正常启动 openwrt 虚拟机即可。 * 配置 openwrt 通过 virt-manager 或 vnc 进入刚刚创建好的 openwrt 虚拟机，修改配置文件 =/etc/config/network= 。将其中的 =config interface ‘lan’= 中的 =option ipaddr= 地址设置为 192.168.3.2。之后重启 openwrt。</p>
<p>这样就可以在网页上通过地址 192.168.3.2 登陆 openwrt 的管理页面 luci 了。再进入[网络-&gt;接口]页面，编辑 WAN 接口，选择 PPPoE 选择，填入用户名、密码连接互联网。</p>
<p>这时将光猫的网线插到 eth0 网口中，再将路由器改为 AP 模式，再通过以下步骤为 br0 设置静态 ip，然后重启整个物理机。这样最基本的网络就应该已经配置完成了。</p>
<p>#+begin_src sh nmcli connection modify bridge-br0 ipv4.addresses 192.168.3.10 nmcli connection modify bridge-br0 ipv4.gateway 192.168.3.2 nmcli connection modify bridge-br0 ipv4.dns 192.168.3.2 nmcli connection modify bridge-br0 ipv4.method manual nmcli connection up interface #+end_src * 插件安装 在 luci 的[系统-&gt;软件包]页面中，安装 openclash、passwall、ddns、wake on line、upnp、netdata、online user 等常用插件后，再对插件进行简单的配置，即可正常使用了，科学上网、路由监控等功能都已完备。 * 参考链接 1. Network_bridge wiki https://wiki.archlinux.org/title/Network_bridge 2. 软路由折腾记 https://github.com/fanchangyong/blog/issues/22 3. qemu-kvm 安装 koolshare LEDE-X64 固件 https://koolshare.cn/thread-68876-1-1.html 4. 将 ubuntu 设置为 NAS——10. 虚拟机 KVM 及软路由 LEDE 安装 https://post.smzdm.com/p/adwrn5gn/ 5. KVM 虚拟化网络优化技术总结 https://www.cnblogs.com/lsgxeva/p/8964363.html 6. OpenWrt 编译 LuCI -&gt; Applications 添加插件应用说明 https://www.right.com.cn/forum/thread-3682029-1-1.html</p>]]></description>
    <pubDate>Wed, 4 Aug 2021 00:17:06 +0800</pubDate>
    </item>
</channel>
</rss>
