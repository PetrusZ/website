<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
<title>codeplayer</title>
<atom:link href="https://www.codeplayer.org/publish/feed.xml" rel="self" type="application/rss+xml" />
<link>https://www.codeplayer.org</link>
<description>codeplayer wiki</description>
    <item>
    <title><![CDATA[Ebuild_Manpage]]></title>
    <link>https://www.codeplayer.org/Wiki/Gentoo/Ebuild/Ebuild_Manpage.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Gentoo/Ebuild/Ebuild_Manpage.html</guid>
    <description><![CDATA[<h1 id="name">NAME</h1>
<p>ebuild - 含有内部格式、变量和函数的 ebuild 脚本</p>
<h1 id="description">DESCRIPTION</h1>
<p>ebuld 程序接受一个 ebuild 脚本作为参数。该脚本包含变量和指明如何从一个特别的软件源代码进行 download、unpack、patch、complile、install 和 merge 的命令。除了所有这些，ebuild 脚本还包含按要求进行 pre/post install/remove 命令。所有的 ebuild 脚本均以 bash 编写。</p>
<h1 id="dependencies">Dependencies</h1>
<p>一个依赖 <code class="verbatim">Atom</code> 是 portage 计算包之间关系的依赖基础。请注意，如果 atom 还没有被 merge，那么将匹配最新可用的版本。</p>
<h2 id="atom-base">Atom Base</h2>
<p>Atom base 只是完整的 <code class="verbatim">category/packagename</code> ，又常叫做"catpkg"。</p>
<pre class="example"><code>sys-apps/sed
sys-libs/zlib
net-misc/dhcp
</code></pre>
<h2 id="atom-versions">Atom Versions</h2>
<p>更具体一点，使用包含特定版本的 atom 也是可以接受的。版本必须和前缀一起使用，所以可以将版本号作为后缀添加到 base 上。</p>
<pre class="example"><code>sys-apps/sed-4.0.5
sys-libs/zlib-1.1.4-r1
net-misc/dhcp-3.0_p2
</code></pre>
<p>版本号可能跟随诸如像 1.2a 或 4.5.2z 的字符，注意这些字母并不代表 alpha, beta 等状态。对于这种情况可以使用可选的后缀，如<sub>alpha</sub>, <sub>beta</sub>, <sub>pre</sub> (pre-release), <sub>rc</sub> (release candidate), 或 <sub>p</sub> (patch)。这些后缀可以不受限制的任意链接。</p>
<h2 id="atom-prefix-operators">Atom Prefix Operators [&gt; &gt;= = &lt;= &lt;]</h2>
<p>有时你可能希望依赖于一个大致的版本，而不是一直指定特定的版本。所以，这里还提供了标准的布尔运算符：</p>
<pre class="example"><code>&gt;media-libs/libgd-1.6
&gt;=media-libs/libgd-1.6
=media-libs/libgd-1.6
&lt;=media-libs/libgd-1.6
&lt;media-libs/libgd-1.6
</code></pre>
<h2 id="extended-atom-prefixes-and-postfixes">Extended Atom Prefixes [!~] and Postfixes [*]</h2>
<p>现在为了更加精巧，ebuild 还提供了定义屏蔽包和版本范围匹配的功能。另外，这些扩展的前缀和后缀可以和上面提到的 atom 类型以各种方式组合。</p>
<ul>
<li><p><code class="verbatim">~</code></p>
<p>匹配指定基础版本的任何修订版。如以下例子中，匹配'1.0.2a', '1.0.2a-r1', '1.0.2a-r2'等。</p>
<p><code class="verbatim">~net-libs/libnet-1.0.2a</code></p></li>
<li><p><code class="verbatim">!</code></p>
<p>阻止该软件包同时安装</p>
<p><code class="verbatim">!app-text/dos2unix</code></p></li>
<li><p><code class="verbatim">!!</code></p>
<p>阻止该软件同时安装，并且明确禁止在升级的时候临时安装它们。该语法从 EAPI 2 开始支持。</p>
<p><code class="verbatim">!!&lt;sys-apps/portage-2.1.4_rc1</code></p></li>
<li><p><code class="verbatim">*</code></p>
<p>匹配基于指定的基础版本的任意版本软件包。=*=之前必须是有效的版本号。例如，=2=是有效的版本号，=2.=则不是，所以=2*=是被允许的，=2.*=则不被允许。</p>
<pre class="example"><code>=dev-libs/glib-2*
!=net-fs/samba-2*
</code></pre></li>
</ul>
<h2 id="atom-slots">Atom Slots</h2>
<p>从 EAPI 1 开始，可以限制 atom 匹配特定的 SLOT。这通过在冒号后面加上一个 SLOT 来实现</p>
<pre class="example"><code>x11-libs/qt:3
~x11-libs/qt-3.3.8:3
&gt;=x11-libs/qt-3.3.8:3
=x11-libs/qt-3.3*:3
</code></pre>
<h2 id="sub-slots">Sub Slots</h2>
<p>从 EAPI 5 开始，一个 slot 依赖可能包含一个可选的 sub-slot，该部分位于常规 slot 之后，并且以=/=字符分隔。</p>
<pre class="example"><code>dev-libs/icu:0/0
dev-libs/icu:0/49
dev-lang/perl:0/5.12
dev-libs/glib:2/2.30
</code></pre>
<h2 id="atom-slot-operators">Atom Slot Operators</h2>
<p>从 EAPI 5 开始，slot 操作符包含一个冒号，后面跟着以下操作符之一：</p>
<ul>
<li><p><code class="verbatim">*</code></p>
<p>表示任何 slot 值都是可以接受的。另外，对于运行时依赖，如果卸载了指定版本的软件包并且在其他的 slot 中将其替换为了另一个匹配的软件包，则该软件包不会损坏。</p>
<pre class="example"><code>dev-libs/icu:*
dev-lang/perl:*
dev-libs/glib:*
</code></pre></li>
<li><p><code class="verbatim">=</code></p>
<p>表示任何 slot 值都是可以接受的。另外，对于运行时依赖，除非安装了 slot 和 sub-slot 等于该软件包在可安装时的最佳安装版本的 slot 和 sub-slot 的匹配软件包，否则该软件包会损坏。</p>
<pre class="example"><code>dev-libs/icu:=
dev-lang/perl:=
dev-libs/glib:=
</code></pre></li>
<li><p><code class="verbatim">slot=</code></p>
<p>表示只能接受特定的 slot 值，否则其行为与普通 slot 操作符相同。</p>
<pre class="example"><code>dev-libs/icu:0=
dev-lang/perl:0=
dev-libs/glib:2=
</code></pre></li>
</ul>
<p>为了实现等号 slot 操作符，包管理软件需要存储匹配软件包的最佳已安装版本的 slot/sub-slot 对。该语法仅供包管理软件使用且一定不能在 ebuild 中使用。包管理软件可以通过在保存软件包依赖时在分号和等好之间插入适当的 slot/sub-slot 对来实现次目的。sub-slot 部分在这里必须不能省略（当 SLOT 变量省略 sub-slot 部分时，该软件包被认为是具有一个等于常规 slot 的隐式 sub-slot）。</p>
<pre class="example"><code>dev-libs/icu:0/0=
dev-libs/icu:0/49=
dev-lang/perl:0/5.12=
dev-libs/glib:2/2.30=
</code></pre>
<h2 id="atom-use">Atom USE</h2>
<p>从 EAPI 2 开始，任何 atom 可以被匹配的特定 USE flag 设置限制。当和 SLOT 依赖一起使用时，USE 依赖出现在 SLOT 依赖的右手侧。</p>
<p><strong>无条件的 USE 依赖</strong></p>
<table>
<thead>
<tr class="header">
<th>Example</th>
<th>Meanning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>foo[bar,baz]</td>
<td>foo 必须同时启用 bar 和 baz</td>
</tr>
<tr class="even">
<td>foo[-bar,baz]</td>
<td>foo 必须禁用 bar 同时启用 baz</td>
</tr>
</tbody>
</table>
<p><strong>有条件的 USE 依赖</strong></p>
<table>
<thead>
<tr class="header">
<th>Compat Form</th>
<th>Equivalent Expaned Form</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>foo[!bar?]</td>
<td>bar? ( foo ) !bar? ( foo[-bar] )</td>
</tr>
<tr class="even">
<td>foo[bar=]</td>
<td>bar? ( foo[bar] ) !bar? ( foo[-bar] )</td>
</tr>
<tr class="odd">
<td>foo[!bar=]</td>
<td>bar? ( foo[-bar] ) !bar? ( foo[bar] )</td>
</tr>
</tbody>
</table>
<h2 id="atom-use-defualts">Atom USE defualts</h2>
<p>USE 依赖可以指定有关匹配包的 IUSE 中可能或可能不存在的 flag 值为默认假设。这种默认值被通过在 flag 后紧接(<del>)或(-)指定。使用(</del>)表现为好像一个缺少的 flag 存在并且被启用，或(-)表现为好像 flag 存在并且被禁用。</p>
<pre class="example"><code>media-video/ffmpeg[threads(+)]
media-video/ffmpeg[-threads(-)]
</code></pre>
<h2 id="dynamic-dependencies">Dynamic Dependencies</h2>
<p>有时程序或许会根据 USE 变量依赖不同的东西。Portage 提供了一些选项来处理这种情况。注意当使用下面的语法时，每个情况都被认为是在它出现的范围内的的一个 Atom。这意味着每一个 Atom 都有条件的包含多个 Atom 并且可以被嵌套到无限深度。</p>
<p><strong>usevar? ( Atom )</strong></p>
<p>当用户在 USE 中含有 jpeg flag 的时候要 include jpeg library，简单的使用如下语法：</p>
<p><code class="verbatim">jpeg? (media-libs/jpeg)</code></p>
<p><strong>!uservar? ( Atom )</strong></p>
<p>如果你仅想在用户在他们的 USE 变量中没有确定选项时 include 一个 package，使用如下语法：</p>
<p><code class="verbatim">!nophysfs?( dev-games/physfs )</code></p>
<p>当在你想添加可选功能并默认启用该功能时，这通常非常有用。</p>
<p><strong>usevar? ( Atom if true ) !usevar? ( Atom if false )</strong></p>
<p>对于 C 中的三目算符之类的功能，你必须使用两个语句，一个为普通语句，一个为反向语句。如果一个软件包使用 GTK2 和 GTK1，但不是同时，那么你可以像这样处理：</p>
<p><code class="verbatim">gtk2? ( =x11-libs/gtk+-2*) !gtk2? ( =x11-libs/gtk+-1*)</code></p>
<p>这种方法模式优先使用 GTK2 库。</p>
<p><strong>|| ( Atom Atom … )</strong></p>
<p>当一个软件包可以使用几个不同的软件包但不适合使用虚包时，这个语法可以被轻松使用。</p>
<pre class="example"><code>|| (
        app-games/unreal-tournament
        app-games/unreal-tournament-goty
)
</code></pre>
<p>这里我们看到 unreal-tourament 有一个普通的版本，还有一个 goty 的版本。因为它们提供相同的基本文件集，所以一个软件包可以使用其中任意一个。因为使用范围很小，所以添加虚包时不合适的。</p>
<p>另一个好的例子是当软件包可以使用多个视频接口构建，但仅能使用其中一个接口。</p>
<pre class="example"><code>|| (
        sdl? ( media-libs/libsdl )
        svga? ( media-libs/svgalib )
        opengl? ( virtual/opengl )
        ggi? ( media-libs/libggi )
        virtual/x11
)
</code></pre>
<p>这里只有一个软件包将会被选中，并且偏好顺序由它们出现的顺序决定。所以 sdl 是最佳选择，接下来是 svga，然后是 opengl，再是 ggl，并且 X 作为默认如果用户没有指定上面提到的任何一种。</p>
<p>注意，如果列出的任何一个软件包已经 merge，包管理器将会使用它并认为依赖已满足。</p>
<h1 id="variable-usage-notes">Variable Usage Notes</h1>
<ul>
<li>定义在 <code class="verbatim">make.conf</code> 中的变量可以在 ebuild 中使用（除了 Portage 特定的变量，其他的包管理器可能不支持）。</li>
<li>当在 ebuild 中分配变量时，变量名和等好之间不能有空格（与 bash 语法类似）</li>
<li>变量值应该仅包含 ascii 字符集中的字符。GLEP 31 要强制要求如此。</li>
</ul>
<h1 id="variables-used-in-ebuilds">Variables Used In Ebuilds</h1>
<ul>
<li><p>ARCH</p>
<p>该变量包含了运行系统的当前架构的官方 Gentoo 专用缩写。有关权威列表可以查看 /var/db/repos/gentoo/profiles/arch.list</p></li>
<li><p>P</p>
<p>该变量包含了不包括 ebuild 修订版本的包名。该变量必须不能修改。</p>
<p><code class="verbatim">x11-base/xorg-server-1.20.5-r2 --&gt; 'x11-base/xorg-server-1.20.5'</code></p></li>
<li><p>PN</p>
<p>包含不包括版本号的脚本名</p>
<p><code class="verbatim">x11-base/xorg-server-1.20.5-r2 --&gt; 'x11-base/xorg-server'</code></p></li>
<li><p>PV</p>
<p>包括不带修订的版本号</p>
<p><code class="verbatim">x11-base/xorg-server-1.20.5-r2 --&gt; '1.20.5'</code></p></li>
<li><p>PR</p>
<p>包含修订号，或者 <code class="verbatim">r0</code> 如果不存在修订号</p>
<p><code class="verbatim">x11-base/xorg-server-1.20.5-r2 --&gt; 'r2'</code></p></li>
<li><p>PVR</p>
<p>包含版本号和修订号（如果不是 0）</p>
<pre class="example"><code>x11-base/xorg-server-1.20.5 --&gt; &#39;1.20.5&#39;
x11-base/xorg-server-1.20.5-r2 --&gt; &#39;1.20.5-r2
</code></pre></li>
<li><p>PF</p>
<p>包含完整包名 PN-PVR</p>
<pre class="example"><code>x11-base/xorg-server-1.20.5 --&gt; &#39;xorg-server-1.20.5&#39;
x11-base/xorg-server-1.20.5-r2 --&gt; &#39;xorg-server-1.20.5-r2&#39;
</code></pre></li>
<li><p>CATEGORY</p>
<p>包含包目录名</p>
<p><code class="verbatim">x11-base/xorg-server-1.20.5-r2 --&gt; 'x11-base'</code></p></li>
<li><p>A</p>
<p>包含软件包包含的所有源文件。该变量必须不能定义。它由 SRC\<sub>URI</sub> 变量自动生成</p></li>
<li><p><code class="verbatim">WORKDIR = ${PORTAGE_TMPDIR}/portage/${CATEGORY}/${PF}/work</code></p>
<p>包含软件包构建目录的路径。不要修改此变量</p></li>
<li><p><code class="verbatim">FILESDIR = ${PORTAGE_TMPDIR}/${CATEGORY}/${PF}/files</code></p>
<p>包含软件包特定的辅助文件路径。不要修改此变量</p></li>
<li><p>EBUILD<sub>PHASE</sub></p>
<p>包含当前正在执行的阶段函数缩写名称，比如"setup", "unpack", "compile", or "preinst"</p></li>
<li><p>EBUILD<sub>PHASEFUNC</sub></p>
<p>从 EPAI 5 开始，包括当前正在执行的阶段函数全名，比如"pkg<sub>setup</sub>", "src<sub>unpack</sub>", "src<sub>compile</sub>", or "pkg<sub>preinst</sub>"</p></li>
<li><p>EPREFIX</p>
<p>从 EAPI 3 开始，包含此 Portage 在安装过程中配置的偏移量。在 ebuild 或 eclass 中有时候需要偏移量，并且在这种情况下可作为${EPREFIX}使用。EPREFIX 不包含尾部斜杠，所以空字符串表示缺少偏移量。不要修改此变量。</p></li>
<li><p><code class="verbatim">S = ${WORKDIR}/${P}</code></p>
<p>包含临时构建目录的路径。该变量被 src<sub>compile</sub> 和 src<sub>install</sub> 函数使用。两者都以 <code class="verbatim">S</code> 为当前目录执行。可以修改此变量以与软件包的 tarball 提取目录匹配。</p></li>
<li><p><code class="verbatim">T = ${PORTAGE_TMPDIR}/portage/${CATEGORY}/${PF}/temp</code></p>
<p>包含临时目录的路径。该变量可以根据自己的喜好随意使用。</p></li>
<li><p><code class="verbatim">D = ${PORTAGE_TMPDIR}/portage/${CATEGORY}/${PF}/image/</code></p>
<p>包含临时安装目录的路径。每个不涉及 helper tools 和函数（如下所见）的写操作都应以 <code class="verbatim">{$D}</code> 为前缀。从 EAPI 3 开始，这里偏移量前缀应该经常被考虑到，为此提供了 <code class="verbatim">${ED}</code> 变量。注意在 EAPI 7 中，为了方便在 ebuild 中连接路经，此路径中的任何尾部斜杠都会被自动删除。不要修改该变量。</p></li>
<li><p><code class="verbatim">ED = ${PORTAGE_TMPDIR}/portage/${CATEGORY}/${PF}/image/${EPREFIX}/</code></p>
<p>为了方便使用，包含 <code class="verbatim">${D%/}${EPREFIX}/</code> 的路径。注意，注意，为了方便在 ebuild 中连接路经，此路径中的任何尾部斜杠都会被自动删除。不要修改该变量。</p></li>
<li><p>MERGE<sub>TYPE</sub></p>
<p>从 EAPI 4 开始，MERGE<sub>TYPE</sub> 变量可以查询当前 merge 类型。该变量包含以下可能值之一：</p>
<table>
<thead>
<tr class="header">
<th>Value</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>buildonly</td>
<td>未计划合并 source-build</td>
</tr>
<tr class="even">
<td>source</td>
<td>计划合并 source-build</td>
</tr>
</tbody>
</table></li>
<li><p>PROVIDES<sub>EXCLUDE</sub> = [space delimited list of fnmatch patterns]</p>
<p>在生成 PROVIDES 元数据时，被 fnmatch 模式匹配的 soname 和文件路径将会被排除在外。模式由空格分隔，并且可以创建包含引用的空格的模式。</p></li>
<li><p>PORTAGE<sub>LOGFILE</sub></p>
<p>包含构建日志的路径。如果 PORTAGE<sub>LOGFILE</sub> 没有设置，则 <code class="verbatim">PORTAGE_LOG_FILE = "${T}/build.log"</code></p></li>
<li><p>PORTAGE<sub>SOCKS5PROXY</sub></p>
<p>包含提供主机网络访问的 UNIX socket 路径到 SOCKSv5 代理。仅当运行在 network-sandbox 内部并且代理可用时有效。</p></li>
<li><p>REPLACED<sub>BYVERSION</sub></p>
<p>REPLACED<sub>BYVERSION</sub> 变量可以在 pkg<sub>perm</sub> 和 pkg<sub>postrm</sub> 中查询要被替换的软件包的当前版本。如果没有替换包，则变量为空，否则它将包含一个版本号。</p></li>
<li><p>REPLACING<sub>VERSIONS</sub></p>
<p>从 EAPI 4 开始，REPLACED<sub>BYVERSION</sub> 变量可以在 pkg<sub>perm</sub> 和 pkg<sub>postrm</sub> 中查询要替换的软件包的当前版本。如果没有替换包，则变量为空，否则它将包含一个与被替换的软件包版本相对应的版本号空格分隔列表。通常，该变量不会含有超过一个版本，但是根据 PMS 它可以包含多个版本。</p></li>
<li><p><code class="verbatim">REQUIRES_EXCLUDE = [space delimited list of fnmatch patterns]</code></p>
<p>从 EAPI 4 开始，在生成 REQUIRES 元数据时，被 fnmatch 模式匹配的 name 和文件路径将会被排除在外。模式由空格分隔，并且可以创建包含引用的空格的模式。</p></li>
<li><p>ROOT = /</p>
<p>请注意一个关于 ROOT 变量的重要改变 – 在 EAPI 7 中，在 ebuild 指向根文件系统时，中该变量将会默认为“”而不是传统的"<em>"，而且当设置为非根路径时该变量将永远不会包含尾部斜杠。这有一个附加的便利，无需在连接路径时指定 <code class="verbatim">"${ROOT%/}"</code> ，使得 ROOT 变量使用起来更加便利。这也适用于变量 EROOT，D 和 ED。请注意这意味着 ebuild 必须使用不同的逻辑来确定它们是否要安装到根文件系统上 – 使用 <code class="verbatim">[["$ROOT" =</code> "" ]]]= 来代替 <code class="verbatim">[[ "$ROOT" =</code> "</em>" ]]= 。</p>
<p>包含 portage 应该用作为 live filesystem 的 root 的路径。当软件包希望对 live filesystem 作出改变的时候，他们应该在以 <code class="verbatim">${ROOT}</code> 为前缀的树中这样做。通常这里需要考虑偏移量前缀，为了提供了 <code class="verbatim">${EROOT}</code> 变量。不要修改该变量。</p></li>
<li><p><code class="verbatim">EROOT = ${ROOT%/}${EPREFIX}/</code></p>
<p>从 EAPI 3 开始，为了方便使用，包含="${ROOT%/}${EPREFIX}/"=。不要修改该变量。也请看关于 ROOT 在 EAPI 7 中的重要说明。与 ROOT 一样，在 ebuild 中当设置为根文件系统时 EROOT 默认定义为“”，并且在永远不会有尾部斜杠。</p></li>
<li><p>DESCRIPTION = A happy little package</p>
<p>应该包含软件包的简短说明</p></li>
<li><p>EAPI = 0</p>
<p>定义此软件包所遵循的的 ebuild API 版本。如果未定义则默认为"0"。如果 prtage 不认识一个 EAPI 变量，则它会屏蔽该软件包，并且执行任何操作，因为这意味着首先需要安装新版本的 portage。为了最大的向后兼容性，软件包应该符合最低的 EAPI。注意，任何人于软件包使用 ebuild 和 reopman 命令都需要获取可识别该软件包所遵循的 EAPI 版本的 portage。</p></li>
<li><p>SRC<sub>URI</sub> = <a href="https://example.com/path/$%7BP%7D.tar.gz">https://example.com/path/${P}.tar.gz</a></p>
<p>包含所需源文件的 URI 列表。对单个源文件它可以包含多个 URI。如果文件未在任何 GENTOO<sub>MIRRORS</sub> 找到，则按顺序处理该列表。从 EAPI 2 开始，可以在右侧使用 <code class="verbatim">"-&gt;"</code> 运算符来自定义给定 URI 的输出文件名，后跟希望的输出文件名。所有 token，包括操作符和输出文件名，都应该用空格分隔。</p></li>
<li><p>HOMEPAGE = <a href="https://example.com/">https://example.com/</a></p>
<p>应该包含源主要网站和其他与软件包有关的依赖信息的 URI 列表</p></li>
<li><p>KEYWORDS = [-~][x86,ppc,sparc,mips,alpha,arm,hppa,…]</p>
<p>KEYWORDS 和 ACCEPT<sub>KEYWORLDS</sub> 结果使用，以实现创建彝族不同类型的软件包集，然后可以对它们进行整体屏蔽或非屏蔽。在 Gentoo Linux 项目，Gentoo 架构团队使用它们来定义一个特定的 CPU 架构的稳定或不稳定未屏蔽的软件包集中包含的 ebuild。</p>
<p>这里是它们如何工作的。为了解释目的，我们假设你有一个稳定的 x86-64bit 系统，通常称为"amd64"。ARCH 将定义为"amd64"。如果你使用的是稳定的 Gentoo Linux，那么 ACCEPT<sub>KEYWORLDS</sub> 会通过 profile 被设为"amd64"。任何在 KEYWORDS 中含有"amd64"的 ebuild 都会默认被设为非屏蔽的。</p>
<p>在一个"unstable"的 amd64 系统上，ACCEPT<sub>KEYWORDS</sub> 将会被设置为"amd64 ~amd64"，波浪号表示"unstable"。那么如果一个 ebuld 在 KEYWORDS 中包换"amd64"或"~amd64"，默认情况下该关键在会在系统上被取消屏蔽。类似的，如果一个 ebuild 已知与特定架构不兼容， <code class="verbatim">"-"</code> 前缀（像"-amd64"）设置可以指定仅在该架构上对其屏蔽。如果你正在为 Gentoo LInux 开发 ebuild，为了与 Gentoo 架构团队工作流程一致，你 需要遵循一些关于关键字的政策。下面列出了最重要的政策：</p>
<ul>
<li><p>如果你不知道一个 ebuild 是否可以在特定的架构下运行，那么不要在 KEYWORDS 中指定它。这样默认情况下它在该架构上会被屏蔽</p></li>
<li><p>如果一个 ebuild 已知不能在一个架构上运行，那么在 KEYWORDS 中禁用该架构。例如，这可以通过指定"-ppc"来完成。这将会确保对该架构进行显式的关键字屏蔽。</p></li>
<li><p>当提交一个 ebuild 到 Gentoo Linux 的时候，在 KEYWORDS 中仅对已成功测试的架构设置"~arch"是项目政策，没有测试的则不设置。随着 ebuild 接受更多的测试，Gentoo 架构团队将逐步扩展 KEYWORDS 的设置，以将软件包"bump"到不稳定，甚至可能是稳定状态。</p>
<p>依据使用 profile 中的 package.accept<sub>keywords</sub> 和 package.keywords 文件对每个软件包自定义 ACCEPT<sub>KEYWORFS</sub> 和 KEYWORDS 的行为是可能的。有关使用这些文件的更多信息，请参见 portage(5)。</p></li>
</ul>
<p>注意虽然其他基于 Gentoo 的项目具有 KEYWORDS 和 ACCEPT<sub>KEYWORDS</sub>，它们可能在关于使用方面没有完全相同的政策。所以，有必须要研究它们的特性策略以及它们与 Gentoo 的不同之处。</p></li>
<li><p>SLOT</p>
<p>这为可能需要同时存在多个版本的软件包设置了 SLOT。默认你应该设置 SLOT="0"。如果你不确定，那么在你寻求一些大时的指导之前，不要摆弄这个。应该永远不能让这个值未定义。</p>
<p>从 EAPI 5 开始，SLOT 变量可以包含一个可选的 sub-slot 部分跟随在常规 slot 之后，并用字符 <code class="verbatim">/</code> 分隔。sub-slot 必须是一个有效的 slot 名。sub-slot 用于表示以下情况：升级到一个具有不同的 sub-slot 软件包的新版本可能需要依赖软件重新构建。当 sub-slot 从 SLOT 定义中省略时，软件包被认为有一个等同与常规 slot 的隐式的 sub-slot。关于 sub-slot 的使用的更多信息，请参考 Atom Slot Operators 章节。</p></li>
<li><p>LICENSE</p>
<p>这应该是软件包所属的 license 的空格分隔的列表。这必须设置为在/var/db/repos/gentoo/licenses/中的匹配的 license。如果在仓库中还不存在 license，你需要先添加它。</p></li>
<li><p>IUSE</p>
<p>它应该是在你的构建脚本中所有可使用的 USE flag 列表。仅有的不应该列在此处的 USE flag 是与架构相关的 flag。从 EAPI 1 开始，可以在 flag 前加上 <code class="verbatim">+</code> 或 <code class="verbatim">-</code> 以创建分别开启或禁用相应 USE flag 的默认设置。有关 USE flag 堆叠顺歇的详细信息，请参考 <code class="verbatim">make.conf(5)</code> 中的 USE<sub>ORDER</sub> 变量。在给定默认 USE<sub>ORDER</sub> 设置的情况下，负值的 IUSE 默认设置仅会否定 repo-level 的 USE 设置，因为 profile 和用户设置都会覆盖它们。</p></li>
<li><p>DEPEND</p>
<p>它应该包含该程序编译所需的所有软件包的列表（aka 构建时依赖）。这些通常是库和头文件。</p>
<p>从 EAPI 7 开始，tools 应该改为使用 BDEPEND 变量，因为 DEPEND 仅会安装到正在构建的系统中，因此在交叉编译时无法执行。</p>
<p>你可以使用上面 Dependencies 部分中描述的语法。</p></li>
<li><p>RDEPEND</p>
<p>它应该包含该程序运行所需的所有软件包列表（aka 运行时依赖）。这些通常是库。</p>
<p>在 EAPI 3 或更早中，如果该变量没有设置，则它被默认设置为 DEPEND 的值。在 EAPI 4 或之后中，永远不能隐式设置 RDEPEND</p>
<p>你可以使用上面 Dependencies 部分中描述的语法。</p></li>
<li><p>BDEPEND</p>
<p>它应该包含在编译该程序期间所需的可执行的所有软件包列表（aka native build dependencies）。这些通常是工具，像解释器或（交叉）编译器。它们将会被安装到执行构建的系统中。</p>
<p>该变量在 EAPI 7 中正式引入，但以前在 EAPI 5-hdepend 中被成为 HDEPEND。</p>
<p>你可以使用上面 Dependencies 部分中描述的语法。</p></li>
<li><p>PDEPEND</p>
<p>它应该包含在这此之后应该被 merge 的所有软件包列表（aka post merge dependencies），但是如果不能在此之后安装，则可能被包管理软件在任何时候安装。</p>
<p>*警告*：仅将此作为打破循环依赖的最后手段。</p>
<p>你可以使用上面 Dependencies 部分中描述的语法。</p></li>
<li><p>REQUIRED<sub>USE</sub></p>
<p>从 EAPI4 开始，REQUIRED<sub>USE</sub> 变量可用于指定允许或不允许的 USE flag 组合。必要的时候可以嵌套元素。</p>
<table>
<thead>
<tr class="header">
<th>Behavior</th>
<th>Expression</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>If flag1 enabled then flags2 enabled</td>
<td>flag1? ( flag2 )</td>
</tr>
<tr class="even">
<td>If flag1 disabled then flag2 enabled</td>
<td>!flag1? ( flag2 )</td>
</tr>
<tr class="odd">
<td>If flag1 disabled then flag2 disabled</td>
<td>!flag1? ( !flag2 )</td>
</tr>
<tr class="even">
<td>Must enable any one or more (inclusive or)</td>
<td> ( flag1 flag2 flag3 )</td>
</tr>
<tr class="odd">
<td>Must enable exactly one but not more (exclusive or)</td>
<td>^^ (flag1 flag2 flag3 )</td>
</tr>
<tr class="even">
<td>Must enable at most one(EAPI 5 or later)</td>
<td>?? (flag1 flag2 flag3 )</td>
</tr>
</tbody>
</table></li>
<li><p>RESTRICT = [strip,mirror,fetch,userpriv]</p>
<p>这应该是限制 portage 功能的以空格为分隔的列表。你可以使用条件语法来更改限制，如上面 DEPEND 中所示。</p>
<ul>
<li><p>binchecks</p>
<p>禁用所有对二进制文件的 QA 检查。这应该*仅*在二进制检查没有意义的软件包中使用（例如，linux-headers 和 kernel-sources 可以安全跳过，因为它们没有二进制文件）。如果二进制检查需要因为其他原因跳过（像专有二进制文件），关于更具体的豁免请参见 QA CONTROL VARIABLES 部分</p></li>
<li><p>bindist</p>
<p>已构建软件包的分发受到限制。</p></li>
<li><p>fetch</p>
<p>类似与 mirror，但也不通过 SRC<sub>URI</sub> 获取文件。</p></li>
<li><p>installsources</p>
<p>禁用特定软件包的安装源。这是用于与 debugedit 不兼容的二进制软件包。</p></li>
<li><p>mirror</p>
<p>SRC<sub>URI</sub> 中的文件将不会从 GENTOO<sub>MIRRORS</sub> 下载</p></li>
<li><p>network-sandbox</p>
<p>对特定软件包禁用 network namespace。不能在 main Gentoo tree 上使用。</p></li>
<li><p>preserve-libs</p>
<p>对特定软件包禁用 preserve-libs。注意，当软件包被 merge 时，如果新实例或旧实例设置了 RESTRICT=preserve-libs，则 RESTRICT=preserve-libs 使用。</p></li>
<li><p>primaryuri</p>
<p>在从 GENTOO<sub>MIRRORS</sub> 获取之前，先从 SRC<sub>URI</sub> 获取。</p></li>
<li><p>splitedebug</p>
<p>对特定软件包禁用 splitedebug。这适用于二进制文件会与 splitdebug 触发问题的软件包，例如在/usr/lib/debug/.build-id 的符号链接之间的 file-collisions（由捆绑的库触发）。</p></li>
<li><p>strip</p>
<p>最终的二进制文件/库不会删除调试符号。</p></li>
<li><p>test</p>
<p>即使用户设置的 FEATURES=test 也不要运行 src<sub>test</sub></p></li>
<li><p>userpriv</p>
<p>对特定软件包禁用 userpriv</p></li>
</ul></li>
<li><p>PROPERTIES = [interactive,live]</p>
<p>空格分隔的属性列表，带有条件语法支持。</p>
<ul>
<li><p>interactive</p>
<p>一个或多个 ebuild 阶段将产生提示，要求用户进行交互。</p></li>
<li><p>live</p>
<p>该软件包使用实时源代码，每次安装该软件包时，源代码可能会有所不同。</p></li>
</ul></li>
<li><p>DOCS</p>
<p>从 EAPI 4 开始，用于在默认 src<sub>install</sub> 函数中使用 dodoc 来安装的一个数组或空格分隔列表的文档文件。如果未定义，一个合理的默认列表将会被使用。具体请见下文关于 src<sub>install</sub> 的文档。</p></li>
</ul>
<h1 id="qa-control-variables">QA Control Variables:</h1>
<ul>
<li><p>Usage Notes</p>
<p>提供多个 QA 变量允许 ebuild 操作一些由 portage 执行的 QA 检查。这些变量在 ebuild 中的使用应保持在绝对最低限度，否则它们会破坏质量检查的目的，并且它们的使用需要经过 QA 团队的同意。它们主要供安装无法改变的闭源二进制对象的 ebuild 使用。请注意，违反这些规则的对象在某些架构上可能会失败。</p></li>
<li><p>QA<sub>PREBUILT</sub></p>
<p>该变量应该包含相对 image 目录且预先构建的二进制文件的文件路径列表。在此列出的路径将会附加到下面列出的每个 QA<sub>*</sub>变量中。路径可能包含 fnmatch-like 模式，这些模式将在内部转换为 QA<sub>*</sub>变量支持的正则表达式，而不是 fnmatch 模式。转换机制只是简单的将 <code class="verbatim">"*"</code> 接换为 <code class="verbatim">".*"</code> 。</p></li>
<li><p>QA<sub>TEXTRELS</sub></p>
<p>该变量可以被设置为包含相对 image 目录且无法消除的文本重定位的文件的文件路径列表。路径可能包含 fnmatch 模式。</p>
<p>该变量旨在用于无法更改的闭源二进制对象。</p></li>
<li><p>QA<sub>EXECSTACK</sub></p>
<p>该变量应该包含相对 image 目录且需要可执行堆栈才能运行的对象的文件路径列表。路径可能包含 fnmatch 模式。</p>
<p>该变量旨在用于确实需要可执行堆栈的对象（即不是那些实际上不需要的）。</p></li>
<li><p>QA<sub>WXLOAD</sub></p>
<p>该变量应包含相对 image 目录且为包含可写和可执行段的文件的文件路径列表。它们非常罕见。路径可能包含 fnmatch 模式。</p></li>
<li><p>QA<sub>FLAGSIGNORED</sub></p>
<p>该变量应包含相对 image 目录且不包含.GCC.command.line 部分或包含.hash 部分的文件的文件路径列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p>
<p>该变量旨在用于忽略 CFLAGS、CXXFLAGS、FFLAGS、FCFLAGS 和 LDFLAGS 变量的二进制软件包文件。</p></li>
<li><p>QA<sub>MULTILIBPATHS</sub></p>
<p>该变量包含相对 image 目录且应该忽略 multilib-strict 检查的文件的文件路径列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p></li>
<li><p>QA<sub>PRESTRIPPED</sub></p>
<p>该变量包含相对 image 目录且包含 pre-stripped 的二进制文件的文件路径列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p></li>
<li><p>QA<sub>SONAME</sub></p>
<p>该变量包含相对 image 目录且缺少 SONAME 的共享库的文件路径列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p></li>
<li><p>QA<sub>SONAMENOSYMLINK</sub></p>
<p>该变量包含相对 image 目录的文件路径且具有 SONAME 但在同一目录不应具有对应 SONAME 符号连接的共享库的文件列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p></li>
<li><p>QA<sub>AMMAINTAINERMODE</sub></p>
<p>该变量包含 autmake 缺失–run 命令的行的列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p></li>
<li><p>QA<sub>CONFIGUREOPTIONS</sub></p>
<p>该变量包含触发有关无法识别的选项的配置选项的列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p></li>
<li><p>QA<sub>DTNEEDED</sub></p>
<p>该变量包含相对 image 目录且缺少 NEEDED 条目的共享库的文件路径列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p></li>
<li><p>QA<sub>DESKTOPFILE</sub></p>
<p>该变量包含相对 image 目录且不应被验证的桌面文件的文件路径列表。路径可能包含带有转义引号的特殊字符的正则表达式。</p></li>
</ul>
<h1 id="portage-declarations">PORTAGE DECLARATIONS</h1>
<ul>
<li><p>inherit</p>
<p>inherit 是 portage 对 ebuild 外部的额外 class 的维护的函数并且作为继承能力和数据提供。它们定义函数并设置数据类型作为插件替代、扩展和简化程序，用于极为常见的任务以简化构建过程。调用 inherit 不能依赖于给定 ebuild 中可能有所不同的条件。eclass 的规范仅包含其名称，而不包含.eclass 扩展名。还要注意，inherit 语句必须位于其他 全变量声明之前，除非这些变量在 eclass 的全局范围内使用。</p></li>
</ul>
<h1 id="phase-functions">PHASE FUNCTIONS</h1>
<ul>
<li><p>pkg<sub>pretend</sub></p>
<p>从 EAPI 4 开始，为了检查是否满足杂项要求，该函数必须被定义。该函数应该尽可能的早被调用，在任何尝试满足依赖之前。如果函数检测到问题，则它应该调用 eerror 并且 die。用来执行 pkg<sub>pretend</sub> 的环境（变量、函数、临时目录等）不会被保存，所以在之后的执行阶段中不可用。</p></li>
<li><p>pkg<sub>nofecth</sub></p>
<p>该函数将会在无论任何原因都无法获取 SRC\<sub>URI</sub> 中的文件时执行。如果你在 RESTRICT 中开启 fetch，这对于向用户显示如何获取所述文件的信息很有用。你所要做仅是输出信息，然后让函数返回。不要在函数结尾调用 die。</p></li>
<li><p>pkg<sub>setup</sub></p>
<p>如果软件包需要指定 setup 操作或要首先执行检查，则可以使用该函数。</p>
<p>初始工作目录：$PORTAGE<sub>TEMPDIR</sub></p></li>
<li><p>src<sub>unpack</sub></p>
<p>该函数用于 unpack 在 A 中的所有源文件到 WORKDIR。如果未在 ebuild 脚本是定义该函数，则它调用 unpack ${A}。任何 patch 或其他预配置/编译的修改都不应该在这里。</p>
<p>初始工作目录：$WORKDIR</p></li>
<li><p>src<sub>prepare</sub></p>
<p>所有源代码的准备工作，例如不定的应用，都应该在此处完成。这个函数从 EAPI 2 开始支持</p>
<p>初始工作目录：$S</p></li>
<li><p>src<sub>configure</sub></p>
<p>配置的所有必要步骤都应该此处完成。该函数从 EAPI 2 开始支持。</p>
<p>初始工作目录：$S</p></li>
<li><p>src<sub>compile</sub></p>
<p>小于 EPAI 2 时，配置和编译的所有必要步骤都应该在此处完成。从 EAPI 2 开始，仅编译步骤应该在此处完成。</p>
<p>初始工作目录：$S</p></li>
<li><p>src<sub>test</sub></p>
<p>运行所有软件包特定的测试用例。默认运行 <code class="verbatim">emake check</code> 后跟着运行 <code class="verbatim">emake test</code> 。在 EAPI 5 之前，src<sub>test</sub> 的默认实现自动传递-j1 选项作为 emake 的最后一个参数，并且从 EAPI 5 开始将允许并行运行测试。</p>
<p>初始工作目录：$S</p></li>
<li><p>src<sub>install</sub></p>
<p>应该在临时安装目录中包含安装软件包所要求的所有内容。</p>
<p>初始工作目录：$S</p>
<p>从 EAPI 4 开始，如果 src<sub>install</sub> 未定义，则下列默认实现将会被使用：</p>
<div class="sourceCode" id="cb16" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">src_install()</span> <span class="kw">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">[[</span> <span class="ot">-f</span> Makefile <span class="kw">||</span> <span class="ot">-f</span> GNUmakefile <span class="kw">||</span> <span class="ot">-f</span> makefile <span class="kw">]]</span> <span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="ex">emake</span> DESTDIR=<span class="st">&quot;</span><span class="va">${D}</span><span class="st">&quot;</span> install</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">fi</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="ot">! </span><span class="bu">declare</span> <span class="at">-p</span> <span class="va">DOCS</span> <span class="op">&amp;&gt;</span>/dev/null <span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">local</span> <span class="va">d</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> d <span class="kw">in</span> README<span class="pp">*</span> ChangeLog AUTHORS NEWS TODO CHANGES <span class="dt">\</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>                THANKS BUGS FAQ CREDITS CHANGELOG <span class="kw">;</span> <span class="cf">do</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">[[</span> <span class="ot">-s</span> <span class="st">&quot;</span><span class="va">${d}</span><span class="st">&quot;</span> <span class="kw">]]</span> <span class="kw">&amp;&amp;</span> <span class="ex">dodoc</span> <span class="st">&quot;</span><span class="va">${d}</span><span class="st">&quot;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">done</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="kw">[[</span> <span class="va">$(</span><span class="bu">declare</span> <span class="at">-p</span> <span class="va">DOCS)</span> <span class="ot">==</span> <span class="st">&quot;declare -a &quot;</span><span class="pp">*</span> <span class="kw">]]</span> <span class="kw">;</span> <span class="cf">then</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        <span class="ex">dodoc</span> <span class="st">&quot;</span><span class="va">${DOCS</span><span class="op">[@]</span><span class="va">}</span><span class="st">&quot;</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="ex">dodoc</span> <span class="va">${DOCS}</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">fi</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span></span></code></pre></div></li>
<li><p>pkg<sub>preinst</sub> pkg<sub>postinst</sub></p>
<p>上软件包被 merge 之前和之后，所有需要在实时文件系统上的修改都应该放在这里。而且对用户的注释也应该放在此处并在最后显示。</p>
<p>初始工作目录：$PWD</p></li>
<li><p>pkg<sub>prerm</sub> pkg<sub>postrm</sub></p>
<p>类似与 pkg<sub>*</sub>inst 函数，但是在 unmerge 时使用。</p>
<p>初始工作目录：$PWD</p></li>
<li><p>pkg<sub>config</sub></p>
<p>该函数应包含可选的基本配置步骤。</p>
<p>初始工作目录：$PWD</p></li>
</ul>
<h1 id="helper-functions">HELPER FUNCTIONS</h1>
<h2 id="phase">Phase:</h2>
<ul>
<li><p>defualt</p>
<p>为当前正在执行的阶段调用默认阶段函数实现。该方程从 EAPI 2 开始支持。</p></li>
<li><p>defualt<sub>*</sub></p>
<p>从 EAPI 2 开始，默认 pkg<sub>nofetch</sub> 和 src<sub>*</sub>阶段函数可以通过方程以 defualt<sub>开头并以相应的阶段函数名结尾的函数访问</sub>。例如，调用名为 defualt<sub>srccompile</sub> 的函数等同于调用 src<sub>compile</sub> 函数的默认实现。</p>
<table>
<thead>
<tr class="header">
<th>Defualt Phase Functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>defualt<sub>srcunpack</sub></td>
</tr>
<tr class="even">
<td>defualt<sub>srcprepare</sub></td>
</tr>
<tr class="odd">
<td>defualt<sub>srccomfigure</sub></td>
</tr>
<tr class="even">
<td>defualt<sub>srccompile</sub></td>
</tr>
<tr class="odd">
<td>defualt<sub>srctest</sub></td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="general">General:</h2>
<ul>
<li><p>assert [reason]</p>
<p>检查 shell 的 PIPESTATUS 数组变量的值，如果有任何非 0 值（表示失败），调用 die 并且 reason 作为失败消息。</p></li>
<li><p>die [reason]</p>
<p>使当前 emerge 程序中止。最后显示的信息将包括 reason。</p>
<p>从 EAPI 4 开始，所有 helper 每当发生某种错误就自动调用 die。helper 调用可以以 nofatal 为前缀，以防止错误变成 fatal。</p></li>
<li><p>nofatal [helper]</p>
<p>执行 helper 并且如果失败也不调用 die。nofatal helper 从 EAPI 4 开始可用。</p></li>
<li><p><code class="verbatim">use &lt;USE item&gt;</code></p>
<p>如果 USE item 在 USE 变量中，函数会默默返回 0（aka shell true）。如果 USE item 不在 USE 变量中，函数会默默返回 1（aka shell false）。usev 时 use 的详细版本。</p></li>
<li><p><code class="verbatim">usev &lt;USE item&gt;</code></p>
<p>就像 use，但在 use 返回 true 的时候同时 echo USE item。</p></li>
<li><p><code class="verbatim">usex &lt;USE flag&gt; [true output] [false output] [true suffix] [false suffix]</code></p>
<p>如果 USE flags 设置了，echo <code class="verbatim">[true output][true suffix]</code> （默认为"yes"），否则 echo <code class="verbatim">[false output][false suffix]</code> （默认为"no"）。usex heper 从 EAPI 5 开始可用。</p></li>
<li><p><code class="verbatim">use_with &lt;USE item&gt; [configure name] [configure opt]</code></p>
<p>对于创建自定义选项以传递到配置脚本很有用。如果 USE item 在 USE 变量中并且 configure opt 指定了，那么字符串–with-[configure-name]=[configure opt]将会被 echo。如果 configure opt 没有被指定，那么仅–with-[configure name]会被 echo。如果 USE item 不在 USE 变量中，那么字符串–without-[configure name]将会被 echo。如果 configure name 没有被指定，那么 USE item 将会在其位置上使用。从 EAPI 4 开始，空的 configure opt 参数可以被识别。在 EAPI 3 和更早中，空的 configure opt 参数被视为未被提供。</p>
<div class="sourceCode" id="cb17" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="va">USE</span><span class="op">=</span><span class="st">&quot;opengl&quot;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="va">myconf</span><span class="op">=</span><span class="va">$(</span><span class="ex">use_with</span> opengl<span class="va">)</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="ex">myconf</span> now has the value <span class="st">&quot;--with-opengl&quot;</span><span class="kw">)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="va">USE</span><span class="op">=</span><span class="st">&quot;jpeg&quot;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="va">myconf</span><span class="op">=</span><span class="va">$(</span><span class="ex">use_with</span> jpeg libjpeg<span class="va">)</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="ex">myconf</span> now has the value <span class="st">&quot;--with-libjpeg&quot;</span><span class="kw">)</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="va">USE</span><span class="op">=</span><span class="st">&quot;&quot;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="va">myconf</span><span class="op">=</span><span class="va">$(</span><span class="ex">use_with</span> jpeg libjpeg<span class="va">)</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="ex">myconf</span> now has the value <span class="st">&quot;--without-libjpeg&quot;</span><span class="kw">)</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="va">USE</span><span class="op">=</span><span class="st">&quot;sdl&quot;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="va">myconf</span><span class="op">=</span><span class="va">$(</span><span class="ex">use_with</span> sdl SDL all-plugins<span class="va">)</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="ex">myconf</span> now has the value <span class="st">&quot;--with-SDL=all-plugins&quot;</span><span class="kw">)</span></span></code></pre></div></li>
<li><p><code class="verbatim">use_enable &lt;USE item&gt; [configure name] [configure opt]</code></p>
<p>和上面的 use<sub>with</sub> 一样，除了配置选项是 <code class="verbatim">--enable-</code> 替代 <code class="verbatim">--with-</code> 、 <code class="verbatim">--disable-</code> 替代 <code class="verbatim">--without-</code> 。从 EAPI 4 开始，空的 configure opt 参数可以被识别。在 EAPI 3 和更早中，空的 configure opt 参数被视为未被提供。</p></li>
<li><p><code class="verbatim">has &lt;item&gt; &lt;item list&gt;</code></p>
<p>如果 item 在 item list 中，则 has 返回 0，否则返回 1。还有另外一个版本，hasv，会有条件的 echo item。</p>
<p>item list 由 IFS 变量分隔。该变量的默认值为' '或空格。这是一个 bash 设置。</p></li>
<li><p><code class="verbatim">hasv &lt;item&gt; &lt;item list&gt;</code></p>
<p>就像 has，但在 has 返回 true 的时候同时 echo item。</p></li>
<li><p><code class="verbatim">has_version [-b] [-d] [-r] [--host-root] &lt;category/package-version&gt;</code></p>
<p>检查 category/package-version 是否已安装。该参数接受在 DEPEND 变量中可接受的所有值。如果 category/package-version i 已安装，该函数返回 0，否则返回 1。该软件包默认在 ROOT 中搜索。</p>
<p>在 EAPI 5 和 EAPI 6 中，如果提供了–host-root 选项，则软件包在 build host 中搜索。</p>
<p>在 EAPI 7 和之后，令人困惑的–host-root 选项被替换为-b，和 build host 中 BDEPEND 满足的依赖关系对应。类似的，-d 选项对应 SYSROOT 中的 DEPEND 并且-r 选项对应 ROOT 中的 RDEPEND。</p></li>
<li><p><code class="verbatim">best_version [-b] [-d] [-r] [--host-root] &lt;package name&gt;</code></p>
<p>该函数将会在当前已安装软件包的数据库中查找 package name 并且 echo 找到的软件包的“best version”，或者如果没有安装则为空。软件包默认在 ROOT 中搜索。它接受于 has<sub>version</sub> 一样的选项。</p>
<div class="sourceCode" id="cb18" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="va">VERINS</span><span class="op">=</span><span class="st">&quot;</span><span class="va">$(</span><span class="ex">best_version</span> net-ftp/glftpd<span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="ex">VERINS</span> now has the value <span class="st">&quot;net-ftp/glftpd-1.27&quot;</span> if glftpd-1.27 is       installed<span class="kw">)</span></span></code></pre></div></li>
</ul>
<h2 id="output">Output:</h2>
<ul>
<li><p>einfo disposable message</p>
<p>和 elog 一样，当应该在消息对用户不重要时使用（像构建过程中的进度或状态信息）。</p></li>
<li><p>elog informative message</p>
<p>如果你需要显示信息并且你希望用户阅读并提起注意，那么使用 elog。它就像 echo 一样，但是添加一点输出，以引起用户的注意。信息还会被 portage 记录以供之后查看。</p></li>
<li><p>ewarn warning message</p>
<p>和 einfo 一样，但是应该对用户显示警告时使用。</p></li>
<li><p>eqawarn QA warning message</p>
<p>和 einfo 一样，但应该在对用户显示 QA 警告时使用</p></li>
<li><p>eerror error message</p>
<p>和 einfoi 一样，但应该在对用户显示错误时使用。</p></li>
<li><p>ebegin helpful message</p>
<p>就像 einfo，我们输出 helpful message，然后提示以下操作可能需要一些时间才能完成。一旦任务完成，你需要调用 eend。</p></li>
<li><p><code class="verbatim">eend &lt;status&gt; [error message]</code></p>
<p>跟随在 ebegin 消息之后，并使用适当"OK"或"!!"（错误）标记。如果 status 是非 0 的，那么附加的 error message 会被显示。</p></li>
</ul>
<h2 id="unpack">Unpack</h2>
<ul>
<li><p><code class="verbatim">unpack &lt;source&gt; [list of more sources]</code></p>
<p>该函数解压所源文件列表到当前目录中。该函数会将 source 附加到 DISTDIR 变量中。</p></li>
</ul>
<h2 id="compile">Compile:</h2>
<ul>
<li><p>econf [configure options]</p>
<p>用于替代 configure。执行：</p>
<div class="sourceCode" id="cb19" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="va">${ECONF_SOURCE</span><span class="op">:-</span>.<span class="va">}</span><span class="ex">/configure</span> <span class="dt">\</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="va">${CBUILD</span><span class="op">:+</span>--build=<span class="va">${CBUILD}}</span> <span class="dt">\</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">--datadir</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${EPREFIX}</span><span class="st">&quot;</span>/usr/share <span class="dt">\</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">--host</span><span class="op">=</span><span class="va">${CHOST}</span> <span class="dt">\</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">--infodir</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${EPREFIX}</span><span class="st">&quot;</span>/usr/share/info <span class="dt">\</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">--localstatedir</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${EPREFIX}</span><span class="st">&quot;</span>/var/lib <span class="dt">\</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">--prefix</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${EPREFIX}</span><span class="st">&quot;</span>/usr <span class="dt">\</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">--mandir</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${EPREFIX}</span><span class="st">&quot;</span>/usr/share/man <span class="dt">\</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">--sysconfdir</span><span class="op">=</span><span class="st">&quot;</span><span class="va">${EPREFIX}</span><span class="st">&quot;</span>/etc <span class="dt">\</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="va">${CTARGET</span><span class="op">:+</span>--target=<span class="va">${CTARGET}}</span> <span class="dt">\</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">--disable-dependency-tracking</span> <span class="dt">\</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="va">${EXTRA_ECONF}</span> <span class="dt">\</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    configure options <span class="kw">||</span> <span class="ex">die</span> <span class="st">&quot;econf failed&quot;</span></span></code></pre></div>
<p>注意 EXTRA<sub>ECONF</sub> 仅适用于用户，不适用于 ebuild writer。如果你希望传递更多的参数到 configure，只需将额外的参数传递给 econf。另外注意如果 configure 脚本失败，econf 自动调用 die。从 EAPI 3 开始，econf 使用被之前的 EAPI 值忽略的${EPREFIX}变量。从 EAPI 4 开始，如果字符串 disable-dependency-tarcking 出现在 configure –help 的输出中，econf 会在参数中添加–disable-dependency-tracking。从 EAPI 5 开始，如果字符串 disable-silent-rules 出现在 configure –help 中，econf 会在参数中添加 disable-silent-rules。</p></li>
<li><p>emake [make options]</p>
<p>在 ebuild 中必须使用它来代替 make。执行 <code class="verbatim">${MAKE:-make} ${MAKEOPTS} make options ${EXTRA_EMAKE}</code> ，并且从 EAPI 4 开始会自动调用 <code class="verbatim">die</code> 。</p>
<p>MAKEOPTS 变量由用户设置，所以能够开启一些像并行构建的特性。更多细节请见 make.conf(5)。</p>
<p>EXTRA<sub>EMAKE</sub> knob 是 portage 的特性，所以开发者可以在调试 ebuild 时覆盖一些东西。这不是任何 EAPI 规范的一部分。</p>
<p><strong>警告</strong> ：你必须确定你的构建在并行编译上没有任何问题(make -j2)。应该对它进行彻底的测试，因为众所周知并行编译有时会失败，但又不总是如此。如果你确定你的软件包在并行构建中失败，并且无法解决这个问题，那么你应该显式的运行 <code class="verbatim">emake -j1</code> 。这是不得已的办法，因为它会显著的降低具有很多处理器的在系统的构建速度。</p></li>
</ul>
<h2 id="install">Install:</h2>
<ul>
<li><p>einstall [make options] 这用来代替 make install。执行：</p>
<div class="sourceCode" id="cb20" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span> <span class="dt">\</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    prefix=<span class="va">${ED}</span>/usr <span class="dt">\</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    datadir=<span class="va">${ED}</span>/usr/share <span class="dt">\</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    infodir=<span class="va">${ED}</span>/usr/share/info <span class="dt">\</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    localstatedir=<span class="va">${ED}</span>/var/lib <span class="dt">\</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    mandir=<span class="va">${ED}</span>/usr/share/man <span class="dt">\</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    sysconfdir=<span class="va">${ED}</span>/etc <span class="dt">\</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="va">${EXTRA_EINSTALL}</span> <span class="dt">\</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    make options <span class="dt">\</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    install</span></code></pre></div>
<p>请 <strong>不</strong> 要用它代替 <code class="verbatim">emake install DESTDIR=${D}</code> 。那是安装 make-based 软件包的首选方法。还有，不要使用 EXTRA<sub>EINSTALL</sub> 变量，因为它仅适用于用户。</p></li>
<li><p><code class="verbatim">docompress [-x] &lt;path&gt; [list of more paths]</code></p>
<p>从 EAPI 4 开始，docompress helper 用来管理用以从可选的压缩中包括或排除的文件的列表。如果首个参数是-x，其后每个后续参数都添加到排除列表中。否则，将每个参数添加到包含列表。包含列表最初包含 <code class="verbatim">/usr/share/doc</code> 、 <code class="verbatim">/usr/share/info</code> 和 <code class="verbatim">/usr/share/man</code> 。排除列表最初包含 <code class="verbatim">/usr/share/doc/${PF}/html</code> 。</p>
<p>可选压缩应在 src<sub>install</sub> 完成后执行，并且在执行任何后续阶段函数之前。对于包含列表中的每一项，假设它有 D 变量前置的值，那么：</p>
<ul>
<li>如果它是一个目录，则应将其时为该目录下的每个文件或目录都在包含列表中。</li>
<li>如果项目是文件，则可以将其压缩除非如下所述已将其排除在外。</li>
<li>如果项目不存在，则将其忽略。</li>
</ul>
<hr />
<p>一个项目是否被排除根据如下决定：对于每个在排除列表中的项目，假设它具有 D 变量前置的值，那么：</p>
<ul>
<li>如果它是一个目录，则应将其时为该目录下的每个文件或目录都在排除列表中。</li>
<li>如果项目是一个文件，则它将不会被压缩。</li>
<li>如果项目不存在，则将其忽略。</li>
</ul></li>
<li><p><code class="verbatim">dosed s:orig:change:g &lt;filename&gt;</code></p>
<p>从 EAPI 4 开始，dosed helper 不在存在。ebuild 应该直接调用 sed（并且假设为 GNU sed）</p>
<p>在${ED}中的文件名上执行 sed。如果未给出表达式，则将`s:${D}::g`作为默认表达式。注意该表达式没有使用便宜前缀。</p>
<p><code class="verbatim">dosed s:/usr/local:/usr:g /usr/bin/some-script</code> 在 <code class="verbatim">${ED}/usr/bin/some-script</code> 上运行 sed。</p></li>
<li><p><code class="verbatim">dodir &lt;path&gt; [more paths]</code></p>
<p>在${ED}中创建目录。</p>
<p><code class="verbatim">dodir /usr/lib/apache</code> 创建 <code class="verbatim">${ED}/usr/lib/apache</code> 。请注意，do*函数将会为你运行 dodir。</p>
<p>如果该目录在 merge 的时候为空，那么请改用 keepdir。</p></li>
<li><p>diropts [options for install(1)]</p>
<p>可用于为在 dodir 中使用的安装函数定义选项。默认为-m0755</p></li>
<li><p><code class="verbatim">into &lt;path&gt;</code></p>
<p>为其他函数像 dobin、dosbin、doman、doinfo、dolib 设置 root(DESTTREE)</p>
<p>默认 root 是/usr</p></li>
<li><p><code class="verbatim">keepdir &lt;path&gt; [more paths]</code></p>
<p>类似于 dodir，但是用户创建原本为空的目录。PMS 未定义对完全空目录的处理，使用 keepdir 可以保证它们被追踪。</p></li>
<li><p><code class="verbatim">dobin &lt;binary&gt; [list of more binaries]</code></p>
<p>安装二进制或一列表的二进制到 DESTTREE/bin 中。创建所有必要的目录。</p></li>
<li><p><code class="verbatim">dosbin &lt;binary&gt; [list of more binaries]</code></p>
<p>安装二进制或一列表的二进制到 DESTTREE/sbin 中。创建所有必要的目录。</p></li>
<li><p><code class="verbatim">doinitd &lt;init.d script&gt; [list of more init.d scripts]</code></p>
<p>安装 Gentoo init.d 脚本。它们将会被安装到 Gentoo init.d 脚本的正确位置(etc/init.d)。创建所有必要的目录。</p></li>
<li><p><code class="verbatim">doconfd &lt;conf.d file&gt; [list of more conf.d files]</code></p>
<p>安装 Gentoo conf.d 文件。它们将会被安装到 Gentoo conf.d 文件的正确位置(etc/conf.d)。创建所有必要的目录。</p></li>
<li><p><code class="verbatim">doenvd &lt;env.d entry&gt; [list of more conf.d entries]</code></p>
<p>安装 Gentoo env.d 条目。它们将会被安装到 Gentoo env.d 条目的正确位置(etc/env.d)。创建所有必要的目录。</p></li>
<li><p><code class="verbatim">dolib &lt;libraray&gt; [list of more libraries]</code></p></li>
<li><p><code class="verbatim">dolib.a &lt;libraray&gt; [list of more libraries]</code></p></li>
<li><p><code class="verbatim">dolib.so &lt;libraray&gt; [list of more libraries]</code></p>
<p>安装库或一个列表的库到 DESTTREE/lib。创建所有必要的目录。</p></li>
<li><p>libopts [options for install(1)]</p>
<p>可用于为在 dolib 函数中使用的安装函数的定义选项。默认值为-m0644</p></li>
<li><p><code class="verbatim">doman [-i18n=&lt;locale&gt;] &lt;man-page&gt; [list of more man-pages]</code></p>
<p>根据手册文件结尾将 manual-pages 安装到 <code class="verbatim">/usr/share/man/man[0-9n]</code> 中。如果文件尚未压缩，则将其压缩。你可以用-i18n 选项指定特定语言环境的 manpages。那么 man-page 将会被安装到 <code class="verbatim">/usr/share/man/&lt;locale&gt;/man[0-9n]</code> 中。从 EAPI 2 开始，一个在文件名中包含语言环境的特定语言环境 manpage 将会被安装到 <code class="verbatim">/usr/share/man/&lt;locale&gt;/man[0-9n]</code> ，如果删除了文件名的语言环境部分，-i18n 选项将会没有效果。例如，在 EAPI2 中，命名为 <code class="verbatim">foo.&lt;locale&gt;.1</code> 的 manpage 将会安装为 <code class="verbatim">/usr/share/man/&lt;locale&gt;/man1/foo.1</code> 。从 EAPI 4 开始，-i18n 选项将会优先于语言环境后缀。</p></li>
<li><p><code class="verbatim">dohard &lt;filename&gt; &lt;linkname&gt;</code></p>
<p>从 EAPI 4 开始，dohard helper 不再继续存在。ebuild 应该直接调用 ln(1)。</p></li>
<li><p><code class="verbatim">dosym &lt;filename&gt; &lt;linkname&gt;</code></p>
<p>执行 ln 命令以创建符号链接。</p></li>
<li><p><code class="verbatim">doheader [-r] &lt;file&gt; [list of more files]</code></p>
<p>将给定的头文件安装到/usr/include 中，默认文件模式为 0644（可以通过 insopts 函数修改）。设置-r 设置递归。doheader helper 从 EAPI 5 开始可用。</p></li>
<li><p>dohtml [-a filetypes] [-r] [-x list-of-dirs-to-ignore] [list-of-files-and-dirs]</p>
<p>将文件列表（以空格分隔）中的文件安装到/usr/share/doc/${PF}/html 中，提供的文件以.htm、.html、.css、.js 结尾，设置-a 限制将会包含什么类型的文件，-A 追加到默认列表，设置-x 设置要排除的目录（默认不包括 CVS），-p 设置文档前缀，-r 设置为递归。</p></li>
<li><p><code class="verbatim">doinfo &lt;info-file&gt; [list of more info-files]</code></p>
<p>安装 info-page 到 DESTDIR/info 中。文件将会自动被 gzip 压缩。创建所有必要的目录。</p></li>
<li><p><code class="verbatim">domo &lt;locale-file&gt; [list of more locale-files]</code></p>
<p>根据 local-file 的结尾将 locale-file 安装到 DESTDIR/usr/share/locale/[LANG]中。创建所有必要的目录。</p></li>
<li><p><code class="verbatim">fowners [-h|-H|-L|-P|-R] [user][:group] &lt;file&gt; [files]</code></p></li>
<li><p><code class="verbatim">fperms [-R] &lt;permissions&gt; &lt;file&gt; [files]</code></p>
<p>执行 chown(foweners)或 chmod(fperms)更改文件权限。</p></li>
<li><p>insinto [path] 设置 doins 函数的目的路径。</p>
<p>默认路径为/。</p></li>
<li><p>insopts [options for install(1)]</p>
<p>可用于定义 doins 中使用的安装函数的选项。默认值为-m0644。</p></li>
<li><p><code class="verbatim">doins [-r] &lt;file&gt; [list of more files]</code></p>
<p>安装文件到被 insinto 控制的路径。该函数使用 install(1)。创建所有必须的目录。设置-r 设置递归。从 EAPI 4 开始，doins 和 newins 都保留符号链接。在 EAPI 3 或更早，符号链接被取消引用而不是保留。</p></li>
<li><p>exeinto [path]</p>
<p>设置 doexe 函数的目的路径。</p>
<p>默认路径为/。</p></li>
<li><p>exeopts [options for install(1)]</p>
<p>可用于为 doexe 中使用的安装函数定义选项。默认值为-m0755。</p></li>
<li><p><code class="verbatim">doexe &lt;executable&gt; [list of more executables]</code></p>
<p>安装可执行文件到被 exeinto 控制的路径中。该函数使用 install(1)。创建所有必要的目录。</p></li>
<li><p>docinto [path]</p>
<p>设置安装到文档树中时 dodoc 和 dohtml 所使用的子目录（基于/usr/share/doc/${PF}/）。默认没有子目录，或仅""。</p></li>
<li><p><code class="verbatim">dodoc [-r] &lt;document&gt; [list of more documents]</code></p>
<p>安装文档或一列表的文档到 <code class="verbatim">/usr/share/doc/${PF}/&lt;docinfo path&gt;</code> 。文档被标记为压缩。创建所有必要的目录。从 EAPI 4 开始，通过开启新的-r 选项启用对递归的支持。</p></li>
<li><p><code class="verbatim">newbin &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newsbin &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newinitd &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newconfd &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newenvd &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newlib.so &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newlib.a &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newman &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newins &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newexe &lt;old file&gt; &lt;new filename&gt;</code></p></li>
<li><p><code class="verbatim">newdoc &lt;old file&gt; &lt;new filename&gt;</code></p>
<p>所有这些函数就像 do*函数一样，但是它们仅处理一个文件，并且文件被安装为[new filename]。从 EAPI 5 开始，当第一个参数为 <code class="verbatim">-</code> （连字符）时，将读取标准输入。</p></li>
</ul>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Developer]]></title>
    <link>https://www.codeplayer.org/Wiki/Gentoo/Developer.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Gentoo/Developer.html</guid>
    <description><![CDATA[<h1 id="guru">GURU</h1>
<p><a href="https://wiki.gentoo.org/wiki/Project:GURU">https://wiki.gentoo.org/wiki/Project:GURU</a></p>
<h2 id="guru-1">GURU</h2>
<p>GURU 项目的目的是创建一个由 Gentoo 用户合作维护的新 Gentoo 软件包的官方仓库。它遵循 Sunrise 项目的传统，但是旨在通过减少 Gentoo 开发者的参与并让有经验的贡献者来负责审核其他人的工作来提高其可维护性。</p>
<h2 id="the-regulations">The regulations</h2>
<p>每一个愿意贡献到 GURU 项目的用户都需要明确的同意以下规定：</p>
<ol>
<li>GURU 项目的目的是维护一个可以被 Gentoo 用户合理使用的仓库。所有贡献者都有责任确保仓库可以安全使用并且没有恶意活严重漏洞的软件。</li>
<li>GURU 是 Gentoo 的官方项目，因此受 Gentoo 官方政策的约束。特别是，<a href="https://www.gentoo.org/glep/glep-0076.html">Copyright Policy(GLEP 76)</a>对所有提交者都有约束力。</li>
<li>虽然遵循 Gentoo ebuild 的政策和质量标准是推荐的，但不会严格的强制执行。鼓励更有经验的用户更高 GURU 中 ebuild 的质量，更里缺乏经验的用户从这些更正中学习。</li>
<li>GURU 中的软件包应具有 <code class="verbatim">~arch</code> 关键字。不得使用 stable 关键字。</li>
<li>GURU 中的软件包由社区维护。虽然鼓励用户将自己列为维护着并对其软件包承担明确的责任，其他人也可以对这些软件包进行改进，而且提交软件包而无明确的维护着也是可以接受的。</li>
<li>同时，用户被要求保持尊重和专业的行为，并尝试对 GURU 整体保持一个良好的质量。</li>
<li>GURU 的主要目的是维护不在 Gentoo 仓库中的软件包。Forking(overrding)活跃维护的 Gentoo 软件包到 GURU 中是禁止的。如果软件包被移动到 Gentoo，那么它应该从 GURU 中删除。</li>
</ol>
<h2 id="用户角色和责任">用户角色和责任</h2>
<p>GURU 将用户分为三类：</p>
<ul>
<li><em>常规用户</em> 允许提交到开发（dev）分支。</li>
<li><em>信任用户</em> 获得附加的合并提交到已审核的（master）分支的权限。</li>
<li><em>Gentoo 开发者</em> 负责处理新用户的接受、规定的执行和紧急情况的处理。</li>
</ul>
<p>新的贡献者通过<a href="https://bugs.gentoo.org/enter_bug.cgi?product=GURU&amp;component=Access+requests">在 GURU 产品中提交 bug</a> 并声明同意规定来请求访问。Gentoo 开发者授予访问仓库的权限。</p>
<p>常规贡献者在开发分支执行他们的工作。这些工作之后被信任贡献者和/或 Gentoo 开发者审核。他们要么通知作者必要的修改，要么自己修复 ebuild。无论何时最终状态足够好，他们就会合并这些修改到已审核的（master）分支。</p>
<p>信任贡献者状态由 Gentoo 开发者根据之前在 GURU 中所做的出色工作授予。信任用户通常被期望负责确保仓库免于恶意或其他危险的代码，并阻止它通过审核分支到达最终用户。</p>
<p>Gentoo 开发者可以在闲暇时间加入项目。他们的主要角色是处理来自用户的技术请求，授予信任贡献者权限以及防止滥用。</p>
<h2 id="generatingmanaging-glep-63-based-openpgp-keys">Generating/Managing GLEP 63 based OpenPGP keys</h2>
<p><a href="https://wiki.gentoo.org/wiki/Project:Infrastructure/Generating_GLEP_63_based_OpenPGP_keys">https://wiki.gentoo.org/wiki/Project:Infrastructure/Generating_GLEP_63_based_OpenPGP_keys</a></p>
<div class="sourceCode" id="cb1" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 生成新的GPG key</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">gpg</span> <span class="at">--expert</span> <span class="at">--full-generate-key</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 显式现有的GPG keys</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ex">gpg</span> <span class="at">--list-keys</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ex">gpg</span> <span class="at">--list-secret-keys</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ex">gpg</span> <span class="at">--list-secret-keys</span> <span class="at">--keyid-format</span> LONG</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 提交key到keyserver</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="ex">gpg</span> <span class="at">--keyserver</span> hkps://hkps.pool.sks-keyservers.net <span class="at">--send-keys</span> KEY-FINGERPRINT</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 生成ssh-key</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="ex">gpg</span> <span class="at">--export-ssh-key</span> <span class="op">&lt;</span>KEYID<span class="op">&gt;</span></span></code></pre></div>
<h2 id="git-setup">git setup</h2>
<div class="sourceCode" id="cb2" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># git local config</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--local</span> pull.ff only</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--local</span> pull.rebase preserve</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--local</span> commit.gpgsign 1</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--local</span> push.gpgsign 1</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="co"># warning: git rebase --preserve-merges is deprecated. Use --rebase-merges instead.</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># git user information</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--local</span> user.name <span class="st">&quot;Your Full Name&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--local</span> user.email <span class="st">&quot;someone@example.com&quot;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> config <span class="at">--local</span> user.signingkey KEY-FINGERPRINT</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># /etc/portage/make.confRepoman setup for committing</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="va">PORTAGE_GPG_KEY</span><span class="op">=</span><span class="st">&#39;KEY-FINGERPRINT&#39;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="va">DCO_SIGNED_OFF_BY</span><span class="op">=</span><span class="st">&#39;Your Real Name &lt;someone@example.com&gt;&#39;</span></span></code></pre></div>
<h2 id="committing">Committing</h2>
<div class="sourceCode" id="cb3" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># stage changes</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> add <span class="op">&lt;</span>files<span class="op">&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># check staged changes</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> status</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="co"># use repoman for committing</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="ex">repoman</span> <span class="at">-dx</span> commit</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># alternatively (or whenever direct use of Repoman is insufficient,</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ex">repman</span> <span class="at">-dx</span> full</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> commit <span class="at">-s</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># after committing, look through changs</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> log <span class="at">-p</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># finally push them</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> pull <span class="at">--rebase</span> <span class="kw">&amp;&amp;</span> <span class="fu">git</span> push</span></code></pre></div>
<h2 id="resources">Resources</h2>
<p>GURU guides:</p>
<ul>
<li><a href="https://wiki.gentoo.org/wiki/Project:GURU/Information_for_Contributors">/Information for Contributors</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Project:GURU/Information_for_Trusted_Contributors">/Information for Trusted Contributors</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Project:GURU/Information_for_Gentoo_Developers">/Information for Gentoo Developers</a> Useful development documentation:</li>
<li><a href="http://devmanual.gentoo.org/">Devmanual — Gentoo Developer Guide</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Project:Proxy_Maintainers/User_Guide">Proxy-maint project user guide</a> (not strictly suited to GURU but contains many useful tips)</li>
<li><a href="https://www.gentoo.org/glep/glep-0076.html">GLEP 76: Copyright Policy</a> (obligatory)</li>
<li><a href="https://www.gentoo.org/glep/glep-0063.html">GLEP 63: Gentoo OpenPGP Policies</a> (recommended)</li>
<li><a href="https://www.gentoo.org/glep/glep-0066.html">GLEP 66: Gentoo Git Workflow</a> (recommended)</li>
</ul>
<h2 id="links">Links</h2>
<ol>
<li><a href="https://www.gentoo.org/get-involved/become-developer/">Become a developer</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Project:GURU">Project:GURU</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Project:Proxy_Maintainers">Project:Proxy Maintainers</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Project:Recruiters">Project:Recruiters</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Project:GitHub">Project:GitHub</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Gentoo_GitHub">Gentoo GitHub</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Gentoo_git_workflow">Gentoo git workflow</a>(Not maintained by Gentoo developers)</li>
</ol>
<h1 id="proxy-maintainers">Proxy Maintainers</h1>
<p><a href="https://wiki.gentoo.org/wiki/Project:Proxy_Maintainers">https://wiki.gentoo.org/wiki/Project:Proxy_Maintainers</a></p>
<h2 id="intro">Intro</h2>
<p>Proxy Maintainers 项目是有兴趣对于贡献未维护的包到官方 Gentoo 仓库的用户的主要联系点。我们帮助用户好像他们自己一样采用一个包，无论是以前放弃的，还是新包。我们还提供了一个框架，用户可以在其中帮助开发人员在 Proxy Maintainters 项目的监督下维护他们自己的包。</p>
<h2 id="成为-proxy-maintainer-需要什么">成为 Proxy Maintainer 需要什么</h2>
<p><strong>热情</strong> ：用户关于你的包的问题将直接指向你。我们希望你能享受维护，而不觉得这是一件苦差事。</p>
<p><strong>团队合作</strong> ：我们的开发者团队将会协助和指导你确保你的提交符合 Gentoo QA 政策标准。我们将确保我们的反馈富有成效，并且你受到尊重。</p>
<p><strong>责任</strong> ： <strong>Proxy Maintainer 希望维护一个包，对任何的相关 bugs 负责，并长期保持它为最新状态。</strong> Proxy Maintainer 在提交之前在他的本地 overlay 中 <strong>仔细地测试包</strong> 。</p>
<p><strong>耐心</strong> ：包维护包括与开发者、用户和上游程序员沟通。有时你的 <strong>提交可能需要大量的工作才能满足 Gentoo QA 标准</strong> 。这可能令人沮丧，但是 Proxy Maintainers 项目将在整个尽最大努力帮助 Proxy Maintainer。</p>
<h2 id="入门">入门</h2>
<ul>
<li>如何<a href="https://wiki.gentoo.org/wiki/Project:Proxy_Maintainers/find_interesting_ebuilds_to_contribute">找到有趣的ebuild来贡献</a>？</li>
<li><a href="https://wiki.gentoo.org/wiki/Tools_for_the_work_as_proxied_maintainer">作为Proxy Maintainer工作的最佳工具</a>是什么？</li>
<li><a href="https://wiki.gentoo.org/wiki/Project:Proxy_Maintainers/merge_contributions_by_proxied_maintainers">Proxy Maintainers如何与开发者在一个包上共同工作</a>？</li>
<li>Proxy Maintainer的<a href="https://wiki.gentoo.org/wiki/Proxied_Maintainer_FAQ">FAQ和常见错误</a></li>
<li>Gentoo 新（代理）维护者在 wiki 中的常见<a href="https://wiki.gentoo.org/wiki/Abbreviations">缩写</a>列表</li>
</ul>
<h2 id="资源">资源</h2>
<ul>
<li><a href="https://wiki.gentoo.org/wiki/Project:Proxy_Maintainers/User_Guide">关于Proxy-Maint所有事情的指南</a>：这里你会找到与开发者和项目进行交互的有用信息。你会找到参与项目时要遵循的指南以及所有参与者都受约束的政策。还有关于 Proxy Maintainers 项目的 QA 标准以及如何实现这些标准的信息。</li>
<li><a href="https://wiki.gentoo.org/wiki/Gentoo_Github">Git指南</a>：通过 <strong>pull requests</strong> 和 <strong>补丁提交为项目做出贡献</strong> 。</li>
<li><a href="https://wiki.gentoo.org/wiki/Project:Proxy_Maintainers/Policies_and_Guidelines">项目政策和指南</a>：鼓励用户和开发人员熟悉项目的内部工作。</li>
</ul>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[如何向开源项目提交pull request]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/Github/%e5%a6%82%e4%bd%95%e5%90%91%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae%e6%8f%90%e4%ba%a4PR.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/Github/%e5%a6%82%e4%bd%95%e5%90%91%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae%e6%8f%90%e4%ba%a4PR.html</guid>
    <description><![CDATA[<h1 id="如何向开源项目提交-pull-request">如何向开源项目提交 pull request</h1>
<p>fork 到自己的仓库</p>
<p>git clone 到本地</p>
<p>上游建立连接 <code class="verbatim">git remote add upstream</code> 上游的仓库地址</p>
<p>创建开发分支 (非必须) <code class="verbatim">git checkout -b &lt;brance&gt;</code></p>
<p>修改提交代码 <code class="verbatim">git status</code>, <code class="verbatim">git add .</code>, <code class="verbatim">git commit -m</code></p>
<p>同步代码三部曲 <code class="verbatim">git fetch upstream</code>, <code class="verbatim">git rebase upstream/master</code> 或 <code class="verbatim">git merge origin &lt;branch&gt;</code>, <code class="verbatim">git push origin &lt;branch&gt;</code></p>
<p>提交 pr 去自己 github 仓库对应 fork 的项目下 new pull request</p>
<h1 id="参考">参考</h1>
<ul>
<li><a href="https://juejin.im/post/5b5d50bd5188251b3e646c5c">如何优雅地pull request</a></li>
<li><a href="https://juejin.im/post/5dd28604f265da0bbd5589d7">Github如何提交一个PR (Pull Requests)</a></li>
</ul>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[贪心算法：赫夫曼编码]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%ef%bc%9a%e8%b5%ab%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%ef%bc%9a%e8%b5%ab%e5%a4%ab%e6%9b%bc%e7%bc%96%e7%a0%81.html</guid>
    <description><![CDATA[<p>赫夫曼编码可以有效地压缩数据，通常可以节省 20%～90%的空间，具体压缩率依赖于数据的特性。我们将待压缩的数据看做字符序列。根据每个字符的出现频率，赫夫曼贪心算法构造出字符的最优二进制表示</p>
<p>假设有一个 10 万个字符的数据文件，它只有 6 个不同的字符，下图给出来了文件中所出现的字符和它们的出现频率。</p>
<p><img src="../../../pics/CLRS/赫夫曼编码1.png" /></p>
<p>有很多方法可以表示这个文件的信息，在本文中，我们考虑用一种*二进制字符编码*的方法，每个字符用一个唯一的二进制串表示，称为 <strong>码字</strong> 。如果使用 <strong>定长编码</strong> (Fixed-length codeword)，需要用 3 位来表示 6 个字符，具体如下图所示。这种方法需要使用 300000 个二进制位才能编码文件。</p>
<p>而 <strong>变长编码</strong> (variable-length code)可以达到更好的压缩率，其思想是赋予高频字符短码字，赋予低频字符长码字。具体如上图所示。这种编码方法需要</p>
<p>(45/1 + 13/3 + 12/3 + 16/3 + 9/4 + 5/4) * 1000 = 224 000 位</p>
<p>与定长编码相比，节省了 25%的空间，而且实际上这也是此文件最优的编码方法。</p>
<h1 id="前缀码">前缀码</h1>
<p><strong>前缀码</strong> ，即没有任何码字是其他码字的前缀。且前缀码确实可以保证达到最优数据压缩率。</p>
<p>二进制字符码的编码过程都简单，只要将表示每个字符的码字连接起来即可。前缀码的作用是简化解码过程，由于没有任何码字是其他码字的前缀 i，编码文件的开始码字是无意义的。我们简单的就能识别开始码字并转换回原字符。</p>
<p>解码过程需要前缀码的一种方便的表示形式，以便我们可以容易地截取开始码字。二叉树可以满足这种需求，其叶结点为给定的字符。一个字符的二进制码字用从根节点到叶结点的简单路径表示，其中 0 意味着转向左孩子，1意味着转向右孩子。如下图所示，a对应定长编码，b对应变长编码。文件的最优编码方案总是会对应一棵满二叉树。</p>
<p><img src="../../../pics/CLRS/赫夫曼编码2.png" /></p>
<h1 id="构造赫夫曼编码">构造赫夫曼编码</h1>
<p>赫夫曼设计了一个贪心算法来构造最优前缀码，被成为 <strong>赫夫曼编码</strong> 。</p>
<p>在下面的伪代码中，假定 C 是一个 n 个字符的集合，而其中每个字符 c ∈ C 都是一个对象，其属性 c.freq 表示字符出现的频率，算法自底向上构造出对应最优编码的二叉树。算法使用一个以 freq 为关键字的<a href="堆排序和优先队列.org">优先队列</a>Q，以识别两个最低频率的对象将其合并，从|C|个叶结点开始，执行|C|-1 个合并构造出最终的二叉树。</p>
<pre class="example"><code>n = |C|
Q = C
for i = 1 to n - 1
    allocate a new node z
    z.left = x = EXTRACT-MIN(Q)
    z.right = y = EXTRACT-MIN(Q)
    z.freq = x.freq + y.freq
    INSERT(Q, z)
return EXTRACT-MIN(Q)       //返回树的根结点
</code></pre>
<p>第二行用 C 中的字符初始化优先队列 C，具体执行过程如下图所示：</p>
<p><img src="../../../pics/CLRS/赫夫曼编码3.png" /></p>
<h1 id="实现">实现</h1>
<p>赫夫曼编码算法本身倒不算复杂，但是实现起来就有些麻烦了，因为使用混合使用了两种数据结构——优先队列和二叉树。用 C 语言使用<a href="堆排序和优先队列.org">算法导论第六章</a>中用数组实现的优先队列很难将赫夫曼编码实现。这一点亲身体验……不过找到了一篇外国的关于<a href="http://nerdaholyc.com/a-simple-example-of-huffman-coding-on-a-string/">赫夫曼编码的文章</a>。</p>
<p>他使用了三个数据结构，优先队列、二叉数、码字链表，其中优先队列是用链表实现的，并且将树的结点存储到优先队列中。作者在文章最后给出了完整的基于 C99 标准的 C 语言代码。注释也很全，我将其中的英文注释翻译为了中文(渣英语见谅)，下载链接见下。</p>
<p><a href="https://github.com/PetrusZ/CLRS-code/tree/master/chapter16/huffman">源代码下载</a></p>
<p>自己写了一个其程序流程图如下：</p>
<p><img src="http://codeplayer.org/wp-content/uploads/2013/11/2013-11-30-223810的屏幕截图.png" /> （图片丢失）</p>
<p>赫夫曼编码、解码运行结果：</p>
<p><img src="http://codeplayer.org/wp-content/uploads/2013/11/2013-11-30-213546的屏幕截图.png" /> （图片丢失）</p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[贪心算法：活动选择]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%ef%bc%9a%e6%b4%bb%e5%8a%a8%e9%80%89%e6%8b%a9.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%ef%bc%9a%e6%b4%bb%e5%8a%a8%e9%80%89%e6%8b%a9.html</guid>
    <description><![CDATA[<p>采用<a href="动态规划原理.org">动态规划</a>求解最优化问题时，需要经过一系列的步骤，并且在每个步骤都面临多种选择，这对许多最优化问题来说有杀鸡用牛刀了，可以使用更加简单、高效的算法。*贪心算法*就是这样的算法，在每一步都选择当时看起来的最优解，总是作出局部最优的选择，从而希望能够得到一个全局最优解。贪心算法不保证能够得到最优解，但是对许多问题的确可以得到最优解。贪心算法是一种强有力的算法，可以很好地解决很多问题。下面通过一个活动选择例子来直观了解一下贪心算法。</p>
<hr />
<h1 id="活动选择问题">活动选择问题</h1>
<p>假设有一个包含 n 个活动的集合 S = {a1, a2, …, an}，这些活动使用同一个资源（如同一个教室），而这个资源在同一时刻只能由一个活动使用。每个活动 ai 都有一个开始时间 s1 和结束时间 f1，也就是说一个活动的半开时间为[si, fi)。如果两个活动 ai 和 aj 的半开时间区间是不重叠的，则称它们是兼容的。 <strong>活动选择问题</strong> 就是希望选出一个最大兼容活动集。假设活动已按结束时间单调递增顺序排序。则一个活动集合 S 如下：</p>
<p><img src="../../../pics/CLRS/活动选择1.png" /></p>
<h1 id="活动选择问题的最优子结构">活动选择问题的最优子结构</h1>
<p>令 S(ij)表示在 ai 结束之后开始，且在 aj 开始之前结束的活动集合。我们需要求 S(ij)的一个最大互相兼容的活动子集，假设 A(ij)就是这样的子集，包含活动 ak。由于最优解包含活动 ak，我们得到两个子问题：寻找 S(ik)中的兼容活动和寻找 S(kj)中的兼容活动。因此，有 A(ij) = A(ik) ∪ {ak} ∪ A(kj)，S(ij)中最大兼容活动子集 A(ij)包含|A(ik)|+|A(kj)|+1 个活动。</p>
<p>令 C[i, j]表示合计 S(ij)的最优解大小，遍历考察 ak 的最优选择，则可以得到递归式：</p>
<p><img src="../../../pics/CLRS/活动选择2.png" /></p>
<h1 id="贪心选择">贪心选择</h1>
<p>其实，对于活动选择问题，我们不必考察所有可能的选择就可解决问题，即只考虑一个选择：贪心选择。</p>
<p>直观上，贪心选择就是选择这样一个任务，选出它后剩下的资源能够被尽量多的其他任务所用。对于活动选择问题来说，贪心选择其实就是选择 S 中最早结束的活动，即 a1。不过选择最早结束的活动并不是活动选择问题唯一的贪心选择方法。令 Sk 为在 ak 结束后开始的活动集合，当做出了贪心选择 a1 后，剩下的 S1 就成了唯一需要求解的子问题。相比动态规划需要求解两个子问题来说，贪心选择更加简单、高效。另外，贪心算法通常都是自顶向下的设计：做出一个选择，然后求解剩下的那个子问题，而不是自底向上地求解出很多子问题，然后再做出选择。</p>
<h1 id="递归贪心算法">递归贪心算法</h1>
<p>过程 recursive<sub>activityselector</sub> 的输入为两个数组 s 和 f，分别是活动的开始和结束时间，k指出要求解的子问题 Sk，n 为问题规模，它返回 Sk 的一个最大兼容活动子集并保存在 a 中。为了方便求解，假设输入的 n 个活动都已经按结束时间的单调递增顺序排列好，如果没有排好序，我们也可以在Ο(nlgn)时间内对其进行排序。另外为了方便算法初始化，还添加了一个虚拟活动 a0，其结束时间为 f0 = 0。这样子问题 S0 就是完整的活动集 S。具体算法见下文 C 语言代码，也加了几行简单的注释。如下图所示，其核心思想只是简单的选择第一个在活动 ak 结束之后开始的活动。</p>
<p><img src="../../../pics/CLRS/活动选择3.png" /></p>
<h1 id="迭代贪心算法">迭代贪心算法</h1>
<p>很好理解，没有什么好说的，详细信息见下文代码。</p>
<hr />
<h1 id="c-语言实现代码">C 语言实现代码</h1>
<div class="sourceCode" id="cb1" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N       11</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXBUF  20</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>recursive_activity_selector<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>f<span class="op">,</span> <span class="dt">int</span> k<span class="op">,</span> <span class="dt">int</span> n <span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>a<span class="op">)</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     m<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span>    buf<span class="op">[</span><span class="dv">4</span><span class="op">];</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> k <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>m <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> s<span class="op">[</span>m<span class="op">]</span> <span class="op">&lt;</span> f<span class="op">[</span>k<span class="op">])</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">         * 跳过开始时间在f[k]之前的活动</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> m <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>m <span class="op">&lt;=</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co">         * 贪心选择，找到开始时间在f[k]之后的第一个活动后，</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">         * 直接把它加入到活动列表中</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">         */</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        sprintf<span class="op">(</span>buf<span class="op">,</span> <span class="st">&quot;a%d &quot;</span><span class="op">,</span> m<span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        strcat<span class="op">(</span>a<span class="op">,</span> buf<span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        recursive_activity_selector<span class="op">(</span>s<span class="op">,</span> f<span class="op">,</span> m<span class="op">,</span> n<span class="op">,</span> a<span class="op">);</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>greedy_activity_selector<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>f<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>a<span class="op">)</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     k<span class="op">,</span> n<span class="op">,</span> m<span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span>    buf<span class="op">[</span><span class="dv">4</span><span class="op">];</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    strcat<span class="op">(</span>a<span class="op">,</span> <span class="st">&quot;a1 &quot;</span><span class="op">);</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> N<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>m <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> m <span class="op">&lt;=</span> n<span class="op">;</span> m<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>m<span class="op">]</span> <span class="op">&gt;=</span> f<span class="op">[</span>k<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            sprintf<span class="op">(</span>buf<span class="op">,</span> <span class="st">&quot;a%d &quot;</span><span class="op">,</span> m<span class="op">);</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>            strcat<span class="op">(</span>a<span class="op">,</span> buf<span class="op">);</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>            k <span class="op">=</span> m<span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     s<span class="op">[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span>  <span class="dv">6</span><span class="op">,</span>  <span class="dv">8</span><span class="op">,</span>  <span class="dv">8</span><span class="op">,</span>  <span class="dv">2</span><span class="op">,</span> <span class="dv">12</span><span class="op">};</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     f<span class="op">[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">12</span><span class="op">,</span> <span class="dv">14</span><span class="op">,</span> <span class="dv">16</span><span class="op">};</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span>    a<span class="op">[</span>MAXBUF<span class="op">]</span> <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* recursive_activity_selector(s, f, 0, N, a); */</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    greedy_activity_selector<span class="op">(</span>s<span class="op">,</span> f<span class="op">,</span> a<span class="op">);</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%s&quot;</span><span class="op">,</span> a<span class="op">);</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[贪心算法原理]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e5%8e%9f%e7%90%86.html</guid>
    <description><![CDATA[<blockquote>
<p>在每个贪心算法之下，几乎总有一个更繁琐的动态规划算法</p>
</blockquote>
<p>贪心算法通过做出一系列在选择来求出问题的最优解。在每个决策点，它做出在当时看来最佳的选择。这种启发式策略并不保证总能找到最优解，但对有些问题确实有效。</p>
<p>一般情况下，我们可以按如下步骤设计贪心算法： 1. 将最优化问题转化为这样的形式：对其做出一次选择后，只剩下一个子问题需要求解。 2. 证明做出贪心选择后，原问题总是存在最优解，即贪心选择是安全的。 3. 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。</p>
<p>如果证明一个贪心算法是否呢给你求解一个最优化问题呢？虽然没有适合所有情况的方法，但贪心选择性质和最优子结构是两个关键的要素。如果我们能够证明问题具有这些性质，就向贪心算法迈出了重要一步。</p>
<hr />
<h1 id="贪心选择性质">贪心选择性质</h1>
<p>第一个关键要素是 <strong>贪心选择性质</strong> ：我们可以通过做出局部最优选择来构造全局最优解。换句话说，在进行选择的时候，直接做出在当前问题中看起来最优的选择，而不必考虑子问题的解。</p>
<p>当然，我们必须证明每个步骤做出贪心选择能生成全局最优解。这种证明通常首先考察某个子问题的最优解，然后用贪心选择替换某个其他选择来修改此解，从而得到一个相似但是更小的子问题。如果在进行贪心选择的时候不得不考虑众多选择，通常意味着可以改进贪心选择，使其更为高效。</p>
<hr />
<h1 id="最优子结构">最优子结构</h1>
<p><strong>最优子结构</strong> 性质是能否应用动态规划和贪心算法的关键要素。比起动态规划而言，贪心算法通常使用更为直接的最优子结构。假定通过对原问题进行贪心选择就可以得到子问题。我们真正要做的全部工作就是论证：将子问题的最优解与贪心选择组合在一起能生成原问题的最优解。这种方法隐含地对子问题使用了数学归纳法，证明了在每个步骤进行贪心选择会生成原问题的最优解。</p>
<hr />
<h1 id="贪心对动态规划">贪心对动态规划</h1>
<p>由于贪心算法和动态规划都使用了最优子结构性质，你可能会对一个可用贪心算法求解的问题使用动态规划，或者相反。为了说明这两种方法之间的微妙差别，我们研究一个经典最优化问题的两个变形。</p>
<p><strong>0-1 背包问题</strong> ：一个正在抢劫商店的小偷发现了 n 个商品，第 i 个商品价值 vi 元，重 wi 磅，vi 和 wi 都是整数。小偷希望拿走价值尽可能高的商品，但是背包最做只能容纳 W 磅。他应该拿走哪些商品呢？</p>
<p><strong>分数背包问题</strong> ：设定与 0-1 背包一样，但是对每个商品，小偷可以只拿走其一部分，而不是只能做出二元(0-1)选择。可以把 0-1 背包问题中的商品看做品质不一大小不同的金块，而分数背包问题中的商品更像是金砂。</p>
<p>两个问题都具有最优子结构性质，虽然两个问题相似，但是我们可以用贪心算法求解分数背包，而不能求解 0-1 背包。为了求解分数背包，我们先计算每个商品的价重比即 vi/wi。遵循贪心选择，先尽可能的拿走价重比最高的商品，如果此商品全部都拿走了，再继续拿价重比第二高的商品，依次类推，直到背包装满为止。</p>
<p>为了说明贪心策略对 0-1 背包问题无效，我们使用下图中实例。商品的价格在最下，而用长度来表示商品的重量和背包的最大容量 W，即 50。按照贪心算法，小偷应先拿走商品 1，但是如下图(b)所示，最优解应该是拿走商品 2 和商品 3。</p>
<p>但是对于分数背包问题，如(c)所示先拿走商品 1 是可以生成最优解的。拿走商品 1 对 0-1 背包问题无效是因为小偷无法装满背包，空闲空间降低了方案的有效价重比。在 0-1 背包问题中，当考虑是否将一个商品装入背包时，必须比较包含此商品的子问题的解与不包含它的子问题的解，然后才能做出选择。这会导致大量的重叠子问题——动态规划的标识。<br />
<img src="../../../pics/CLRS/贪心算法原理.png" /></p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[红黑树]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e7%ba%a2%e9%bb%91%e6%a0%91.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e7%ba%a2%e9%bb%91%e6%a0%91.html</guid>
    <description><![CDATA[<p>花了两天时间用 C 语言实现了红黑树，顺便做一下读书笔记，写完之后才发现居然写了 3000 字。略微有点长了……不过红黑树的确不怎么好理解。完整的 C 语言红黑树实现在<a href="红黑树的C语言实现.org">另一篇红黑树博文</a>中，太长不方便放到同一篇中。</p>
<hr />
<p>红黑树是许多“平衡”搜索树中的一种，可以保证在最坏的情况下基本动态集合操作的时间复杂度为Ο(lgn)。</p>
<h1 id="红黑树的性质">1.红黑树的性质</h1>
<p>红黑树是一颗<a href="二叉搜索树.org">二叉搜索树</a>，它在每个结点上增加了一个存储位来表示结点的颜色，可以是 RED 或 BLACK。通过任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出 2 倍，因而是近似于平衡的。</p>
<p>树中每个结点包含 5 个属性：color、key、left、right 和 parent。如果一个结点没有子节点或父节点，则该结点相应指针属性的值为 NIL。我们可以把这些 NIL 视为指向二叉搜索树的叶结点（外部节点）的指针，而把带关键字的结点视为树的内部节结点。</p>
<p>一颗红黑树是满足下面红黑性质的<a href="二叉搜索树.org">二叉搜索树</a>：</p>
<ol>
<li>每个结点或是红色的，或是黑色的。</li>
<li>根节点是黑色的。</li>
<li>每个叶结点（NIL）是黑色的。</li>
<li>如果一个结点是红色的，则它的两个子节点都是黑色的。</li>
<li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包括相同数目的黑色结点。</li>
</ol>
<p>为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL。</p>
<p><img src="../../../pics/CLRS/rb_tree1.png" /></p>
<h1 id="旋转">2.旋转</h1>
<p>rbtree<sub>insert</sub> 和 rbtree<sub>delete</sub> 这两个操作对树做了修改，结果可能违反红黑性质。为了维护这些性质，必须要改变树中某些结点的颜色以及指针结构。</p>
<p>指针结构的修改是通过旋转(ratation)来完成的，这是一种能够保持二叉搜索性质的搜索树局部操作。</p>
<p><img src="../../../pics/CLRS/rb_tree2.png" /></p>
<p>在 left<sub>rotate</sub> 的伪代码中，假设 x.right != T.nil 且根节点的父节点为 T.nil。</p>
<div class="sourceCode" id="cb1" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>left_rotate<span class="op">(</span>RB_TREE <span class="op">*</span>T<span class="op">,</span> RB_NODE <span class="op">*</span>x<span class="op">)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    RB_NODE <span class="op">*</span>y<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> x<span class="op">-&gt;</span>right<span class="op">;</span>                   <span class="co">//set y</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    x<span class="op">-&gt;</span>right <span class="op">=</span> y<span class="op">-&gt;</span>left<span class="op">;</span>             <span class="co">//turn y&#39;s left subtree into x&#39;s right subtree</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>y<span class="op">-&gt;</span>left <span class="op">!=</span> T<span class="op">-&gt;</span>nil<span class="op">)</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        y<span class="op">-&gt;</span>left<span class="op">-&gt;</span>parent <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    y<span class="op">-&gt;</span>parent <span class="op">=</span> x<span class="op">-&gt;</span>parent<span class="op">;</span>          <span class="co">//link x&#39;s parent to y</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x<span class="op">-&gt;</span>parent <span class="op">==</span> T<span class="op">-&gt;</span>nil<span class="op">)</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        T<span class="op">-&gt;</span>root <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>left<span class="op">)</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>left <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>right <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    y<span class="op">-&gt;</span>left <span class="op">=</span> x<span class="op">;</span>                    <span class="co">//put x on y&#39;s left</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    x<span class="op">-&gt;</span>parent <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>left<sub>rotate</sub> 和 right<sub>rotate</sub> 操作的代码是对称的。其运行时间为Ο(1)，旋转过程中只有指针改变，其他所有属性不变。</p>
<p><img src="../../../pics/CLRS/rb_tree3.png" /></p>
<p>修改前和修改后的树进行中序遍历，产生相同的关键字</p>
<h1 id="插入">3.插入</h1>
<p>我们可以在Ο(lgn)时间内完成向一颗树含 n 个结点的红黑树中插入一个新结点。将二叉搜索树的 tree<sub>insert</sub> 略做修改来把结点 z 插入到红黑树中，就像红黑树是一颗普通的二叉搜索树，然后将 z 着为红色，并且调用一个辅助函数 rbinsert<sub>fixup</sub> 来对结点重新着色并旋转，以保证不新插入的结点不会违反红黑性质。</p>
<div class="sourceCode" id="cb2" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>rb_insert<span class="op">(</span>RB_TREE <span class="op">*</span>T<span class="op">,</span> RB_NODE <span class="op">*</span>z<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    RB_NODE     <span class="op">*</span>x<span class="op">,</span> <span class="op">*</span>y<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> T<span class="op">-&gt;</span>nil<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> T<span class="op">-&gt;</span>root<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>x <span class="op">!=</span> T<span class="op">-&gt;</span>nil<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>z<span class="op">-&gt;</span>key <span class="op">&amp;</span>lt<span class="op">;</span> x<span class="op">-&gt;</span>key<span class="op">)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> x<span class="op">-&gt;</span>left<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> x<span class="op">-&gt;</span>right<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    z<span class="op">-&gt;</span>parent <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>y <span class="op">==</span> T<span class="op">-&gt;</span>nil<span class="op">)</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        T<span class="op">-&gt;</span>root <span class="op">=</span> z<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>z<span class="op">-&gt;</span>key <span class="op">&amp;</span>lt<span class="op">;</span> y<span class="op">-&gt;</span>key<span class="op">)</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        y<span class="op">-&gt;</span>left <span class="op">=</span> z<span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        y<span class="op">-&gt;</span>right <span class="op">=</span> z<span class="op">;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    z<span class="op">-&gt;</span>left <span class="op">=</span> T<span class="op">-&gt;</span>nil<span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    z<span class="op">-&gt;</span>right <span class="op">=</span> T<span class="op">-&gt;</span>nil<span class="op">;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    z<span class="op">-&gt;</span>color <span class="op">=</span> RED<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    rb_insert_fixup<span class="op">(</span>T<span class="op">,</span> z<span class="op">);</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>rb_insert_fixup<span class="op">(</span>RB_TREE <span class="op">*</span>T<span class="op">,</span> RB_NODE <span class="op">*</span>z<span class="op">)</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    RB_NODE     <span class="op">*</span>y<span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>color <span class="op">==</span> RED<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>parent <span class="op">!=</span> T<span class="op">-&gt;</span>nil <span class="op">&amp;&amp;</span> z<span class="op">-&gt;</span>parent <span class="op">==</span> z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>left<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>            y <span class="op">=</span> z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>right<span class="op">;</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>y<span class="op">-&gt;</span>color <span class="op">==</span> RED<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>                z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span>           <span class="co">//case 1</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>                y<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span>                   <span class="co">//case 1</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>color <span class="op">=</span> RED<span class="op">;</span>     <span class="co">//case 1</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>                z <span class="op">=</span> z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>parent<span class="op">;</span>              <span class="co">//case 1</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span><span class="op">;</span>                           <span class="co">//case 1</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>z <span class="op">==</span> z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>                z <span class="op">=</span> z<span class="op">-&gt;</span>parent<span class="op">;</span>                      <span class="co">//case 2</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>                left_rotate<span class="op">(</span>T<span class="op">,</span> z<span class="op">);</span>                  <span class="co">//case 2</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>            z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span>               <span class="co">//case 3</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>            z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>color <span class="op">=</span> RED<span class="op">;</span>         <span class="co">//case 3</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>            right_rotate<span class="op">(</span>T<span class="op">,</span> z<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>parent<span class="op">);</span>     <span class="co">//case 3</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>            same as then<span class="op">,</span> but exchanged <span class="op">&amp;</span>quot<span class="op">;</span>right<span class="op">&amp;</span>quot<span class="op">;</span> and <span class="op">&amp;</span>quot<span class="op">;</span>left<span class="op">&amp;</span>quot<span class="op">;</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    T<span class="op">-&gt;</span>root<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>while 循环在每次迭代的开头都保持下列 3 个部分的不变：</p>
<ul>
<li>结点 z 是红色的。</li>
<li>如果 z.parent 是根结点，则它是黑色的。</li>
<li>如果有任何红黑性质被破坏，则最多只有一条被破坏，或是性质 2,或是性质 4。</li>
</ul>
<p>rbinsert<sub>fixup</sub> 操作一共可以分为三种情况，下面我们逐一进行分析：</p>
<p><img src="../../../pics/CLRS/rb_tree4.png" /></p>
<p>情况 1 和情况 2、3 的区别在于父亲的兄弟结点（叔结点）的颜色不同。使 y=z.parent.parent.right，然后测试 y 的颜色。如果 y 是红色的，那么执行情况 1。否则，进入情况 2、3。在所有三种情况中，z.parent.parent 的颜色都是黑色的，因为 z.parent 的颜色是红色的，所以性质 4 只在 z 和 z.parent 之间被破坏了。</p>
<h2 id="情况-1z-的叔结点-y-是红色的">情况 1：z 的叔结点 y 是红色的</h2>
<p>这种情况在 z.parent 和 y 都是红色时发生。因为 z.parent.parent 是黑色的，所以将 z.parent 和 y 都着为黑色，来解决 z 和 z.parent 都是红色的问题，将 z.parent.parent 着为红色以保持性质 5。然后，把 z.parent.parent 作为新结点 z 来重复 while 循环。指针 z 在树中上移两层。</p>
<p><img src="../../../pics/CLRS/rb_tree5.png" /></p>
<h2 id="情况-2z-的叔结点-y-是黑色的且-z-是一个右孩子">情况 2：z 的叔结点 y 是黑色的且 z 是一个右孩子</h2>
<h2 id="情况-3z-的叔结点-y-是黑色的且-z-是一个左孩子">情况 3：z 的叔结点 y 是黑色的且 z 是一个左孩子</h2>
<p>在情况 2、3 中 z 的叔结点 y 是黑色的。通过 z 是 z.parent 的右孩子还是左孩子来区分这两种情况。在情况 2 中，可以使用一个左旋来将此情况变为情况 3，结点 z 变为左孩子。因为 z 和 z.parent 都是红色的，所以这次旋转对黑高和性质 5 都没有影响。在旋转前先将 z 上移一层，然后旋转又将 z 下移了一层，z.parent.parent 的身份保持不变。在情况 3 中，改变某些节点的颜色并做一次右旋，以保持性质 5。这样，由于在一行中不再有两个红色结点，所有的处理到此完毕。另外因为此时 z.parent 是黑色的，所以无需再执行一次 while 循环。</p>
<p><img src="../../../pics/CLRS/rb_tree6.png" /></p>
<h1 id="删除">4.删除</h1>
<p>与红黑树的其他操作一样，删除一个结点要花费Ο(lgn)时间，但是与插入相比，删除要复杂一些。</p>
<p>红黑树的删除操作是基于<a href="二叉搜索树.org">二叉搜索树</a>的 tree<sub>delete</sub> 的，首先，我们需要设计一个特别的 rb<sub>transplant</sub> 供 rb<sub>delete</sub> 使用。</p>
<div class="sourceCode" id="cb3" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>rb_transplant<span class="op">(</span>RB_TREE <span class="op">*</span>T<span class="op">,</span> RB_NODE <span class="op">*</span>u<span class="op">,</span> RB_NODE <span class="op">*</span>v<span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>u<span class="op">-&gt;</span>parent <span class="op">==</span> T<span class="op">-&gt;</span>nil<span class="op">)</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        T<span class="op">-&gt;</span>root <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>u <span class="op">==</span> u<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>left<span class="op">)</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        u<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>left <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        u<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>right <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    v<span class="op">-&gt;</span>parent <span class="op">=</span> u<span class="op">-&gt;</span>parent<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>过程 rb<sub>delete</sub> 和 tree<sub>delete</sub> 类似，只是多了几行代码。多出的几行代码记录结点 y 的踪迹，y有可能导致红黑性质的破坏。当想要删除结点 z，且此时 z 的子节点少于 2 个时，直接将 z 删除，并让 y 成为 z。当 z 有两个子结点时，y应该是 z 的后继，并且 y 移到树中 z 的位置。在结点被删除或在树中移动前，必须记住 y 的颜色，并且记录结点 x 的踪迹，将 x 移到树中 y 的原来位置，因为结点 x 也可能引起红黑性质的破坏。删除结点 z 之后，rb<sub>delete</sub> 调用一个辅助过程 rb<sub>deletefixup</sub>，通过改变颜色和旋转来保持红黑性质。</p>
<p>总结一下，z是要删除的结点，y是结点 z 的后继，是要顶替 z 原来的位置的结点，而 x 是 y 的子结点，需要 x 顶替原来的位置。</p>
<p>下面是 rb<sub>delete</sub> 和 tree<sub>delete</sub> 过程之间的其他区别：</p>
<ul>
<li>始终维持结点 y 为从树中删除或移到树内的结点。</li>
<li>由于结点 y 的颜色可能改变，变量 y<sub>originalcolor</sub> 存储了发生改变前的 y 的颜色。我们需要保存 y 的原始颜色，以在 rb<sub>delete</sub> 结束时测试它，如果它是黑色的，那么删除或移动 y 会引起红黑性质的破坏。</li>
<li>正如前面讨论过的，我们保存结点 x 的踪迹，使它移到结点 y 的原始位置上。令 x 或指向 y 的唯一子结点或指向哨兵 T.nil（如果 y 没有子结点）。</li>
<li>当 y 的原父结点是 z 时，我们并不想让 x.parent 指向 y 的原父结点，因为要从树中删除该点。由于结点 y 将在树中向上移动占据 z 的位置，我们将 x.parent 设置为 y，使得 x.parent 指向 y 父结点的原始位置，甚至当 x=T.nil 时也是这样。</li>
</ul>
<p>最后，如果结点 y 是黑色的，那么就调用 rb<sub>deletefixup</sub> 来恢复红黑性质。如果 y 是红色的，当 y 被删除或移动时，红黑性质仍被保持，原因如下：</p>
<ol>
<li>树中的黑高没有变化。</li>
<li>不存在两个相邻的红结点。因为 y 在树中占据了 z 的位置，再考虑 z 的颜色，树中 y 的新位置不可能有两个相邻的红结点。另外，如果 y 不是 z 的右孩子，则 y 的原右孩子 x 代替 y。如果 y 是红色，则 x 一定为黑色，所以用 x 代替 y 不可能使两个红结点相邻。</li>
<li>如果 y 是红色的，就不可能是根结点，所以性质 2 保持。</li>
</ol>
<p>如果结点 y 是黑色的，则会产生 3 个问题，可以通过调用 rb<sub>deletefixup</sub> 弥补。</p>
<ol>
<li>如果 y 是原来的根结点，而 y 的一个红色的孩子成为新的根结点，就违反了性质 2。</li>
<li>如果 x 和 x.parent 是红色的，则违反了性质 4。</li>
<li>在树中移动 y 将导致先前包含 y 的简单路径上黑结点数目少 1。</li>
</ol>
<p>改正这一问题的办法是将现在占据 y 原来位置的结点 x 视为还有一重额外的黑色（只是看作还有一层额外的黑色不是真的有）。也就是说，任意包含 x 的简单路径上黑结点个数加 1。在这种假设下性质 5 成立。当将黑结点 y 删除或移动时，将其黑色“下推”给结点 x。现在的问题变成了 x 可能既不是红色也不是黑色，违反了性质 1。</p>
<p>下面，我们将通过 rb<sub>deletefixup</sub> 保持红黑性质，并解决 x 既不是红色也不是黑色的问题。</p>
<div class="sourceCode" id="cb4" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>rb_delete_fixup<span class="op">(</span>RB_TREE <span class="op">*</span>T<span class="op">,</span> RB_NODE <span class="op">*</span>x<span class="op">)</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    RB_NODE     <span class="op">*</span>w<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>x <span class="op">!=</span> T<span class="op">-&gt;</span>root <span class="op">&amp;&amp;</span> x<span class="op">-&gt;</span>color <span class="op">==</span> BLACK<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>x <span class="op">==</span> x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>left<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>right<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>w<span class="op">-&gt;</span>color <span class="op">==</span> RED<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                w<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span>                               <span class="co">//case 1</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>color <span class="op">=</span> RED<span class="op">;</span>                         <span class="co">//case 1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                left_rotate<span class="op">(</span>T<span class="op">,</span> x<span class="op">-&gt;</span>parent<span class="op">);</span>                      <span class="co">//case 1</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                w <span class="op">=</span> x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>right<span class="op">;</span>                           <span class="co">//case 1</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>w<span class="op">-&gt;</span>left<span class="op">-&gt;</span>color <span class="op">==</span> BLACK <span class="op">&amp;&amp;</span> w<span class="op">-&gt;</span>right<span class="op">-&gt;</span>color <span class="op">==</span> BLACK<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                w<span class="op">-&gt;</span>color <span class="op">=</span> RED<span class="op">;</span>                                 <span class="co">//case 2</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                x <span class="op">=</span> x<span class="op">-&gt;</span>parent<span class="op">;</span>                                  <span class="co">//case 2</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>w<span class="op">-&gt;</span>right<span class="op">-&gt;</span>color <span class="op">==</span> BLACK<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                w<span class="op">-&gt;</span>left<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span>                         <span class="co">//case 3</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>                w<span class="op">-&gt;</span>color <span class="op">=</span> RED<span class="op">;</span>                                 <span class="co">//case 3</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                right_rotate<span class="op">(</span>T<span class="op">,</span> w<span class="op">);</span>                             <span class="co">//case 3</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                w <span class="op">=</span> x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>right<span class="op">;</span>                           <span class="co">//case 3</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            w<span class="op">-&gt;</span>color <span class="op">=</span> x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>color<span class="op">;</span>                        <span class="co">//case 4</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>            x<span class="op">-&gt;</span>parent<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span>                           <span class="co">//case 4</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            w<span class="op">-&gt;</span>right<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span>                            <span class="co">//case 4</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>            left_rotate<span class="op">(</span>T<span class="op">,</span> x<span class="op">-&gt;</span>parent<span class="op">);</span>                          <span class="co">//case 4</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> T<span class="op">-&gt;</span>root<span class="op">;</span>                                        <span class="co">//case 4</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>            same as then<span class="op">,</span> but exchanged <span class="st">&quot;right&quot;</span> and <span class="st">&quot;left&quot;</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    x<span class="op">-&gt;</span>color <span class="op">=</span> BLACK<span class="op">;</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>while 循环的目标是将额外的黑色沿树上移，直到：</p>
<ol>
<li>x 指向红黑结点，此时在最后，将 x 着为（单个）黑色。</li>
<li>x 指向根结点，此时可以简单地“移除”额外的黑色。</li>
<li>执行适当的旋转和重新着色，退出循环。</li>
</ol>
<p>在 while 循环中，x总是指向一个具有双重黑色的非根结点。并保持 w 指向 x 的兄弟。由于 x 是双重黑色的，所以 w 不可能是 T.nil，否则 x.parent 到 w 的简单路径上的黑结点数目就会少于 x.parent 到 x 的简单路径上的黑结点数目。</p>
<p>rb<sub>deletefixup</sub> 的关键思想是在每种情况中，从子树的根到每棵字数α，β，……，ζ之间的黑结点个数（包括 x 的额外黑色）并不改变。</p>
<p><img src="../../../pics/CLRS/rb_tree7.png" /></p>
<p>加黑的结点颜色为 BLACK，深阴影的结点颜色为 RED，浅阴影的结点颜色用 c 和 c'表示，既可以为红色也可以为黑色。</p>
<h2 id="情况-1x-的兄弟结点-w-是红色的">情况 1：x 的兄弟结点 w 是红色的</h2>
<p>因为 w 必须有黑色子结点，所以可以改变 w 和 x.parent 的颜色，然后对 x.parent 做一次左旋而不违背红黑性质。现在，x的新兄弟结点是旋转前 w 的某个子结点，其颜色为黑色。这样就把情况 1 转换为了情况 2、3、4。</p>
<p>当结点 w 为黑色时，属于情况 2、3 和 4 这些情况是由 w 的子结点的颜色来区分的。</p>
<h2 id="情况-2x-的兄弟结点-w-为黑色且-w-的两个子结点都是黑色">情况 2：x 的兄弟结点 w 为黑色，且 w 的两个子结点都是黑色</h2>
<p>因为 w 也是黑色的，所以从 x 和 w 上去掉一重黑色，使得 x 只有一重黑色而 w 为红色。为了补偿从 x 和 w 中去掉的黑色，在原来的 x.parent 上新增一重额外额黑色。通过将 x.parent 作为新的 x 来重复 while 循环。</p>
<h2 id="情况-3x-的兄弟结点-w-为黑色且-w-的左孩子为红色右孩子为黑色">情况 3：x 的兄弟结点 w 为黑色，且 w 的左孩子为红色，右孩子为黑色</h2>
<p>可以交换 w 和其左孩子 w.left 的颜色，然后对 w 进行右旋。现在 x 新的兄弟结点 w 是一个有红色右孩子的黑色结点，于是情况 3 就变成了情况 4。</p>
<h2 id="情况-4x-的兄弟结点-w-为黑色且-w-的右孩子为红色">情况 4：x 的兄弟结点 w 为黑色，且 w 的右孩子为红色</h2>
<p>通过进行某些颜色修改并对 x.parent 做一次左旋，可以去掉 x 的额外黑色，从而使它变为单重黑色，而不破坏红黑性质。之后再将 x 设置为根，退出 while 循环。</p>
<p>通过以上 4 中情况的循环，我们可以将 x 的额外黑色消除，从而在不违背任何红黑性质的情况下删除一个结点。</p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[数据结构的扩张]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%9a%84%e6%89%a9%e5%bc%a0.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%9a%84%e6%89%a9%e5%bc%a0.html</guid>
    <description><![CDATA[<p>一些工程应用需要的只是一些”教科书“中的标准数据结构，然而也有需要其他的应用需要对现有的数据结构进行少许的创新和改造，不过很少需要创造出一类全新的数据结构。更经常的是，通过存储额外信息的方法来扩张一种标准的数据结构，然后编写新的操作来支持所需要的应用。但是对数据结构的扩张并不是简单直接的，因为添加的信息必须要能被该数据结构上的常规操作更新和维护。</p>
<p>下面介绍了两种红黑树扩张出的两种数据结构，和扩张数据结构的一般方法。</p>
<hr />
<h1 id="动态顺序统计">1.动态顺序统计</h1>
<p>顺序统计树是一种支持快速顺序统计的数据结构，它只是简单地在每个结点上存储附加信息的一颗红黑树。在结点 x 中除了一般的结点属性之外还包括一个 x.size 属性，它包含了以 x 为根的子树还有 x 本书的结点数，即这颗子树的大小。（哨兵的 size 属性为 0）</p>
<p>x.size = x.left.size + y.right.size + 1</p>
<p><img src="../../../pics/CLRS/顺序统计树.png" /></p>
<h2 id="查找具有给定秩的元素">查找具有给定秩的元素</h2>
<p>在说明如何在插入和删除中维护 size 属性前，我们先来看看可以利用 size 属性实现的功能。第一是查找具有给定秩的元素。我们定义一个元素的秩为在中序遍历时其输出的位置。</p>
<p>过程 os<sub>select</sub>(x, i)，返回一个指向以 x 为根的子树包含第 i 小关键字的结点。</p>
<pre><code>RB_NODE *
os_select(RB_NODE *x, int i)
{
    /*
    * return ith small element in tree.
    */
    int     r;

    r = x-&gt;left-&gt;size + 1;
    if (i == r)
        return(x);
    else if (i &lt; r)
        return(os_select(x-&gt;left, i));
    else
        return(os_select(x-&gt;right, i - r));
}
</code></pre>
<p>其核心思想很简单，x.left.size  + 1 就是以 x 为根的子树中结点 x 的秩。如果 i = r，那么 x 就是第 i 小元素，如果 i &lt; r，那么第 i 小元素就在 x 的左子树中，如果 i &gt; r，那么第 i 小元素在 x 的右子树中。因为以 x 为根的子树进行中序遍历时，有 r 个元素排在 x 的右子树之前，所以在以 x.right 为根进行递归 i 调用时，第 i 小元素就变成了第 i – r 小元素。</p>
<p>因为每次递归都在树中下降一层，所以 os<sub>select</sub> 的运行时间与树的高度成正比，又因为它是一颗红黑树，所以 os\<sub>select</sub> 运行时间为Ο(lgn)。</p>
<h2 id="确定一个元素的秩">确定一个元素的秩</h2>
<p>给定一个元素，过程 os<sub>rank</sub> 返回这个元素的秩。</p>
<pre><code>int
os_rank(RB_TREE *T, RB_NODE *x)
{
    /*
    * return x&#39;s rank in inorder_tree_walk.
    */
    int         r;
    RB_NODE     *y;

    r = x-&gt;left-&gt;size + 1;
    y = x;

    while (y != T-&gt;root) {
        if (y == y-&gt;parent-&gt;right)
        r = r + y-&gt;parent-&gt;left-&gt;size + 1;
        y = y-&gt;parent;
    }

    return(r);
}
</code></pre>
<p>x 的秩是中序遍历次序排在 x 之前的结点数再加上 1。如果 x 是其父结点的右孩子，说明 x.parent.left 是排在 x 之前的结点。while 循环中 y 在树中上升一层，直到根为止，依次遍历了排在 x 之前的结点，然后将在 while 循环中遇到的排在 x 之前的结点数累加起来，最后得到 x 的秩并返回。</p>
<h2 id="对子树规模的维护">对子树规模的维护</h2>
<p>下面我们来看看如何对修改后的红黑树进行维护。</p>
<p>由<a href="红黑树.org">红黑树的理论</a>可知，红黑树上的插入操作包括两个阶段。第一阶段从根开始沿树下降，将新节点插入作为某个已存在结点的孩子。第二阶段沿树上升，做一些变色和旋转操作来保持红黑树性质。</p>
<p>对第一阶段的维护没有采用算法导论中的方法，没想明白书中的“对由根至叶子的路径上遍历的每一个结点 x，都增加 x.size 属性。新增加结点的 size 为 1。”是怎么可能实现对红黑树的维护的……</p>
<p>我的方法是从插入的结点开始到根为止，遍历这条路径上的每一个结点，并使用一开始介绍的公式维护其 size 属性，正好删除的时候也要使用这个方法，一举两得。</p>
<pre><code>
void
os_fixwalk(RB_TREE *T, RB_NODE *x)
{
    RB_NODE *y;

    y = x;

    while (y != T-&gt;root) {
        y-&gt;size = y-&gt;left-&gt;size + y-&gt;right-&gt;size + 1;
        y = y-&gt;parent;
    }
}
</code></pre>
<p>在第二阶段，对红黑树结构上的改变仅仅是由旋转所致，它会使两个结点的 size 属性失效，只要在 left\<sub>rotate</sub> 和 right\<sub>rotate</sub> 中简单的增加两行就可以对失效的 size 属性进行更新。</p>
<pre><code>
/* left_rotate */
y-&gt;size = x-&gt;size;
x-&gt;size = x-&gt;left-&gt;size + x-&gt;right-&gt;size + 1;

/*right_rotate */
x-&gt;size = y-&gt;size;
y-&gt;size = y-&gt;left-&gt;size + y-&gt;right-&gt;size + 1;
</code></pre>
<p><img src="../../../pics/CLRS/对树子规模的维护.png" /></p>
<p>红黑树上的删除操作也包括两个阶段：第一阶段中，要么将结点 y 从树中删除，要么将它在树中上移。为了更新子树的规模，我们只需要遍历一条由结点 y（从它在书中的原始位置开始）到根的简单路径，并减少路径上每个结点的 size 属性值，使用的还是上面的 os\<sub>fixwalk</sub> 过程。第二阶段最多做三次旋转，其他对结构没有影响。</p>
<h1 id="如果扩张数据结构">2.如果扩张数据结构</h1>
<p>对基本的数据结构进行扩张以支持一些附加功能，在算法设计过程中是相当常见的。</p>
<p>扩张一种数据结构可以分为 4 个步骤：</p>
<ol>
<li>选择一种基础数据结构。</li>
<li>确定基础数据结构中要维护的附加信息。</li>
<li>检验基础数据结构上的基本修改操作能否维护附加信息。</li>
<li>设计一些新操作</li>
</ol>
<p>以上仅作为一个一般模式，不应盲目地按照上面给定的次序来执行这些步骤。大多数的设计工作都包含试探和纠错的成分，过程中的所有步骤通常都可以并行执行。</p>
<p>设计顺序统计树时，就依照了这 4 个步骤。</p>
<p>步骤 1，选择了红黑树作为基础数据结构。</p>
<p>步骤 2，添加了 size 属性，附加信息可使各种操作更加有效。有了 size 属性，我们可以在Ο(lgn)时间内完成 os\<sub>select</sub> 和 os\<sub>rank</sub>。</p>
<p>步骤 3，保证了插入和删除操作仍能在Ο(lgn)时间内维护 size 属性。比较理想的是，只需要更新该数据结构中的几个元素就可以维护附加信息。</p>
<p>步骤 4，设计了新操作 os\<sub>select</sub> 和 os\<sub>rank</sub>。归根结底，一开始考虑去扩张一个数据结构的原因就是为了满足新操作的需要。然后有时并不是为了设计一些新操作，而是利用附加信息来加速已有的操作。</p>
<h1 id="区间树">3.区间树</h1>
<p>区间便于表示占用一连续时间段的一些事件。例如，查询一个由时间区间数据构成的数据库，去找出给定时间区间内发生了什么时间。</p>
<p>这里所有的区间都是闭区间，我们可以把一个区间表示为一个对象 i，其中属性 i.low 为低端点，i.high 为高端点，任何两个区间 i 和 i'都满足区间三分律，即下面三条性质之一成立：</p>
<ul>
<li>i 和 i'重叠</li>
<li>i 在 i'的左边</li>
<li>i 在 i'的右边</li>
</ul>
<p><img src="../../../pics/CLRS/区间树1.png" /></p>
<p>(a)i 和 j 重叠的四种情况。(b)i 在 i'的左边。(c)i 在 i‘的右边。</p>
<p>区间树是一种对动态集合维护的红黑树，其中每个元素 x 都包含一个区间 x.int。我们将按照第 2 节中的 4 个步骤，来分析区间树以及区间树上各种操作的设计。</p>
<p><img src="../../../pics/CLRS/区间树2.png" /></p>
<p>(a)10 个区间的集合，按低端点自底向上顺序。(b)表示它们的区间树。其中序遍历列出按低端点顺序排列的结点。</p>
<h2 id="步骤-1数据数据结构">步骤 1：数据数据结构</h2>
<p>选择一颗红黑树，其每个结点 x 包含一个区间属性 x.int，且 x 的关键字为区间的低端见 x.int.low。</p>
<h2 id="步骤-2附加信息">步骤 2：附加信息</h2>
<p>每个结点除了区间属性外，还包含一个值 x.max，它是以 x 为根的子树中所有区间的端点的最大值。</p>
<h2 id="步骤-3对信息的维护">步骤 3：对信息的维护</h2>
<p>验证 n 个结点的区间树上的插入和删除操作能否在Ο(lgn)内完成。通过给定的区间和子结点的 max 值，可以确定该结点的 max 值。</p>
<p><code class="verbatim">x.max = max(x.int.high, x.left.max, x.right.max)</code></p>
<p>维护过程与顺序统计树类似，这里不再重复叙述。</p>
<h2 id="步骤-4设计新的操作">步骤 4：设计新的操作</h2>
<p>interval<sub>search</sub> 用来找出树 T 中与区间 i 重叠的那个结点。</p>
<pre><code>RB_NODE *
interval_search(RB_TREE *T, INT i)
{
    RB_NODE *x;
    x = T-&gt;root;

    while (x != T-&gt;nil &amp;&amp; !overlap(x-&gt;inv, i)) {
        if (x-&gt;left != T-&gt;nil &amp;&amp; x-&gt;left-&gt;max &gt;= i.low)
            x = x-&gt;left;
        else
            x = x-&gt;right;
        }
    return(x);
    }

    int
    overlap(INT x, INT y)
    {
        if (x.high &lt; y.low || x.low &gt; y.high)
            return(0);
        else
            return(1);
    }
}
</code></pre>
<p>该过程的基本思想是在任意结点 x 上，如果 x.int 不与 i 重叠，则查找总是沿着一个安全的方向进行。</p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[散列表之链接法]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e6%95%a3%e5%88%97%e8%a1%a8%e4%b9%8b%e9%93%be%e6%8e%a5%e6%b3%95.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e6%95%a3%e5%88%97%e8%a1%a8%e4%b9%8b%e9%93%be%e6%8e%a5%e6%b3%95.html</guid>
    <description><![CDATA[<p>许多应用都需要一种数据结构，至少支持 INSERT、SEARCH 和 DELETE 字典操作。例如，用于程序语言编译的编译器维护了一个符号表，其中元素的关键字为任意字符串，它与程序中的标识符相对应。散列表(hash table)是实现字典操作的一种有效数据结构。尽管最坏情况下，散列表中欧给你查找一个元素的时候与链表中查找的时间相同，达到了Θ(n)。然后在实际应用中，散列查找的性能是非常好的。</p>
<h1 id="直接寻址表">直接寻址表</h1>
<p>当关键字的全域 U 比较小时，直接寻址是一种简单而有效的技术。一般可以采用数组实现直接寻址表，数组下标对应的就是关键字的值，即具有关键字 k 的元素被放在直接寻址表的槽 k 中。直接寻址表的字典操作实现比较简单，直接操作数组即可，只需 O(1)的时间。</p>
<h1 id="散列表">散列表</h1>
<p>直接寻址技术的缺点也非常明显：如果全域 U 很大，则在一台标准的计算机可用内存容量中，要存储大小为|U|的一张表 T 也许不实际。还有，实际存储的关键字集合 K 相对 U 来说可能很小，使得分配给 T 的大部分空间都浪费掉。 所以我们需要将散列表的存储需求降至Θ(|k|)，同时散列表中查找一个元素的优势仍得到保持（O(1)时间）。所以在散列方式下，利用散列函数(hash function)h，由关键字 k 计算出槽的位置 h(k)。这里函数 h 将关键字的全域 U 映射到散列表 T[0..m-1]的槽位上。</p>
<figure>
<img src="../../../pics/CLRS/hash1.png" alt="hash1" /><figcaption aria-hidden="true">hash1</figcaption>
</figure>
<p>这里存在一个问题：两个关键字可能映射到同一个槽中。我们称这种情形为冲突(collision)。幸运的是，我们能找到有效的方法来解决冲突。</p>
<p>有两种种解决冲突的方法，一种是链接法(chaining)，另一种是开放寻址法(open addressing)。本文先介绍其中的一种——链接法。</p>
<h1 id="链接法">链接法</h1>
<p>在链接法中，把散列到同一槽中的所有元素都放在一个链表中。槽中有一个指针，它指向存储所有散列到该槽的元素的链表的表头，如果不存在这样的元素，则该槽中为 NIL。其插入操作、删除操作的最坏情况运行时间为 O(1)，而搜索操作的最坏情况运行时间为 O(n)，如果所有的元素都散列到同一槽中。</p>
<figure>
<img src="../../../pics/CLRS/hash2.png" alt="hash2" /><figcaption aria-hidden="true">hash2</figcaption>
</figure>
<p>在实现链接法散列表前先来看看散列函数。</p>
<h1 id="散列函数">散列函数</h1>
<p>一个好的散列函数应近似的满足简单均匀假设：每一个关键字都被等可能的散列到 m 个槽位中的任何一个，并与其他关键字已散列到哪个槽位无关。另外如果关键字的全域不是自然数集，我们需要找到一种方法将它转换为自然数。散列函数可以说是散列表性能最关键的一部分。</p>
<h2 id="除法散列法">(1)除法散列法</h2>
<p>通过取 k 除以 m 的余数，将关键字 k 映射到 m 个槽中的某一个上：</p>
<p>h(k) = k mod m</p>
<p>当应用除法散列法时，要避免选择 m 的某些值。如 m 不应为 2 的幂，如果 m=2<sup>p</sup>，则 h(k)就是 k 的 p 个最低位数字。</p>
<h2 id="乘法散列法">(2)乘法散列法</h2>
<p>第一步：用关键字 k 乘上常熟 A(0 &lt; A &lt;1)，并提取 kA 的小数部分。第二步：用 m 乘以这个值，再向下取整。总之，散列函数为：h(k) = m(kA mod 1)。</p>
<p>乘法散列法也是某种随机的一个实现，乘法与除法散列法要好的多。</p>
<h2 id="全域散列法">(3)全域散列法</h2>
<p>给定一组散列函数 H，每次进行散列时候从 H 中随机的选择一个散列函数 h，使得 h 独立于要存储的关键字。全域散列函数类的平均性能是比较好的。   在网上搜索过不少散列表的实现，不知道为什么都是比较复杂，在这里给出一种比较简单的使用链表数组的实现。</p>
<p>链接法散列表的 C 语言实现：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define m           16
//#define HASH(k)     k % m         //除法散列法

#define A           0.65
#define HASH(k)     (int)(m * (k * A - (int)(k * A)))         //乘法散列法

struct elemt{
    struct elemt    *prev;
    struct elemt    *next;
    int     key;
};

typedef struct elemt    ELEM;

typedef struct {
    ELEM    *head;
}LIST;

void
list_init(LIST *L)
{
    L-&gt;head = (ELEM *)malloc(sizeof(ELEM));
    L-&gt;head-&gt;next = L-&gt;head;
    L-&gt;head-&gt;prev = L-&gt;head;
    L-&gt;head-&gt;key = NULL;
}

void
list_insert(LIST *L, int key)
{
    /*
     * 给定一个关键字key，将key插入到链表的最前端。
     */
    ELEM    *x;

    x = (ELEM *)malloc(sizeof(ELEM));
    x-&gt;key = key;
    if (L-&gt;head-&gt;next == L-&gt;head &amp;&amp; L-&gt;head-&gt;prev == L-&gt;head)
        x-&gt;next = NULL;
    else
        x-&gt;next = L-&gt;head;
    if (L-&gt;head-&gt;next != L-&gt;head) {
        L-&gt;head-&gt;prev = x;      //L-&gt;head-&gt;prev表示的是L-&gt;head所指向的对象的prev属性
    }
    L-&gt;head = x;
    x-&gt;prev = NULL;
}

void
list_delete(LIST *L, ELEM *x)
{
    /*
     * 给定需要删除的元素x，通过修改指针将x从链表中删除。
     */
    if (x-&gt;prev != NULL) {
        x-&gt;prev-&gt;next = x-&gt;next;
    } else {
        L-&gt;head = x-&gt;next;
    }

    if (x-&gt;next != NULL) {
        x-&gt;next-&gt;prev = x-&gt;prev;
    }

    free(x);
}

ELEM *
list_search(LIST *L, int k)
{
    /*
     * 给定关键字k，查找链表中第一个关键字为k的元素，并返回指向该元素的指针。
     */
    ELEM    *x;

    x = L-&gt;head;
    while (x != NULL &amp;&amp; x-&gt;next != x &amp;&amp; x-&gt;key != k) {
        x = x-&gt;next;
    }

    if (x == NULL || x-&gt;key != k)
        x = NULL;

    return(x);
}

void
hash_insert(LIST *table, int x)
{
    /*
     * 将元素x散列后，调用链表的插入以将x到散列表中
     */
    list_insert(&amp;table[HASH(x)], x);
}

void
hash_delete(LIST *table, int x)
{
    /*
     * 调用链表搜索找到元素x的，然后再调用链表删除
     * 将其从散列表中删除
     */
    ELEM    *k;

    k = list_search(&amp;table[HASH(x)], x);
    list_delete(&amp;table[HASH(x)], k);
}

void
hash_search(LIST *table, int x)
{
    /*
     * 为了方便测试，将散列表的搜索做了一点修改，
     * 直接在stdout中输出是否找到了该元素。
     */
    ELEM    *k;
    k = list_search(&amp;table[HASH(x)], x);
    /*
    if (k != NULL)
        return(k-&gt;key);
    else
        return(NULL);
    */

    if (k != NULL)
        printf(&quot;found %d, key = %d\n&quot;, x, HASH(x));
    else
        fprintf(stderr, &quot;can&#39;t found %d\n&quot;, x);
}

void
print_hash(LIST *table)
{
    /*
     * 打印散列表
     */
    int     i;
    ELEM    *j;

    printf(&quot;--------------HASHTABLE--------------\n&quot;);
    for (i = 0; i &lt; m; i++) {
        printf(&quot;key = %2d: &quot;, i);
        j = table[i].head;
        if (j != NULL &amp;&amp; j-&gt;next != table[i].head)
            for ( ; j != NULL; j = j-&gt;next) {
                printf(&quot;value = %4d  &quot;, j-&gt;key);
            }
        else
            printf(&quot;value = NULL  &quot;, i);

        printf(&quot;\n&quot;);
    }
    printf(&quot;-----------------END-----------------\n&quot;);
}

int
main(void)
{
    /*
     * 简单的使用链表数组实现散列表
     */
    int     i, key;
    LIST    table[m];

    for (i = 0; i &lt; m; i++) {
        list_init(&amp;table[i]);
    }

    hash_insert(table, 38);
    hash_insert(table, 123);
    hash_insert(table, 94);
    hash_insert(table, 29);
    hash_insert(table, 48);
    hash_insert(table, 38);
    hash_insert(table, 923);
    hash_insert(table, 31);
    hash_insert(table, 32);
    hash_insert(table, 39);
    hash_insert(table, 2);
    hash_insert(table, 24);
    hash_insert(table, 823);

    print_hash(table);

    hash_delete(table, 38);
    hash_delete(table, 48);
    hash_delete(table, 31);

    printf(&quot;\nafter delete 38, 48, 31:\n\n&quot;);

    print_hash(table);

    printf(&quot;\nsearch 923: \n\n&quot;);
    hash_search(table, 923);

    printf(&quot;\nsearch 239: \n\n&quot;);
    hash_search(table, 239);

    exit(0);
}
</code></pre>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[散列表之开放寻址法]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e6%95%a3%e5%88%97%e8%a1%a8%e4%b9%8b%e5%bc%80%e6%94%be%e5%af%bb%e5%9d%80%e6%b3%95.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e6%95%a3%e5%88%97%e8%a1%a8%e4%b9%8b%e5%bc%80%e6%94%be%e5%af%bb%e5%9d%80%e6%b3%95.html</guid>
    <description><![CDATA[<p>在开放寻址法(open addressing)中，所有的元素都存放在散列表中。也就是说，每个表项或包含动态集合的一个元素，或包含 NIL。当查找某个元素时，要系统地检查所有的表项，直到找到所需的元素，或者最终查明该元素不在表中。不像链接法，这里既没有链表，也没有元素存放在散列表以外。因此在开放寻址法中，散列表可能会被填满，以至于不能插入任何新的元素。该方法导致的一个结果便是装载因子绝对不会超过 1。</p>
<p>开放寻址方式的好处在于它不用指针，而是计算出要存取的槽序列。于是，不用存储指针而节省的空间，使得可以用同样的空间来提供更多的槽，潜在地减少了冲突，提高了检索速度。</p>
<p>为了使用开放寻址法插入一个元素，需要连续地检查散列表，或称为探查（probe），直到找到一个空槽来存放待插入的关键字为止。</p>
<h1 id="线性探查">线性探查</h1>
<p>给定一个普通的散列函数 h‘: U‘→{0, 1, …, m – 1}，称之为辅助散列函数，线性探查方法采用的散列函数为：</p>
<p>h(k, i) = (h'(k) + i) mod m,  i = 0, 1, …, m – 1</p>
<p>线性探查方法比较容易实现，但它存在着一个问题，称为一次群集。随着连续被占用的槽不断增加，平均查找时间也随之不断增加。群集现象很容易出现，这是因为当一个空槽前有 i 个满的槽时，该空槽为下一个将被占用的概率是(i + 1) / m。连续被占用的槽就会变得越来越长，因而平均查找时间也会越来越大。</p>
<h1 id="二次探查">二次探查</h1>
<p>二次探查采用如下形式的散列函数：</p>
<p>h(k, i) = (h'(k) + c1* i + c2 * i * i) mod m</p>
<p>其中 h'是一个辅助散列函数，c1 和 c2 为正的辅助常数， i = 0, 1, …, m – 1。初始探查位置为 T[h'(k)]，后续的探查位置要加上一个偏移量，该偏移量以二次的方式依赖于探查序号 i。这种探查方法的效果要比线性探查好得多，但是，为了能够充分利用散列表， c1、c2 和 m 的值要受到限制。</p>
<p>此外，如果两个关键字的初始探查位置相同，那么它们的探查序列也是相同的，这是因为 h(k1, 0) = h(k2, 0)蕴含着 h(k1, i) = h(k2, i)。这一性质可导致一种轻度的群集，成为二次群集。</p>
<h1 id="双重散列">双重散列</h1>
<p>双重散列是用于开放寻址法的最好的方法之一，因为它所产生的排序具有随机选择排列的许多特性。双重散列采用如下形式的散列函数：</p>
<p>h(k, i) = (h1(k) + i * h2(k)) mod m</p>
<p>其中 h1 和 h2 均为辅助散列函数。初始探查位置为 T[h1(k)]，后续的探查位置是前一个位置加上偏移量 h2(k)模 m。因此，不像线性探查或二次探查，这里的探查序列以两种不同方式依赖于关键字 k，因为初始探查位置、偏移量或者二者都可能发生变化。</p>
<p>为了能查找整个散列表，值 h2(k)必须要与表大小 m 互素。有一种简便的方法确保这个条件成立，就是取 m 为 2 的幂，并设计一个总产生奇数的 h2。另一种方法是取 m 为素数，并设计一个总是返回较 m 小的正整数的函数 h2。例如，我们可以取 m 为素数，并取</p>
<p>h1(k) = k mod m，h2(k) = 1 + ( k mod m')</p>
<p>其中 m‘略小于 m（比如 m-1）。</p>
<p>最后，开放寻址法散列表的实现：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define m           17
//#define HASH(k)    k % m       //除法散列法

#define A           0.85
//#define HASH(k)    (int)(m * (k * A - (int)(k * A)))         //乘法散列法

#define c1          7
#define c2          5
//#define h(k, i)     (HASH(k) + i) % m       //线性探查
//#define h(k, i)     (HASH(i) + c1 * i + c2 * i * i) % m         //二次探查

#define h1(k)       k % m
#define h2(k)       1 + (k % (m - 1))
#define h(k, i)     (h1(k) + i * h2(k)) % m       //双重散列

#define DEL         -65535

int
hash_insert(int *T, int k)
{
    /*
     * 在散列表中插入一个元素，不断的探查
     * 以找到一个空槽可以插入，或者探查了
     * 整个散列表，输出错误信息并退出
     */
    int     i, j;

    for (i = 0; i != m; i++) {
        j = h(k, i);
        if (T[j] == NULL || T[j] == DEL) {
            T[j] = k;
            return(j);
        }
    }

    fprintf(stderr, &quot;hash table overflow\n&quot;);
    exit(1);
}

int
hash_search(int *T, int k)
{
    /*
     * 在散列表中查找一个元素，不断进行
     * 探查，直到找到该元素，或者探查到
     * 了一个空槽，或者找遍了整个散列表
     */
    int     i, j;

    for (i = 0; i != m; i++) {
        j = h(k, i);
        if (T[j] == k) {
            printf(&quot;found value: %d in key: %d\n&quot;, k, j);
            return(j);
        } else if (T[j] == NULL) {
            break;
        }
    }

    fprintf(stderr, &quot;can&#39;t find value: %d\n&quot;, k);
    return(NULL);
}

int
hash_delete(int *T, int k)
{
    /*
     * 删除一个元素的时候并不将它置为NULL，
     * 因为这有可能会使得在查找的时候找不到
     * 后续的元素，查找在删除的地方就中断了。
     * 可以在删除的时候将其置为一个特殊的值，
     * 以避免这种情况。这里用的是DEL。
     */
    int     i, j;

    for (i = 0; i != m; i++) {
        j = h(k, i);
        if (T[j] == k) {
            T[j] = DEL;
            return(0);
        }
    }

    fprintf(stderr, &quot;can&#39;t find %d in hashtable\n&quot;, k);
    exit(1);
}

void
print_hash(int *T)
{
    int     i;

    printf(&quot;---------------hashtable---------------\n&quot;);
    for (i = 0; i &lt; m; i++) {
        if (T[i] != NULL &amp;&amp; T[i] != DEL)
            printf(&quot;key: %2d, value: %4d\n&quot;, i, T[i]);
        else
            printf(&quot;key: %2d, value: NULL\n&quot;, i);
    }
    printf(&quot;------------------end------------------\n\n&quot;);
}

int
main(void)
{
    /*
     * 用数组实现的简单的开放寻址法的散列表
     */
    int     i;
    int     T[m];

    for (i = 0; i &lt; m; i++) {
        T[i] = NULL;
    }

    hash_insert(T, 28);
    hash_insert(T, 438);
    hash_insert(T, 923);
    hash_insert(T, 239);
    hash_insert(T, 29);
    hash_insert(T, 31);
    hash_insert(T, 32);
    hash_insert(T, 39);
    hash_insert(T, 2);
    hash_insert(T, 24);
    hash_insert(T, 432);

    print_hash(T);

    hash_delete(T, 239);
    hash_delete(T, 31);
    hash_delete(T, 28);

    printf(&quot;\nafter delete 239, 31, 28...\n\n&quot;);

    print_hash(T);

    hash_search(T, 438);
    hash_search(T, 239);

    exit(0);
}
</code></pre>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[摊还分析：动态表]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e6%91%8a%e8%bf%98%e5%88%86%e6%9e%90%ef%bc%9a%e5%8a%a8%e6%80%81%e8%a1%a8.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e6%91%8a%e8%bf%98%e5%88%86%e6%9e%90%ef%bc%9a%e5%8a%a8%e6%80%81%e8%a1%a8.html</guid>
    <description><![CDATA[<p>对某些应用程序，我们无法预先知道会将多少个元素存储在表中。我们为一个表分配一定的内存空间，随后可能会发现不够用。于是为其重新分配更大的空间，并将所有对象从原表中复制到新的空间中。类似地，如果从表中删除了很多元素，可能为其重新分配一个更小的内存空间是值得的。本文我们使用摊还分析来证明，虽然表在扩张和收缩时有较高的实际代价，但它们的摊还代价都是О(1)，且表中的空间空间与总空间的比例永远不会超过一个常量分数。为了方便分析，我们将一个非空表 T 的*装载因子*α(T)定义为表中存储的数据项的数量除以表的规模，一个规模为 0 的空表α(T) = 1。</p>
<h1 id="表扩张">表扩张</h1>
<p>一个常用的分配新表的启发式策略是：当旧表被填满时，我们为新表分配 2 倍旧表的槽。如果只允许插入操作，那么装载因子总是保持在 1/2 以上，因此，浪费的空间永远不会超过总空间的一半。</p>
<p>令 T.table 保存指向表的存储空间的指针，T.num 保存表中的数据数量，T.size 保存表的规模，其伪代码如下：</p>
<pre class="example"><code>if T.size == 0
    allocate T.table with 1 slot
    T.size = 1
if T.num == T.size
    allocate new-table with 2*T.size slot
    insert all items in T.table into new-table
    free T.table
    T.table = new-table
    T.size = 2*T.size
insert x into T.table
T.num = T.num + 1
</code></pre>
<p>我们将每次插入一个元素的代价设定为 1,然后用插入元素的次数来描述 TABLE-INSERT 的运行时间。设第 i 个操作的代价为 ci，一个操作的最坏情况发生在需要表扩张时，如果执行 n 个操作，一个操作的最坏情况时间为Ο(n)，从而可以的到 n 个操作的总运行时间上界Ο(n\<sup>2</sup>)。</p>
<p>当然这不是一个紧确界，因为实际上仅当 i-1 恰好为 2 的幂时，第 i 个操作才会引起一次扩张，所以第 i 个操作的代价为</p>
<p><img src="../../../pics/CLRS/动态表1.png" /></p>
<p>因此 n 个 TABLE-INSERT 操作的总代价为</p>
<p><img src="../../../pics/CLRS/动态表2.png" /></p>
<p>由于 n 个 TABLE-INSERT 操作的总代价以 3n 为上界，所以单一操作的摊还代价仅为 3。</p>
<p>如果使用核算法，则插入一个元素的 3 个代价其实分别为：插入到当前表中的代价，当表扩张时移动它的代价，当表扩张时移动另一个已经移动过一次的数据项。前一个是插入元素的实际代价，我们将后两个代价存为信用，这样在表需要扩张的时候，表中的每一个数据项都储存了 1 个代价，可以用来支付扩张时插入到新表的代价。</p>
<p>另外我们还可以使用势能法来分析。定义一个势函数Φ，在扩张操作之后其值为 0，而表满时其值为表的规模，这样就可以用势能来支付下次扩张的代价。则势函数为</p>
<p>Φ(T) = 2*T.num – T.size</p>
<p>为了分析第 i 个 TABLE-INSERT 操作的摊还代价，我们另 numi 表示第 i 个操作后表中数据数量，sizei 表示第 i 个操作后的总规模，Φi 表示第 i 个操作后的势。则如果第 i 个操作没有触发扩张，size(i) = size(i-1)，则摊还代价为</p>
<p><img src="../../../pics/CLRS/动态表3.png" /></p>
<p>如果第 i 个操作触发了扩张，则 size(i) = 2/size(i-1)及 size(i-1) = num(i-1) = num(i)-1，也就是 size(i) = 2/(num(i) – 1)。所以其摊还代价为</p>
<p><img src="../../../pics/CLRS/动态表4.png" /></p>
<p>下图画出了 num(i)、size(i)和Φ(i)随 i 变化的情况。注意势是如何累积来支付表扩张代价的，另外在每次扩张之后，势变为 0，但会立即变为 2——引起扩张的那个数据被插入表中。</p>
<p><img src="../../../pics/CLRS/动态表5.png" /></p>
<h1 id="表扩张和收缩">表扩张和收缩</h1>
<p>表收缩和表扩张是类似的操作所以省略的收缩的叙述及伪代码。理想情况下，我们希望表收缩的时候保持两个性质：</p>
<ul>
<li>动态表的装载因子有一个正的常数的下界</li>
<li>一个表操作的摊还代价有一个常数上界</li>
</ul>
<p>我们假定用元素的插入、删除次数来衡量动态表操作的代价。</p>
<p>你可能认为当插入一个数据到满表时应该将其扩张，当删除一个数据导致装载因子小于 1/2 时就应该将表规模减半。此策略可以保证表的装载因子永远不会低于 1/2，但遗憾的是，这回导致操作的瘫痪代价过大。考虑如下场景，对一个表 T 执行 n 个操作，n恰好是 2 的幂。其中前 n/2 个操作都是插入，由之前的分析可知其总代价为Θ(n)。插入序列结束时，T.num = T.size = n/2。接下来 n/2 个操作是这样的：</p>
<p>插入、删除、删除、插入、插入、删除、删除、插入、插入、……</p>
<p>第一个插入导致表扩张至 n，接下来两个删除导致表收缩为 n/2，再接下来两个插入又导致表扩张为 n，依此类推。收缩和扩张的次数将为Θ(n)，每次扩张和收缩的代价为Θ(n)。因此，n个操作的总代价为Θ(n\<sup>2</sup>)，每个操作的摊还代价为Θ(n)。</p>
<p>此策略的缺点是明显的：在表扩张之后，我们无法删除足够多的数据项来为收缩操作支付费用;类似地，在表收缩之后，我们无法插入足够多的表项来支付扩张操作。</p>
<p>我们可以改进此策略，当向一个满表插入一个新数据项时，我们仍然将表规模加倍，但是只有当装载因子小于 1/4 而不是 1/2 时，才将表规模减半。</p>
<p>可能我们直觉上认为装载因子为 1/2 比较理想，而表的势此时为 0。随着装载因此偏离 1/2，势应该增长，使得当扩张或收缩表时，表已经储存了足够的势来支付复制所有数据到新表的代价。因此，我们需要一个势函数，当装载因子增长为 1 或下降为 1/4 时，势函数值增长为 T.num。而表扩张或收缩之后，装载因子重新变为 1/2，而表的势降回 0。因此可以得到势函数如下：</p>
<p><img src="../../../pics/CLRS/动态表6.png" /></p>
<p>空表时势为 0，且势永远不可能为负，所以势函数定义的操作序列的总摊还代价是总实际代价的上界。</p>
<p>下图画出了 num(i)、size(i)和Φ(i)随 i 变化的情况。</p>
<p><img src="../../../pics/CLRS/动态表7.png" /></p>
<p>使用势能法首先分析第 i 个操作为 TABLE-INSERT 时的情况，若α(i-1) &gt;= 1/2，分析与前文相同，无论表是否扩张摊还代价最多为 3。若α(i-1) &lt; 1/2 且α(i) &lt; 1/2，第 i 个操作的摊还代价为</p>
<p><img src="../../../pics/CLRS/动态表8.png" /></p>
<p>若α(i-1) &lt; 1/2 但α(i) &gt;= 1/2，则</p>
<p><img src="../../../pics/CLRS/动态表9.png" /></p>
<p>所以，一个 TABLE-INSERT 操作的摊还代价最多为 3.</p>
<p>接着分析第 i 个操作为 TABLE-DELETE 的情况。如果α(i-1) &lt;1/2 且并未引起收缩，则摊还代价为</p>
<p><img src="../../../pics/CLRS/动态表10.png" /></p>
<p>如果α(i-1) &lt; 1/2 且第 i 个操作触发了收缩，我们有</p>
<p><img src="../../../pics/CLRS/动态表11.png" /></p>
<p>当第 i 个操作为 TABLE-DELETE 且α(i-1)时，书中将这个分析留做练习，我的算出来的答案是摊还代价为-1。</p>
<p>总之，每个操作的摊还代价的上界是一个常数，在一个动态表上执行任意 n 个操作的实际运行时间是Ο(n)。</p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[摊还分析]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e6%91%8a%e8%bf%98%e5%88%86%e6%9e%90.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e6%91%8a%e8%bf%98%e5%88%86%e6%9e%90.html</guid>
    <description><![CDATA[<p>先来直观的介绍一下什么是 <strong>摊还分析</strong> ：在摊还分析中，我们求数据结构的一个操作序列中所执行的所有操作的平均时间，来评价操作的代价。这样，我们就可以说明一个操作的平均代价是很低的，即使序列中某个单一操作的代价很高。摊还分析不同于平均情况分析，它不涉及概率，它可以保证/最坏情况下每个操作的平均性能/。</p>
<p>在学习摊还分析的时候要注意，在摊还分析中赋予对象的费用仅仅是用来分析而已，不需要也不应该出现在程序中。通过做瘫痪分析，通常可以获得对某种特定数据结构的认识，这种认识有助于优化设计。</p>
<h1 id="聚合分析">聚合分析</h1>
<p>使用 <strong>聚合分析</strong> ，我们可以证明对所有 n，一个 n 个操作的序列最坏情况下花费的总时间为 T(n)。因此，在最坏情况下，每个操作的平均时间，或 <strong>摊还代价</strong> 为 T(n)/n。注意，此摊还代价是适用于每个操作的，即使序列中有多种类型操作。下面通过两个例子来了解一下聚合分析。</p>
<h2 id="栈操作">栈操作</h2>
<p>经典的栈操作，这里不过多叙述，它支持三种操作：</p>
<ul>
<li>PUSH(S, x)，压入对象 x。</li>
<li>POP(S)，弹出一个对象。</li>
<li>MULTIPOP(S, k)，弹出 k 个对象，如果栈中对象的数量少于 k，则将所有对象弹出。</li>
</ul>
<p>我们来分析一下 n 个这三种操作在一个空栈上的运行时间。一个 MULTIPOP 操作的最坏情况时间为О(n)，因为栈的大小为最大为 n，PUSH 和 POP 最坏情况时间均为 1，假设序列中的有О(n)个 MULTIPOP 操作，所以我们通过分析每个操作的最坏情况时间得到操作序列的最坏情况时间为О(n\<sup>2</sup>)，但是这不是一个确界。</p>
<p>通过使用聚合分析，考虑整个序列的 n 个操作，可以得到更好的上界。实际上虽然 MULTIPOP 操作的最坏情况时间很高，但是在一个空栈上执行 PUSH、POP、MULTIPOP 的操作序列，代价最多是О(n)。因为我们将一个对象压入到栈后，最多只将其弹出一次，所以一个非空的栈，可以执行的 POP 次数最多为 n。因此上述操作序列最多花费О(n)时间，而一个操作的平均时间为О(n) / n = О(1)。在聚合分析中，我们将每个操作的摊还代价设定为平均代价。所以，这三种操作的摊还代价均为О(1)。</p>
<p>这里我们并未使用概率分析就证明了一个栈操作的平均代价。我们实际上得出的是一个 n 个操作序列的最坏情况运行时间О(n)，再除以 n 得到了每个操作的平均代价，或者说摊还代价。</p>
<h2 id="二进制计数器递增">二进制计数器递增</h2>
<p>一个 k 位二进制计数器递增的问题的例子。简单来说就是使用二进制来计数，并将这个二进制数放到一个数组中，可以使用一个 INCREMENT 的操作来对这个二进制数增加 1。A.length = k，将最低位保存在 A[0]中，最高位保存在 A[k-1]中。INCREMENT 的伪代码如下：</p>
<pre class="example"><code>i = 0
while i &lt; A.length and A[i] == 1
    A[i] = 0
    i = i+1
if i &lt; A.length
    A[i] = 1
</code></pre>
<p>如下图所示，在 2～4 行 while 循环时，我们希望将 1 加在第 i 位上。如果 A[i]=1，那么加 1 操作会将第 i 位翻转为 0，并产生一个进位——在一次循环中将 1 加到 i+1 位上。否则循环结束，此时若 i</p>
<p><img src="../../../pics/CLRS/摊还分析1.png" /></p>
<p>与上一个例子类似，粗略的分析会的到一个正确但是不紧的界。最坏情况下翻转数组上所有的位，INCREMENT 执行一次花费Θ(k)时间，因此 n 个 INCREMENT 的最坏时间为О(nk)。但是通过摊还分析，我们可以得到最坏运行时间О(n)，因为不可能每次 INCREMENT 都翻转所有的位。实际上，对一个初值为 0 的计数器，执行 n 个 INCREMENT 的过车给你中，A[i]会翻转 n/(2\<sup>i</sup>)次。所以我们可以得到的执行翻转操作的总数为：</p>
<p><img src="http://codeplayer.org/wp-content/uploads/2013/12/2013-12-01-170843的屏幕截图.png" /> （图片丢失）</p>
<p>所以可以得到 n 个 INCREMENT 操作序列的最坏情况时间为О(n)，摊还代价为О(n)/n = О(1)。</p>
<h1 id="核算法">核算法</h1>
<p>用 <strong>核算法</strong> 进行摊还分析时，我们对不同操作赋予不同费用，赋予某些操作的费用可能多于或少于实际代价。我们将赋予一个操作的费用成为它的*摊还代价*。当一个操作的摊还代价超出其实际代价时，我们将差额存入数据结构中的特定对象，存入的差额成为*信用*。对于后续操作中摊还代价小于实际代价的情况，信用可以用来支付差额。</p>
<p>我们必须小心地选择操作的摊还代价。如果我们希望通过分析摊还代价来证明每个操作的平均代价的最坏情况很小，就应确保操作序列的总摊还代价给出了序列总真实代价的上界。而且，这种关系必须对所有操作序列都成立。数据结构中存储的信用恰好等于总摊还代价与总实际代价的差值。数据结构所关联的信用必须一直非负值，如果在某个步骤，我们允许信用为负值，那么当时的总摊还代价就会低于总实际代价，对于到那个时刻为止的操作序列，总摊还代价就不再是总实际代价的上界了。</p>
<h2 id="栈操作-1">栈操作</h2>
<p>为了说明摊还分析的核算法，再次使用栈的例子。我们赋予 PUSH、POP、MULTIPOP 如下的摊还代价：</p>
<pre class="example"><code>PUSH 2
POP 0
MULTIPOP 0
</code></pre>
<p>PUSH 时我们将 1 元的代价支付 PUSH 操作的实际代价，将剩余的 1 元存为信用，这 1 元实际上是作为将来被 POP 时代价的预付费。当执行一个 POP 时，并不缴纳任何费用，而是使用存储的信用来支付其实际代价，对于 MULTIPOP 也是一样的。因为栈中元素的数量总是非负的，所以可以保证信用也非负的。因此，对任意 n 个 PUSH、POP、MULTIPOP 组成的序列，总摊还代价О(n)为总实际代价的上界。</p>
<h2 id="二进制计数器递增-1">二进制计数器递增</h2>
<p>在这个例子中，对一次置位操作，我们设其摊还代价为 2 元，用 1 元支付实际代价，1元存为信用，用来支付将来复位操作的代价。在任何时刻，计数器中任何为 1 的位都存有 1 元信用，这样在复位的时候，我们就不需要支付任何费用了。</p>
<p>INCREMENT 过程一次最多置位一次，因此摊还代价最多为 2 美元，计数器中 1 的个数永远不会为负，所以对于 n 个 INCREMENT 操作的总摊还代价О(n)是总实际代价的上界。</p>
<hr />
<h1 id="势能法">势能法</h1>
<p><strong>势能法</strong> 摊还分析并不预付代价表示为数据结构中特定对象的信用，而是表示为“势能”，将势能释放即可用来支付未来操作的代价。我们将势能于整个数据结构而不是特定对象相关联。</p>
<p>工作方式如下。对一个初始数据结构 D0 执行 n 个操作，对每个 i=1,2,…,n，令 ci 为第 i 个操作的实际代价，令 Di 为数据结构 Di-1 执行第 i 个操作得到的结果数据结构。*势函数*Φ将每个数据结构 Di 映射到一个实数Φ(Di)，此值即为关联到数据结构 Di 的\<sub>势</sub>\_。第 i 个操作的 <strong>摊还代价</strong> \<sup>ci</sup> 用势函数Φ定义为：</p>
<p><img src="../../../pics/CLRS/摊还分析2.png" /></p>
<p>所以每个操作的摊还代价等于其实际代价加上此操作引起的势能变化。则 n 个操作的总摊还代价为</p>
<p><img src="../../../pics/CLRS/摊还分析3.png" /></p>
<p>不同的势函数会产生不同的摊还代价，但摊还代价仍未实际代价的上界。在选择势函数时，我们常常发现可以做出一定的权衡，是否使用最佳势函数依赖于对时间界的要求。</p>
<p>两个例子还是盏和二进制计数器，不过势能法分析起来使用公式计算较多，在这里公式写起来不太方便就不详细叙述了。总体思想就是将预支付的代价添加的整个数据结构的势能中，将势能释放即可支付未来操作的代价。</p>
<p>势能法具体的例子可以看<a href="摊还分析：动态表.org">下一篇摊还分析动态表的文章</a>，虽然表面上看起来扩张与收缩会有О(n)的代价，但是实际上在表满时将表扩张一倍、装载因子为 1/4 时将表收缩一半的摊还代价仅为О(1)。</p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[基本数据结构]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.html</guid>
    <description><![CDATA[<h1 id="栈stack">栈(stack)</h1>
<p>在栈中，被删除的是最近插入的元素：栈实现的是一种后进先出（LIFO）的策略。</p>
<p>栈上的 INSERT 操作成为压入（PUSH），而无元素参数的 DELETE 操作成为弹出（POP）。这里使用一个大小为 n 的数组 S 来实现一个最多可以容纳 n 个元素的栈。该数组有一个属性 S.top，指向最新插入的元素。这很容易联想到餐馆里装有弹簧的摞盘子的栈，盘子从其中拿走的顺序刚好同它们放入的顺序相反，因为只有最上面的盘子才能被取下来。</p>
<p>如果试图对一个空栈执行 POP，则成栈下溢（underflow），如果 S.top 超过了 n，则称栈上溢（overflow），这些操作通过都是错误的。</p>
<p>栈的 C 语言实现：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct stack {
    int     *stack;
    int     size;
    int     top;
};

void
stack_init(struct stack *S)
{
    S-&gt;size = 100;
    S-&gt;stack = (int *)malloc(sizeof(int) * S-&gt;size);
    S-&gt;top = -1;
}

int
stack_empty(struct stack *S)
{
    if (S-&gt;top == -1)
        return 1;
    else
        return 0;
}

void
push(struct stack *S, int x)
{
    if (S-&gt;top == S-&gt;size) {
        printf(&quot;error: up to overflow\n&quot;);
    } else {
        S-&gt;top++;
        S-&gt;stack[S-&gt;top] = x;
    }
}

pop(struct stack *S)
{
    if (stack_empty(S)) {
        printf(&quot;error: stack underflow\n&quot;);
    } else {
        S-&gt;top--;
        return(S-&gt;stack[S-&gt;top + 1]);
    }
}

int
main(void)
{
    int             i;
    struct stack    S;

    stack_init(&amp;S);
    push(&amp;S, 10);
    push(&amp;S, 1);
    push(&amp;S, 32);
    push(&amp;S, 83);
    push(&amp;S, 23);

    printf(&quot;after push: &quot;);
    for (i = 0; i &lt;= S.top; i++) {
        printf(&quot;%d &quot;, S.stack[i]);
    }
    printf(&quot;\n&quot;);

    pop(&amp;S);
    pop(&amp;S);
    pop(&amp;S);
    printf(&quot;after pop: &quot;);
    for (i = 0; i &lt;= S.top; i++) {
        printf(&quot;%d &quot;, S.stack[i]);
    }
    printf(&quot;\n&quot;);

    return(0);
}
</code></pre>
<p>运行结果：</p>
<div class="sourceCode" id="cb2" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">silence@codeplayer:~/Projecta/CLRS$</span> ./a.out</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">after</span> push: 10 1 32 83 23</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ex">after</span> pop: 10 1</span></code></pre></div>
<h1 id="队列queue">队列(queue)</h1>
<p>在队列中，被删除去的总是在集合中存在时间最长的元素：队列实现的是一个中先进先出（FIFO）策略，就像我们平时排队一样。</p>
<p>队列上的 INSERT 操作被成为入队（ENQUEUE），DELETE 操作称为出对（DEQUEUE），就像栈的 POP 操作一样，DEQUEUE 操作也没有参数。队列有队头和队尾，当一个元素入队时，它被放在队尾的位置，而出队的元素总是在队头的那个。在这里也是用数组实现的队列。</p>
<figure>
<img src="../../../pics/CLRS/queue.png" alt="queue" /><figcaption aria-hidden="true">queue</figcaption>
</figure>
<p>队列的 C 语言实现：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define queuesize   12

typedef struct {
    int     *queue;
    int     tail;
    int     head;
    int     length;
}QUEUE;

void
queue_init(QUEUE *Q)
{
    Q-&gt;tail = 0;
    Q-&gt;head = 0;
    Q-&gt;queue = (int *)malloc(sizeof(int) * queuesize);
    Q-&gt;length = 0;
}

void
enqueue(QUEUE *Q, int x)
{
    if (Q-&gt;length == queuesize)
        printf(&quot;error: queue overflow\n&quot;);
    else {
        Q-&gt;queue[Q-&gt;tail] = x;
        if (Q-&gt;tail == queuesize - 1)
            Q-&gt;tail = 0;
        else
            Q-&gt;tail++;
        Q-&gt;length++;
    }
}

int
dequeue(QUEUE *Q)
{
    int     x;

    if (Q-&gt;length == 0)
        printf(&quot;error: queue underflow\n&quot;);
    else {
        x = Q-&gt;queue[Q-&gt;head];
        if (Q-&gt;head == queuesize - 1)
            Q-&gt;head = 0;
        else
            Q-&gt;head++;
        Q-&gt;length--;
        return x;
    }
}

int
main(void)
{
    int     i;
    QUEUE   Q;

    queue_init(&amp;Q);
    enqueue(&amp;Q, 24);
    enqueue(&amp;Q, 83);
    enqueue(&amp;Q, 1);
    enqueue(&amp;Q, 23);
    enqueue(&amp;Q, 48);
    enqueue(&amp;Q, 12);
    enqueue(&amp;Q, 94);

    printf(&quot;after qnqueue: &quot;);
    for (i = Q.head; i != Q.tail; i++) {
        if (i == queuesize - 1)
            i = 0;
        printf(&quot;%d &quot;, Q.queue[i]);
    }
    printf(&quot;\n&quot;);

    dequeue(&amp;Q);
    dequeue(&amp;Q);
    dequeue(&amp;Q);
    dequeue(&amp;Q);
    dequeue(&amp;Q);
    dequeue(&amp;Q);
    dequeue(&amp;Q);

    printf(&quot;after dequeue: &quot;);
    for (i = Q.head; i != Q.tail; i++) {
        if (i == queuesize - 1)
            i = 0;
        printf(&quot;%d &quot;, Q.queue[i]);
    }
    printf(&quot;\n&quot;);

    enqueue(&amp;Q, 23);
    enqueue(&amp;Q, 48);
    enqueue(&amp;Q, 12);
    enqueue(&amp;Q, 94);

    printf(&quot;after enqueue2: &quot;);
    for (i = Q.head; i != Q.tail; i++) {
        if (i == queuesize - 1)
            i = 0;
        printf(&quot;%d &quot;, Q.queue[i]);
    }
    printf(&quot;\n&quot;);
}
</code></pre>
<p>其运行结果为：</p>
<div class="sourceCode" id="cb4" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">silence@codeplayer:~/Projecta/CLRS$</span> ./a.out</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">after</span> enqueue: 24 83 1 23 48 12 94</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ex">after</span> dequeue:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ex">after</span> enqueue2: 23 48 12 94</span></code></pre></div>
<h1 id="链表linked-list">链表（linked list）</h1>
<p>双向链表的每一个元素都是一个对象，每一个对象有一个关键字 key 和两个指针：next 和 prev。假设 x 是链表是的一个元素，x.next 指向它在链表中的后继元素，x.prev 指向前驱元素。属性 L.head 指向链表的第一个元素。如果 L.head = NIL，则链表为空。</p>
<p><img src="../../../pics/CLRS/linked_list.png" /></p>
<p>链表的 C 语言实现：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct elemt{
    struct elemt    *prev;
    struct elemt    *next;
    int     key;
};

typedef struct elemt    ELEM;

typedef struct {
    ELEM    *head;
}LIST;

void
list_init(LIST *L)
{
    L-&gt;head = (ELEM *)malloc(sizeof(ELEM));
    L-&gt;head-&gt;next = L-&gt;head;
    L-&gt;head-&gt;prev = L-&gt;head;
    L-&gt;head-&gt;key = NULL;
}

void
list_insert(LIST *L, int key)
{
    /*
     * 给定一个关键字key，将key插入到链表的最前端。
     */
    ELEM    *x;

    x = (ELEM *)malloc(sizeof(ELEM));
    x-&gt;key = key;
    if (L-&gt;head-&gt;next == L-&gt;head &amp;&amp; L-&gt;head-&gt;prev == L-&gt;head)
        x-&gt;next = NULL;
    else
        x-&gt;next = L-&gt;head;
    if (L-&gt;head-&gt;next != L-&gt;head) {
        L-&gt;head-&gt;prev = x;      //L-&gt;head-&gt;prev表示的是L-&gt;head所指向的对象的prev属性
    }
    L-&gt;head = x;
    x-&gt;prev = NULL;
}

void
list_delete(LIST *L, ELEM *x)
{
    /*
     * 给定需要删除的元素x，通过修改指针将x从链表中删除。
     */
    if (x-&gt;prev != NULL) {
        x-&gt;prev-&gt;next = x-&gt;next;
    } else {
        L-&gt;head = x-&gt;next;
    }

    if (x-&gt;next != NULL) {
        x-&gt;next-&gt;prev = x-&gt;prev;
    }

    free(x);
}

ELEM *
list_search(LIST *L, int k)
{
    /*
     * 给定关键字k，查找链表中第一个关键字为k的元素，并返回指向该元素的指针。
     */
    ELEM    *x;

    x = L-&gt;head;
    while (x != NULL &amp;&amp; x-&gt;key != k) {
        x = x-&gt;next;
    }
    return(x);
}

int
main(void)
{
    LIST    L;
    ELEM    *elem;

    list_init(&amp;L);
    list_insert(&amp;L, 29);
    list_insert(&amp;L, 48);
    list_insert(&amp;L, 93);
    list_insert(&amp;L, 38);
    list_insert(&amp;L, 12);
    list_insert(&amp;L, 94);

    printf(&quot;after insert: &quot;);
    for (elem = L.head; elem != NULL; elem = elem-&gt;next) {
        printf(&quot;%d &quot;, elem-&gt;key);
    }
    printf(&quot;\n&quot;);

    elem = list_search(&amp;L, 12);
    list_delete(&amp;L, elem);
    elem = list_search(&amp;L, 93);
    list_delete(&amp;L, elem);
    elem = list_search(&amp;L, 29);
    list_delete(&amp;L, elem);

    printf(&quot;after delete: &quot;);
    for (elem = L.head; elem != NULL; elem = elem-&gt;next) {
        printf(&quot;%d &quot;, elem-&gt;key);
    }
    printf(&quot;\n&quot;);

    free(L.head);
}
</code></pre>
<p>其运行结果为：</p>
<div class="sourceCode" id="cb6" data-org-language="sh"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">silence@codeplayer:~/Projecta/CLRS$</span> ./a.out</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ex">after</span> insert: 94 12 38 93 48 29</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ex">after</span> delete: 94 38 48</span></code></pre></div>
<p>另外，一个有哨兵的双向循环链表的 C 语言实现：</p>
<figure>
<img src="../../../pics/CLRS/list.png" alt="list" /><figcaption aria-hidden="true">list</figcaption>
</figure>
<p>（哨兵是一个哑对象，作用是简化边界条件的处理）</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

struct elemt{
    struct elemt    *prev;
    struct elemt    *next;
    int     key;
};

typedef struct elemt    ELEM;

typedef struct {
    ELEM    *nil;
}LIST;

void
list_init(LIST *L)
{
    L-&gt;nil = (ELEM *)malloc(sizeof(ELEM));
    L-&gt;nil-&gt;next = L-&gt;nil;
    L-&gt;nil-&gt;prev = L-&gt;nil;
    L-&gt;nil-&gt;key = NULL;
}

void
list_insert(LIST *L, int key)
{
    ELEM    *x;

    x = (ELEM *)malloc(sizeof(ELEM));
    x-&gt;key = key;
    x-&gt;next = L-&gt;nil-&gt;next;
    L-&gt;nil-&gt;next-&gt;prev = x;
    L-&gt;nil-&gt;next = x;
    x-&gt;prev = L-&gt;nil;
}

void
list_delete(LIST *L, ELEM *x)
{
    x-&gt;prev-&gt;next = x-&gt;next;
    x-&gt;next-&gt;prev = x-&gt;prev;
    free(x);
}

ELEM *
list_search(LIST *L, int k)
{
    ELEM    *x;

    x = L-&gt;nil-&gt;next;
    while (x != L-&gt;nil &amp;&amp; x-&gt;key != k) {
        x = x-&gt;next;
    }
    return(x);
}

int
main(void)
{
    LIST    L;
    ELEM    *elem;

    list_init(&amp;L);
    list_insert(&amp;L, 29);
    list_insert(&amp;L, 48);
    list_insert(&amp;L, 93);
    list_insert(&amp;L, 38);
    list_insert(&amp;L, 12);
    list_insert(&amp;L, 94);

    printf(&quot;after insert: &quot;);
    for (elem = L.nil-&gt;next; elem != L.nil; elem = elem-&gt;next) {
        printf(&quot;%d &quot;, elem-&gt;key);
    }
    printf(&quot;\n&quot;);

    elem = list_search(&amp;L, 12);
    list_delete(&amp;L, elem);
    elem = list_search(&amp;L, 93);
    list_delete(&amp;L, elem);
    elem = list_search(&amp;L, 29);
    list_delete(&amp;L, elem);

    printf(&quot;after delete: &quot;);
    for (elem = L.nil-&gt;next; elem != L.nil; elem = elem-&gt;next) {
        printf(&quot;%d &quot;, elem-&gt;key);
    }
    printf(&quot;\n&quot;);

    free(L.nil);

}
</code></pre>
<p>其运行结果与没有哨兵的链表结果一致。</p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[动态规划：钢铁切割]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e9%92%a2%e6%9d%a1%e5%88%87%e5%89%b2.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e9%92%a2%e6%9d%a1%e5%88%87%e5%89%b2.html</guid>
    <description><![CDATA[<p>动态规划与分治法相似，都是通过组合子问题的解来求解原问题。分治方法将问题划分为互不相交的子问题，递归地求解子问题，即不同的子问题具有公共的子子问题。在这种情况下，分治算法会反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了不必要的计算工作。</p>
<p>动态规划方法通常用来求解*最优化问题*。这类问题有很多个可行解，每个解都有一个值，我们需要寻找具有最优值的解。</p>
<p>通常按如下 4 个步骤来设计一个动态规划算法： 1. 刻画一个最优解的结构特征。 2. 递归地定义最优解的值。 3. 计算最优解的值，通常采用自底向上的方法。 4. 利用计算出的信息构造一个最优解</p>
<p>步骤 1～3 是动态规划求解问题的基础，如果仅仅需要一个最优解的值，而非解本身，可以忽略步骤 4。</p>
<hr />
<h1 id="钢铁切割">钢铁切割</h1>
<p>先通过一个例子来直观的学习一下动态规划。</p>
<p>*切割钢铁问题*是这样的，给定一段长度为 n 的钢铁和一个价格表 p，求切割钢铁方案，使得收益 r 最大。</p>
<p><img src="../../../pics/CLRS/钢条切割.png" /></p>
<p>长度为 n 的钢铁有 2\<sup>(n-1)</sup>种不同的切割方案。一般而言，对于最大收益 rn，我们可以如下公式来描述：</p>
<p><code class="verbatim">rn = max(pn, r1+rn-1, r2+rn-2, …, rn-1+r1)</code></p>
<p>pn 对应不切割，直接出售长度为 n 的钢条。另外你 n-1 个参数对应 n-1 个方案：对于每个 i，首先将钢条切割为长度 i 和 n-i 两段，接着球这两段的最优切割收益 ri 和 rn-1。我们不知道哪种方案会获得最优收益，所以必须考察所有可能的 i，选出其中最大值。</p>
<p>注意到，为了求解规模为 n 的原问题，我们先求解形式完全一样，但规模更小的子问题。即首次切割之后，将切割后的两段钢条看作两个独立的钢条切割问题。通过组合两个相关子问题的最优解，并在所有可能的两端切割方案中选取组合收益最大的，构成原问题的最优解。我们称钢条切割问题满足*最优子结构*性质：问题的最优解由相关子问题的最优解组合而成，而这些子问题可以独立求解。</p>
<p>除了上述求解方法外，还存在一种更为简单的递归求解方法：将钢条从左边切割下长度为 i 的一段，然后只对右边剩下的长度为 n-i 的一段继续进行切割（递归求解）。即将长度为 n 的钢条分解为左边开始一段，以及剩余部分继续分解的结果。于是我们可以得到上面公式的简化版本：</p>
<p><code class="verbatim">rn = max(pi + rn-i)</code></p>
<hr />
<h1 id="自顶向下的递归实现">自顶向下的递归实现</h1>
<p>有了上面的公式，我们就可以使用 C 语言递归求解钢条切割问题了：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAX(a, b)   ((a) &amp;gt; (b) ? (a) : (b))

int
cut_rod(int *p, int n)
{
    int     i, q;

    if (n == 1)
        return(0);
    q = -65535;
    for (i = 1; i &amp;lt; n; i++) {
        q = MAX(q, p[i] + cut_rod(p, n - i));
    }

    return(q);
}

int
main(int argc, const char *argv[])
{
    int     p[11] = {0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30};
    int     max;

    max = cut_rod(p, 11);

    printf(&quot;%d\n&quot;, max);

    return 0;
}
</code></pre>
<p>在价格数组最前加个 0，是为了够能使函数 cut\<sub>rod</sub> 正确运行，令 i 从 1 开始，不会造成无限循环的问题。在实际求解问题的过程中，一旦输入的规模稍微变大，运行时间就成倍的增长。n每增大 1，运行时间就会增加一倍。实际上，cut\<sub>rod</sub> 的运行时间是 n 的指数函数，会爆炸性的增长。 当 n=10 时，运行时间都不会觉察到，当 n=20 时，大概会运行 20 秒，当 n=30 时，运行了 1 个小时都还没有结果……</p>
<p>递归算法效率这么查的原因在于它反复地用相同的参数对自身进行调用。下图显示了 n 为 4 时的调用过程。</p>
<p><img src="../../../pics/CLRS/钢条切割2.png" /></p>
<hr />
<h2 id="动态规划方法求解问题">动态规划方法求解问题</h2>
<p>与一开始说的一样，动态规划方法仔细安排求解的顺序，对每个子问题只求解一次，并将结果保存下来。如果之后再次遇到此子问题，只需查找保存的结构，而不必重新计算。所以，动态规划是付出额外的内存空间来节省计算时间，典型的时空权衡的例子，而且时间上的节省可能是非常巨大的。</p>
<p>动态规划有两种等价的实现方法：</p>
<p>第一种方法称为 <strong>带备忘的自顶向下法</strong> 。此方法仍然是按递归形式编写，但过程会保存每个子问题的解（保存在数组或散列表中）。当需要一个子问题的解时，会首先检查是否已经保存了这个解。</p>
<p>第二种方法成为 <strong>自底向上法</strong> 。这种方案一般需要恰当的定义子问题“规模”的概念，使得任何子问题的求解都只依赖于“更小的”子问题求解。因此可以将子问题排序，按由大到小的顺序进行求解。当求解某个子问题时，它所依赖的那些更小的子问题都已求解完毕，结果已经保存。</p>
<p>这两种方法的渐进运行时间相同，仅有的差异在某些特殊情况下，自顶向下方法并未真正的考察所有可能的子问题。另外，由于没有频繁的递归函数调用，自底向上的方法时间复杂度通常有更小的系数。</p>
<p>以下分别是自顶向下和自底向上解钢条切割问题的 C 语言实现：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MAX(a, b)   ((a) &amp;gt; (b) ? (a) : (b))

int
memized_cut_rod_aux(int *p, int n, int *r)
{
    /*
     *自顶向下
     */
    int     i, q;

    if (r[n - 1] &amp;gt;= 0)
        return(r[n - 1]);
    if (n == 1)
        q = 0;
    else {
        q = -65535;
        for (i = 1; i &amp;lt; n; i++) {
            q = MAX(q, p[i] + memized_cut_rod_aux(p, n - i, r));
        }
    }

    r[n - 1] = q;

    return(q);      //返回最优解
}

int
memized_cut_rod(int *p, int n)
{
    int     i, *r, max;

    r = (int *)malloc(n * sizeof(int));

    for (i = 0; i &amp;lt; n; i++) {
        r[i] = -65535;
    }

    max = memized_cut_rod_aux(p, n, r);

    free(r);

    return(max);
}

int bottom_up_cut_rod(int *p, int n)
{
    /*
     *自底向上
     */
    int     i, j, q;
    int     r[n];
    r[0] = 0;           //长度为0的钢条没有收益

    for (j = 1; j &amp;lt; n; j++) {
        q = -65535;

        for (i = 1; i &amp;lt;= j; i++)
            q = MAX(q, p[i] + r[j - i]);

        r[j] = q;       //保存子问题的最优解
    }

    return(r[n - 1]);   //返回最优解
}

int
main(int argc, const char *argv[])
{
    int     p[11] = {0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30};
    int     max;

    /* max = memized_cut_rod(p, 11); */
    max = bottom_up_cut_rod(p, 11);

    printf(&quot;%d\n&quot;, max);

    return 0;
}
</code></pre>
<p>自顶向下法中，主过程 memized\<sub>cut</sub>\<sub>rod</sub> 将辅助数组 r 初始化为一个负值，表示尚未保存任何子问题的解。然后调用辅助过成 memized\<sub>cut</sub>\<sub>rod</sub>\<sub>aux</sub>，它与递归法类似，只是保存子问题的解，并在一开始 i 检查所需的解是否已知(r[n]&gt;= 0)。</p>
<p>自底向上法，bottom\<sub>up</sub>\<sub>cut</sub>\<sub>rod</sub> 采取子问题的自然顺序依次对其进行求解。求解时采用的公式相同，只是直接访问数组元素 r[j - i]来获得子问题规模为 j – i 的解，而不进行递归调用。</p>
<p>两种方法的渐进运行时间都是Θ(n\<sup>2</sup>)。</p>
<hr />
<h1 id="子问题图">子问题图</h1>
<p>当思考一个动态规划问题时，我们应该弄清所涉及的子问题及子问题之间的依赖关系。</p>
<p>问题的 <strong>子问题图</strong> 准备地表达了这些信息。下图显示了 n=4 时钢条切割问题的子问题图。它是一个有向图，每个顶点唯一地对应一个子问题。若求子问题 x 的最优解时需要直接用到子问题 y 的最优解，那么在子问题图中就会有一条从 x 到 y 的有向边。我们可以把子问题图看作自顶向下递归树的简化版，因为树中所有相同的子问题结点都合并为了图中的单一顶点。<br />
<img src="../../../pics/CLRS/钢条切割3.png" /></p>
<p>子问题图的规模还可以帮助我们确定动态规划算法的运行时间。由于每个子问题只求解一次，因此算法的运行时间等于每个子问题求解时间之和。通常，一个子问题的求解时间与子问题图中对应顶点的度成正比。</p>
<hr />
<h1 id="重构解">重构解</h1>
<p>前面给出的算法的 C 语言实现只给出了问题的最优解的收益值，但是并没有返回最优解本身。我们可以扩展动态规划算法，使之对每个子问题不仅保存收益值，还保存对应的切割方案。利用这些信息，就可以输出最优解。下面的 C 语言代码将最优解对应的第一段钢条切割长度保存在数组 s 中，然后重构并输出最优解：</p>
<pre><code>void
extended_bottom_up_cut_rod(int *p, int n, int *r, int *s)
{
    int     i, j ,q;

    r[0] = 0;
    for (j = 1; j &amp;lt; n; j++) {
        q = -65535;

        for (i = 1; i &amp;lt;= j; i++) {
            if (q &amp;lt; p[i] + r[j - i]) {
                q = p[i] + r[j - i];
                s[j] = i;
            }
        }
        r[j] = q;
    }
}

void
print_cut_rod_solution(int *p, int n)
{
    int     r[n], s[n];

    extended_bottom_up_cut_rod(p, n, r, s);

    while (n - 1 &amp;gt; 0) {
        printf(&quot;%d &quot;, s[n - 1]);
        n = n - s[n - 1];
    }
    printf(&quot;\n&quot;);
}
</code></pre>
<p>对于前面给出的钢条切割实例，extended<sub>bottomupcutrod</sub> 会返回下面的数组：</p>
<p><img src="../../../pics/CLRS/钢条切割4.png" /></p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[动态规划：矩阵链相乘]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e7%9f%a9%e9%98%b5%e9%93%be%e7%9b%b8%e4%b9%98.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e7%9f%a9%e9%98%b5%e9%93%be%e7%9b%b8%e4%b9%98.html</guid>
    <description><![CDATA[<h1 id="动态规划矩阵链相乘-1">动态规划：矩阵链相乘</h1>
<p>本文介绍用动态规划的方法求解矩阵链相乘问题。</p>
<p>*矩阵链乘法问题*可以描述为：给定 n 个矩阵的链，矩阵 Ai 的规模为 P(i-1) * p(i)， 求完全括号化方案，使得计算乘积 A1, A2 … An 所需表量乘法次数最少。 *完全括号化*可以描述为：是一个单一的矩阵，或者是两个完全括号化的矩阵乘积链的积，且已外加括号。如下，矩阵链，一共有 5 种完全括号化方案。</p>
<p><img src="../../../pics/CLRS/矩阵链相乘1.png" /></p>
<p>对矩阵链加括号会对乘积运算的代价产生巨大的影响，加括号的顺序不同，造成结果可能会相差 10 倍。还要注意，只有两个矩阵相容的时候，即 A 的列数等于 B 的行数，才能够相乘。</p>
<hr />
<p>用穷举法解矩阵链相乘的的渐进运行时间会与 n 呈指数关系，所以我们用上一篇<a href="动态规划：钢条切割.org">动态规划上</a>中介绍的 4 个步骤来解决问题。</p>
<p><strong>步骤 1：最优括号化方案的结构特征</strong></p>
<p>动态规划的第一步就是寻找最优子结构，然后就可以使用这种子结构从子问题的最优解构造出原问题的最优解。假设 A(i)A(i+1)…A(j)的最优括号化方案的分割点在 A(k)和 A(k+1)之间。那么，继续对其前缀子链 A(i)…A(k)进行划分时，可以直接采用独立求解它时所得到的最优方案。换句话说，就是一个非平凡的矩阵链乘法问题实例的任何解都需要划分，而任何最优解都是由子问题的最优解构成的。所以，求解一个矩阵链乘法问题时，我们可以将问题划分为两个子问题，求出子问题的最优解，然后将子问题的最优解组合起来。我们必须保证在确定分割点时，考察了所有可能的划分点。</p>
<p><strong>步骤 2：一个递归求解方案</strong></p>
<p>令表 p 保存矩阵链的规模，m[i][j]表示计算矩阵 A(i, j)所需乘法次数的最少值，k为最优括号化方案的分割点，令 s[i][j]保存分割点位置 k。根据矩阵乘法公式，我们可以得到：</p>
<p>m[i][j] = m[i][k] + m[k+1][j] + p(i-1)p(k)p(j)</p>
<p>上面的公式假设 k 是已知的，虽然实际上我们并不知道，但是可以遍历 k 的 j-i 种可能，就一定能得到最优分割点 k。因此递归公式变为：</p>
<p><img src="../../../pics/CLRS/矩阵链相乘2.png" /></p>
<p><strong>步骤 3：计算最优代价</strong></p>
<p>采用自底向上的方法求解问题。首先，我们必须确定求解的顺序，在计算 m[i][j]时，需要访问哪些表项。上面的公式显示，最优代价 m[i][j]只依赖于那些少于 j-i+1 个矩阵相乘的最优代价。所以，算法应该按长度递增的顺序求解问题，并按对应顺序填写表 m。具体的计算见下文的完整代码。</p>
<p><strong>步骤 4：构造最优解</strong></p>
<p>利用表 s 保存的最优切割点，我们可以还原、构造出最优解。递归的将表 s 进行展开，就可以重构出最优解。具体实现见下文代码。</p>
<p>作为例子的矩阵链为：</p>
<p><img src="http://codeplayer.org/wp-content/uploads/2013/11/2013-11-27-181607的屏幕截图.png" /> （图片丢失）</p>
<p>完整的 C 语言代码为（为了计算方便，使矩阵的行列下表从 1 开始）：</p>
<div class="sourceCode" id="cb1" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>matrix_chain_order<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>p<span class="op">,</span> <span class="dt">int</span> m<span class="op">[</span><span class="dv">7</span><span class="op">][</span><span class="dv">7</span><span class="op">],</span> <span class="dt">int</span> s<span class="op">[</span><span class="dv">7</span><span class="op">][</span><span class="dv">7</span><span class="op">])</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">     * 计算最优代价</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     i<span class="op">,</span> j<span class="op">,</span> k<span class="op">,</span> l<span class="op">,</span> n<span class="op">,</span> q<span class="op">;</span>           <span class="co">//l为矩阵链长度</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>p<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">char</span><span class="op">)</span> <span class="op">-</span> <span class="dv">2</span><span class="op">;</span>   <span class="co">//n为矩阵个数</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span>            <span class="co">//计算矩阵链长度为1时的m</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        m<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>l <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> l <span class="op">&lt;=</span> n<span class="op">;</span> l<span class="op">++)</span> <span class="op">{</span>          <span class="co">//循环计算矩阵链长度大于1时的m</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> l <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> l <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            m<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">65535</span><span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span>k <span class="op">=</span> i<span class="op">;</span> k <span class="op">&lt;=</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span>      <span class="co">//遍历寻找最优切割点</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                q <span class="op">=</span> m<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> m<span class="op">[</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> p<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">*</span> p<span class="op">[</span>k<span class="op">]*</span> p<span class="op">[</span>j<span class="op">];</span>  <span class="co">//矩阵乘法公式</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>q <span class="op">&lt;</span> m<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                    m<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> q<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                    s<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>print_optimal_parens<span class="op">(</span><span class="dt">int</span> s<span class="op">[</span><span class="dv">7</span><span class="op">][</span><span class="dv">7</span><span class="op">],</span> <span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co">     * 重构最优解</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> j<span class="op">)</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;A%d&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;(&quot;</span><span class="op">);</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        print_optimal_parens<span class="op">(</span>s<span class="op">,</span> i<span class="op">,</span> s<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>        print_optimal_parens<span class="op">(</span>s<span class="op">,</span> s<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;)&quot;</span><span class="op">);</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     p<span class="op">[</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">30</span><span class="op">,</span> <span class="dv">35</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">25</span><span class="op">};</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     m<span class="op">[</span><span class="dv">7</span><span class="op">][</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     s<span class="op">[</span><span class="dv">7</span><span class="op">][</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>    matrix_chain_order<span class="op">(</span>p<span class="op">,</span> m<span class="op">,</span> s<span class="op">);</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;table m:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">7</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">7</span><span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;%5d &quot;</span><span class="op">,</span> m<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">矩阵链A1...A6所需的最少乘法次数为： %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> m<span class="op">[</span><span class="dv">1</span><span class="op">][</span><span class="dv">6</span><span class="op">]);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;最优解为：&quot;</span><span class="op">);</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    print_optimal_parens<span class="op">(</span>s<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">6</span><span class="op">);</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<p>动态规划的关键是分析其最优子结构和如果利用最优子结构求解问题，与前文的算法不同，没有一个固定的方法求解，不过动态规划也不限于一个固定的问题。另外在本例中如何处理数组下表来简化计算也很重要。</p>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[最长公共子序列]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97.html</guid>
    <description><![CDATA[<p>本文介绍使用动态规划的方法解最长公共子序列（LCS）问题。</p>
<p>先介绍一下定义。给定两个序列 X 和 Y，如果 Z 既是 X 的子序列，也是 Y 的子序列，Z就可以成为 X 和 Y 的*公共子序列*。*最长公共子序列问题*指的是给定两个序列 X 和 Y，求 X 和 Y 长度最长的公共子序列。下面开始求解。</p>
<hr />
<h1 id="步骤-1刻画最长公共子序列">步骤 1：刻画最长公共子序列</h1>
<p>暴力求解的穷举法绝对是一个坏主意，因为其运行时间为指数阶。所以我们要来寻找 LCS 的最优子结构。最优子结构如下：</p>
<p>令 X = 和 Y = 为两个序列，Z = 为 X 和 Y 的任意 LCS。 1. 如果 xm = yn，则 zk=xm=yn 且 Z(k-1)是 X(m-1)和 Y(n-1)的一个 LCS。 2. 如果 xm != yn，那么 zk != xm 意味着 Z 是 X(m-1)和 Y 的一个 LCS。 3. 如果 xm != yn，那么 zk != yn 意味着 Z 是 X 和 Y(n-1)的一个 LCS。</p>
<p>第一条很好理解，如果 xm = yn，则只是把 LCS 的长度加 1 即可。第二条和第三条就不是那么直观了，大概意思就是如果 xm != yn，则 Z 是 X(m-1)和 Y 或者是 X 和 Y(n-1)的一个 LCS。LCS 的长度实质上没有改变，只是跳过了一个 xm 或 yn 而已，因为在这一步中 xm 和 yn 不等，所以 LCS 没变。</p>
<hr />
<h1 id="步骤-2一个递归解">步骤 2：一个递归解</h1>
<p>如步骤 1 所述，如果 xm = yn，我们应该求解 X(m-1)和 Y(n-1)的一个 LCS，然后将 xm = yn 添加到这个 LCS 的末尾，就得到了 X 和 Y 的 LCS。如果 xm != yn，我必须求解两个子问题，X(m-1)和 Y 的 LCS 与 X 和 Y(n-1)的 LCS，然后将其中较长的作为 X 和 Y 的 LCS。因为这些情况覆盖了所有的可能，所以必然有一个最优解出现在 X 和 Y 的 LCS 中。另外 LCS 的重叠子问题性质也很明显，在求解 X 和 Y 的 LCS 时，我们会需要 X 和 Y(n-1)的 LCS 及 X(m-1)和 Y 的 LCS，也需要求解 X(m-1)和 Y(n-1)的子问题。</p>
<p>定义 c[i, j]表示 X(i)和 Y(j)的 LCS 长度，由上述的讨论我们可以得到递归公式：</p>
<p><img src="../../../pics/CLRS/最长公共子序列1.png" /></p>
<hr />
<h1 id="步骤-3计算-lcs-的长度">步骤 3：计算 LCS 的长度</h1>
<p>采用自底向上的方法，用表 c 存储 LCS 长度，用表 b[i, j]存储对应计算 c[i, j]时所选择的子问题最优解，然后按行主次序计算表项。具体计算方法见下文的完整 C 语言代码。</p>
<p>下图显示了输入序列 X = 和 Y = 生成的表 c 和表 b（两张表放在了同一张图中），运行时间为Θ(mn)。注意图中显示了两个不同的 LCS，长度均为 4。</p>
<p><img src="../../../pics/CLRS/最长公共子序列2.png" /></p>
<hr />
<h1 id="步骤-4构造-lcs">步骤 4：构造 LCS</h1>
<p>利用表 b，将其递归展开，就可以得到一个 LCS。简单地从 b[m ,n]开始，然后按箭头的方向追踪下去即可，当遇到一个”↖”时，就意味着 xi = yj 是 LCS 的一个元素。同样，具体实现见下本的 C 语言代码。</p>
<hr />
<h1 id="c-语言实现">C 语言实现</h1>
<p>动态规划法解 LCS 问题的 C 语言实现如下，其中包含了两个例子，一个是上文中的 ABCD 的例子，又一个是算法导论中求 DNS 串相似度的例子：</p>
<div class="sourceCode" id="cb1" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">/* DNA串 例1 */</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define A   1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define C   2</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define G   3</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="pp">#define T   4</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">/* 简单的ABCD 例2 */</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">/* #define A   1 */</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">/* #define B   2 */</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">/* #define C   3 */</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">/* #define D   4 */</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="pp">#define UPRIGTH     5</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="pp">#define UP          6</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="pp">#define LEFT        7</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">/* 例1 */</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="pp">#define XLEN       29</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="pp">#define YLEN       28</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">/* 例2 */</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">/* #define XLEN       7 */</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co">/* #define YLEN       6 */</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>lcs_length<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>x<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>y<span class="op">,</span> <span class="dt">int</span> c<span class="op">[</span>XLEN <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>YLEN <span class="op">+</span> <span class="dv">1</span><span class="op">],</span> <span class="dt">int</span> b<span class="op">[</span>XLEN <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>YLEN <span class="op">+</span> <span class="dv">1</span><span class="op">])</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> XLEN<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        c<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> XLEN<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        c<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> XLEN<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> YLEN<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>x<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> y<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>                c<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> c<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>                b<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> UPRIGTH<span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>c<span class="op">[</span>i <span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">&gt;=</span> c<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>                c<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> c<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>                b<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> UP<span class="op">;</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>                c<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> c<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>                b<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> LEFT<span class="op">;</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>print_elem<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span><span class="op">(</span>x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> A<span class="op">:</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;A&quot;</span><span class="op">);</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* case B: */</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>            <span class="co">/* printf(&quot;B&quot;); */</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>            <span class="co">/* break; */</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> C<span class="op">:</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;C&quot;</span><span class="op">);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* case D: */</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>            <span class="co">/* printf(&quot;D&quot;); */</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>            <span class="co">/* break; */</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> G<span class="op">:</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;G&quot;</span><span class="op">);</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> T<span class="op">:</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;T&quot;</span><span class="op">);</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;0&quot;</span><span class="op">);</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>print_arrow<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span><span class="op">(</span>x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> UPRIGTH<span class="op">:</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;↖ &quot;</span><span class="op">);</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> UP<span class="op">:</span></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;↑ &quot;</span><span class="op">);</span></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> LEFT<span class="op">:</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;← &quot;</span><span class="op">);</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;0 &quot;</span><span class="op">);</span></span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>print_lcs<span class="op">(</span><span class="dt">int</span> b<span class="op">[</span>XLEN <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>YLEN <span class="op">+</span> <span class="dv">1</span><span class="op">],</span> <span class="dt">int</span> <span class="op">*</span>x<span class="op">,</span> <span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> j <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>b<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> UPRIGTH<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>        print_lcs<span class="op">(</span>b<span class="op">,</span> x<span class="op">,</span> i <span class="op">-</span><span class="dv">1</span><span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>        print_elem<span class="op">(</span>x<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>b<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> UP<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>        print_lcs<span class="op">(</span>b<span class="op">,</span> x<span class="op">,</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>        print_lcs<span class="op">(</span>b<span class="op">,</span> x<span class="op">,</span> i<span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     n<span class="op">,</span> m<span class="op">;</span></span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* 例1 */</span></span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     x<span class="op">[</span>XLEN <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span>A<span class="op">,</span>C<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>G<span class="op">,</span>T<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>A<span class="op">,</span>G<span class="op">,</span>T<span class="op">,</span>G<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>G<span class="op">,</span>A<span class="op">,</span>A<span class="op">,</span>G<span class="op">,</span>C<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>G<span class="op">,</span>C<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>A<span class="op">,</span>A<span class="op">};</span></span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     y<span class="op">[</span>YLEN <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span>G<span class="op">,</span>T<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>T<span class="op">,</span>T<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>G<span class="op">,</span>A<span class="op">,</span>A<span class="op">,</span>T<span class="op">,</span>G<span class="op">,</span>C<span class="op">,</span>C<span class="op">,</span>G<span class="op">,</span>T<span class="op">,</span>T<span class="op">,</span>G<span class="op">,</span>C<span class="op">,</span>T<span class="op">,</span>C<span class="op">,</span>T<span class="op">,</span>G<span class="op">,</span>T<span class="op">,</span>A<span class="op">,</span>A<span class="op">,</span>A<span class="op">};</span></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* 例2 */</span></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* int     x[XLEN + 1] = {0, A, B, C, B, D, A, B}; */</span></span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* int     y[YLEN + 1] = {0, B, D, C, A, B, A}; */</span></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     c<span class="op">[</span>XLEN <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>YLEN <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     b<span class="op">[</span>XLEN <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>YLEN <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>    lcs_length<span class="op">(</span>x<span class="op">,</span> y<span class="op">,</span> c<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;table b:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> XLEN<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> YLEN<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>            print_arrow<span class="op">(</span>b<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;table c:</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> XLEN<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> YLEN<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;%2d &quot;</span><span class="op">,</span> c<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;sequence X: &quot;</span><span class="op">);</span></span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> XLEN<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a>        print_elem<span class="op">(</span>x<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;sequence Y: &quot;</span><span class="op">);</span></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> YLEN<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>        print_elem<span class="op">(</span>y<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;LCS: &quot;</span><span class="op">);</span></span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a>    print_lcs<span class="op">(</span>b<span class="op">,</span> x<span class="op">,</span> XLEN<span class="op">,</span> YLEN<span class="op">);</span></span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[动态规划：最优二叉搜索树]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e6%9c%80%e4%bc%98%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%9a%e6%9c%80%e4%bc%98%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91.html</guid>
    <description><![CDATA[<p>*最优二叉搜索树*问题可以定义如下：给定一个 n 个不同关键字的已排序的序列 K = ，用这些关键字构造一棵二叉搜索树。每个关键字 ki，都有一个概率 pi 表示其搜索频率。有些要搜索的值可能不在 K 中，因此还有 n+1 个伪关键字 d0, d1, d2, …, dn 表示不在 K 中的值。d0 表示小于 k1 的值，dn 表示大于 kn 的值，其他的 di 表示所有在 ki 和 ki+1 之间的值。对于每个伪关键字 di，也都有一个频率 qi 表示对应的搜索频率。</p>
<p>下图显示了对一个 n=5 个关键字集合构造的两棵二叉搜索树，每个关键字的频率如下表所示。每个关键字 ki 是一个内部结点，而 di 是一个叶子结点。每次搜索要么成功，要么失败，所以有如下公式：<br />
<img src="../../../pics/CLRS/最优二叉搜索树1.png" /></p>
<p>二叉搜索树（左边的树期望搜索代价为 2.80，右边的为最优二叉搜索树 2.75）：</p>
<p><img src="../../../pics/CLRS/最优二叉搜索树2.png" /></p>
<p>关键字搜索概率：</p>
<p><img src="../../../pics/CLRS/最优二叉搜索树3.png" /></p>
<p>由于我们知道每个关键字搜索概率，所以可以确定在一棵给定的二叉搜索树 T 中进行一次搜索的期望代价。假定一次搜索的代价等于访问的结点数，即此次搜索找到的结点在 T 中的深度再加 1。那么一次搜索的期望代价如下，第二个等式时由上文的公式推导而来：</p>
<p><img src="../../../pics/CLRS/最优二叉搜索树4.png" /></p>
<p>对于一个给定的概率集合，构造一棵期望搜索代价最小的二叉搜索树，即为*最优二叉搜索树*。这个例子也显示了最优二叉搜索树不一定是高度最矮的，而且概率高的关键字也不一定为根节点。下面我们来求解最优二叉搜索树问题。</p>
<hr />
<h1 id="步骤-1最优二叉搜索树的结构">步骤 1：最优二叉搜索树的结构</h1>
<p>二叉搜索树的最优子结构为：如果一棵最优二叉搜索树 T 有一棵包含关键字 ki, …, kj 的子树 T'，那么 T'必然是包含关键字 ki, …, kj 和伪关键字 di-1, …, dj 的子问题最优解。由最优解子结构，我们可以用子问题的最优解构造原问题的最优解。给定关键字序列 ki, …, kj，其中某个关键字 kr 是这些关键字的最优子树的根节点，其左子树包含 ki, …, kr-1 和伪关键字 di-1, …dr-1，右子树包含 kr+1, …, kj 和伪关键字 dr, …, dj。只要我们检查 kr 的所有可能(i &lt;= r &lt;= j)，并对每种情况求解最优二叉搜索树，就能保证得到原问题的最优解。</p>
<p>不过，还有一个需要注意的细节——空子树”。如果 ki 的左子树只有 ki, .., ki-1，则其不包含任何关键字，但是仍包含伪关键字 di-1，对称的右子树情况也一样。</p>
<hr />
<h1 id="步骤-2一个递归算法">步骤 2：一个递归算法</h1>
<p>定义 e[i, j]为在包含 ki, …, kj 的最优二叉搜索树中进行一次搜索的期望代价。当 j = i – 1 时，只关键字 di-1，所以 e[i, i-1] = qi-1。当 j &gt;= i 时，我们就需要从中选择一个根结点还构造二叉搜索树。当一棵子树成为一个结点的子树时，期望搜索代价应如何变化呢？由于每个结点的深度都增加了 1,所以根据公式 15.11,这棵子树的期望搜索代价的增加值应为所有概率之和：</p>
<p><img src="../../../pics/CLRS/最优二叉搜索树5.png" /></p>
<p>而以 kr 为根的最优二叉搜索树的期望搜索代价就为：</p>
<p><img src="../../../pics/CLRS/最优二叉搜索树6.png" /></p>
<p>由上面两个公式，假定知道哪个结点 k 应该作为根结点，我们可以的到递归公式(15.14)：</p>
<p><img src="../../../pics/CLRS/最优二叉搜索树7.png" /></p>
<hr />
<h1 id="步骤-3计算最优二叉搜索树的期望搜索代价">步骤 3：计算最优二叉搜索树的期望搜索代价</h1>
<p>使用自底向上的方法，用表 e 保存最优期望搜索代价，表 root 保存选择的根结点 kr 的下标 r，同时为了避免每次计算 e[i, j]时都要重新计算 w(i, j)，所以还用一个表 w 来保存这些值。对于基本情况 w[i, i-1] = qi-1，对于 j &gt;= i 的情况 w[i, j] = w[i, j-1] + pj, +qj（公式 15.15）。然后基于上面的递归公式来计算最优二叉搜索树的期望搜索代价，具体实现见下文的 C 语言代码。注意其算法与矩阵链相乘问题的算法非常相似，所以不在这里过多叙述了。</p>
<hr />
<h1 id="步骤-4重构最优二叉搜索树">步骤 4：重构最优二叉搜索树</h1>
<p>这一步书上并没有，参考了<a href="http://www.cnblogs.com/Anker/archive/2013/03/13/2958488.html">这里</a>的代码。</p>
<hr />
<h1 id="c-语言实现代码">C 语言实现代码</h1>
<div class="sourceCode" id="cb1" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define N           5</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define INFINITY    65535</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>optimal_bst<span class="op">(</span><span class="dt">float</span> <span class="op">*</span>p<span class="op">,</span> <span class="dt">float</span> <span class="op">*</span>q<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">float</span> <span class="op">(*</span>e<span class="op">)[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">],</span> <span class="dt">int</span> <span class="op">(*</span>root<span class="op">)[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">])</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     i<span class="op">,</span> j<span class="op">,</span> l<span class="op">,</span> r<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span>   t<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span>   w<span class="op">[</span>N <span class="op">+</span> <span class="dv">2</span><span class="op">][</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span>  <span class="co">/* 根据公式15.14和15.15，以概率q[i-1]初始化表e和w中的空子树 */</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        e<span class="op">[</span>i<span class="op">][</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> q<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        w<span class="op">[</span>i<span class="op">][</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> q<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>l <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> l <span class="op">&lt;=</span> n<span class="op">;</span> l<span class="op">++)</span> <span class="op">{</span>      <span class="co">/* 与矩阵链相乘问题类似，自底向上遍历所有可能的最优BST */</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> l <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> l <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            e<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> INFINITY<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            w<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> w<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> p<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> q<span class="op">[</span>j<span class="op">];</span>    <span class="co">/* 公式15.15 */</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span>r <span class="op">=</span> i<span class="op">;</span> r <span class="op">&lt;=</span> j<span class="op">;</span> r<span class="op">++)</span> <span class="op">{</span>  <span class="co">/* 遍历所有可能确定最优子树根 */</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                t <span class="op">=</span> e<span class="op">[</span>i<span class="op">][</span>r <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> e<span class="op">[</span>r <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> w<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span>    <span class="co">/* 公式15.14 */</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>t <span class="op">&lt;</span> e<span class="op">[</span>i<span class="op">][</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>                    e<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                    root<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> r<span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>construct_optimal_bst<span class="op">(</span><span class="dt">int</span> <span class="op">(*</span>root<span class="op">)[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">],</span> <span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">)</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     r<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> j <span class="op">==</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;k%d为根</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> root<span class="op">[</span><span class="dv">1</span><span class="op">][</span>N<span class="op">]);</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> root<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>r <span class="op">!=</span> i<span class="op">)</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;k%d为k%d的左孩子</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> root<span class="op">[</span>i<span class="op">][</span>r <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> r<span class="op">);</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        construct_optimal_bst<span class="op">(</span>root<span class="op">,</span> i<span class="op">,</span> r <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>r <span class="op">!=</span> j<span class="op">)</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>            printf<span class="op">(</span><span class="st">&quot;k%d为k%d的右孩子</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> root<span class="op">[</span>r <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> r<span class="op">);</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>        construct_optimal_bst<span class="op">(</span>root<span class="op">,</span> r <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;d%d为k%d的左孩子</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;d%d为k%d的右孩子</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;d%d为k%d的右孩子</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> j<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span>   p<span class="op">[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="fl">0.15</span><span class="op">,</span> <span class="fl">0.10</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.10</span><span class="op">,</span> <span class="fl">0.20</span><span class="op">};</span></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span>   q<span class="op">[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.10</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.05</span><span class="op">,</span> <span class="fl">0.10</span><span class="op">};</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span>   e<span class="op">[</span>N <span class="op">+</span> <span class="dv">2</span><span class="op">][</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     root<span class="op">[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>    optimal_bst<span class="op">(</span>p<span class="op">,</span> q<span class="op">,</span> N<span class="op">,</span> e<span class="op">,</span> root<span class="op">);</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>    construct_optimal_bst<span class="op">(</span>root<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> N<span class="op">);</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[线型时间排序]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e7%ba%bf%e6%80%a7%e6%97%b6%e9%97%b4%e6%8e%92%e5%ba%8f.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e7%ba%bf%e6%80%a7%e6%97%b6%e9%97%b4%e6%8e%92%e5%ba%8f.html</guid>
    <description><![CDATA[<p>在排序的最终结果中，各元素的次序依赖于他们之间的比较。我们把这类排序算法成为 <strong>比较排序</strong> 。它的时间复杂度下界为Ω(nlgn)，归并排序、堆排序等都是比较排序，并且这两个排序算法是比较排序中渐进最优的。</p>
<p>而下面介绍的线性时间排序都不是通过比较来确定排序顺序的，所以下界Ω(nlgn)对它们是不适用的。</p>
<h1 id="计数排序">1.计数排序</h1>
<p><strong>计数排序</strong> 假设 n 个输入元素中的每一个都是在 0 打 k 区间内的一个整数，其中 k 为某个整数。当 k=Ο(n)时，排序的运行时间为Ω(n)。</p>
<p>其基本思想是：对每一个输入元素 x，确定小于 x 的元素的个数。利用这一信息，就可以直接把 x 放到它在输出数组中的位置上了。当有几个元素相同时，这一方案要略做修。因为不能把他们都放在同一个位置上。</p>
<p>在计数排序的代码中，假设输入是一个数组 A[1..n]，A.leng = n。我们还需要两个数组：B[n]存放排序的输出，C[0..k]提供临时存储空间。</p>
<p>计数排序的 C 语言实现：</p>
<div class="sourceCode" id="cb1" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>counting_sort<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>A<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>B<span class="op">,</span> <span class="dt">int</span> k<span class="op">,</span> <span class="dt">int</span> size<span class="op">)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span>     <span class="op">*</span>C<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span>k <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>A<span class="op">[</span>j<span class="op">]]</span> <span class="op">=</span> C<span class="op">[</span>A<span class="op">[</span>j<span class="op">]]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">//C[i] now contains the number of elements equal to i.</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> C<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> C<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">//C[i] now contains the number of elements less than or equal to i.</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> size <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        B<span class="op">[</span>C<span class="op">[</span>A<span class="op">[</span>j<span class="op">]]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> A<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>A<span class="op">[</span>j<span class="op">]]</span> <span class="op">=</span> C<span class="op">[</span>A<span class="op">[</span>j<span class="op">]]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>C<span class="op">);</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>counting_sort_easy<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>A<span class="op">,</span> <span class="dt">int</span> max<span class="op">,</span> <span class="dt">int</span> size<span class="op">)</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count<span class="op">[</span>max <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> max <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        count<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        count<span class="op">[</span>A<span class="op">[</span>i<span class="op">]]++;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> max <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span><span class="op">(</span>count<span class="op">[</span>i<span class="op">]--)</span> <span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>            A<span class="op">[</span>j<span class="op">++]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> A<span class="op">[</span><span class="dv">8</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">3</span><span class="op">};</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>B<span class="op">;</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>A<span class="op">));</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* counting_sort(A, B, 6, 8); */</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    counting_sort_easy<span class="op">(</span>A<span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">8</span><span class="op">);</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">8</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%d &quot;</span><span class="op">,</span> A<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>B<span class="op">);</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><img src="../../../pics/CLRS/counting_sort.gif" /></p>
<p>11～12 行的 for 循环遍历每一个输入元素。如果一个输入元素的值为 i，就将 C[i]值加 1。所以 12 行执行完后 C[i]中保存的就是等于 i 的元素的个数。第 14～15 行通过加总计算确定有多少个元素小于等于 i 的。最后，17～20 行把每个元素 A[j]放到它在输出数组 B 中的正确位置上。</p>
<p>计数排序的第一个 for 循环所花费的时间为Θ(k)，第二个 for 循环花费的时间为Θ(n)，第三个 for 循环所花费的时间为Θ(k)，第四个 for 循环花费的时间为Θ(n)。所以总时间代价为Θ(k+n)。当 k=Ο(n)时，一般会采用计数排序，运行时间为Θ(n)。</p>
<p>另外技术排序还有一个重要的性质就是*稳定*的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同。</p>
<h1 id="基数排序">2.基数排序</h1>
<p>基数排序是一种用在卡片排序机上的算法，其主要思想是利用稳定的排序（如计数排序）按最低有效位到最高有效位的顺序一次进行排序。其时间复杂度为Θ(n)。</p>
<p><img src="../../../pics/CLRS/radixsort.jpg" /></p>
<p>最左边一列是输入数据，从左向右显示基数排序了由低位到高位进行排序的情况。</p>
<p>基数排序的 C 语言实现：</p>
<div class="sourceCode" id="cb2" data-org-language="C"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">/*被排序元素的最大位数，4则意味着只能排序&lt; 10000 的数*/</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define WIDTH 4</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MAXK 10  </span><span class="co">//位数划分基于的基数，10表示为10进制划分</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> radixSort<span class="op">(</span><span class="dt">int</span> a<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> innerCountingSort<span class="op">(</span><span class="dt">int</span> a<span class="op">[],</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> d<span class="op">);</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> WIDTH<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        innerCountingSort<span class="op">(</span>a<span class="op">,</span> n<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> innerCountingSort<span class="op">(</span><span class="dt">int</span> a<span class="op">[],</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> d<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> j<span class="op">,</span> x<span class="op">,</span> k<span class="op">[</span>MAXK<span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>ip <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span>n <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>bp <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span>malloc<span class="op">(</span>n <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getDValue<span class="op">(</span><span class="dt">int</span> value<span class="op">,</span> <span class="dt">int</span> d<span class="op">);</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        ip<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> getDValue<span class="op">(</span>a<span class="op">[</span>i<span class="op">],</span> d<span class="op">);</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        k<span class="op">[</span>ip<span class="op">[</span>i<span class="op">]]++;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> MAXK<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        k<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> k<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> k<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        bp<span class="op">[</span>k<span class="op">[</span>ip<span class="op">[</span>i<span class="op">]]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> a<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        k<span class="op">[</span>ip<span class="op">[</span>i<span class="op">]]--;</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> bp<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>ip<span class="op">);</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    free<span class="op">(</span>bp<span class="op">);</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a><span class="co">*获取一个数第d位数的值，位数索引从0开始</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> getDValue<span class="op">(</span><span class="dt">int</span> value<span class="op">,</span> <span class="dt">int</span> d<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(;</span>d <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> value <span class="op">&gt;</span> <span class="dv">0</span><span class="op">;</span> d<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> value <span class="op">/</span> MAXK<span class="op">;</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> value <span class="op">%</span> MAXK<span class="op">;</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>argv<span class="op">[])</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> array<span class="op">[</span><span class="dv">30</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">258</span><span class="op">,</span> <span class="dv">976</span><span class="op">,</span> <span class="dv">515</span><span class="op">,</span> <span class="dv">337</span><span class="op">,</span> <span class="dv">359</span><span class="op">,</span> <span class="dv">701</span><span class="op">,</span> <span class="dv">916</span><span class="op">,</span> <span class="dv">494</span><span class="op">,</span> <span class="dv">303</span><span class="op">,</span> <span class="dv">175</span><span class="op">,</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>                        <span class="dv">677</span><span class="op">,</span> <span class="dv">825</span><span class="op">,</span> <span class="dv">131</span><span class="op">,</span> <span class="dv">560</span><span class="op">,</span> <span class="dv">147</span><span class="op">,</span> <span class="dv">254</span><span class="op">,</span> <span class="dv">759</span><span class="op">,</span> <span class="dv">814</span><span class="op">,</span> <span class="dv">917</span><span class="op">,</span> <span class="dv">382</span><span class="op">,</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>                        <span class="dv">452</span><span class="op">,</span> <span class="dv">114</span><span class="op">,</span> <span class="dv">873</span><span class="op">,</span> <span class="dv">585</span><span class="op">,</span> <span class="dv">881</span><span class="op">,</span> <span class="dv">127</span><span class="op">,</span> <span class="dv">819</span><span class="op">,</span> <span class="dv">658</span><span class="op">,</span> <span class="dv">461</span><span class="op">,</span> <span class="dv">435</span><span class="op">};</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;before</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">30</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%d  &quot;</span><span class="op">,</span> array<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* 排序函数，从个位开始 */</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>    radixSort<span class="op">(</span>array<span class="op">,</span> <span class="dv">30</span><span class="op">);</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;final</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span><span class="dv">30</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;%d  &quot;</span><span class="op">,</span> array<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>（以上代码转载）</p>
<hr />
<h1 id="桶排序">3.桶排序</h1>
<figure>
<img src="../../../pics/CLRS/桶排序.png" alt="桶排序" /><figcaption aria-hidden="true">桶排序</figcaption>
</figure>
<p>伪代码：</p>
<pre class="example"><code>BUCKET-SORT（A）
n = A.length
let B[0..n-1] be a new array
for i = 0 to n-1
        make B[i] an empty list
for i = 1 to n
        insert A[i] into list B[nA[i]]
for i = 0 to n-1
        sort list B[i] with insertion sort
concatenate hte lists B[0], B[1], ……, B[n-1] together in order
</code></pre>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[堆排序和优先队列]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/CLRS/%e5%a0%86%e6%8e%92%e5%ba%8f%e5%92%8c%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/CLRS/%e5%a0%86%e6%8e%92%e5%ba%8f%e5%92%8c%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97.html</guid>
    <description><![CDATA[<h1 id="堆排序">堆排序</h1>
<p>堆排序的时间复杂度是 O(nlgn)，同时还具有空间原址性，所以堆排序集合了插入排序和归并排序两种算法优点的一种排序算法。</p>
<p><strong>（二叉）堆</strong> 是一个数组，它可以被看成一个近似的完全二叉树。树上的每一个结点对应数组中的一个元素。除了最底层外，该树是完全充满的，而且是从左向右填充。</p>
<p><img src="../../../pics/CLRS/heap_sort.png" /></p>
<p>数组上方和下方的连线显示的是父子关系：父节点总是在其孩子结点的左边。</p>
<p>最大堆指的是除了根节点以外的所有结点的值至多与其父节点一样大。而最小堆则正好相反，最小堆中的最小元素存放在根节点中。在堆排序算法中，使用的是最大堆，最小堆通常用于构造优先队列。 C 语言堆排序代码：</p>
<pre><code>#include &lt;stdlib.h&gt;

//#define PARENT(i)       ((i) / 2)       //返回其父节点
#define LEFT(i)         (2 * (i) + 1)     //返回其左孩子节点
#define RIGHT(i)        (2 * (i) + 2)     //返回其右孩子节点
#define exchange(a, b)  {(a) = (a) + (b); (b) = (a) - (b); (a) = (a) - (b);}

int heapsize, length;

void
max_heapify(int *A, int i)
{
    /*
     * 从A[i], A[LEFT(i)], A[RIGHT(i)]中选出最大的，
     * 并将其下标存储在largest中。如果A[i]是最大的
     * 那么以i为根结点的子树已经是最大堆，程序结束。
     * 否则最大元素是i的某个孩子节点，则交换A[i]和
     * A[largest]的值，然后递归向下因为刚刚的改动
     * 可能会违反最大堆性质。
     */
    int     l, r, largest;

    l = LEFT(i);
    r = RIGHT(i);

    if (l &lt; heapsize &amp;&amp; A[l] &gt; A[i]) {
        largest = l;
    } else {
        largest = i;
    }

    if (r &lt; heapsize &amp;&amp; A[r] &gt; A[largest]) {
        largest = r;
    }

    if (largest != i) {
        exchange(A[i], A[largest]);
        max_heapify(A, largest);
    }
}

void
build_maxheap(int *A)
{
    /*
     * 子数组A(n / 2 + 1..n)中的元素都是树的叶节点，
     * 该过程对树中的其他节点都调用一次max_heapify。
     */
    int     i;

    for (i =  (length - 1) / 2; i &gt;= 0; i--) {
        max_heapify(A, i);
    }
}

void
heapsort(int *A)
{
    /*
     * 数组中的最大元素总在根节点A[0]中，把它与A[i]交换，
     * 我们可以让该元素放到正确的位置。然后通过heapsize-1
     * 来从堆中去掉该节点。在交换完毕后，剩余的节点可能会
     * 违反最大堆性质，所以调用max_heapify维护最大堆
     */
    int     i;

    build_maxheap(A);
    for (i = length - 1; i &gt;= 1; i--) {
        exchange(A[0], A[i]);
        heapsize = heapsize - 1;
        max_heapify(A, 0);
    }
}

int
main(void)
{
    int i;
    int A[] = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7};

    heapsize  = sizeof(A) / sizeof(int);
    length = heapsize;

    heapsort(A);

    for (i = 0; i &lt; 10; i++)
        printf(&quot;%d &quot;, A[i]);
    printf(&quot;\n&quot;);

    return(0);
}
</code></pre>
<p>虽然堆排序是一个优秀的算法，但是在实际应用中，快速排序的性能一般会优于堆排序。</p>
<h1 id="优先队列">优先队列</h1>
<p><strong>优先队列</strong> （priority queue）是一种用来维护由一组元素构成的集合的数据结构，其中的每一个元素都有一个相关的 <strong>关键值</strong> （ key）。一个 <strong>最大优先队列</strong> 支持以下操作：</p>
<pre><code>#define MIN             -65535

int
heap_max(int *A)
{
    /*
     * 返回A中具有最大关键字的元素
     */
    return A[0];
}

int
heap_extract_max(int *A)
{
    /*
     * 去掉并返回A中具有最大关键字的元素
     */
    int     max;

    if (heapsize &lt; 1) {
        printf(&quot;heap underflow\n&quot;);
        return(-1);
    }

    max = A[0];
    A[0] = A[heapsize];
    heapsize--;
    max_heapify(A, 0);
    return(max);
}

void
heap_increase_key(int *A, int i, int key)
{
    /*
     * 将元素i的关键字值增加到key，key不小于i的源关键字值
     */
    int     i;

    if (key &lt; A[i]) {
        printf(&quot;new key is smaller than current key\n&quot;);
    }
    A[i] = key;
    while (i &gt; 0 &amp;&amp; A[PARENT(i)] &lt; A[i]) {
        exchange(A[i], A[PARENT(i)]);
        i = PARENT(i);
    }
}

void
max_heap_insert(int *A, int key)
{
    /*
     * 把元素x插入集合A中
     */
    heapsize++;
    A[heapsize] = MIN;
    heap_increase_key(A, heapsize, key);
}
</code></pre>]]></description>
    <pubDate>Sat, 16 Oct 2021 14:21:33 +0800</pubDate>
    </item>
</channel>
</rss>
