<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
<title>codeplayer</title>
<atom:link href="https://www.codeplayer.org/publish/feed.xml" rel="self" type="application/rss+xml" />
<link>https://www.codeplayer.org</link>
<description>codeplayer wiki</description>
    <item>
    <title><![CDATA[设计模式]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f.html</guid>
    <description><![CDATA[<p>#+TITLE: 设计模式 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>设计原则</li>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。（Java 中的接口，在 C++也称为抽象类。如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。）</li>
<li>多用组合，少用继承。</li>
<li>为了交互对象之间的松耦合设计而努力。</li>
<li>类应该对扩展开放，对修改关闭。</li>
<li>要依赖抽象，不要依赖具体类。</li>
<li>最少知识原则：只和你的密友谈话。</li>
<li>别调用（打电话给）我们，我们会调用（打电话给）你。</li>
<li>一个类应该只有一个引起变化的原因。</li>
<li>设计模式 ** 工厂方法 <em>工厂方法模式</em> 定义了一个创建对象的接口，但由子类决定实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</li>
</ul>
<p>[[file:../../pics/Desgin-Patterns/Factory-Method.png]] ** 抽象工厂 <em>抽象工厂模式</em> 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
<p>[[file:../../pics/Desgin-Patterns/Abstract-Factory.png]] ** 适配器 <em>适配器模式</em> 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
<p>[[file:../../pics/Desgin-Patterns/Adapter.png]] ** 命令 <em>命令模式</em> 将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持可撤销的操作。</p>
<p>[[file:../../pics/Desgin-Patterns/Command.png]] ** 组合 <em>组合模式</em> 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象及对象组合。</p>
<p>[[file:../../pics/Desgin-Patterns/Composite.png]] ** 装饰者 <em>装饰者模式</em> 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<p>[[file:../../pics/Desgin-Patterns/Decorator.png]] ** 外观 <em>外观模式</em> 提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</p>
<p>[[file:../../pics/Desgin-Patterns/Facade.png]] ** 迭代器 <em>迭代器模式</em> 提供了一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。</p>
<p>[[file:../../pics/Desgin-Patterns/Iterator.png]] ** 观察者 <em>观察者模式</em> 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p>
<p>[[file:../../pics/Desgin-Patterns/Observer.png]] ** 单件 <em>单件模式</em> 确保一个类只有一个实例，并提供一个全局访问点。</p>
<p>[[file:../../pics/Desgin-Patterns/Singleton.png]] ** 代理（保护） <em>保护代理</em> 为另一个对象提供一个替身货占位符以访问这个对象。</p>
<p>[[file:../../pics/Desgin-Patterns/Proxy-Protection.png]] ** 代理（远程） <em>远程代理</em> 就好比远程对象的本地代表。</p>
<p>[[file:../../pics/Desgin-Patterns/Proxy-Remote.png]] ** 代理（虚拟） <em>虚拟代理</em> 作为创建开销大的对象的代表。虚拟代理经常直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。</p>
<p>[[file:../../pics/Desgin-Patterns/Proxy-Virtual.png]] ** 策略 <em>策略模式</em> 定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<p>[[file:../../pics/Desgin-Patterns/Strategy.png]] ** 状态 <em>状态模式</em> 允许对象在内部状态改变的时候改变它的行为，对象看起来好像修改了它的类。</p>
<p>[[file:../../pics/Desgin-Patterns/State.png]] ** 模板方法 <em>模板方法模式</em> 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>[[file:../../pics/Desgin-Patterns/Template-Method.png]] ** MVC <em>一个复合模式</em> 模式-视图-控制器模式（MVC）把一个应用分成三个截然不同的组件：模型、视图和控制器。</p>
<p>[[file:../../pics/Desgin-Patterns/MVC.png]] ** 简单工厂 <em>不是一个真正的模式</em> 但是和抽象工厂和工厂方法模式一样，它经常被用于封装创建对象的代码。</p>
<p>[[file:../../pics/Desgin-Patterns/Simple-Factory.png]]</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[General Concepts]]></title>
    <link>https://www.codeplayer.org/Wiki/Gentoo/Ebuild/General%20Concepts.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Gentoo/Ebuild/General%20Concepts.html</guid>
    <description><![CDATA[<p>#+TITLE: General Concepts #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>Emerge and Ebuild Relationships #+CAPTION: relationship-diagram [[file:../../../pics/Gentoo/relationship-diagram.png]]</li>
</ul>
<p>=emerge= 程序是 =ebuild.sh= 的高级包装，它处理依赖追踪、安全安装和卸载等。 =emerge= 在构建过程中调用 =ebuild.sh= ，后者又处理 ebuild 文件和任何 eclass。从 =<span class="math inline"><em>D</em> = <em>到</em>=</span>{ROOT}= 的安装由 =emerge= 处理。</p>
<ul>
<li>FEATURES =FEATURES= 变量指定影响 portage 操作和软件包编译的选项。它不用于对生成的软件包产生实质性影响的设置。</li>
</ul>
<p>与开发者相关的 =FEATURES= 包括：</p>
<table>
<thead>
<tr class="header">
<th>Feature</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>=collision-protect=</td>
<td>如果安装的软件包尝试覆盖其他软件包提供的文件，则引发一个错误</td>
</tr>
<tr class="even">
<td>=noauto=</td>
<td>当使用 =ebuild= 时，仅运行指定的函数</td>
</tr>
<tr class="odd">
<td>=sandbox=</td>
<td>开启 sandbox</td>
</tr>
<tr class="even">
<td>=sign=</td>
<td>使用 GPG 签名 =Manifest= 文件</td>
</tr>
<tr class="odd">
<td>=strict=</td>
<td>对潜在的危险情况做一些额外的检查（例如缺少 =Manifest= 文件）</td>
</tr>
<tr class="even">
<td>=test=</td>
<td>启用 =src_test= 阶段</td>
</tr>
<tr class="odd">
<td>=userpriv=</td>
<td>在特定的阶段，使用非 root 权限</td>
</tr>
<tr class="even">
<td>=usersandbox=</td>
<td>启用 sanbox，即使运行在非 root 权限</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Git to RSYNC 对 tree 所做的更改将分阶段传播给用户：</p></li>
<li><p>开发者 commit 到本地 git clone 并且 push 到中央远程 git 仓库。commit 和 push 使用 git 基于 GPG 的机制签名。</p></li>
<li><p>staging box 从中央 git 仓库同步，生成元数据缓存，ChangLogs 并从 git 历史记录中签名 Manifests。</p></li>
<li><p>=rsync1= 从 staging box 同步</p></li>
<li><p>公共 rsync 服务器从 =rysnc1= 同步</p></li>
<li><p>用户从公共 rsync 服务器同步</p></li>
</ul>
<p>#+CAPTION: git-to-rsync [[file:../../../pics/Gentoo/git-to-rsync.png]]</p>
<p>/Diagram showing Git to RSYNC Propagation/</p>
<p>=emerge-websync= 的快照是每日从 staging box 中生成的。</p>
<ul>
<li>Mirrors ** Mirroring 软件包会自动将其在=SRC_URI=中的组件镜像到 Gentoo mirrors 上，包括托管在官方 Gentoo 基础设施上的那些（即 =dev.gentoo.org= 中的开发者空间）。当拉取的，包管理器会在尝试从原始上游位置之前先检查 Gentoo mirrors。</li>
</ul>
<p>这通常是期望的行为 —— 上游镜像易于重新排列、整理或修改文件。</p>
<p>** Restricting Automatic Mirroring 三个 =RESTRICT= 关键字可以用于控制镜像过程。</p>
<p><sub>RESTRICT=“mirror”</sub> 设置应该用于如果我们无法合法的镜像特定文件；文件将仍从原始位置下载。</p>
<p><sub>RESTRICT=“primayuri”</sub> 设置会导致 portage 首先尝试从原始位置下载，然后如果有必要则退回镜像。这不应该新的 ebuild 中使用。</p>
<p><sub>RESTRICT=“fetch”</sub> 将会阻止 portage 尝试手动获取任何内容。如果找不到任何 =SRC_URI= 组件，则 pkg_nofetch 函数将会被调用。仅在 license 要求时才应使用此选项。</p>
<ul>
<li>Sandbox 在 =src_unpack= 、 =src_compile= 、 =src_test= 和 =src_install= 阶段， =ebuild.sh= 运行在 sandbox 中。这是一个特殊的环境，它帮助防止错误编写的 ebuild（或与错误编写的构建系统一起工作的 ebuild）意外写在允许的位置之外。</li>
</ul>
<h2 id="当-sandbox-处于活动状态时所有的软件包都必须正确构建-软件包不得通过使用狡猾的技巧使-sandbox-警告不显示来达成此目的"><em>当 sandbox 处于活动状态时所有的软件包都必须正确构建</em> 。软件包不得通过使用狡猾的技巧使 sandbox 警告不显示来达成此目的</h2>
<p>sandbox 可以保证二进制软件包正常工作，而且写得不好的 Makefile 不会造成问题。使用 =addwrite= 通常不是正确的解决方案。</p>
<p>关于 sanbox 相关函数的详细信息请见[[https://devmanual.gentoo.org/function-reference/sandbox-functions/index.html][sandbox函数参考]]。关键修复 sandbox 相关构建问题的建议请见[[https://devmanual.gentoo.org/appendices/common-problems/index.html#handling-access-violations][Handling Access Violations]]。</p>
<ul>
<li>Slotting 软件包可以支同时安装多个版本。这对于在不同版本之间可能会改变接口的库很有用 —— 例如， =gtk+= 软件包可以同时安装 =2.24= 和 =3.6= 版本。这个特性叫做 slotting。</li>
</ul>
<p>大多数软件包不需要 slotting。这些软件包在 ebuild 中指定 <sub>SLOT=“0”</sub> 。这纯属惯例；包管理器不会将 =0= 于其他任何 slot 值区别对待。</p>
<p>#+BEGIN_QUOTE Note: =SLOT= 时强制变量并且必须不能为空。 #+END_QUOTE</p>
<p>portage 允许每个 SLOT 值最多一个软件包安装实例。例如，说我们有如下内容：</p>
<ul>
<li>=foo-1.1= with <sub>SLOT=“1”</sub></li>
<li>=foo-1.2= with <sub>SLOT=“1”</sub></li>
<li>=foo-2.0= with <sub>SLOT=“2”</sub></li>
<li>=foo-2.1= with <sub>SLOT=“2”</sub></li>
</ul>
<p>那么用户可能同时安装 =foo-1.2= 和 =foo-2.0= ，但是不能同时安装 =foo-1.1= 和 =foo-1.2= 。注意完全有可能用户安装了 =foo-2.0= ，而根本没有安装 =foo-1.x= 。</p>
<p>对于 =DEPEND= 中特定 slot 的软件包，参考[[https://devmanual.gentoo.org/general-concepts/dependencies/index.html#slot-dependencies][SLOT Dependencies]]。</p>
<p>** Sub-Slots 有时候软件包安装在不同版本之间改变接口的库，但是又不希望或不方便允许同时安装其中一些版本。在 EAPI 5 或更高中，这种情况可以使用 sub-slot 处理，其通过 =/= 字符于常规 slot 分隔，像 <sub>SLOT=“slot/subslot”</sub> 。当 subslot 的运行时依赖改变时，软件包可以[[https://devmanual.gentoo.org/general-concepts/dependencies/index.html#slot-operators][要求自动重新构建]]。</p>
<p>例如，假设软件包 =foo= 安装了一个库，其 soname 对于不同的版本时不同的。将 soname 版本用作 sub-slot 的名称时合理的：</p>
<ul>
<li>=foo-1.1= installs =libfoo.so.5= - <sub>SLOT=“1/5”</sub></li>
<li>=foo-1.5= installs =libfoo.so.6= - <sub>SLOT=“1/6”</sub></li>
<li>=foo-2.0= installs =libfoo-2.so.0= - <sub>SLOT=“2/0”</sub></li>
<li>=foo-2.1= installs =libfoo-2.so.1= - <sub>SLOT=“2/1”</sub></li>
</ul>
<p>安装了链接到 =libfoo-2= （或 =libfoo= ）的二进制文件的其他 ebuild 可以在安装的 =foo:2= 或 =foo:1= 更改 sub-slot 时请求自动重建 —— 例如，当用户从 =foo-2.0= 升级到 =foo-2.1= 时。</p>
<p>如果一个 ebuild 没有显式的声明 sub-slot，则将常规 slot 用作 sub-slot 的默认值。</p>
<p>#+BEGIN_QUOTE Note:首次在库 ebuild 中使用 sub-slot 时必须小心处理。添加 sub-slot 将会触发已使用 sub-slot 依赖的所有软件包重新构建（例如 =media-libs/libpng= 从 SLOT=“0”切换到 SLOT=“0/14”并且软件包 =foo= 依赖于 =libpng:0== ）。因此，最好在现在库的接口更改时开始在库中使用 sub-slot。 #+END_QUOTE</p>
<p>** SLot Names 当前版本的 portage 接受以字母数字字符或 =-= 开始，并且包含字符数字和 =_= 、 =-= 、 =.= 和 =+= 字符。</p>
<ul>
<li>User Environment 用户环境变量和 =make.conf= 的设置可以传递给 ebuild。这很有用 —— 例如 =CFLAGS= 和其朋友们的工作方式 —— 但是它也会导致肮脏的 build-breaking 变量（像 =LANG= 和 =LC_ALL= ）通过。当前没有对环境进行消毒。</li>
</ul>
<p>** Filtering Variables 某些变量会使某些构建系统非常非常受挫。一个好的例子是 locale 变量（ =LC_ALL= 等），如果将其设置为某些值，则会导致涉及 =[A-Z]= 之类的 sed 或 grep 表达式失败。此处最简单的方法是取消设置或在 =pkg_setup= 中清理有害变量。</p>
<p>取消设置所有与 locale 相关的变量是最简单的方法：</p>
<p>#+BEGIN_SRC sh pkg_setup() { # Unset all locale related variables, they can make the # build fail.</p>
<pre><code>    eval unset ${!LC_*} LANG
}</code></pre>
<p>#+END_SRC</p>
<p>** Not Filtering Variables 在另一方面，尽可能尊重某些用户的偏好是非常重要的。一个好的例子是 =CFLAGS= ，必须予以尊重（选择行过滤是可以的，但是不能完全忽略）。当编译时忽略 =CFLAGS= 会造成严重的问题：</p>
<ul>
<li>忽略 =march/mcpu= 可能会强制内核或软件模拟一些架构上的某些操作码。这可能很慢 —— 例如，为 SPARC v7 构建的 =oepnssl= 却运行在 v9 上大该会使 RSA 操作慢五倍。</li>
<li>stripping 某些 ABI 相关的 flag 会破坏链接。</li>
<li>stripping 某些 ABI 相关的 flag 会导致为某些设置产生无效的代码。在极端的例子中，最终可能会出现愚蠢的事情，例如为 little endian CPU 生成 big endian 代码。</li>
<li>如果用户的 =march/mcpu/mtune= 被忽略，而是使用自动检测的设置，则 GRP 和 stages 会被破坏。例如， =i686= 平台不再可以在 =pentium-4= 上生产， =v8= 平台不再可以在 =UltraSparc= 上生产。</li>
</ul>
<p>一些软件包偶然的会这么做。例如，可能在 =Makefile.am= 中看到 <sub>CFLAGS=-Wall</sub> 。为了修复这个，在用户的 =CFLAGS= 中使用 =sed= ，或（更好的办法）将变量更改为 =AM_CLFAGS= ，该变量将自动与用户设置合并。LDFLAGS 也应该受到尊重。</p>
<ul>
<li>Links</li>
</ul>
<ol type="1">
<li>[[https://devmanual.gentoo.org/general-concepts/filesystem/index.html][Filesystem]]</li>
<li>[[https://devmanual.gentoo.org/general-concepts/tree/index.html][The Gentoo Repository]]</li>
<li>[[https://devmanual.gentoo.org/general-concepts/virtuals/index.html][Virtuals]] NEED TO READ AGAIN.</li>
</ol>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[语法]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e8%af%ad%e6%b3%95.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e8%af%ad%e6%b3%95.html</guid>
    <description><![CDATA[<p>#+TITLE: 语法 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>英文的五个基本句型</li>
<li>主语 + 及物动词 + 宾语</li>
<li>主语 + 及物动词 + 宾语 + 宾语补足语</li>
<li>主语 + 及物动词 + 间接宾语 + 直接宾语</li>
<li>主语 + 不及物动词</li>
<li>主语 + 系动词 + 表语</li>
</ul>
<p>我们将语法概念分成两类，一类是 <em>句子的成分</em> ，也就是一个英文句子的组成部分；另一类是 <em>词性</em> ，也就是一个单词的性质。英语句子是由不同单词组成的，这些单词在句子中充当不同的成分，我们需要搞清楚什么性质的单词（词性）可以放在句子的什么地方，充当什么成分（句子成分）。</p>
<p>句子成分：</p>
<table>
<thead>
<tr class="header">
<th>语法术语</th>
<th>英文</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>主语</td>
<td>subject</td>
<td>一个句子动作的发出者，或者是描述的对象</td>
</tr>
<tr class="even">
<td>谓语</td>
<td>predicate</td>
<td>表示句子主语的状态或动作</td>
</tr>
<tr class="odd">
<td>宾语（动词宾语）</td>
<td>object</td>
<td>一个句子动作的接受者</td>
</tr>
<tr class="even">
<td>宾语补足语</td>
<td>object complement</td>
<td>用来补充说明宾语</td>
</tr>
<tr class="odd">
<td>直接宾语</td>
<td>direct object</td>
<td>动作的直接承受者</td>
</tr>
<tr class="even">
<td>间接宾语</td>
<td>indirect object</td>
<td>动作所针对的对象，一般是人</td>
</tr>
<tr class="odd">
<td>表语（主语补足语）</td>
<td>subject complement</td>
<td>用来说明句子主语的特点（如性质、特征和状态）</td>
</tr>
<tr class="even">
<td>定语</td>
<td>attribute</td>
<td>修饰名词，起到描述和限制的作用</td>
</tr>
<tr class="odd">
<td>状语</td>
<td>adverbial</td>
<td>修饰动词、形容词等，增加句子的信息（包括地点、时间等）</td>
</tr>
</tbody>
</table>
<p>词性：</p>
<table>
<thead>
<tr class="header">
<th>语法术语</th>
<th>英文</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>名词</td>
<td>noun</td>
<td>可以充当句子主语、宾语、表语的单词，代表人、事、物等描述对象</td>
</tr>
<tr class="even">
<td>及物动词</td>
<td>transitive verb</td>
<td>可以充当谓语的动词，后面可以加宾语，代表动作</td>
</tr>
<tr class="odd">
<td>不及物动词</td>
<td>intransitive verb</td>
<td>可以充当谓语的动词，后面不可以直接加宾语，或者不用加宾语，也代表动作</td>
</tr>
<tr class="even">
<td>系动词</td>
<td>linking verb</td>
<td>用来连接主语和表语的动词，帮助表语来说明主语</td>
</tr>
<tr class="odd">
<td>主动词</td>
<td>main verb</td>
<td>及物动词、不及物动词、系动词的合成，有具体的意义</td>
</tr>
<tr class="even">
<td>助动词</td>
<td>auxiliary verb</td>
<td>辅助助动词的动词，表示时态和语态，但是没有具体的意义</td>
</tr>
<tr class="odd">
<td>情态动词</td>
<td>modal verb</td>
<td>也是辅助主动词的动词，表示语气，和助动词一样，不能独立存在去充当谓语</td>
</tr>
<tr class="even">
<td>代词</td>
<td>pronoun</td>
<td>指代名词或句子的词。代词可以是名词性质，也是可以形容词活副词性质的</td>
</tr>
<tr class="odd">
<td>形容词</td>
<td>adjective</td>
<td>修饰名词的词。形容词可以充当补语、表语和定语</td>
</tr>
<tr class="even">
<td>动名词</td>
<td>gerund</td>
<td>动词的 ing 形式。具有名词性质，可以充当名词充当的成分，包括主语和宾语等</td>
</tr>
<tr class="odd">
<td>不定式</td>
<td>infinitive</td>
<td>动词前加一个 to。具备名词性质，可以充当名词充当的成分，包括主语和宾语等；</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>也具备副词性质，可以充当状语或者形容词性质，可以充当定语</td>
</tr>
<tr class="odd">
<td>冠词</td>
<td>article</td>
<td>一般出现在名词前面，帮助说明名词的特点。冠词有不定冠词、定冠词和零冠词</td>
</tr>
<tr class="even">
<td>副词</td>
<td>adverb</td>
<td>可以修饰形容词、动词和句子等</td>
</tr>
</tbody>
</table>
<ul>
<li>句子的修饰成分 #+BEGIN_QUOTE 形容词、副词、介宾短语、定语和状语 #+END_QUOTE</li>
</ul>
<p>修饰成分是一个句子中可以去掉的部分。这些成分去掉后对句子没有语法上的影响，只会影响句意。</p>
<p>** 什么成分在句子中是可以删除的？ | 句子中不可删除的成分（一旦在句子中出现，就不可以删除） | 句子中可以删除的成分 | |———————————————————-+————————| | 主语、谓语、宾语、补语、表语 | 定语、状语、同位语 |</p>
<p>定语一般由 <em>形容词行的单词活短语</em> （如形容词、介宾短语和分词等）来充当，而状语一般是由 <em>副词性的单词活短语</em> （如副词、介宾短语和分词等）来充当。</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>定语</th>
<th>状语</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>功能</td>
<td>限制和修饰名词</td>
<td>修饰谓语、定语和句子</td>
</tr>
<tr class="even">
<td>使用单词</td>
<td>一般来说，形容词可以充当定语</td>
<td>状语一般是由副词充当，分词和介宾短语也可以充当状语</td>
</tr>
<tr class="odd">
<td></td>
<td>分词和介宾短语也可以充当定语</td>
<td></td>
</tr>
<tr class="even">
<td>例句</td>
<td>He is a dedicated teacher.</td>
<td>He has been working hard.</td>
</tr>
<tr class="odd">
<td>大意</td>
<td>他是一个敬业的老师</td>
<td>他一直工作很勤奋</td>
</tr>
<tr class="even">
<td>解析</td>
<td>老师这个名词前出现了 dedicated 这个形容词，</td>
<td>这里的 hard 就是一个副词，修饰 work 这个动词</td>
</tr>
<tr class="odd">
<td></td>
<td>充当定语。</td>
<td></td>
</tr>
<tr class="even">
<td>句子中的位置</td>
<td>定语一般放在名词的前面，</td>
<td>位置非常灵活</td>
</tr>
<tr class="odd">
<td></td>
<td>有时候也会放在名词的后面，称为后置定语。</td>
<td></td>
</tr>
<tr class="even">
<td>使用限制</td>
<td>定语不能修饰动词</td>
<td>状语不能修饰名词</td>
</tr>
</tbody>
</table>
<p>** 形容词和副词怎么分辨？ 形容词的英文是 adjective，副词的英文是 adverb。查英文字典的时候可以留意单词后面的 =adj.= 或者 =adv.= 。在单词构造上，形容词很多时候后加 ly 就是副词。 <em>在句子里，形容词一般都是修饰名词（不管是充当定语，还是表语）的，而副词除了不能修饰名词之外，其他词都能修饰。</em></p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 42%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>形容词</th>
<th>副词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>例词</td>
<td>quick,slow,efficient,effective,clear,</td>
<td>quickly,slowly,efficiently,effectively,clearly,</td>
</tr>
<tr class="even">
<td></td>
<td>brave,recent 等</td>
<td>bravely,recently 等</td>
</tr>
<tr class="odd">
<td>例句</td>
<td>Students have found an effective way</td>
<td>Studens can learn this language effectively.</td>
</tr>
<tr class="even">
<td></td>
<td>to learn this language.</td>
<td></td>
</tr>
<tr class="odd">
<td>大意</td>
<td>学生们找到了一种学习这种语言的有效方法</td>
<td>学生可以有效地学习这门语言</td>
</tr>
<tr class="even">
<td>解析</td>
<td>这句话里的 effective 是形容词，修饰名词 way</td>
<td>这句话里的 effectively 是副词，修饰动词 learn</td>
</tr>
</tbody>
</table>
<p>然而，有时候，形容词和副词的变化又未必如此。</p>
<p>有些形容词，是没有副词形式的；有些副词和形容词的拼写一样的；</p>
<p><em>因此，分析这些单词的区别可以借鉴一定规律，但也要注意特例。</em></p>
<p>** 介宾短语在句子中可以充当什么成分？ 所谓的介宾短语， <em>就是在介词 in，at，on 这些单词后面，出现一个名字或动名词充当介词的宾语。</em> 介词后面一般不可以加动词、形容词、副词、句子等。</p>
<p>介宾短语可以充当定语、表语、状语、补语。</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 23%" />
<col style="width: 22%" />
<col style="width: 22%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>定语</th>
<th>表语</th>
<th>状语</th>
<th>补语</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>例句</td>
<td>Gu jiabei is a teacher</td>
<td>Gu Jiabei is in China</td>
<td>Gu Jiabei is working</td>
<td>Gu Jiabei has relocated</td>
</tr>
<tr class="even">
<td></td>
<td>from New Zealand.</td>
<td>now.</td>
<td>in China.</td>
<td>to Shenzhen.</td>
</tr>
<tr class="odd">
<td>大意</td>
<td>顾家北是来自新西兰的</td>
<td>顾家北目前在中国</td>
<td>顾家北在中国工作</td>
<td>顾家北搬到深圳</td>
</tr>
<tr class="even">
<td></td>
<td>一位老师</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>解析</td>
<td>这里的 from New Zealand</td>
<td>这里的 in China 就是一个</td>
<td>这里的 in China 就是一个</td>
<td>这里的 to Shenzhen 就是一个</td>
</tr>
<tr class="even">
<td></td>
<td>就是一个介词 from 加名词</td>
<td>介词 in 加名词 China 的结</td>
<td>介词 in 加名词 China 的结</td>
<td>介词 to 加上 Shenzhen，充当</td>
</tr>
<tr class="odd">
<td></td>
<td>New Zealand 的结构，充当</td>
<td>构，充当表语，修饰主语</td>
<td>构，修饰 work 这个动词，</td>
<td>relocate 的补语</td>
</tr>
<tr class="even">
<td></td>
<td>定语，修饰 teacher</td>
<td>Gu Jiabei</td>
<td>充当状语。</td>
<td></td>
</tr>
</tbody>
</table>
<p>常用的介词有这么一些。</p>
<table>
<thead>
<tr class="header">
<th>表示方位的介词</th>
<th>表示时间的介词</th>
<th>表示原因的介词</th>
<th>表示让步的介词</th>
<th>表示“关于”的介词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>in,at,on,above,</td>
<td>before,after,until</td>
<td>because of,</td>
<td>despite,</td>
<td>about,concerning,</td>
</tr>
<tr class="even">
<td>below,inside,</td>
<td>since</td>
<td>due to,</td>
<td>in spite of,</td>
<td>as to, as for,</td>
</tr>
<tr class="odd">
<td>side,next to,</td>
<td></td>
<td>owing to,</td>
<td>notwithstanding</td>
<td>regarding</td>
</tr>
<tr class="even">
<td>besides</td>
<td></td>
<td>thanks to</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>补语 补语（complement）补充说明前面一个名词：有些时候也可以是补充说明形容词和动词。</li>
</ul>
<p>** 补语一般出现在句子哪里？ 补语是句子的必要成分。换言之，如果补语在句子中出现，不可以删除。否则，句子会不完成。</p>
<p>很多时候， <em>补语是由句子结构决定的，而句子结构由动词决定</em> 。</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 43%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>系动词</th>
<th>某些及物动词</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>动词</td>
<td>become,appear,seem,feel,stay 等</td>
<td>make,enable,let,regard 等</td>
</tr>
<tr class="even">
<td>句子结构</td>
<td>主语+系动词+表语（主语的补语）</td>
<td>主语+及物动词+宾语+宾语补足语</td>
</tr>
<tr class="odd">
<td>例句</td>
<td>Studens have become knowledgeable.</td>
<td>Education has makde students knowledgeable.</td>
</tr>
<tr class="even">
<td>大意</td>
<td>学生变得有知识</td>
<td>教育使得学生变得有知识</td>
</tr>
<tr class="odd">
<td>解析</td>
<td>knowledgeable 是补充说明主语 students 的补语</td>
<td>knowledgeable 是补充说明宾语 students 的补语</td>
</tr>
</tbody>
</table>
<p>** 补语还可以在哪里出现？ 在某些情况下，补语也可以是 <em>由单词的性质来决定的</em> 。</p>
<ol type="1">
<li><p>动词有些时候后面会出现一些固定的搭配，充当这个动词的补语</p>
<p>下面这句话的 take 有固定的词伙，就是 take…seriously，而 seriously 就是这个 take 的补语。</p>
<p>People take education seriously.</p></li>
<li><p>名词有些时候后面会出现一些固定的搭配，充当这个名词的补语</p>
<p>下面这句话的 key 有固定的词伙，就是 key to…，而 to success 就是这个 key 的补语。</p>
<p>People regard education as the key to success.</p></li>
<li><p>形容词有些时候后面会出现一些固定的搭配，充当这个形容词的补语</p>
<p>下面这句话的 aware 有固定的词伙，就是 aware of…，而 of environmental problems 就是这个 aware 的补语。</p>
<p>People are aware of environmental problems.</p></li>
</ol>
<ul>
<li>TODO 非谓语动词（不定式和动名词）</li>
</ul>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[策略路由及ip route,ip rule,iptables]]></title>
    <link>https://www.codeplayer.org/Wiki/Router/%e7%ad%96%e7%95%a5%e8%b7%af%e7%94%b1%e5%8f%8aip%20route,ip%20rule,iptables.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Router/%e7%ad%96%e7%95%a5%e8%b7%af%e7%94%b1%e5%8f%8aip%20route,ip%20rule,iptables.html</guid>
    <description><![CDATA[<p>#+TITLE: 策略路由及ip route,ip rule,iptables #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup * 介绍 :PROPERTIES: :CUSTOM_ID: 介绍 :END:</p>
<p>linux 高级路由即基于策略的路由，比传统路由在功能上更强大，使用也更灵活，它不仅能够像传统路由一样，根据目的地址来转发数据，而且也能够根据报文大小、应用，协议或 ip 源地址来选择路由转发路径从而让系统管理员能轻松做到：</p>
<ol type="1">
<li>管制某台计算机的带宽。</li>
<li>管制通向某台计算机的带宽</li>
<li>帮助你公平地共享带宽</li>
<li>保护你的网络不受 DOS 的攻击</li>
<li>保护你的 Internet 不受到你的客户的攻击</li>
<li>把多台服务器虚拟成一台，并进行负载均衡或者提高可用性</li>
<li>限制你的用户访问某些计算机</li>
<li>限制对你的计算机的访问</li>
<li>基于用户帐号、MAC 地址、源 IP 地址、端口、QOS(TOS)、时间或者 content 等进行路由</li>
</ol>
<p>#+BEGIN_QUOTE 策略路由和路由策略是两个不同的概念，策略路由是根据 IP 包中的源地址，端口号等来实现的；而路由策略可以理解为路由表中的一系列路由动作。 #+END_QUOTE</p>
<p>路由表和策略区别：</p>
<p>规则指向路由表，多个规则可以引用一个路由表，而且某些路由表可以没有策略指向它。如果系统管理员删除了指向某个路由表的所有规则，这个表就没有用了，但是仍然存在，直到里面的所有路由都被删除，它才会消失。</p>
<ul>
<li>案例 :PROPERTIES: :CUSTOM_ID: 案例 :END:</li>
</ul>
<p>公司内网要求 192.168.0.100 以内的使用 10.0.0.1 网关上网（电信），其他 IP 使用 20.0.0.1 （网通）上网。</p>
<p>首先要在网关服务器上添加一个默认路由，当然这个指向是绝大多数的 IP 的出口网关：</p>
<p>=ip route add default gw 20.0.0.1=</p>
<p>之后通过 =ip route= 添加一个路由表：</p>
<p>=ip route add table 3 via 10.0.0.1 dev ethX=</p>
<p>#+BEGIN_QUOTE (ethX 是 10.0.0.1 所在的网卡，3 是路由表的编号) #+END_QUOTE</p>
<p>之后添加 ip rule 规则：</p>
<p>=ip rule add fwmark 3 table 3=</p>
<p>#+BEGIN_QUOTE （fwmark 3 是标记，table 3 是路由表 3 上边。 意思就是凡是标记了 3 的数据使用 table3 路由表） #+END_QUOTE</p>
<p>之后使用 iptables 给相应的数据打上标记：</p>
<p>=iptables -A PREROUTING -t mangle -i eth0 -s 192.168.0.1 -192.168.0.100 -j MARK –set-mark 3=</p>
<p>因为 mangle 的处理是优先于 nat 和 fiter 表的，所以相应数据包到达之后先打上标记，之后再通过 ip rule 规则。对应的数据包使用相应的路由表进行路由，最后读取路由表信息，将数据包送出网关。</p>
<ul>
<li>高级路由基础 IP ROUTE2 :PROPERTIES: :CUSTOM_ID: 高级路由基础 ip-route2 :END:</li>
</ul>
<p>ip 是 iproute2 软件包里面的一个强大的网络配置工具，它能够替代一些传统的网络管理工具。例如：ifconfig、route 等。</p>
<p>** 传统网络配置命令 :PROPERTIES: :CUSTOM_ID: 传统网络配置命令 :END:</p>
<ol type="1">
<li>使用 ifconfig 命令配置并查看网络接口情况</li>
</ol>
<p>#+BEGIN_SRC sh # 示例1: 配置eth0的IP，同时激活设备: ifconfig eth0 192.168.4.1 netmask 255.255.255.0 up # 示例2: 配置eth0别名设备 eth0:1 的IP，并添加路由 ifconfig eth0:1 192.168.4.2 route add –host 192.168.4.2 dev eth0:1 # 示例3:激活（禁用）设备 ifconfig eth0:1 up(down) # 示例4:查看所有（指定）网络接口配置 ifconfig (eth0) #+END_SRC</p>
<ol start="2" type="1">
<li>使用 route 命令配置路由表</li>
</ol>
<p>使用 Route 命令行工具查看并编辑计算机的 IP 路由表。Route 命令和语法如下所示：</p>
<p>#+BEGIN_SRC sh route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface] # -f 清除所有网关入口的路由表。 # -p 与 add 命令一起使用时使路由具有永久性。 # Command 指定您想运行的命令 (Add/Change/Delete/Print)。 # Destination 指定该路由的网络目标。 # mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 # Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 # metric Metric 为路由指定一个整数成本值标（从 1 至 ArrayArrayArrayArray），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。 # if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。 # /? 在命令提示符处显示帮助。 #+END_SRC</p>
<p>使用 route 命令添加的路由，机器重启或者网卡重启后路由就失效了。</p>
<p>#+BEGIN_SRC sh # 示例1:添加到主机路由 route add –host 192.168.4.2 dev eth0:1 route add –host 192.168.4.1 gw 192.168.4.250 # 示例2:添加到网络的路由 route add –net IP netmask MASK eth0 route add –net IP netmask MASK gw IP route add –net IP/24 eth1 # 示例3:添加默认网关 route add default gw IP # 示例4:删除路由，删除的时候不用写网关 route del –host 192.168.4.1 dev eth0:1 # 示例5:查看路由信息 route 或 route -n (-n 表示不解析名字,列出速度会比route 快) #+END_SRC</p>
<p>单纯的 route 命令会显示 IP 路由表的全部内容，其结果是自上而下，就是说，哪条在前面，哪条就有优先，前面都没有， 就用最后一条 default。</p>
<ol start="3" type="1">
<li>ARP 管理命令</li>
</ol>
<p>#+BEGIN_SRC sh # 示例1:查看ARP缓存 arp # 示例2: 添加 arp –s IP MAC # 示例3: 删除 arp –d IP #+END_SRC</p>
<p>** ip 命令的基本语法 :PROPERTIES: :CUSTOM_ID: ip 命令的基本语法 :END:</p>
<ul>
<li>ip link list 显示 ip 链路状态信息</li>
<li>ip address show 显示所有网络地址</li>
<li>ip route show 显示主路由表信息</li>
<li>ip neigh show 显示邻居表</li>
</ul>
<p>上面的示例完全可以用下面的 ip 命令实现，而且 ip 命令可以实现更多的功能。下面介绍一些示例：</p>
<p>** ip 命令的语法 :PROPERTIES: :CUSTOM_ID: ip 命令的语法 :END:</p>
<p>ip 命令的用法如下：</p>
<p>=ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]=</p>
<ol type="1">
<li><p>ip link set – 改变设备的属性. 缩写：set、s</p>
<p>#+BEGIN_SRC sh # 示例1：up/down 起动／关闭设备。 ip link set dev eth0 up #这个等于传统的 ifconfig eth0 up(down) # 示例2：改变设备传输队列的长度。 # 参数:txqueuelen NUMBER或者txqlen NUMBER ip link set dev eth0 txqueuelen 100 # 示例3：改变网络设备MTU(最大传输单元)的值。 ip link set dev eth0 mtu 1500 # 示例4： 修改网络设备的MAC地址。 # 参数: address LLADDRESS ip link set dev eth0 address 00:01:4f:00:15:f1 #+END_SRC</p></li>
<li><p>ip link show – 显示设备属性. 缩写：show、list、lst、sh、ls、l</p>
<p>#+BEGIN_SRC sh # -s选项出现两次或者更多次，ip会输出更为详细的错误信息统计。 $ ip -s -s link ls eth0 eth0: mtu 1500 qdisc cbq qlen 100 link/ether 00:a0:cc:66:18:78 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 2449949362 2786187 0 0 0 0 RX errors: length crc fifo missed 0 0 0 0 0 TX: bytes packets errors dropped carrier collsns 178558497 1783946 332 0 332 35172 TX errors: aborted fifo window heartbeat 0 0 0 332 # 这个命令等于传统的 ifconfig eth0 #+END_SRC</p></li>
<li><p>ip address add – 添加一个新的协议地址. 缩写：add、a</p>
<p>#+BEGIN_SRC sh # 示例1：为每个地址设置一个字符串作为标签。为了和Linux-2.0的网络别名兼容，这个字符串必须以设备名开头，接着一个冒号， ip addr add local 192.168.4.1/28 brd + label eth0:1 dev eth0 # 示例2: 在以太网接口eth0上增加一个地址192.168.20.0，掩码长度为24位(155.155.155.0)，标准广播地址，标签为eth0:Alias： ip addr add 192.168.4.2/24 brd + dev eth1 label eth1:1 # 这个命令等于传统的: ifconfig eth1:1 192.168.4.2 #+END_SRC</p></li>
<li><p>ip address delete – 删除一个协议地址. 缩写：delete、del、d</p>
<p>=ip addr del 192.168.4.1/24 brd + dev eth0 label eth0:Alias1=</p></li>
<li><p>ip address show – 显示协议地址. 缩写：show、list、lst、sh、ls、l</p>
<p>=ip addr ls eth0=</p></li>
<li><p>ip address flush–清除协议地址. 缩写：flush、f</p>
<p>#+BEGIN_SRC sh # 示例1 : 删除属于私网10.0.0.0/8的所有地址： ip -s -s a f to 10/8 # 示例2 : 取消所有以太网卡的IP地址 ip -4 addr flush label “eth0” #+END_SRC</p></li>
<li><p>ip neighbour – neighbour/arp 表管理命令</p>
<p>缩写 neighbour、neighbor、neigh、n</p>
<p>命令 add、change、replace、delete、fulsh、show(或者 list)</p></li>
<li><p>ip neighbour add – 添加一个新的邻接条目</p>
<p>ip neighbour change – 修改一个现有的条目</p>
<p>ip neighbour replace – 替换一个已有的条目</p>
<p>缩写：add、a；change、chg；replace、repl</p>
<p>#+BEGIN_SRC sh # 示例1: 在设备eth0上，为地址10.0.0.3添加一个permanent ARP条目： ip neigh add 10.0.0.3 lladdr 0:0:0:0:0:1 dev eth0 nud perm # 示例2:把状态改为reachable ip neigh chg 10.0.0.3 dev eth0 nud reachable #+END_SRC</p></li>
<li><p>ip neighbour delete – 删除一个邻接条目</p>
<p>#+BEGIN_SRC sh # 示例1:删除设备eth0上的一个ARP条目10.0.0.3 ip neigh del 10.0.0.3 dev eth0 #+END_SRC</p></li>
<li><p>ip neighbour show – 显示网络邻居的信息. 缩写：show、list、sh、ls</p>
<p>#+BEGIN_SRC sh # 示例1: $ ip -s n ls 193.233.7.254 193.233.7.254. dev eth0 lladdr 00:00:0c:76:3f:85 ref 5 used 12/13/20 nud reachable #+END_SRC</p></li>
<li><p>ip neighbour flush – 清除邻接条目. 缩写：flush、f</p>
<p>#+BEGIN_SRC sh # 示例1: (-s 可以显示详细信息) ip -s -s n f 193.233.7.254 #+END_SRC</p></li>
</ol>
<p>** linux 系统路由表 :PROPERTIES: :CUSTOM_ID: linux 系统路由表 :END:</p>
<p>linux 可以自定义从 1－252 个路由表，linux 系统维护了 4 个路由表：</p>
<ul>
<li><p>0 表 系统保留表</p></li>
<li><p>255 local 本地路由表，存有本地接口地址，广播地址，以及 NAT 地址。</p>
<p>local 表由系统自动维护，管理员不能操作此表。</p></li>
<li><p>254 main 主路由表，传统路由表，ip route 若没指定表即操作表 254。</p>
<p>平时用 route 查看的亦是此表设置的路由。</p></li>
<li><p>253 default，默认路由表一般存放默认路由。</p></li>
</ul>
<p>#+BEGIN_QUOTE 注：rt_tables 文件中表以数字来区分表，保留最多支持 255 张表。 #+END_QUOTE</p>
<p>路由表的查看可有以下二种方法：</p>
<ul>
<li>ip route list table table_number</li>
<li>ip route list table table_name</li>
</ul>
<p>路由表序号和表名的对应关系在/etc/iproute2/rt_tables 中，可手动编辑。</p>
<p>默认情况下，所有的路由都会被插入到表 main(编号 254)中。在进行路由查询时，内核只使用路由表 main。</p>
<p>** 路由表 ip route :PROPERTIES: :CUSTOM_ID: 路由表-ip-route :END:</p>
<ol type="1">
<li><p>ip route add – 添加新路由</p>
<p>ip route change – 修改路由</p>
<p>ip route replace – 替换已有的路由</p>
<p>缩写：add、a；change、chg；replace、repl</p>
<p>#+BEGIN_SRC sh # 示例1: 设置到网络10.0.0/24的路由经过网关193.233.7.65 ip route add 10.0.0/24 via 193.233.7.65 # 示例2: 修改到网络10.0.0/24的直接路由，使其经过设备dummy ip route chg 10.0.0/24 dev dummy # 示例3: 实现链路负载平衡.加入缺省多路径路由，让ppp0和ppp1分担负载(注意：scope值并非必需，它只不过是告诉内核，这个路由要经过网关而不是直连的。实际上，如果你知道远程端点的地址，使用via参数来设置就更好了)。 ip route add default scope global nexthop dev ppp0 nexthop dev ppp1 ip route replace default scope global nexthop dev ppp0 nexthop dev ppp1 # 示例4: 设置NAT路由。在转发来自192.203.80.144的数据包之前，先进行网络地址转换，把这个地址转换为193.233.7.83 ip route add nat 192.203.80.142 via 193.233.7.83 # 示例5: 实现数据包级负载平衡,允许把数据包随机从多个路由发出。weight 可以设置权重. ip route replace default equalize nexthop via 211.139.218.145 dev eth0 weight 1 nexthop via 211.139.218.145 dev eth1 weight 1 #+END_SRC</p></li>
<li><p>ip route delete – 删除路由</p>
<p>缩写：delete、del、d</p>
<p>#+BEGIN_SRC sh # 示例1:删除上一节命令加入的多路径路由 ip route del default scope global nexthop dev ppp0 nexthop dev ppp1 #+END_SRC</p></li>
<li><p>ip route show – 列出路由</p>
<p>缩写：show、list、sh、ls、l</p>
<p>#+BEGIN_SRC sh # 示例1: 计算使用gated/bgp协议的路由个数 $ ip route ls proto gated/bgp | wc 1413 9891 79010 # 示例2: 计算路由缓存里面的条数，由于被缓存路由的属性可能大于一行，以此需要使用-o选项 $ ip -o route ls cloned | wc 159 2543 18707 # 示例3: 列出路由表TABLEID里面的路由。缺省设置是table main。TABLEID或者是一个真正的路由表ID或者是/etc/iproute2/rt_tables文件定义的字符串，或者是以下的特殊值： # all – 列出所有表的路由； # cache – 列出路由缓存的内容。 ip route ls 193.233.7.82 tab cache # 示例4: 列出某个路由表的内容 ip route ls table fddi153 # 示例5: 列出默认路由表的内容 ip route ls # 这个命令等于传统的: route #+END_SRC</p></li>
<li><p>ip route flush – 擦除路由表</p>
<p>#+BEGIN_SRC sh 示例1: 删除路由表main中的所有网关路由（示例：在路由监控程序挂掉之后）： # ip -4 route flush scope global type unicast 示例2:清除所有被克隆出来的IPv6路由： # ip -6 -s -s route flush cache 示例3: 在gated程序挂掉之后，清除所有的BGP路由： # ip -s route f proto gated/bgp 示例4: 清除所有ipv4路由cache # ip route flush cache *** IPv4 routing cache is flushed. #+END_SRC</p></li>
<li><p>ip route get – 获得单个路由 .缩写：get、g</p>
<p>使用这个命令可以获得到达目的地址的一个路由以及它的确切内容。</p>
<p>ip route get 命令和 ip route show 命令执行的操作是不同的。ip route show 命令只是显示现有的路由，而 ip route get 命令在必要时会派生出新的路由。</p>
<p>#+BEGIN_SRC sh # 示例1: 搜索到193.233.7.82的路由 $ ip route get 193.233.7.82 193.233.7.82 dev eth0 src 193.233.7.65 realms inr.ac cache mtu 1500 rtt 300 # 示例2: 搜索目的地址是193.233.7.82，来自193.233.7.82，从eth0设备到达的路由（这条命令会产生一条非常有意思的路由，这是一条到193.233.7.82的回环路由） $ ip r g 193.233.7.82 from 193.233.7.82 iif eth0 193.233.7.82 from 193.233.7.82 dev eth0 src 193.233.7.65 realms inr.ac/inr.ac cache mtu 1500 rtt 300 iif eth0 #+END_SRC</p></li>
</ol>
<p>** 路由规则 ip rule :PROPERTIES: :CUSTOM_ID: 路由规则-ip-rule :END:</p>
<p>进行路由时，根据路由规则来进行匹配，按优先级（pref）从低到高匹配，直到找到合适的规则，所以在应用中配置默认路由是必要的。</p>
<p>策略路由一般手工添加路由表，路由表的添加只需编辑 rt_tables 文件，规定表序号，表名即可。路由表添加完毕，即可在策略路由表内添加路由。</p>
<p>=ip rule show= 显示路由规则。</p>
<p>路由规则的添加：</p>
<p>=ip rule add from 192.168.1.10/32 table 1 pref 100=</p>
<p>如果 pref 值不指定，则将在已有规则最小序号前插入</p>
<p>创建完路由规则若需立即生效须执行：</p>
<p>=ip route flush cache=</p>
<p>刷新路由缓冲。</p>
<p>命令格式如下：</p>
<p>#+BEGIN_SRC sh Usage: ip rule { add | del } SELECTOR ACTION ip rule { flush | save | restore } ip rule [ list [ SELECTOR ]] SELECTOR := [ not ] [ from PREFIX ] [ to PREFIX ] [ tos TOS ] [ fwmark FWMARK[/MASK] ] [ iif STRING ] [ oif STRING ] [ pref NUMBER ] [ l3mdev ] [ uidrange NUMBER-NUMBER ] [ ipproto PROTOCOL ] [ sport [ NUMBER | NUMBER-NUMBER ] [ dport [ NUMBER | NUMBER-NUMBER ] ] ACTION := [ table TABLE_ID ] [ protocol PROTO ] [ nat ADDRESS ] [ realms [SRCREALM/]DSTREALM ] [ goto NUMBER ] SUPPRESSOR SUPPRESSOR := [ suppress_prefixlength NUMBER ] [ suppress_ifgroup DEVGROUP ] TABLE_ID := [ local | main | default | NUMBER ] #+END_SRC</p>
<p>参数解析如下：</p>
<p>#+BEGIN_EXAMPLE From – 源地址 To – 目的地址（这里是选择规则时使用，查找路由表时也使用） Tos – IP包头的TOS（type of sevice）域Linux高级路由- Dev – 物理接口 Fwmark – iptables标签</p>
<pre><code>采取的动作除了指定路由表外，还可以指定下面的动作：
Table 指明所使用的表
Nat 透明网关
Prohibit 丢弃该包，并发送 COMM.ADM.PROHIITED的ICMP信息
Reject 单纯丢弃该包
Unreachable丢弃该包， 并发送 NET UNREACHABLE的ICMP信息</code></pre>
<p>#+END_EXAMPLE</p>
<p>** 示例 :PROPERTIES: :CUSTOM_ID: 示例 :END:</p>
<p>Source IP</p>
<p>根据来源端 IP 来决定数据包参考哪个路由表发送出去。以下两个示例分别指出，如果数据包的来源端 IP 是 192.168.1.10，就参考路由表 10；如果来源端 IP 为 192.168.2.0/24 网段的 IP，就参考路由表 20</p>
<p>#+BEGIN_SRC sh ip rule add from 192.168.1.10 table 10 ip rule add from 192.168.2.0/24 table 20 #+END_SRC</p>
<p>Destination IP</p>
<p>根据目的端 IP 来决定数据包参考哪个路由表发送出去。以下两个示例分别指出，如果数据包的目的端 IP 是 168.95.1.1，就参考路由表 10；如果目的端 IP 是 168.95.0.0/24 网段的 IP，就参考路由表 20</p>
<p>#+BEGIN_SRC sh ip rule add to 168.95.1.1 table 10 ip rule add to 168.96.0.0/24 table 20 #+END_SRC</p>
<p>ip rule show 命令所显示内容的第一个字段就是优先级别，数字越小，代表优先级别越高，也代表这条规则可以排得越靠前</p>
<p>#+BEGIN_SRC sh $ ip rule show 0: from all lookup local 32766: from all lookup main 32767: from all lookup default</p>
<pre><code>$ ip rule add from 192.168.1.0/24 table 1 prio 10
$ ip rule add from 192.168.2.0/24 table 2 prio 20

$ ip rule show
0: from all lookup local
10: from 192.168.1.0/24 lookup 1
20: from 192.168.2.0/24 lookup 2
32766: from all lookup main
32767: from all lookup default</code></pre>
<p>#+END_SRC</p>
<p>删除规则</p>
<p>#+BEGIN_SRC sh ip rule del prio 10 ip rule del from 192.168.1.0/24 ip rule del table 1 ip rule del from 192.168.1.0/24 table 1 prio 10 #+END_SRC</p>
<p>添加路由</p>
<p>#+BEGIN_SRC sh $ ip route add 192.168.1.0/24 dev eth1 table 10 $ ip route add default via 192.168.1.254 table 10</p>
<pre><code>$ ip route show table 10
192.168.1.0/24 dev eth1 scope link
default via 192.168.1.254 dev eth1</code></pre>
<p>#+END_SRC</p>
<p>删除路由表</p>
<p>#+BEGIN_SRC sh $ ip route show table 10 192.168.1.0/24 dev virbr0 scope link default via 192.168.1.254 dev eth1</p>
<pre><code>$ ip route del default table 10

$ ip route show table 10
192.168.1.0/24 dev virbr0 scope link

$ ip route del 192.168.1.0/24 table 10

$ ip route show table 10</code></pre>
<p>#+END_SRC</p>
<p>** 多播 ip maddress :PROPERTIES: :CUSTOM_ID: 多播-ip-maddress :END:</p>
<ol type="1">
<li><p>ip maddress – 多播地址管理</p>
<p>缩写：show、list、sh、ls、l</p></li>
<li><p>ip maddress show – 列出多播地址</p></li>
</ol>
<p>=ip maddr ls dummy=</p>
<ol start="3" type="1">
<li><p>ip maddress add – 加入多播地址</p>
<p>ip maddress delete – 删除多播地址</p>
<p>缩写：add、a；delete、del、d</p>
<p>使用这两个命令，我们可以添加／删除在网络接口上监听的链路层多播地址。这个命令只能管理链路层地址。</p>
<p>#+BEGIN_SRC sh # 示例1: 增加 ip maddr add 33:33:00:00:00:01 dev dummy # 示例2: 查看 $ ip -O maddr ls dummy 2: dummy link 33:33:00:00:00:01 users 2 static link 01:00:5e:00:00:01 # 示例3: 删除 ip maddr del 33:33:00:00:00:01 dev dummy #+END_SRC</p></li>
<li><p>ip mroute – 多播路由缓存管理</p></li>
<li><p>ip mroute show – 列出多播路由缓存条目</p>
<p>缩写：show、list、sh、ls、l</p>
<p>#+BEGIN_SRC sh # 示例1:查看 $ ip mroute ls (193.232.127.6, 224.0.1.39) Iif: unresolved (193.232.244.34, 224.0.1.40) Iif: unresolved (193.233.7.65, 224.66.66.66) Iif: eth0 Oifs: pimreg # 示例2:查看 $ ip -s mr ls 224.66/16 (193.233.7.65, 224.66.66.66) Iif: eth0 Oifs: pimreg 9383 packets, 300256 bytes #+END_SRC</p></li>
</ol>
<p>** 通道 ip tunnel :PROPERTIES: :CUSTOM_ID: 通道-ip-tunnel :END:</p>
<ol type="1">
<li><p>ip tunnel – 通道配置</p>
<p>缩写 tunnel、tunl</p></li>
<li><p>ip tunnel add – 添加新的通道</p>
<p>ip tunnel change – 修改现有的通道</p>
<p>ip tunnel delete – 删除一个通道</p>
<p>缩写：add、a；change、chg；delete、del、d</p>
<p>#+BEGIN_SRC sh # 示例1:建立一个点对点通道，最大TTL是32 ip tunnel add Cisco mode sit remote 192.31.7.104 local 192.203.80.1 ttl 32 #+END_SRC</p></li>
<li><p>ip tunnel show – 列出现有的通道</p>
<p>缩写：show、list、sh、ls、l</p>
<p>=ip -s tunl ls Cisco=</p></li>
<li><p>ip monitor 和 rtmon – 状态监视</p>
<p>ip 命令可以用于连续地监视设备、地址和路由的状态。这个命令选项的格式有点不同，命令选项的名字叫做 monitor，接着是操作对象：</p>
<p>ip monitor [ file FILE ] [ all | OBJECT-LIST ]</p>
<p>#+BEGIN_SRC sh rtmon file /var/log/rtmon.log ip monitor file /var/log/rtmon.log r #+END_SRC</p></li>
</ol>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[nmcli examples]]></title>
    <link>https://www.codeplayer.org/Wiki/Router/nmcli%20examples.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Router/nmcli%20examples.html</guid>
    <description><![CDATA[<p>#+TITLE: nmcli examples #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>nmcli examples</li>
</ul>
<p>List nearby wifi networks: =$ nmcli device wifi list=</p>
<p>Connect to a wifi network: =$ nmcli device wifi connect SSID password password=</p>
<p>Connect to a hidden network: =$ nmcli device wifi connect SSID password password hidden yes=</p>
<p>Connect to a wifi on the wlan1 wifi interface: =$ nmcli device wifi connect SSID password password ifname wlan1 profile_name=</p>
<p>Disconnect an interface: =$ nmcli device disconnect ifname eth0=</p>
<p>Reconnect an interface marked as disconnected: =$ nmcli connection up uuid UUID=</p>
<p>Get a list of UUIDs: =$ nmcli connection show=</p>
<p>See a list of network devices and their state: =$ nmcli device=</p>
<p>Turn off wifi: =$ nmcli radio wifi off=</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Linux ip命令详解]]></title>
    <link>https://www.codeplayer.org/Wiki/Router/Linux%20ip%e5%91%bd%e4%bb%a4%e8%af%a6%e8%a7%a3.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Router/Linux%20ip%e5%91%bd%e4%bb%a4%e8%af%a6%e8%a7%a3.html</guid>
    <description><![CDATA[<p>#+TITLE: Linux ip命令详解 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>命令详解 :PROPERTIES: :CUSTOM_ID: 命令详解 :END:</li>
</ul>
<p>=ip= 常用命令格式如下：</p>
<p>=ip [ OPTIONS ] OBJECT { COMMAND | help }=</p>
<p>对象 =OBJECT={ link | addr | addrlabel | route | rule | neigh | ntable | tunnel | maddr | mroute | mrule | monitor | xfrm | token }=</p>
<p>选项 =OPTIONS={ -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] | -h[uman-readable] | -iec | -f[amily] { inet | inet6 | ipx | dnet | link } | -o[neline] | -t[imestamp] | -b[atch] [filename] | -rc[vbuf] [size] }=</p>
<p>常用对象的取值含义如下：</p>
<ul>
<li>=link= ：网络设备</li>
<li>=address= ：设备上的协议（IP 或 IPv6）地址</li>
<li>=addrlabel= ：协议地址选择的标签配置</li>
<li>=route= ：路由表条目</li>
<li>=rule= ：路由策略数据库中的规则</li>
</ul>
<p>常用选项的取值含义如下：</p>
<ul>
<li><p>=-V，-Version= ：显示指令版本信息</p></li>
<li><p>=-s，-stats，statistics= ：输出详细信息</p></li>
<li><p>=-h，-human，-human-readable= ：输出人类可读的统计信息和后缀</p></li>
<li><p>=-o，-oneline= ：将每条记录输出到一行，用‘’字符替换换行符</p></li>
<li><p>使用实例-检查网卡信息 :PROPERTIES: :CUSTOM_ID: 使用实例-检查网卡信息 :END:</p></li>
<li><p>命令： =ip addr show=</p>
<p>说明：显示网卡及配置的地址信息</p>
<p>#+BEGIN_SRC sh 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:1e:4f:c8:43:fc brd ff:ff:ff:ff:ff:ff inet 192.168.0.24/24 brd 192.168.0.255 scope global eth0 valid_lft forever preferred_lft forever #+END_SRC</p>
<p>输出内容详解： 首先这个系统有两个接口：lo 和 eth0，lo 是环回接口，而我们重点关注的则是 eth0 这个普通网络接口；下面在看看每个子项的含义：</p></li>
<li><p>=&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;= ： =BROADCAST= 表示该接口支持广播； =MULTICAST= 表示该接口支持多播； =UP= 表示该网络接口已启用； =LOWER_UP= 表示网络电缆已插入，设备已连接至网络</p></li>
<li><p>=mtu 1500= ：最大传输单位（数据包大小）为 1,500 字节</p></li>
<li><p>=qdisc pfifo_fast= ：用于数据包排队</p></li>
<li><p>=state UP= ：网络接口已启用</p></li>
<li><p>=qlen 1000= ：传输队列长度</p></li>
<li><p>=link/ether 00:1e:4f:c8:43:fc= ：接口的 MAC（硬件）地址</p></li>
<li><p>=brd ff:ff:ff:ff:ff:ff= ：广播地址</p></li>
<li><p>=inet 192.168.0.24/24= ：IPv4 地址</p></li>
<li><p>=brd 192.168.0.255= ：广播地址</p></li>
<li><p>=scope global= ：全局有效</p></li>
<li><p>=dynamic enp0s25= ：地址是动态分配的</p></li>
<li><p>=valid_lft forever= ：IPv4 地址的有效使用期限</p></li>
<li><p>=preferred_lft forever= ：IPv4 地址的首选生存期</p></li>
<li><p>=inet6 fe80::2c8e:1de0:a862:14fd/64= ：IPv6 地址</p></li>
<li><p>=scope link= ：仅在此设备上有效</p></li>
<li><p>=valid_lft forever= ：IPv6 地址的有效使用期限</p></li>
<li><p>=preferred_lft forever= ：IPv6 地址的首选生存期</p></li>
<li><p>使用实例-IP 管理 :PROPERTIES: :CUSTOM_ID: 使用实例-ip 管理 :END:</p></li>
<li><p>命令： =ip addr add 192.168.0.123/24 dev eth0=</p>
<p>说明：设置 IP</p></li>
<li><p>命令： =ip add del 192.168.0.123/24 dev eth0=</p>
<p>说明：删除配置的 IP</p></li>
<li><p>使用实例-启用/禁用网卡 :PROPERTIES: :CUSTOM_ID: 使用实例-启用禁用网卡 :END:</p></li>
<li><p>命令： =ip link set eth0 up=</p>
<p>说明：启用被禁用的网卡</p></li>
<li><p>命令： =ip link set eth0 down=</p>
<p>说明：禁用网卡</p></li>
<li><p>使用实例-路由配置 :PROPERTIES: :CUSTOM_ID: 使用实例-路由配置 :END:</p></li>
<li><p>命令： =ip route show=</p>
<p>说明：查看路由信息</p>
<p>输出：</p>
<p>#+BEGIN_SRC sh default via 172.17.175.253 dev eth0 169.254.0.0/16 dev eth0 scope link metric 1002 172.17.160.0/20 dev eth0 proto kernel scope link src 172.17.169.20 #+END_SRC</p>
<p>输出内容详解：</p>
<ul>
<li>输出内容第一条是默认的路由，我们可以根据我们的需要改动它</li>
<li>=metric 1002= ：跳跃计数，确定网关的优先级，默认 20，数值越小优先级越高</li>
<li>=proto kernel= ：该路由的协议，主要有 =redirect= ， =kernel= ， =boot= ， =static= ， =ra= 等，其中 =kernel= 指的是直接由核心判断自动设定</li>
</ul></li>
<li><p>命令： =ip route get 119.75.216.20=</p>
<p>说明：通过 IP 地址查询路由包从哪条路由来</p></li>
<li><p>命令： =ip route add default via 192.168.0.150/24=</p>
<p>说明：所有的网络数据包都通过 192.168.0.150 来转发，而不是以前的默认路由</p></li>
<li><p>命令： =ip route add 172.16.32.32 via 192.168.0.150/24 dev enp0s3=</p>
<p>说明：修改特定网卡的默认路由</p></li>
<li><p>命令： =ip route del 172.17.160.0/20=</p>
<p>说明：删除路由</p></li>
<li><p>命令： =ip route flush cache=</p>
<p>说明：刷新路由表</p></li>
<li><p>使用实例-显示网络统计数据 :PROPERTIES: :CUSTOM_ID: 使用实例-显示网络统计数据 :END:</p></li>
</ul>
<p>这个显示网络统计数据则是 ip 命令非常重要的一个功能，很多时候，我们都依靠该功能来进行排除网络故障。</p>
<ul>
<li><p>命令： =ip -s link=</p>
<p>说明：显示所有网络接口的统计数据</p>
<p>输出：</p>
<p>#+BEGIN_SRC sh 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 RX: bytes packets errors dropped overrun mcast 361849729592 174114258 0 0 0 0 TX: bytes packets errors dropped carrier collsns 361849729592 174114258 0 0 0 0 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 00:16:3e:08:08:55 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 32345193376 115901261 0 0 0 0 TX: bytes packets errors dropped carrier collsns 139742200499 114451909 0 0 0 0 #+END_SRC</p>
<p>输出重点内容详解：</p>
<ul>
<li>=RX= ：表示接收</li>
<li>=TX= ：表示发送</li>
<li>=bytes= ：接收/发送的字节数</li>
<li>=packets= ：接收/发送的包数</li>
<li>=errors= ：接收/发送的带有错误的包总数</li>
<li>=dropped= ：由于处理资源不足导致接收/发送的丢弃的包数</li>
<li>=overrun= ：因接收溢出（环形缓冲区）导致丢失的包；通常如果接口溢出，则表示内核中存在严重问题，或者说服务器上该网络设备的处理设备太慢</li>
<li>=mcast= ：接收到的多播包数</li>
<li>=carrier= ：因数据链路错误导致发送失败的包数</li>
<li>=collsns= ：因在网络上发送冲突而导致的失败数</li>
</ul></li>
<li><p>命令： =ip -s -s link ls eth0=</p>
<p>说明：获取一个特定网络接口的信息；在网络接口名字后面添加选项 ls 即可。使用多个选项-s 会输出指定接口详细的信息；特别是在排除网络连接故障时，这会非常有用。</p>
<p>输出：</p>
<p>#+BEGIN_EXAMPLE 2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000 link/ether 00:16:3e:08:08:55 brd ff:ff:ff:ff:ff:ff RX: bytes packets errors dropped overrun mcast 32469801665 116402997 0 0 0 0 RX errors: length crc frame fifo missed 0 0 0 0 0 TX: bytes packets errors dropped carrier collsns 140235841575 115066014 0 0 0 0 TX errors: aborted fifo window heartbeat transns 0 0 0 0 2 #+END_EXAMPLE</p></li>
</ul>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Linksys WRT1200AC路由器Openwrt双分区切换固件]]></title>
    <link>https://www.codeplayer.org/Wiki/Router/Linksys%20WRT1200AC%e8%b7%af%e7%94%b1%e5%99%a8Openwrt%e5%8f%8c%e5%88%86%e5%8c%ba%e5%88%87%e6%8d%a2%e5%9b%ba%e4%bb%b6.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Router/Linksys%20WRT1200AC%e8%b7%af%e7%94%b1%e5%99%a8Openwrt%e5%8f%8c%e5%88%86%e5%8c%ba%e5%88%87%e6%8d%a2%e5%9b%ba%e4%bb%b6.html</guid>
    <description><![CDATA[<p>#+TITLE: Linksys WRT1200AC路由器Openwrt双分区切换固件 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>Linksys WRT1200AC 路由器 Openwrt 双分区切换固件</li>
</ul>
<p>路由存放固件的 FLASH 芯片有两个分区，分别存放两个固件，可通过 SSH 命令从当前 OP/LEDE 固件重启切换至另一个备用固件。而不需要通过“三次开关机”大法。</p>
<p>SSH 登录路由，输入以下命令查看所处分区： =fw_printenv boot_part=</p>
<p>例如:</p>
<p>#+BEGIN_EXAMPLE root@lede:~# fw_printenv boot_part boot_part=1 #+END_EXAMPLE</p>
<p>返回结果显示当前使用的固件在第 1 分区。</p>
<p>如果要重启并切换至第 2 分区的另一个固件，则分别输入以下 2 条命令：</p>
<p>#+BEGIN_EXAMPLE fw_setenv boot_part 2 reboot #+END_EXAMPLE</p>
<p>路由器重启。清空浏览器缓存，再次连接即可。</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[<< & <<< & < <()]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/Shell/%3c%3c%20%26%20%3c%3c%3c%20%26%20%3c%20%3c.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/Shell/%3c%3c%20%26%20%3c%3c%3c%20%26%20%3c%20%3c.html</guid>
    <description><![CDATA[<p>#+TITLE: &lt;&lt; &amp; &lt;&lt;&lt; &amp; &lt; &lt;() #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>&lt;&lt;(Here document) =&lt;&lt;= 被称为 =here-document= 结构。你让程序知道什么将会结束文本，并且无论何时见到该分隔符，程序就会读取你提供给程序的所有内容作为输入并在其上执行任务。</li>
</ul>
<p>这里有一个例子：</p>
<p>#+BEGIN_SRC sh $ wc &lt;&lt; EOF &gt; one two three &gt; four five &gt; EOF 2 5 24 #+END_SRC</p>
<p>在该例中我们告诉 =wc= 程序等待 =EOF= 字符串，然后输入五个单词，并之后输入 =EOF= 来通知我们已经完成了输入。实际上，这类似于单独运行 =wc= ，输入单词，然后按 =Ctrl-D= 。</p>
<p>在 bash 中这些通过临时文件实现，通常是 =/tmp/sh-thd.<random string>= 的形式，然而在 dash 中他们被实现为匿名管道。这可以通过使用 =starce= 命令追踪系统调用观察到。使用 =sh= 替换 =bash= 来查看 =/bin/sh= 如何执行此重定向。</p>
<p>#+BEGIN_SRC sh $ strace -e open,dup2,pipe,write -f bash -c ‘cat &lt;<EOF
    > test &gt; EOF’ #+END_SRC</p>
<ul>
<li>&lt;&lt;&lt;(Here string) =&lt;&lt;&lt;= 被称为 =here-string= 。代替输入文本，你将预制的文本字符串提供给程序。例如，对于诸如 =bc= 之类的程序，我们可以执行 =bc &lt;&lt;&lt; 5*4= 来获取此特定情况下的输出，而不需要交互运行 bc。</li>
</ul>
<p>here-string 在 bash 中通过临时文件实现，通常是 =/tmp/sh-thd.<random string>= 的形式，之后被 unlink，所以会使它们临时占用一些内存空间，但又不会出现在 =/tmp= 目录的列表中，并有效的以匿名文件的形式存在，仍然可以由 shell 本身通过文件描述符进行引用，并且该文件描述符被该命令继承，之后通过=dup2()=函数复制到文件描述符 0(stdin)。这可以通过以下命令观察：</p>
<p>#+BEGIN_SRC sh $ ls -l /proc/self/fd/ &lt;&lt;&lt; “TEST” total 0 lr-x—— 1 user1 user1 64 Aug 20 13:43 0 -&gt; /tmp/sh-thd.761Lj9 (deleted) lrwx—— 1 user1 user1 64 Aug 20 13:43 1 -&gt; /dev/pts/4 lrwx—— 1 user1 user1 64 Aug 20 13:43 2 -&gt; /dev/pts/4 lr-x—— 1 user1 user1 64 Aug 20 13:43 3 -&gt; /proc/10068/fd #+END_SRC</p>
<p>并通过追踪系统调用（缩短输出以提高可读性；注意临时文件是如何被作为 fd 3 打开的，写入数据，然后使用=O_RDONLY=flag 作为 fd 4 重新打开并之后被 unlink，然后=dup2()=到 fd 0，其之后会被=cat=继承）：</p>
<p>#+BEGIN_SRC sh $ strace -f -e open,read,write,dup2,unlink,execve bash -c ‘cat &lt;&lt;&lt; “TEST”’ execve(“/bin/bash”, [“bash”, “-c”, “cat &lt;&lt;&lt; "TEST"”], [/* 47 vars */]) = 0 … strace: Process 10229 attached [pid 10229] open(“/tmp/sh-thd.uhpSrD”, O_RDWR|O_CREAT|O_EXCL, 0600) = 3 [pid 10229] write(3, “TEST”, 4) = 4 [pid 10229] write(3, “”, 1) = 1 [pid 10229] open(“/tmp/sh-thd.uhpSrD”, O_RDONLY) = 4 [pid 10229] unlink(“/tmp/sh-thd.uhpSrD”) = 0 [pid 10229] dup2(4, 0) = 0 [pid 10229] execve(“/bin/cat”, [“cat”], [/* 47 vars */]) = 0 … [pid 10229] read(0, “TEST”, 131072) = 5 [pid 10229] write(1, “TEST”, 5TEST ) = 5 [pid 10229] read(0, "", 131072) = 0 [pid 10229] +++ exited with 0 +++ — SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=10229, si_uid=1000, si_status=0, si_utime=0, si_stime=0} — +++ exited with 0 +++ #+END_SRC</p>
<p>观点：可能因为 here-string 使用了临时文件，这是为什么 here-string 总是插入尾随换行符的可能原因，因为由 POSIX 定义的文本文件必须具有以换行符结尾的行。</p>
<ul>
<li>&lt; &lt;()（Process Substitution） 如 tldp.org 的解释：</li>
</ul>
<p>#+BEGIN_QUOTE 进程替换一个（或多个）进程的输出馈送到另一个进程的标准输入中。 #+END_QUOTE</p>
<p>所以这类似于将一个命令的 stdout 传递给另一个命令，例如 =echo foobar barfoo | wc= 。但是注意：再 bash manpage 中你会看到它表示为 =&lt;(list)= 。所以基本上你可以重定向多个(!)命令的输出。</p>
<p>注意：从技术上讲，当你说 =&lt; &lt;= 时并不是指一件事，而是两个重定向，一个是单一的 =&lt;= 以及一个 =&lt;( . . . )= 输出的进程重定向。</p>
<p>现在如果我们仅进行进程替换会发生什么？</p>
<p>#+BEGIN_SRC sh $ echo &lt;(echo bar) /dev/fd/63 #+END_SRC</p>
<p>正如你看到的，shell 在输出所在的位置创建了临时文件描述符 =/dev/fd/63= （根据 Gilles 的回答，这是一个匿名管道）。这意味着 =&lt;= 将文件描述符重定向为命令的输入。</p>
<p>所以非常简单的例子是将两个 echo 命令的输出的进程替换到 wc</p>
<p>#+BEGIN_SRC sh $ wc &lt; &lt;(echo bar;echo foo) 2 2 8 #+END_SRC</p>
<p>所以在这里我们让 shell 为括号中出现的所有输出创建文件描述符，并将其重定向为 =wc= 的输入。如期待的一样，wc 从两个 echo 命令接收该 stream，它们本身输出两行，每行有一个单词，并适当地我们有 2 个单词，2行和 6 个字符加两个换行符。</p>
<p>#+BEGIN_SRC sh $ (echo foo;echo bar) | wc 2 2 8 #+END_SRC</p>
<p>实际上，着和上面的例子相同。然而，这与进程替换在表面之下是不同的，因为我们将 subshell 的整个标准输出与=wc=的标准输入使用管道链接在了一起。在另一方面，进程替换使命令读取一个临时文件描述符。</p>
<h2 id="所以如果我们可以使用管道进行分组为什么我们需要进程替换因为有些时候我们不能使用管道考虑以下示例">所以如果我们可以使用管道进行分组，为什么我们需要进程替换？因为有些时候我们不能使用管道。考虑以下示例</h2>
<p>使用 =diff= 比较两个命令的输出（其需要两个文件，在这种情况下，我们为它提供两个文件描述符）</p>
<p>=diff &lt;(ls /bin) &lt;(ls /usr/bin)=</p>
<ul>
<li>Link</li>
</ul>
<ol type="1">
<li>https://askubuntu.com/questions/678915/whats-the-difference-between-and-in-bash</li>
</ol>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[C++ Primer 第 IV 部分 高级主题]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/C++/C++%20Primer%20Part%20IV.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/C++/C++%20Primer%20Part%20IV.html</guid>
    <description><![CDATA[<p>#+TITLE: C++ Primer 第 IV 部分 高级主题 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>第 17 章 标准库特殊设施 ** 17.1 tuple 类型 <em>tuple</em> 是类似 pair 的模板。每个 pair 的成员类型都不相同，但每个 pair 都恰好有两个成员。不同 tuple 类型的成员类型也不相同，但一个 tuple 可以有任意数量的成员。每个确定的 tuple 类型的成员数目是固定的，但一个 tuple 类型的成员数目可以于另一个 tuple 类型不同。下表列出了 tuple 支持的操作。tuple 类型及其伴随类型和函数都定义在 tuple 头文件中</li>
</ul>
<p>#+CAPTION: tuple 支持的操作 | tuple&lt;T1, T2, …, Tn&gt; t; | t 是一个 tuple，成员数为 n，第 i 个成员的类型为 Ti，所有成员都进行值初始化 | | tuple&lt;T1, T2, …, Tn&gt; t(v1, v2, …, vn); | t 是一个 tuple，成员类型为 T1…Tn，每个成员用对应的初始值 vi 进行初始化。此构造函数是 explicit 的 | | make_tuple(v1, v2, …, vn) | 返回一个用给定初始值初始化的 tuple。tuple 的类型从初始值的类型推断 | | t1 == t2 | 当两个 tuple 具有相同数量的成员且成员对应相等时，两个 tuple 相等。 | | t1 != t2 | 这两个操作使用成员的==运算符来完成。一旦发现某对成员不等，接下来的成员就不用比较了 | | t1 relop t2 | tuple 的关系运算符使用字典序。两个 tuple 必须具有两同数量的成员。使用&lt;运算符比较 t1 的成员和 t2 中的对应成员 | | get<t>(t) | 返回 t 的第 i 个数据成员的引用；如果 t 时一个左值，结果时一个左值引用；否则，结果时一个右值引用。tuple 的所有成员都是 public 的 | | tuple_size<tupleType>::value | 一个类模板，可以通过 tuple 类型来初始化。它有一个名为 value 的 public constexpr static 数据成员，类型为 size_t，表示给定 tuple 类型中成员的数量 | | tuple_element&lt;i, tupleType&gt;::type | 一个类模板，可以通过一个整型常量和一个 tuple 类型来初始化。它有一个名为 type 的 public 成员，表示给定 tuple 类型中指定成员的类型 |</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>我们可以将 tuple 看作一个“快速而随意”的数据结构。 #+END_QUOTE *** 17.1.1 定义和初始化 tuple **** 关系和相等运算符 #+BEGIN_QUOTE Note：</p>
<p>由于 tuple 定义了&lt;和==运算符，我们可以将 tuple 序列传递给算法，并且可以在无序容器中将 tuple 作为关键字类型。 #+END_QUOTE *** 17.1.2 使用 tuple 返回多个值 tuple 的一个常见用途时从一个函数返回多个值。 ** 17.2 bitset 类型 在 4.8 节中我们介绍了将整型运算对象当作二进制位集合处理的一些内置运算符。标准库还定义了 <em>bitset</em> 类，使得位运算符的使用更加容易，并且能够处理超过最长整型类型大小的位集合。bitset 类定义在头文件 bitset 中。 *** 17.2.1 定义和初始化 bitset 下表列出了 bitset 的构造函数。bitset 类时一个类模板，他类似 array 类，具有固定的大小。当我们定义个 bitset 时，需要声明它包含多少个二进制位：</p>
<p>~bitset&lt;32&gt; bitvec(1U); // 32 位；低位为1，其他位为0~</p>
<p>大小必须时一个常量表达式。这条语句定义 bitvec 为一个包含 32 位的 bitset。就像 vector 包含未命名的元素一样，bitset 中的二进制位也是未命名的，我们通过位置来访问它们。二进制的位置是从 0 开始编号的。因此，bitvec 包含编译从 0 到 31 的 32 个二进制位。编号从 0 开始的二进制位被称为 <em>低位(low-order)</em> ，编编号到 31 结束的二进制位被称为 <em>高位(high-order)</em> 。</p>
<p>#+CAPTION: 初始化 bitset 的方法 | bitset<n> b; | b 有 n 位；每一位均为 0，此构造函数是一个 constexpr | | bitset<n> b(u); | b 是 unsigned long long 值 u 的低 n 位的拷贝。如果 n 大于 unsigned long long 的大小，则 b 中超出 unsigned long long 的高位被置位 0。此构造函数是一个 constexpr | | bitset<n> b(s, pos, m, zero, one); | b 是 string s 从位置 pos 开始 m 个字符的拷贝。s只能包含字符 zero 或 one；如果 s 包含任何其他字符，构造函数会抛出 invaid_argument 异常。 | | | 字符在 b 中分别保存为 zero 和 one，pos 默认为 0，m 默认为 string::npos，zero 默认为’o’，one 默认为’1’ | | bitset<n> b(cp, pos, m, zero, one); | 与上一个构造函数相同，但从 cp 指向的字符数组中拷贝字符，如果未提供 m，则 cp 必须指向一个 C 风格字符串。如果提供了 m，则 cp 开始必须至少有 m 个 zero 或 one 字符 |</p>
<p>接受一个 string 或一个字符指针的构造函数是 explicit 的。在新标准中增加了为 0 和 1 执行其他字符的功能。 **** 用 unsigned 值初始化 bitset 当我们使用一个整型值来初始化 bitset 时，此值将被转换为 unsigned long long 类型并被当作位模式来处理。bitset 中的二进制位将是此模式的一个副本。如果 bitset 的大小大于一个 unsigned long long 中的二进制位数，则剩余的高位被置位 0。如果 bitset 的大小小于一个 unsigned long long 中的二进制位数，则只使用给定值中的低位，超出 bitset 大小的高位被丢弃：</p>
<p>#+BEGIN_SRC C++ // bitvec1比初始值小；初始值中的高位被丢弃 bitset&lt;13&gt; bitvec1(0xbeef); // 二进制位序列为1111011101111 // bitvec2比初始值大；它的高为被置位0 bitset&lt;20&gt; bitvec2(0xbeef); // 二进制位序列为00001011111011101111 // 在64位机器中，long long 0ULL是64个0比特，因此~0ULL是64个1 bitset&lt;64&gt; bitvec3(~0ULL); // 0-63位为1；63-127位为0 #+END_SRC **** 从一个 string 初始化 bitset 我们可以从一个 string 或字符数组指针来初始化 bitset。两种情况下，字符都直接表示位模式。与往常一样，当我们使用字符串表示数时，字符串中下标最小的字符对应高位，反之亦然：</p>
<p>~bitset&lt;32&gt; bitvec4(“1100”); // 2、3两位为1，剩余两位为0~</p>
<p>如果 string 包含的字符数比 bitset 少，则 bitset 的高位被置位 0。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>string 的下标编号习惯与 bitset 恰好相反；string 中下标最大的字符（最右字符）用来初始化 bitset 中的低位（下标为 0 的二进制位）。当你用一个 string 初始化一个 bitset 时，要记住这个差别。 #+END_QUOTE *** 17.2.2 bitset 操作 bitset 操作定义了多种检测或设置一个或多个二进制位的方法。bitset 类还支持我们在 4.8 节中介绍过的位运算符。这些运算符用于 bitset 对象的含义与内置运算符用于 unsigned 运算对象相同。</p>
<p>#+CAPTION: bitset 操作 | b.any() | b 中是否存在置位的二进制位 | | b.all() | b 中所有位都置位了吗 | | b.none() | b 中不那在置位的二进制位吗 | | b.count() | b 中置位的位数 | | b.size() | 一个 constexpr 函数，返回 b 中的位数 | | b.test(pos) | u 哦 pos 位置的位是置位的，则返回 true，否则返回 false | | b.set(pos,v) | 将位置 pos 处的位设置为 bool 值 v。v 默认为 true。 | | b.set() | 如果未传递实参，则将 b 中所有位置位 | | b.reset() | 将位置 pos 处的位复位或将 b 中所有位复位 | | b.reset() | | | b.flip(pos) | 改变位置 pos 处的位的状态或改变 b 中每一位的状态 | | b.flip() | | | b[pos] | 访问 b 中位置 pos 处的位；如果 b 是 const 的，则当该位置位时 b[pos]返回一个 bool 值 true，否则返回 false | | b.to_ulong() | 返回一个 unsigned long 或一个 unsigned long long 值，其位模式与 b 相同。如果 b 中位模式不能放入指定的结果类型，则抛出一个 overflow_error 异常 | | b.to_ullong() | | | b.to_string(zero, one) | 返回一个 string，表示 b 中的位模式。zero 和 one 的默认值分别为 0 和 1，用来表示 b 中的 0 和 1 | | os &lt;&lt; b | 将 b 中二进制打印为字符 1 或 0，打印到流 os | | is &gt;&gt; b | 从 is 读取字符存入 b。当下一个字符不是 1 或 0 时，或是已经读入 b.size()个位时，读取过程停止 |</p>
<p>count、size、all、any 和 none 等几个操作都不接受参数，返回整个 bitset 的状态。其他操作——set、reset 和 flip 则改变 bitset 的状态。改变 bitset 状态的成员函数都是重载的。对每个函数，不接受参数的版本对整个集合执行给定的操作：接受一个位置参数的版本则对指定位执行操作。</p>
<p>下标运算符对 const 属性进行了重载，const 版本的下标运算符在指定位置时返回 true，否则返回 false。非 const 版本返回 bitset 定义的一个特殊类型，它允许我们操纵指定位的值：</p>
<p>#+BEGIN_SRC C++ bitvec[0] = 0; // 将第一位复位 bitvec[31] = bitvec[0]; // 将最后一位设置为与第一位一样 bitvec[0].flip(); // 翻转第一位 ~bitvec[0]; // 等价操作，也是翻转第一位 bool b = bitvec[0]; // 将bitvec[0]的值转换为bool类型 #+END_SRC **** 提取 bitset 的值 to_ulong 和 to_ullong 操作都返回一个值，保存了与 bitset 对象相同的位模式。只有当 bitset 的大小小于等于对应的大小（to_ulong 为 unsigned long，to_ullong 为 unsigned long long）时，我们才能使用这两个操作。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果 bitset 中的值不能放入给定类型中，则这两个操作会抛出一个 overflow_error 异常。 #+END_QUOTE **** bitset 的 IO 运算符 输入运算符从一个输入流读取字符，保存到一个临时的 string 对象中。直接读取的字符数达到对应 bitset 的大小时，或是遇到不是 1 或 0 的字符时，或是遇到文件尾或输入错误时，读取过程才对停止。随即用临时 string 对象来初始化 bitset。如果读取的字符小于 bitset 的大小，则与往常一样，高位将被置位 0. ** 17.3 正则表达式 我们重点介绍如果使用 C++正则表达式库（RE 库），它是新标准库的一部分。RE 库定义在头文件 regex 中，它包含多个组件。</p>
<p>#+CAPTION: 正则表达式库组件 | regex | 表示有一个正则表达式的类 | | regex_match | 将一个字符序列与正则表达式匹配 | | regex_search | 寻找第一个与正则表达式匹配的子序列 | | regex_replace | 使用给定格式替换一个正则表达式 | | sregex_iterator | 迭代器适配器，调用 regex_search 来遍历一个 string 中所有匹配的子串 | | smatch | 容器类，保存在 string 中搜索的结果 | | ssub_match | string 中匹配的子表达式的结果 |</p>
<p><em>regex</em> 类表示一个正则表达式。除了初始化和赋值之外，regex 还支持其他一些操作。</p>
<p>函数 <em>regex_match</em> 和 <em>regex_search</em> 确定一个给定字符序列与一个给定 regex 是否匹配。如果整个输入序列与表达式序列匹配，则 regex_match 函数返回 true；如果输入序列中有一个子串与表达式匹配，则 regex_search 函数返回 true。还有一个 regex_replace 函数，我们将在 17.3.4 节中介绍。</p>
<p>下表列出了 regex 的函数参数。这些函数都返回 bool 值，且都被重载了：其中一个版本接受一个类型为 <em>smatch</em> 的附加参数。如果匹配成功，这些函数将成功匹配的相关信息保存在给定的 smatch 对象中。</p>
<p>#+CAPTION: regex_search 和 regex_match 的参数 | | 注意：这些操作返回 bool 值，指出是否找到 i 匹配。 | | (seq, m, r, mft) | 在字符序列 seq 中查找 regex 对象 r 中的正则表达式。seq 可以是一个 string、表是范围的一堆迭代器以及一个指向空字符结尾的字符串数组的指针 | | (seq, r, mft) | m 是一个 match 对象，用来保存匹配结果的相关细节。m和 seq 必须具有兼容的类型（参见 17.3.1 节） | | | mft 是一个可选的 regex_constants::match_flag_type 值。表 17.13 描述了这些值，他们会影响匹配过程 | *** 17.3.1 使用正则表达式库 **** 指定 regex 对象的选项 当我们定义一个 regex 或是对一个 regex 调用 assign 为其赋予新值时，可以指定一些标志来影响 regex 如何操作。这些标志控制 regex 对象的处理过程。下标列出的最后 6 个标志指出编写正则表达式所用的语言。对这 6 个标志，我们必须设置其中之一，且只能设置一个。默认情况下，ECMAScript 标志被设置，从而 regex 会使用 ECMA-262 规范，这也是很多 Web 浏览器所使用的正则表达式语言。</p>
<p>#+CAPTION: regex（和 wregex）选项 | regex r(re) | re 表是一个正则表达式，它可以是一个 string、一个表示字符范围的迭代器对、一个指向空字符结尾的字符数据的指针、一个字符指针 h 额一个计数器或是一个花括号包围的字符列表。 | | regex r(re, f) | f 是指出对象如何处理的标志。f通过下面列出的值来设置。如果未指定 f，其默认值为 ECMAScript | | r1 = re | 将 r1 中的正则表达式替换为 re。re 表是一个正则表达式，它可以是另一个 regex 对象、一个 string、一个指向空字符结尾的字符数组的指针或一个花括号包围的字符列表 | | r1.assign(re, f) | 与使用赋值运算符（=）效果相同；可选的标志 f 与 regex 的构造函数中对应的参数含义相同 | | r.mark_count() | r 中子表达式的数目（我们将在 17.3.3 节中介绍） | | r.flags() | 返回 r 的标志集 | | | 注：构造函数和赋值操作可能会包出类型为 regex_error 的异常 | | | | | | <em>定义 regex 时指定的标志</em> | | | 定义在 regex 和 regex_constants::syntax_option_type 中 | | icase | 在匹配过程中忽略大小写 | | nosbus | 不保存匹配的子表达式 | | optimize | 执行速度优于构造速度 | | ECMAScript | 使用 ECMA-262 指定的语法 | | basic | 使用 POSIX 基本的正则表达式语法 | | extended | 使用 POSIX 扩展的正则表达式语法 | | awk | 使用 POSIX 版本的 awk 语言的语法 | | grep | 使用 POSIX 版本的 grep 的语法 | | egrep | 使用 POSIX 版本的 egrep 的语法 | **** 指定或使用正则表达式时的错误 我们可以将正则表达式本身看作用一种简单程序设计语言编写的“程序”。这种语言不是由 C++编译器解释的。正则表达式是在运行时，当一个 regex 对象被初始化或被赋予一个新模式时，才被“编译”的。与任何其他程序设计语言一样，当我们用这种语言编写正则表达式也可能有错误。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>需要意识到的非常重要的一点是，一个正则表达式的语法是否正确是在运行时解析的。 #+END_QUOTE</p>
<p>如果我们编写的正则表达式存在错误，则在运行时标准库会抛出一个类型为 <em>regex_error</em> 的异常。类似标准异常类型，regex_error 有一个 what 操作来描述发生了什么错误。regex_error 还有一个名为 code 的成员，用来返回某个错误类型对应的数值编码。code 返回的值是由具体实现定义的。RE 库能抛出的标准错误如下表所示：</p>
<p>#+BEGIN_SRC C++ try { // 错误：alnum漏掉了右括号，构造函数会抛出异常 regex r(“[[:alnum:]+\.(cpp|cxx|cc)$”, regex::icase); } catch (regex_error e) { cout &lt;&lt; e.what() &lt;&lt; “:” &lt;&lt; e.code() &lt;&lt; endl; } #+END_SRC</p>
<p>#+CAPTION: 正则表达式错误类型 | | 定义在 regex 和 regex_constants::error_type 中 | | error_collate | 无效的元素校对请求 | | error_ctype | 无效的字符类 | | error_escape | 无效的转义字符或无效的尾置转义 | | error_backref | 无效的向后引用 | | error_brack | 不匹配的方括号（[或]） | | error_paren | 不匹配的小括号（(或)） | | error_brace | 不匹配的花括号（{或}） | | error_badbrace | {}中无效的范围 | | error_range | 无效的字符范围（如[z-a]） | | error_space | 内存不足，无法处理此正则表达式 | | error_badrepeat | 重复字符（*、?、+或{）之前没有有效的正则表达式 | | error_complexity | 要求的匹配过于复杂 | | error_stack | 栈空间不足，无法处理分配 |</p>
<p>我们的编译器定义了 code 成员，返回比上表列出的错误类型的编号，与往常一样，编号从 0 开始。</p>
<p>#+BEGIN_QUOTE 建议：避免创建不必要的正则表达式</p>
<p>如我们所见，一个正则表达式所表是的“程序”是在运行时而非编译时编译的。正则表达式的编译是一个非常慢的操作，特别时在你使用了扩展的正则表达式语法或复杂的正则表达式时。因此，构造一个 regex 对象以及向一个已存在的 regex 赋予一个新的正则表达式大可能时非常耗时的。为了最小化这种开销，你应该努力避免创建很多不必要的 regex。特别是，如果你在一个循环中使用正则表达式，应该在循环外创建它，而不是在每步迭代时都编译它。 #+END_QUOTE **** 正则表达式和输入序列类型 我们可以搜索多种类型的输入序列。输入可以是普通 char 数据或 wchar_t 数据，字符可以保存在标准库 string 中或是 char 数组中（或是宽字符版本，wstring 或 wchat_t 数组中。RE 为这些不同的输入序列类型都定义了对应的类型。</p>
<p>例如，regex 类保存类型 char 的正则表达式。标准库还定义了一个 wregex 诶保存类型 wchar_t，其操作与 regex 完全相同。两种唯一的差别是 wregex 的初始值必须使用 wchar_t 而不是 char。</p>
<p>匹配和迭代器类型（我们将在下面小节中介绍）更为特殊。这些类型的差异不仅在于字符类型，还在于序列是在标准库 string 中还是在数组中：smatch 表示 string 类型的输入序列；cmatch 表示字符数组序列；wsmatch 表示宽字符串（wstring）输入；而 wcmatch 表示宽字符数组。</p>
<p>重点再与我们使用的 RE 库类型必须与输入序列类型匹配。下标列出了 RE 库类型与输入序列类型的对应关系。</p>
<p>#+CAPTION: 正则表达式库类 | 如果输入序列类型 | 则使用正则表达式 | |——————+————————————————| | string | regex、smatch、ssub_match 和 sregex_iterator | | const char* | regex、cmatch、csub_match 和 cregex_iterator | | wstring | wregex、wsmatch、wssub_match 和 wsregex_iterator | | const wchar_t* | wregex、wcmatch、wcsub_match 和 wcregex_iterator | *** 17.3.2 匹配与 Regex 迭代器类型 regex 迭代器是一种迭代器适配器（参见 9.6 节），被绑定到一个输入序列和一个 regex 对象上。如上表所述，每种不同的输入序列类型都有对应的特殊 regex 迭代器类型。迭代器操作如下表所述。</p>
<p>#+CAPTION: sregex_iterator 操作 | | 这些操作也适用于 cregex_iterator、wsregex_iterator 和 wcregex_iterator | | sregex_iterator | 一个 sregex_iterator，遍历迭代器 b 和 e 指定的 string | | it(b, e, r) | 它调用 sregex_search(b, e, r)将 it 定位到输入中第一个匹配的位置 | | sregex_iterator end; | sregex_iterator 的尾后迭代器 | | *it | 根据最后一个调用 regex_search 的结果，返回一个 smatch 对象的引用或一个指向指向 smatch 对象的指针 | | it-&gt; | | | ++it | 从输入序列当前匹配尾值开始调用 regex_search。前置版本返回递增后迭代器；后置版本返回旧值 | | it++ | | | it1 == it2 | 如果两个 sregex_iterator 都是尾后迭代器，则他们相等。如果两个非尾后迭代器都是从相同的输入序列和 regex 对象构造，则它们相等 |</p>
<p>当我们将一个 sregex_iterator 绑定到一个 string 和一个 regex 对象时，迭代器自动定位到给定 string 中第一个匹配尾值。即，sregex_iterator 构造函数对给定 string 和 regex 调用 regex_search。当我们解引用迭代器时，会得到一个对应最近一次搜索结果的 smatch 对象。当我们递增迭代器时，它调用 regex_search 在输入 string 中查找下一个匹配。 **** 使用匹配数据 #+CAPTION: smatch 操作 | | 这些操作也适用于 cmatch、wsmatch、wcmatch 和对应的 csub_match、wssub_match 和 wcsub_match | | m.ready() | 如果已经通过调用 regex_search 或 regex_match 设置了 m，则返回 true；否则返回 false，如果 ready 返回 false，则对 m 进行操作时未定义的 | | m.size() | 如古匹配失败，则返回 0；否则返回最近一次匹配的正则表达式中子表达式的数目 | | m.empty() | 若 m.size()为 0，则返回 true | | m.prefix() | 一个 ssub_match 对象，表示当前匹配之前的序列 | | m.suffix() | 一个 ssub_match 对象，表示当前匹配之后的部分 | | m.format(…) | 见表 17.12 | | | 在接受一个索引的操作中，n的默认值为 0 且必须小于 m.szie()。 | | | 第一个子匹配（索引为 0）表示整个匹配 | | m.length(n) | 第 n 个匹配的子表达式的大小 | | m.position(n) | 第 n 个子表达式距序列开始的距离 | | m.str(n) | 第 n 个子表达式 i 匹配的 string | | m[n] | 对应第 n 个子表达式的 ssub_match 对象 | | m.begin(),m.end() | 表示 m 中 sub_match 元素范围的迭代器。与往常一样，cbegin 和 cend 返回 const_iterator | | m.cbegin(),m.cend() | | *** 17.3.3 使用子表达式 正则表达式的模式通常包含一个或多个 <em>子表达式</em> 。一个子表达式时模式的一部分，本身也具有意义。正则表达式语法通常用括号表示子表达式。</p>
<p>#+BEGIN_SRC C++ // r有两个子表达式：第一个是点之前表示文件名的部分，第二个表示文件扩展名 regex r(“([[:alnum:]]+)\.(cpp|cxx|cc)$”, regex::icase); #+END_SRC</p>
<p>上述模式包含两个括号括起来的子表达式： - <sub>([[:alnum:]]+)</sub> ，匹配一个或多个字符的序列 - <sub>(cpp|cxx+cc)</sub> ，匹配文件扩展名</p>
<p>匹配对象除了提供匹配整体的相关信息外，还提供访问模式中每个子表达式的能力。子匹配是按位置来访问的。第一个子匹配位置为 0,表示整个模式对应的匹配，随后是每个子表达式对应的匹配。因此，本例模式中第一个子表达式，即表示文件名的子表达式，其位置为 1，而文件扩展名对应的子表达式位置为 2.</p>
<p>例如，如果文件名为 foo.cpp，则 results.str(0)将保存 foo.cpp；results.str(1)将保存 foo；而 results.str(2)将保存 cpp。 **** 使用子匹配操作 #+CAPTION: 子匹配操作 | | 注意：这些操作适用于 ssub_match、csub_match、wssub_match、wcsub_match。 | | matched | 一个 public bool 数据成员，指出此 ssub_match 是否匹配了 | | first | public 数据成员，指向匹配函徐序列首元素和尾后位置的迭代器。如果未匹配，则 first 和 second 是相等的 | | second | | | legnth() | 匹配的大小。如果 matched 未 false，则返回 0 | | str() | 返回一个包含输入中匹配部分的 string。如果 matched 为 false，则返回空 string | | s = ssub | 将 ssub_match 对象 ssub 转换为 string 对象 s。等价于 s=ssub.str()。转换运算符不是 explicit 的 | *** 17.3.4 使用 regex_replace 正则表达式不仅用在我们希望查找一个给定序列的时候，还用在当我们想将找到的序列替换为另一个序列的时候。</p>
<p>当我们希望在输入序列中查找并替换一个正则表达式时，可以调用 <em>regex_replace</em> 。下表描述了 regex_replace，类似搜索函数，它接收一个输入字符序列和一个 regex 对象，不同的时，它还接受一个描述我们想要的输出形式的字符串</p>
<p>#+CAPTION: 正则表达式替换操作 | m.format(dest,fmt,mft) | 使用格式字符串 fmt 生成格式化输出，匹配在 m 中，可选的 match_flag_type 标志在 mft 中。第一个版本写入迭代器 dest 指向的目的位置并接受 fmt 参数，可以是一个 string，也可以是表示字符数组中范围的一对指针。 | | m.format(fmt,mft) | 第二个版本返回一个 string，保存输出，并接受 fmt 参数，可以是一个 string，也可以是一个指向空字符结尾的字符数组的指针。mft 的默认值为 format_defualt | | regex_replace(dest,seq,r,fmt,mft) | 遍历 seq，用 regex_search 查找与 regex 对象 r 匹配的子串。使用格式字符串 fmt 和可选的 match_flag_type 标志来生成输出。第一个版本将输出写入到迭代器 dest 指定的位置，并接受一对迭代器 seq 表示范围。 | | regex_replace(seq,r,fmt,mft) | 第二个版本返回一个 string，保存输出，且 seq 既可以是一个 string 也可以是一个指向空字符结尾的字符数组的指针。 | | | 在所有情况下，fmt 既可以是一个 string 也可以是一个指向空字符结尾的字符数组的指针，且 mft 的默认值为 match_defualt |</p>
<p>替换字符串由我们想要的字符组合与匹配的子串对应的子表达式而组成。我们用一个符号$后跟子表达式的索引号来表示一个特定的子表达式：</p>
<p>~string fmt = “$2.$5.$7”; // 将号码格式改为ddd.ddd.dddd~ **** 用来控制匹配的格式的标志 就像标准库定义标志来指导如何处理正则表达式一样，标准库还定义了用来在替换过程中控制匹配或格式的标志。下表列出了这些值。这些标志可以传递给函数 regex_search 或 regex_match 或是类 smatch 的 format 成员。</p>
<p>匹配和格式化标志的类型为 match_flag_type。这些值都定义在名为 regex_constants 的命名空间中。类似用于 bind 的 placeholder（参见 10.3.4 节），regex_constants 也是命名空间 std 中的命名空间。为了使用 regex_constants 中的名字，我们必须在名字前同时加上两个命名空间限定符：</p>
<p>~using std::regex_constants::format_no_copy;~</p>
<p>#+CAPTION: 匹配标志 | | 定义在 regex_constants::match_flag_type 中 | | match_default | 等价于 format_default | | match_not_bol | 不将首字符作为行首处理 | | match_not_eol | 不将尾字符作为行尾处理 | | match_not_bow | 不将首字符作为单词首处理 | | match_not_eow | 不将尾字符作为单词尾处理 | | match_any | 如果存在多余一个匹配，则可返回任意一个匹配 | | matcn_not_null | 不匹配任何空序列 | | match_continuous | 匹配必须从输入的首字符开始 | | match_prev_avail | 输入序列必须包含第一个匹配之前的内容 | | format_defualt | 用 ECMAScript 规则替换字符串 | | format_sed | 用 POSIX sed 规则替换字符串 | | format_no_copy | 不输出输入序列中未匹配的部分 | | format_first_only | 只替换子表达式的第一次出现 | ** 17.4 随机数 程序通常需要一个随机数源。在新标准出现之前，C和 C++都依赖于一个简单的 C 库函数 rand 来生成随机数。此函数生成均匀分布的伪随机数整数，每个随机数的范围在 0 和一个系统相关的最大值（至少为 32767）之间。</p>
<p>rand 函数有一些问题：即使不是大多数，也有很多程序需要不同范围的随机数。一些应用需要随即浮点数。一些程序需要非均匀分布的数。而程序员为了解决着地写问题而试图转换 rand 生成的随机数的范围、类型或分布时，常常会引入非随机性。</p>
<p>定义在头文件 random 中的随机数库通过一组写作的类来解决这些问题： <em>随机数引擎类</em> 和 <em>随机数分布类</em> 。下表描述了这些类。一个引擎类可以生成 unsigned 随机数序列，一个分布类使用一个引擎类生成指定类型的、在给定范围内的、服从特定概率分布的随即数。</p>
<p>#+CAPTION: 随机数库的组成 | 引擎 | 类型，生成随机 unsigned 整数序列 | | 分布 | 类型，使用引擎返回服从特定概率分布的随机数 |</p>
<p>#+BEGIN_QUOTE Best Practies：</p>
<p>C++程序不应该使用库函数 rand，而而应使用 default_random_engine 类和恰当的分布类对象 #+END_QUOTE *** 17.4.1 随机数引擎和分布 随机数引擎是函数对象类（参见 14.8），它们定义了一个调用运算符，运算符不接受参数并返回并返回一个随机 unsigned 整数.我们可以通过调用一个随机数引擎对象来生成原始随机数。</p>
<p>#+BEGIN_SRC C++ default_random_engine e; // 生成随机无符号数 for (size_t i = 0; i &lt; 10 ; ++i) // e() “调用”对象来生成下一个随机数 cout &lt;&lt; e() &lt;&lt; " "; #+END_SRC</p>
<p>标准库定义了多个随机数引擎类，区别在于性能和随机性质量不同。每个编译器都会指定其中一个作为 default_random_engine 类型。此类型一般具有最常用的特性，下表列出了随机数引擎操作，标准库定义的引擎类型列在附录 A3.2 中。</p>
<p>#+CAPTION: 随机数引擎操作 | Engine e; | 默认构造函数；使用该引擎类型默认的种子 | | Engine e(s); | 使用整型值 s 作为种子 | | e.seed(s) | 使用种子 s 重值引擎的状态 | | e.min() | 此引擎可生成的最小值和最大值 | | e.max() | | | Engine::result_type | 此引擎生成的 unsigned 整型类型 | | e.discard(u) | 将引擎推进 u 补；u的链诶行为 unsigned long long | **** 分布类型和引擎 为了得到在一个指定范围内的数，我们使用一个分布类型的对象：</p>
<p>#+BEGIN_SRC C++ // 生成0到9之间（包含）均匀分布的随机数 uniform_int_distribution<unsigned> u(0,9); default_random_engine e; // 生成无符号随机数 for (size_t i = 0; i &lt; 10; ++i) // 将u作为随机数源 // 每个调用返回在指定范围内并服从均匀分布的值 cout &lt;&lt; u(e) &lt;&lt; " "; #+END_SRC</p>
<p>此处我们将 u 定义为 uniform_int_distribution<unsigned>。此类型生成均匀分布的 unsigned 值。当我们定义一个这种类型的对象时，可以提供想要的最小值和最大值。在此程序中，u(0,9)表示我们希望得到 0 到 9 之间（包含）的数。随机数分布类会使用博阿寒的范围，从而我们可以得到给定整型类型的每个可能值。</p>
<p>类似引擎类型，分布类型也是函数对象类。分布类型定义了一个调用运算符，它接受一个随机数引擎作为参数。分布对象使用它的引擎参数生成随机数，并将其映射到指定的分布。</p>
<p>注意，我们传递给分布对象的是引擎对象本身，即 u(e)。如果我们将调用写成 u(e())，含义变为将 e 生成的下一个值传递给 u，会导致一个编译错误。我们传递的是引擎本身，而不是它生成的下一个值，原因是某些分布可能需要调用引擎多次才能得到一个值。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当我们说 <em>随机数发生器</em> 时，是指分布对象和引擎对象的组合。 #+END_QUOTE **** 引擎生成一个数值序列 随机数发生器有一个特性经常会使新手迷惑：即使生成的数看起来像是随机的，但对一个给定的发生器，每次运行程序它都会返回相同的数值序列。序列不变这一事实在调试时非常有用。但另一方面，使用随机数发生器的程序也必须考虑这一特性。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为 static 的。否则，每次调用函数都会生成相同的序列。 #+END_QUOTE **** 设计随机数发生器种子 随机数发生器会生成相同的随机数序列这一特性在调试中很有用。但是，一旦我们的程序调试完毕，我们通常希望每次运行程序都会生成不同的随机结果，可以通过提供一个 <em>种子</em> 来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。</p>
<p>为引擎设置种子有两种方式：在创建引擎对象时提供种子，或者 a 调用引擎的 seed 成员。</p>
<p>选择一个好的种子，与生成好的随机数所涉及的其他大多数事情相同，是极其困难的的。可能最常用的方式时调用系统函数 time。这个函数定义在头文件 ctime 中，它返回从一个特定时刻到当前经过了多少秒。函数 time 接受单个指针参数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单地返回时间：</p>
<p>~default_random_engine e1(time(0)); // 稍微随机些的种子~</p>
<p>由于 time 返回以秒计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>如果程序作为一个自动过程的一部分反复运行，将 time 的返回值作为种子的方式就无效了；它可能多次使用的都是相同的种子。 #+END_QUOTE *** 17.4.2 其他随机数分布 **** 生成随机实数 程序常需要一个随机浮点数的源。特别是，程序经常需要 0 到 1 之间的随机数。</p>
<p>最常用但不正确的从 rand 获取一个随机浮点数的方法时用 rand()的结果除以 RAND_MAX，即，系统定义的 rand 可以生成的最大随机数的上界。这种方法不正确的原因是随机整数的精度通常低于随机浮点数，这样，有一些浮点值就永远不会被生成了。</p>
<p>使用新标准库设施，可以很容易地获得随机浮点数。我们可以定义一个 uniform_real_distribution 类型的对象，并让标准库来处理从随机整数到随机浮点小树的映射。</p>
<p>#+CAPTION: 分布类型的操作 | Dist d; | 默认构造函数；使 d 准备好被使用 | | | 其他构造函数依赖于 Dist 的类型；参见附录 A.3 | | | 分布类型的构造函数是 explicit 的 | | d(e) | 用相同的 e 连续调用 d 的话，会根据 d 的分布是类型生成一个随机数序列；e是一个随机数引擎对象 | | d.min() | 返回 d(e)能生成的最小值和最大值 | | d.max() | | | d.reset() | 重建 d 的状态，使得随后对 d 的使用不依赖于 d 已经生成的值 | **** bernoulli_distribution 类 #+BEGIN_QUOTE WARNING：</p>
<p>由于引擎返回相同的随机序列（参见 17.4.1 节），所以我们必须在循环外声明引擎对象。否则，每步循环都会创建一个新引擎，而从每步循环都会生成相同的值。类似的，分布对象也要保持状态，因此也应该在循环外定义。 #+END_QUOTE ** 17.5 IO 库再探 在第 8 章中我们介绍了 IO 库的基本结构及其最常用的部分。在本节中，我们将介绍三个更特殊的 IO 库特性：格式控制、未格式化 IO 和随机访问。 *** 17.5.1 格式化输入与输出 除了条件状态外（参见 8.1.2 节），每个 iostream 对象还维护一个格式状态来控制 IO 如何格式化的细节。格式状态控制格式化的某些方面，如整型是几进制、浮点值的精度、一个输出元素的宽断等。</p>
<p>标准库定义了一组 <em>操纵符</em> （参见 1.2 节）来修改流的格式状态。一个操作符 shingle 函数或是一个对象，会影响力流的状态，并能用作输入或输出运算符的运算符对象。类似输入和输出运算符，操纵符也返回它所处理的流对象，因此我们未可以在一条语句中组合操纵符和数据。</p>
<p>我们已经在程序使用过一个操纵符——endl，我们将它“写”到输出流，就像它是一个值一样。但 endl 不是一个普通值，而是一个操作：它输出一个换行符并刷新缓冲区。 **** 很多操纵符改变格式状态 草丛服用于两大类输出控制：控制数值的输出形式以及控制补白的数量和位置。大多数改变格式状态的操纵符都是设置/复原成对的；一个操纵符用来将格式状态设置成新值，而另一个用来将其复原，恢复为正常的默认格式。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>当操纵符改变流的格式状态时，通常改变后的状态对素有后续 IO 都生效。 #+END_QUOTE</p>
<p>当我们有一组 IO 操作希望使用相同的格式时，操纵符对格式状态的改变是持久的这一特性很有用。实际上，一些程序会利用操纵符的这一特性对其所有输入或输出重值一个或多个格式规则的行为。在这种情况下，操纵符会改变流这一特性就是满足要求了。</p>
<p>但是，很多重续（而且更重要的是，很多程序员）期望流的状态符合标准库正常的默认设置。在这些情况下，将流的状态置于一个非标准状态可能会导致错误。因此，通常最好在不再需要特殊格式时尽快将流恢复到默认状态。 **** 指定整型值的进制 #+BEGIN_QUOTE Note：</p>
<p>操纵符 hex、oct 和 dec 只影响整型运算符对象，浮点值的表示形式不受影响。 #+END_QUOTE</p>
<p>#+CAPTION: 定义在 iostream 中的操纵符 | boolalpha | 将 true 和 false 输出为字符串 | | * noboolalpha | 将 true 和 false 输出为 1，0 | | showbase | 对整型值输出表示进制的前缀 | | * noshowbase | 不生成表示进制的前缀 | | showpoint | 对浮点值总是显式小数点 | | * noshowpoint | 只有当浮点值包含小数部分时才显示小数点 | | showpos | 对非负数显示+ | | * noshowpos | 对非负数不显示+ | | uppercase | 在十六进制中打印 0X，在科学记数法中打印 E | | * nouppercase | 在十六进制中打印 0x，在科学记数法中打印 e | | * dec | 整型值显示为是禁止 | | hex | 整型值显示为十六进制 | | oct | 整型值显示为八进制 | | left | 在值的右侧添加填充字符 | | right | 在值的左侧添加填充字符 | | internal | 在符号和值之间添加填充字符 | | fixed | 浮点值显示为定点十进制 | | scientific | 浮点值显示为科学记数法 | | hexfloat | 浮点值显示为十六进制（C++11 新特性） | | defaultfloat | 重值浮点数格式为十进制（C++11 新特性） | | unitbuf | 每次输出操作后都刷新缓冲区 | | * nounitbuf | 恢复正常的缓冲区刷新方式 | | * shipws | 输入运算符跳过空白符 | | noskipws | 输入运算符不跳过空白符 | | flush | 刷新 ostream 缓冲区 | | ends | 插入空字符，然后刷新 ostream 缓冲区 | | endl | 插入换行符，然后刷新 ostream 缓冲区 | | * 表示默认流状态 | | **** 指定浮点数记数法 #+BEGIN_QUOTE Best Practies：</p>
<p>除非你需要控制浮点数的表示形式（如，按列打印数据或打印表示金额或百分比的数据），否则由标准库选择记数法是最好的方式。 #+END_QUOTE **** 输出补白 当按列打印数据时，我们常常需要非常精细地控制数据格式。标准库提供了一些操纵符帮助我们完成所需的控制： - setw 指定下一个数字或字符串值的最小空间。 - left 表示左对齐输出 - right 表示右对齐输出，右对齐是默认格式 - internal 控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满所有中间空间。 - setfill 允许指定一个字符代替默认的空格来补白输出。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>setw 类似 endl，不改变输出流的内部状态。它只决定了下一个输出的大小。 #+END_QUOTE</p>
<p>#+CAPTION: 定义在 iomanip 中的操纵符 | setfill(ch) | 用 ch 填充空白 | | setprecision(n) | 将浮点精度设置为 n | | setw(w) | 读或写值的宽度为 w 个字符 | | setbase(b) | 将整数输出为 b 进制 | *** 17.5.2 未格式化的输入/输出操作 到目前为止，我们的程序只使用过 <em>格式化 IO</em> 操作。输入和输出运算符（ =&lt;&lt;= 和 =&gt;&gt;= ）根据读取或写入的数据类型来格式化它们。输入运算符忽略空白符，输出运算符应用补白、精度等规则。</p>
<p>标准库还提供了一组低层操作，支持 <em>未格式化 IO</em> 。这些操作允许我们将一个流当当作一个无解释的字节序列来处理。 **** 单字节操作 有几个未格式化操作每次一个字节地处理流。这些操作列在下表中，它们会读取而不是忽略空白符。</p>
<p>#+CAPTION: 单字节地层 IO 操作 | is.get(ch) | 从 istream is 读取下一个字节存入字符 ch 中。返回 is | | os.put(ch) | 将字符 ch 输出到 ostream os，返回 os | | is.get() | 将 is 的下一个字节作为 int 返回 | | is.putback(ch) | 将字符 ch 放回 is。返回 is | | is.unget() | 将 is 向后移动一个字节。返回 is | | is.peek() | 将下一个字节作为 int 返回，但不从流中删除它 | **** 将字符放回输入流 有时我们需要读取一个字符才能知道还未准备好处理它。在这种情况下，我们希望将字符放回流中。标准库提供了三种方法退会字符，它们有着细微的差别： - peek 返回输入流中下一个字符的副本，但不会将它从流中删除，peek 返回的值仍然在流中。 - unget 使得输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以有调用 unget。 - putback 是更特殊版本的 unget，它退回从流中读取的最后一个值，但它接受一个参数，此参数必须与最后读取的值想通</p>
<p>一般情况下，在读取下一个值之前，标准库保证我们可以退回最多一个值。即，标准库不保证在中间不进行读取操作的情况下能连续调用 pushback 或 unget。 **** 从输入操作返回的 int 值 函数 peek 和无参的 get 版本都以 int 类型从输入流返回一个字符。这有些令人吃惊，可能这些函数返回一个 char 看起来会更自然。</p>
<p>这些函数返回一个 int 的原因是：可以返回文件尾标记。我们使用 char 范围中的每个值来表示一个真实字符，因此，取值范围中没有额外的值可以用来表示文件尾。</p>
<p>返回 int 的函数将它们要返回的字符先转换为 unsigned char，然后再将结果提升到 int。因此，即使字符集中有字符映射到负值，这些操作返回的 int 也是正值（参见 2.1.2 节）。而标准库使用负值表示文件尾，这样就可以保证与任何合法字符的值都不同。文件 cstdio 定义了一个名为 EOF 的 const，我们可以用它来检测从 get 返回的值是否是文件尾，而不必记忆表示文件尾的实际数值 **** 多字节操作 一些未格式化 IO 操作一次处理大块数据。如果速度是要考虑的重点问题的话，这些操作是很重要的，但类似其他低层操作，这些操作也容易出错。特别是，这些操作要求我们自己分配并管理用来保存和提取数据的字符数组。下表列出了多字节操作。</p>
<p>#+CAPTION: 多字节底层 IO 操作 | is.get(sink, size, delim) | 从 is 中读取最多 size 个字节，并保存在字符数组中，字符数组的起始地址由 sink 给出。读取过程直至遇到了字符 delim 或读取了 size 个字节或遇到文件尾时停止。 | | | 如果遇到了 delim，则将其留在输入流中，不读取出来存入 sink | | is.getline(sink, size, delim) | 与接受三个参数的 get 版本类似，但会读取并丢弃 delim | | is.read(sink, size) | 读取最多 size 个字节，存入字符数组 sink 中。返回 is | | is.gcount() | 返回上一个未格式化读取操作从 is 读取的字节数 | | os.write(source, size) | 将字符数组 source 中的 size 个字节写入 os。返回 os | | is.ignore(size, delim) | 读取并忽略最多 size 个字符，包括 delim。与其他未格式化函数不同，ignore 有默认参数；size 的默认值为 1，delim 的默认值为文件尾 |</p>
<p>get 和 getiline 函数接受相同的参数，它们的行为类型但不相同。这两个函数中，sink 都是一个 char 数组，用来保存数据。两个函数都一直读取数据，直至下面条件之一发生： - 已读取了 size-1 字符 - 遇到了文件尾 - 遇到了分隔符</p>
<p>两个函数的差别是处理分隔符的方式：get 将分隔符留作 istream 中的下一个字符，而 getline 则读取并丢弃分隔符。无论哪个函数都不会将分隔符保存在 sink 中。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>一个常见的错误是本想从流中删除分隔符，但却忘了做。 #+END_QUOTE **** 确定读取了多少个字符 某些操作从输入读取未知个数的字节。我们可以调用 gcount 来确定最后一个未格式化输入操作读取了多少个字符。应该在任何后续未格式化输入操作之前调用 gcount。特别是，将字符退回流的单字符操作也属于位格式化输入操作。如果在调用 gcount 之前调用了 peek、unget 或 puback，则 gcount 的返回值为 0。 *** 17.5.3 流随机访问 虽然标准库为所有流类型都定义了 seek 和 tell 函数，单它们是否会做有意义的事情依赖于流绑定到哪个设备。在大多数系统中，绑定到 cin、cout、cerr 和 clog 的流不支持随机访问——毕竟，当我们向 cout 直接输出数据时，类似向回跳十个尾值这种操作是没有意义的。对这些流我们可以调用 seek 和 tell 函数，单在运行时会出错，将流置于一个无效状态。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>由于 istream 和 ostream 类型通常不支持随机访问，所以本节剩余内容只用于 fstream 和 sstream 类型。 #+END_QUOTE **** seek 和 tell 函数 为了支持随机访问，IO 类型维护一个标记来确定下一个读写操作要在哪里进行。它们还提供了两个函数：一个函数通过将标记 seek 到一个给定位置来重新定位它；另一个函数 tell 我们标记的当前位置。标准库实际上定义了两对 seek 和 tell 函数，如下表所示。一对用于输入流，另一对用于输出流。输入和输出版本的差别在于名字的后缀是 g 还是 p。g 版本表示我们正在“获取”（读取）数据，而 p 版本表示我们正在“放置”（写入）数据。</p>
<p>#+CAPTION: seek 和 tell 函数 | tellg() | 返回一个输入流中（tellg）或输出流中（tellp）标记的当前位置 | | tellp() | | | seekg(pos) | 在一个输入流或输出流中将标记重定位到给定的绝对地址。pos 通常是前一个 tellg 或 tellp 返回的值 | | seekp(pos) | | | seekp(off, from) | 在一个输入流或输出流中将标记定位到 from 之前或之后 off 个字符，from 可能是下列值之一 | | | - beg，偏移量相对于流开始位置 | | | - cur，偏移量相对于流当前位置 | | | - end，偏移量相对于流结尾位置 | **** 只有一个标记 标准库区分 seek 和 tell 函数的“放置”和“获得”版本这一特性可能会导致误解，即使标准库进行了区分，但它在一个流中只维护单一的标记——并不存在独立的读标记和写标记。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>由于只有单一的标记，因此只要我们在读写操作间切换，就必须进行 seek 操作来重定位标记。 #+END_QUOTE * 第 18 章 用于大型程序的工具 与仅需几个程序员就能开发完成的系统相比，大规模编程对程序设计语言的要求更高。大规模应用程序的特殊要求包括： - 在独立开发的子系统之间协同处理错误的能力。 - 使用各种库（可能包含独立开发的库）进行协同开发的能力。 - 对比较复杂的应用概念建模的能力。</p>
<p>本章介绍的三种 C++语言特性正好满足上述要求，它们是：异常处理、命名空间和多重继承。 ** 18.1 异常处理 <em>异常处理</em> 机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。异常时的我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。检测环节无序知道问题处理模板的所以细节，反之亦然。 *** 18.1.1 抛出异常 在 C++语言中，我们通过 <em>抛出</em> 一条表达式来 <em>引发</em> 一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段 <em>处理代码</em> 将被用来处理该异常。被选中的处理代码是在调用链中 与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么错误。</p>
<p>当执行一个 throw 时，跟在 throw 后面的语句将不再被执行。相反，程序的控制权从 throw 转移到与之匹配的 catch 模块。该 catch 可能时同一个函数的局部 catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个重要的含义： - 沿着调用链的函数可能会提早退出。 - 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁</p>
<p>因为跟在 throw 后面的语句将不再被执行，所以 throw 语句的用法有点类型于 return 语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。 **** 栈展开 当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的 catch 子句。当 throw 出现在一个 <em>try 语句块</em> 内时，检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch，就使用该 catch 处理异常。如果这一步没找到匹配的 catch 且该 try 语句嵌套在其他 try 块中，则继续检查与外层 try 匹配的 catch 语句。如果还是找不到匹配的 catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找。</p>
<p>如果对抛出异常的函数的调用语句位于一个 try 语句块内，则检查与该 try 块关联的 catch 子句。如果找到了匹配的 catch，就使用该 catch 处理异常。否则，如果该 try 语句嵌套在其他 try 块中，则继续检查与外层 try 匹配的 catch 子句。如果仍然没有找到匹配的 catch，则退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。</p>
<p>上述过程被称为 <em>栈展开</em> 过程。栈展开过程沿着嵌套函数的调用链不断查找，知道找到了与异常匹配的 catch 子句为止；或者也可能一直没有找到匹配的 catch，则退出主函数后查找过程终止。</p>
<p>假设找到了一个匹配的 catch 子句，则程序进入该子句并执行其中的代码。当执行完这个 catch 子句后，找到与 try 块关联的最后一个 catch 子句之后的点，并从这里继续执行。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>一个异常如果没有被捕获，则它将终止当前的程序。 #+END_QUOTE **** 栈展开过程中对象被自动销毁 在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下， 程序在这些块中创建了一些局部对象。我们已经知道，块退出后它的局部对象也随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。如果某个局部对象的类型是类类型，则该对象的析构函数函数被自动调用。与往常一样，编译器在销毁内置类型时不需要做任何事情。</p>
<p>如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始化了，而另外一些成员在异常发生前也许还有没有初始化。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。</p>
<p>类似的，异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似，如果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。 **** 析构函数与异常 析构函数总是会被执行的，但是函数中负责释放资源的代码却可能被跳过，这一特点对于我们如何组织程序结构有重要影响。如我们在 12.1.4 节介绍过的，如果一个块分配资源，并且在负责释放这些资源的代码前面发生了异常，则释放资源的代码将不会被执行。另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们适用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。</p>
<p>析构函数在栈展开的过程中执行，这一事实影响着我们编写析构函数的方式。在栈展开的过程中，已经引发了异常但是我们还没有处理它。如果异常抛出后没有被正确捕获，则系统将调用 terminate 函数。因此，出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个 try 语句块当中，并且在析构函数内部得到处理。</p>
<p>在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所有标准库类型都能确保它们的析构函数不会引发异常。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。 #+END_QUOTE **** 异常对象 <em>异常对象</em> 是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，throw 语句中的表达式必须拥有完全类型（参见 7.3.3 节）。而且如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对象的指针类型。</p>
<p>异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个 catch 子句都能访问该空间。当异常处理完毕后，异常对象被销毁。</p>
<p>如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向局部对象的指针几乎肯定是一种错误的行为。出于同样的原因，从函数中返回指向局部对象的指针也是错误的（参见 6.3.2 节）。如果指针所指向的对象位于某个块中，而该块在 catch 语句之前就已经退出了，则意味着在执行 catch 语句之前局部对象已经被销毁了。</p>
<p>当我们抛出一条表达式时，该表达式的静态编译时类型（参见 15.2.3 节）决定了异常对象的类型。读者必须牢记这一点，因为很多情况下程序抛出的表达式类型来自于某个继承体系。如果一条 throw 表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分（参见 15.2.3 节），只有基类部分被抛出。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>抛出指针要求在任何对应的处理代码存在的地方，指针所指向的对象都必须存在。 #+END_QUOTE *** 18.1.2 捕获异常 <em>catch 子句</em> 中的 <em>异常声明</em> 看起来像是只包含一个形参的函数形参列表。像在形参列表中，如果 catch 无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p>
<p>声明的类型决定处理代码所能捕获的异常类型。这个类型必须是完全类型（参见 7.3.3 节），它可以是左值引用，但不能是右值引用（参见 13.6.1 节）。</p>
<p>当进入一个 catch 语句后，通过异常对象初始化异常声明中的参数。和函数的参数类型。如果 catch 的参数类型是非引用类型，则该参数是异常对象的一个副本，在 catch 语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。</p>
<p>catch 的参数还有一个特性也与函数的参数非常类似：如果 catch 的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果 catch 的参数是非引用类型，则异常对象将被切掉一部分（参见 15.2.3 节），这与将派生类对象以值传递的方式传给一个普通函数差不多。另一方面，如果 catch 的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。</p>
<p>最后一点需要注意的是，异常声明的静态类型将决定 catch 语句所能执行的操作。如果 catch 的参数是基类类型，则 catch 无法使用派生类特有的任何成员。</p>
<p>#+BEGIN_QUOTE Best Practies：</p>
<p>通常情况下，如果 catch 接受的异常与某个继承体系有关，则最好将该 catch 的参数定义成引用类型。 #+END_QUOTE **** 查找匹配的处理代码 在搜寻 catch 语句的过程中，我们最终找到的 catch 未毕是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的 catch 语句。因此，越是专门的 catch 越应该置于整个 catch 列表的前端。</p>
<p>因为 catch 语句是按照出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对 catch 语句的顺序进行组织和管理，使得派生类异常的处理代码出现在基类异常的处理代码之前。</p>
<p>与实参和形参的匹配规则相比，异常和 catch 异常声明的规则受到更多显值。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和 catch 声明的类型时精确匹配的： - 允许从非常量向常量的类型转换，也就是说，一条非常量对象的 throw 语句可以匹配一个接受常量引用的 catch 语句。 - 允许从派生类向基类的类型转换。 - 数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。</p>
<p>除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配 catch 的过程中使用。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果在多个 catch 语句的类型之间存在着继承关系，则我们应该把继承链最底端的类（most derived type）放在前面，而将继承链最顶端的类（least derived type）放在后面。 #+END_QUOTE **** 重新抛出 有时，一个断读的 catch 语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的 catch 可能会决定由调用链更上一层的函数接着处理异常。一条 catch 语句通过 <em>重新抛出</em> 的操作将异常传递给另外一个 catch 语句。这里的重新抛出仍然是一条 throw 语句，只不过不包含任何表达式：</p>
<p><sub>throw;</sub></p>
<p>空的 throw 语句只能出现在 catch 语句或 catch 语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空的 throw 一句，编译器将直接调用 terminate。</p>
<p>一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。</p>
<p>很多时候，catch 语句会改变其参数的内容。如果在改变了参数的内容后 catch 语句重新抛出异常，则只有当 catch 异常声明是引用类型时我们对参数所作的改变才会被保留并继续传播。 **** 捕获所有异常的处理代码 有时我们希望不论抛出的异常时什么类型，程序都能统一捕获它们。要想捕获所有可能的异常时比较有难度的，毕竟有些情况下我们也不知道异常的类型到底是什么。即使我们知道所有的异常类型，也很难为所有类型提供唯一一个 catch 语句。为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为 <em>捕获所有异常</em> 的代码，行如 catch(…)。一条捕获所有异常的语句可以与任意类型的异常匹配。</p>
<p>catch(…)通常与重新抛出语句一起是一噢嗯，其中 catch 执行当前局部能完成的工作，随后重新抛出异常。</p>
<p>catch(…)既能单独出现，也能与其他几个 catch 语句一起出现。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果 catch(…)与其他几个 catch 语句一起出现，则 catch(…)必须在最后的位置。出现在捕获所有异常语句后面的 catch 语句将永远不会被匹配。 #+END_QUOTE *** 18.1.3 函数 try 语句块和构造函数 通常情况下，程序执行的任何时刻都可能发生异常，特别时异常可能发生在处理构造函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的 try 语句块还未生效，所以构造函数体内的 catch 语句无法处构造函数初始值列表抛出的异常。</p>
<p>要想处理构造函数初始值抛出的异常，我们必须将构造函数写成 <em>函数 try 语句块</em> （也称为函数测试块，function try block）的形式，函数 try 语句块使得一组 catch 语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。举个例子，我们可以把 Blob 的构造函数（参见 16.1.2 节）置于一个函数 try 语句块中：</p>
<p>#+BEGIN_SRC C++ template <typename T> Blob<T>::Blob(std::initializer_list<T> il) try : data(std::make_shared&lt;std::vector<T>&gt;(il)) { /* 空函数体 */ } catch(const std::bad_alloc &amp;e) { handle_out_of_memory(e); } #+END_SRC</p>
<p>注意：关键字 try 出现在表示构造函数初始值列表的冒号以及表示构造函数体（此例为空）的花括号之前。这个 try 关联的 catch 既然处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。</p>
<p>还有一种情况值得读者注意，在初始化构造函数的参数时也可能发生异常，这样的异常不属于函数 try 语句块的一部分。函数 try 语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常，则该异常属于调用表达式的一部分，并在调用者所在的上下文中处理。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>处理构造函数初始值异常的唯一方法是将构造函数写成函数 try 语句块。 #+END_QUOTE *** 18.1.4 noexcept 异常说明 对于用户及编译器来说，预先知道某个函数不会抛出异常显然大有裨益。首先，知道函数不会抛出异常有助于简化调用该函数的代码；其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。</p>
<p>在 C++11 新标准，我们可以通过提供 <em>noexcept 说明</em> 指定某个函数不会抛出异常。其形式是关键字 noexcept 紧跟在函数的参数列表后面，用以标识该函数不会抛出异常：</p>
<p>#+BEGIN_SRC C++ void recoup(int) noexcept; // 不会抛出异常 void alloc(int); // 可能抛出异常 #+END_SRC</p>
<p>对于一个函数来说，noexcept 说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型（参见 6.3.3 节）之前。我们也可以在函数指针的声明和定义中指定 noexcept。在 typedef 或类型别名中则不能出现 noexcept。在成员函数中，noexcept 说明符需要跟在 const 及引用限定符之后，而在 final、override 或虚函数的=0 之前。 **** 违反异常说明 读者需要清楚的一个事实是编译器并不会在编译时检查 noexcept 说明。实际上，如果一个函数在说明了 noexcept 的同时又含有 throw 语句或者调用了可能抛出异常的其他函数，编译器将瞬息编译通过，并不会因为这种违反异常说明的情况而报错（不排除个别编译器会对这种用法提出警告）。</p>
<p>因此可能出现这样一种情况：尽管函数声明说明它不会抛出异常，但实际上还是抛出了。一旦一个 noexcept 函数抛出了异常，程序就会嗲用 terminate 以确保遵守不在运行时抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此 noexcept 可以用在两种情况下：一是我们确认函数不会抛出异常，而是我们根本不知道该如何处理异常。</p>
<p>指明某个函数不会抛出异常可以令函数的调用者不必再考虑如何处理异常。无论是函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>通常情况下，编译器不能也不必在编译时验证异常说明。 #+END_QUOTE **** 异常说明的实参 noexcept 说明符接受一个可选的实参，该实参必须能转换为 bool 类型；如果实参是 true，则函数不会抛出异常；如果实参是 false，则函数可能抛出异常：</p>
<p>#+BEGIN_SRC C++ void recoup(int) noexcept(true); // recoup不会抛出异常 void alloc(int) noexcept(false); // alloc可能抛出异常 #+END_SRC **** noexcept 运算符 noexcept 说符命的实参常常与 <em>noexcept 运算符</em> 混合使用。noexcept 运算符是一个一元运算符，它的返回值是一个 bool 类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和 sizeof 类型，noexcept 也不会求其运算对象的值。</p>
<p><sub>noexcept(e)</sub></p>
<p>当 e 调用的所有函数都做了不抛出说明且 e 本身不含有 throw 语句时，上述表达式为 true；否则 noexcept(e)返回 false。</p>
<p>我们可以使用 noexcept 运算符得到如下的异常说明：</p>
<p>~void f() noexcept(noexcept(g())); // f和g的异常说明一致~</p>
<p>如果函数 g 承诺了不会抛出异常，则 f 也不会抛出异常；如果 g 没有异常说明符，或者 g 虽然有异常说明符但是允许抛出异常，则 f 也可能抛出异常。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>noexcept 有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为 noexcept 异常说明的 bool 实参出现时，它是一个运算符。 #+END_QUOTE **** 异常说明与指针、虚函数和拷贝控制 尽管 noexcept 说明符不属于函数类型的一部分，但是函数的异常说明仍然会影响函数的使用。</p>
<p>函数指针及该指针所指的函数必须具有一致的异常说明。也就说，如果我们为某个指针做出了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明指针可能抛出异常，则该指针可以指向任何函数，即使时承诺了不抛出异常的函数也可以：</p>
<p>#+BEGIN_SRC C++ // recoup和pf1都承诺不会抛出异常 void (<em>pf1)(int) noexcept = recoup; // 正确：recoup不会抛出异常，pf2可能抛出异常，二者之间互不干扰 void (</em>pf2)(int) = recoup;</p>
<p>pf1 = alloc; // 错误：alloc可能抛出一次样，但是pf1已经说明了它不会抛出异常 pf2 = alloc; // 正确：pf2和alloc都可能抛出异常 #+END_SRC</p>
<p>如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出一次样，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常。</p>
<p>当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是 noexcept 的。如果合成成员调用的任意一个函数可能抛出异常，则合成的成员是 noexcept(false)。而且，如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。 *** 18.1.5 异常类层次 标准库异常类（参见 5.6.3 节）构成了图的继承体系。</p>
<p>#+CAPTION: 标准 exception 类层次 [[file:../../../pics/C++/exception.png]]</p>
<p>类型 exception 仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为 what 的虚成员。其中 what 函数返回一个 const char*，该指针指向一个以 NULL 结尾的字符数组，并且确保不会抛出任何异常。</p>
<p>类 exception、bad_cast 和 bad_alloc 定义了默认构造函数。类 runtime_error 和 logic_error 没有默认构造函数，但是有一个可以接受 C 风格字符串或标准库 string 类型实参的构造函数，这些实参负责提供关于错误的更多信息。在这些类中，what 负责返回用于初始化异常对象的信息。因为 what 是虚函数，所以当我们捕获基类的引用时，对 what 函数的调用将执行与异常对象动态类型对应的版本。 ** 18.2 命名空间 大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。当应用程序用到多个供应商提供的库时，不可避免地会发生某些名字相互冲突地情况。多个库将名字放置在全局命名空间将引发 <em>命名空间污染</em> 。</p>
<p><em>命名空间</em> 为防止名字冲突提供了更加可控地机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某搞个命名空间中定义库地名字，库的作者（以及用户）可以避免全局名字固有地限制。 *** 18.2.1 命名空间定义 一个命名空间地定义包含两部分：首先是关键字 namespace，随后是命名空间名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中地声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。</p>
<p>和其他名字一样，命名空间地名字也必须在定义它地作用域内保持唯一。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类地内部。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>命名空间作用域后无须分号。 #+END_QUOTE **** 每个命名空间都是一个作用域 和其他作用域类似，命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。</p>
<p>定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间。 **** 命名空间可以不是连续的 如我们在 16.5 节介绍过的，命名空间可以定义在几个不同的部分，这一点与其他作用域不太一样。编写如下的命名空间定义：</p>
<p>#+BEGIN_SRC C++ namespace nsp { // 相关声明 } #+END_SRC</p>
<p>可能定义了一个名为 nsp 的新命名空间，也可能是为已经存在的命名空间添加一些新成员。如果之前没有名为 nsp 的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间并为其添加一些新成员的声明。</p>
<p>命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式： - 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件被包含在在使用了这些成员的文件中。 - 命名空间成员的定义部分则置于另外的源文件中。</p>
<p>在程序中某些实体只能哪定义一次：如非内联函数、静态函数成员、变量等，命名空间中定义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他其名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明。</p>
<p>#+BEGIN_QUOTE Best Practies：</p>
<p>定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型（或关联类型构成的集合）。 #+END_QUOTE **** 定义命名空间成员 #+BEGIN_SRC C++ #include “Sales_data.h” namespace cplusplus_primer { // 重新打开命名空间cplusplus_primer // 命名空间中定义的成员可以直接使用名字，此时无须qi前缀 std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Sales_data&amp; s) { /* … */ } } #+END_SRC</p>
<p>也可以在命名空间定义的外部定义该命名空间的成员。命名空间对于名字的声明必须在做作用域内，同时该名字的定义需要明确指出其所属的命名空间：</p>
<p>#+BEGIN_SRC C++ // 命名空间之外定义的成员必须使用含有前缀的名字 cplusplus_primer::Sales_data cplusplus_primer::operator+(const Sales_data&amp; lhs, const Sales_data&amp; rhs) { Sales_data ret(lhs); // … } #+END_SRC</p>
<p>和定义在类外部的类成员一样，一旦看到含有完整前缀的名字，我们就可以确定该名字位于命名空间的作用域内。</p>
<p>即宽命名空间的成员可以定义在命名空间外部，但这样的定义必须出现在所述命名空间的外层。 **** 模板特例化 模板特例化必须定义在原始模板所属的命名空间中（参见 16.5 节）。和其他其命名空间名字类似，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了：</p>
<p>#+BEGIN_SRC C++ // 我们必须将模板特例化声明成std的成员 namespace std { template &lt;&gt; struct hash<Sales_data>; } // 在std中添加了模板特例化的声明后，就可以在命名空间std的外部定义它了 template &lt;&gt; struct::hash<Sales_data> { size_t operator()(const Sales_data&amp; s) const { return hash<string>()(s.bookNo) ^ hash<unsigned>()(s.units_sold) ^ hash<double>()(s.revenue); } // 其他成员与之前的版本一致 } } #+END_SRC **** 全局命名空间 全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在 <em>全局命名空间</em> 中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。</p>
<p>作用域运算符同样可以用于全局作用域地成员，因为全局作用域是隐式地，所以它并没有名字。下面地形式</p>
<p><sub>::member_name</sub></p>
<p>表示全局命名空间中的一个成员。 **** 内联命名空间 C++11 新标准引入了一种新的嵌套命名空间，称为 <em>内联命名空间</em> 和普通的嵌套命名空间不同。内联命名空间中的名字可以被外层命名空间直接使用。</p>
<p>定义内联命名空间的方式是在关键字 namespace 前添加关键字 inline。</p>
<p>关键字 inline 必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写 inline，也可以不写。</p>
<p>当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。例如，我们可以把本书当前的所有代码都放在一个内联命名空间中，而之前版本的代码都放在一个非内联命名空间中：</p>
<p>#+BEGIN_SRC C++ namespace FourthEd { class Item_base { /* … <em>/ }; class Query_base { /</em> … */ }; // 本书第4版用到的其他代码 } #+END_SRC</p>
<p>命名空间 cplusplus_primer 将同时使用这两个命名空间。例如，假定每个命名空间都定义在同名的头文件中，则我们可以把命名空间 cplusplus_peimer 定义成如下形式：</p>
<p>#+BEGIN_SRC C++ namespace cplusplus_primer { #include “FifthEd.h” #include “FourthEd.h” } #+END_SRC</p>
<p>因为 FifthEd 是内联的，所以形如 cplusplus_primer::的代码可以直接获得 FifthEd 的成员。如果我们想使用早期版本的代码，则必须像其他其嵌套的命名空间一样加上完整的外层命名空间名字，比如 cplusplus_perimer::FourthEd::Query_base。 **** 未命名的命名空间 <em>未命名的命名空间</em> 是指关键字 namespace 后紧跟花括号括起来的一些列 g 神明语句。未命名的命名空间中定义的变量拥有静态声明周期：它们在第一次使用前创建，并且直到程序结束才销毁。</p>
<p>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该文件的文件中对应不同实体。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。 #+END_QUOTE</p>
<p>定义在未命名的命名空间中的名字可以直接使用，毕竟我们找不到什么命名空间的名字来限定它们；同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。</p>
<p>未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别：</p>
<p>#+BEGIN_SRC C++ int i; // i的全局声明 namespace { ini i; // 二义性：i的定义既出现在全局作用域中，又出现在未嵌套的的未命名的命名空间中 i = 10; } #+END_SRC</p>
<p>其他情况下，未命名的命名空间中的成员都属于正确的程序实体。和所有命名空间类似，一个未命名的命名空间也能嵌套在其他命名空间中。此时，未命名的 i 买嗯名空间中的成员可以通过外层命名空间的名字来访问：</p>
<p>#+BEGIN_SRC C++ namespace local { namespace { int i; } } // 正确：定义在嵌套的未命名的命名空间中的i与全局作用域中的i不同 local::i = 42; #+END_SRC</p>
<p>#+BEGIN_QUOTE 未命名的命名空间取代文件中的静态声明</p>
<p>在标准 C++引入命名空间的概念之前，程序需要将名字声明成 static 的以使得其对于整个文件有效。在文件中进行 <em>静态声明</em> 的做法是从 C 语言继承过来的。在 C 语言中，声明未 static 的全局实体在其所在的文件外不可见。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>在文件中进行静态声明的做法已经被 C++标准取消了，现在的做法是使用未命名的命名空间。 #+END_QUOTE *** 18.2.2 使用命名空间成员 **** 命名空间的别名 <em>命名空间的别名</em> 使得我们可以为命名空间的名字设定一个短得多的同义词。例如，一个很多的命名空间的名字形如</p>
<p>~namespace cplusplus_primer { /* … */ }~</p>
<p>我们可以为其设定一个短得多的同义词</p>
<p>~namespace primer = cplusplus_primer~</p>
<p>命名空间的别名声明以关键字 namespace 开始，后面是别名所用的名字，=符号、命名空间原来的名字以及一个分号。</p>
<p>命名空间的别名也可以指向一个嵌套的命名空间：</p>
<p>#+BEGIN_SRC C++ namespace Qlib = cplusplus_primer::QueryLib; Qlib::Query q; #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>一个命名空间可以有好几个同义词或别名，所有别名与命名空间原来的名字等价。 #+END_QUOTE **** using 声明：扼要概述 一条 <em>using 声明</em> 语句一次只引入命名空间的一个成员。它使得我们可以清楚地直到程序中所用的到底是哪个名字。</p>
<p>using 声明引入的名字遵守与过去一样的作用域规则：它的有效范围从 using 声明的地方开始，一直到 using 声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。未加限定的名字只能在 using 声明所在的作用域以及其内层作用域中使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。</p>
<p>一条 using 声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类作用域中。在类的作用域中，这样的声明语句只能指向基类成员（参见 15.5 节）。 **** using 指示 <em>using 指示</em> 和 using 声明类似的地方是，我们可以使用命名空间名字的简写形式：和 using 声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。</p>
<p>using 指示以关键字 using 开始，后面是关键 namespace 以及命名空间的名字。如果这里所用的名字不是一个已经定义好的命名空间的名字，则程序将发生错误。using 指示可以出现在全局作用域、局部作用域和命名空间作用域中，但时不能出现在类的作用域中。</p>
<p>using 指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从 using 指示开始，一直到 using 指示所在的作用结束都能使用。 **** 头文件与 using 声明或指示 头文件如果在其顶层作用域中含有 using 指示或 using 声明，则会将名字注入到所有包含了该头文件的文件中。通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用 using 指示或 using 声明（参见 3.1 节）。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>using 指示也并非一无是处，例如在命名空间本身的实现文件中就可以是一噢嗯 using 指示。 #+END_QUOTE *** 18.2.3 类、命名空间与作用域 **** 实参相关的查找与类类型参数 考虑西面这个简单的程序：</p>
<p>#+BEGIN_SRC C++ std::strign s; std::cin &gt;&gt; s; #+END_SRC</p>
<p>如我们所知，该调用等价于：</p>
<p>~operator&gt;&gt;(std::cin, s)~</p>
<p>operator&gt;&gt;函数定义在标准库 string 中，string 又定义在命名空间 std 中。但是我们不用 std::限定符和 using 声明就可以调用 operator&gt;&gt;。</p>
<p>对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以自号接访问输出运算符。这个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样有效。</p>
<p>在此例中，当编译器发现对 operator&gt;&gt;的调用时，首先在当前作用域中寻找合适的函数，接着查找输出语句的外层作用域作用域。随后，因为&gt;&gt;表达式的形参是类类型的，所以编译器还会查找 cin 和 s 的类所属的命名空间。也就是说，对于这个调用来说，编译器会查找定义了 istream 和 string 的命名空间 std。当在 std 中查找时，编译器找到了 string 的输出运算符函数。</p>
<p>查找规则的这个类外允许概念上作为类接口的一部分的非成员函数无须单独的 using 声明就能被程序使用。 **** 友元声明与实参相关的查找 回顾我们曾经讨论过的，当类声明了一个友元时，该有友元声明并没有使得友元本身可见（参见 7.2.1 节）。然而，一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员。这条规则与实参相关的查找规则结合在一起将产生意想不到的效果：</p>
<p>#+BEGIN_SRC C++ namespace A { class C { // 两个友元，在友元声明之外没有其他声明 // 这些函数隐式地成为命名空间A的成员 friend void f2(); // 除非另有声明，否则不会被找到 friend void f(const C&amp;); // 根据实参相关的查找规则可以被找到 }; } #+END_SRC</p>
<p>此时，f和 f2 都是命名空间 A 的成员。即使 f 不存在其他声明，我们也能通过实参相关的查找规则调用 f： ‘ #+BEGIN_SRC C++ int main() { A::C cobj; f(cobj); // 正确：通过在A::C中的友元声明找到A;;f f2(); // 错误：A::f2没有被声明 } #+END_SRC</p>
<p>因为 f 接受一个类类型的实参，而且 f 在 C 所属的命名空间进行了隐式的声明，所以 f 能被找到。相反，因为 f2 没有形参，所以它无法被找到。 *** 18.2.4 重载与命名空间 **** 与实参相关的查找与重载 在上一节中我们了解到，对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。我们将在每个实参类（以及实参类的基类）所属的命名空间中搜寻候选函数。在这些命名空间中所有被与调用函数同名的函数都将被添加到候选集中，即使其中某些函数在调用语句处不可见也是如此：</p>
<p>#+BEGIN_SRC C++ namespace NS { class Quoto { /* … <em>/ }; void display(const Quote&amp;) { /</em> … <em>/ } } // Bulk_item的基类声明在命名空间NS中 class Bulk_iitem : public NS:Quote { /</em> … */ }; int main() { Bulk_iitem book1; display(book1); return 0; } #+END_SRC</p>
<p>命名空间 NS 中声明的 display(const Quote&amp;)也将被添加到候选函数集中。 **** 重载与 using 声明 要想理解 using 声明与重载之间的交互关系，必须首先明确一条：using 声明语句声明的是一个名字，而非一个特定的函数：</p>
<p>#+BEGIN_SRC C++ using NS:print(int); // 错误：不能指定形参列表 using NS:print; // 正确：using声明只声明一个名字 #+END_SRC</p>
<p>当我们为函数书写 using 声明时，该函数的所有版本都被引入到当前作用域中。</p>
<p>一个 using 声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果 using 声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如果 using 声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如果 using 声明所在的作用域已经有一个函数与新引入的函数同名且形参列表相同，则该 using 声明将引发错误。除此之外，using 声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。 **** 重载与 using 指示 与 using 声明不同的时，对于 using 指示，引入一个已有函数形参列表完全相同的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可。 **** 跨越多个 using 指针的重载 如果存在多个 using 指示，则来自每个命名空间的名字都会称为候选函数集的一部分。 ** 18.3 多重继承与虚继承 <em>多重继承</em> 是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。 *** 18.3.1 多重继承 **** 多重继承的派生类从每个基类中继承状态 #+CAPTION: Panda 对象的概念结构 [[file:~/Documents/org/src/pics/C++/panda.png]] **** 派生类初始化所有基类 构造一个派生类的对象将同时构造并初始化它的所有基类子对象。与从一个基类进行派生一样，多重继承的派生类的构造函数初始值也只能初始化它的直接基类。</p>
<p>派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生类中基类的出现顺序保持一致，而与派生类构造函数初始值中的基类顺序无关。一个 Panda 对象按照如下顺序进行初始化： - ZooAnimal 是整个继承体系的最终基类，Bear 是 Panda 的直接基类，ZooAnimal 是 Bear 的基类，所以首先初始化 ZooAnimal。 - 接下来初始化 Panda 的第一个直接基类 Bear。 - 然后初始化 Panda 的第二个直接基类 Endangered。 - 最后初始化 Panda。 **** 继承的构造函数与多重继承 在 C++11 新标准中，允许派生类从它的一个或几个基类中继承构造函数（参见 15.7.4 节）。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同（），则程序产生错误：</p>
<p>#+BEGIN_SRC C++ struct Base1 { Base1() = default; Base1(const std::string&amp;); Base1(std::shared_ptr<int>); }; struct Base2 { Base2() = default; Base2(const std::string&amp;); Base2(int); }; // 错误：D1试图从两个基类中都继承D1::D1(const string&amp;) struct D1: public Base1, public Base2 { using Base1::Base1; // 从Base1继承构造函数 using Base12:Base2; // 从Base2继承构造函数 }; #+END_SRC</p>
<p>如果一个类从它的多个基类中即成了相同的构造函数，则这个类必须为该构造函数定义自己的版本：</p>
<p>#+BEGIN_SRC C++ struct D2: public Base1, public Base2 { using Base1::Base1; // 从Base1继承构造函数 using Base2::base2; // 从Base2继承构造函数 // D2必须自定义一个接受string的构造函数 D2(const string &amp;s) : Base1(s), Base2(s) { } D2() = default; // 一旦D2定义了它自己的构造函数，则必然出现 }; #+END_SRC **** 析构函数与多重继承 和往常一样，派生类的析构函数只负责清楚派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。</p>
<p>析构函数的调用顺序与构造函数相反，在我们的例子中，析构函数的调用顺序是<sub>Panda、</sub>Endangered、~Bear 和~ZooAnimal。 **** 多重继承和派生类的拷贝与移动操作 与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作（参见 15.7.2 节）。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作。在合成的拷贝控制成员中，买个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作。 *** 18.3.2 类型转换与多个基类 在只有一个基类的情况下，派生类的指针或引用能自动转换成一个可访问基类的指针或引用。多个基类的情况与之类似。我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。</p>
<p>编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任何一种基类都一样好。 **** 基类指针类型或引用类型的查找 与只有一个基类的继承一样，对象、指针和引用的静态类型决定我们能够使用哪些成员。 *** 18.3.3 多重继承下的类作用域 在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中（参见 15.6 节）。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。</p>
<p>在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。</p>
<p>对于一个派生类，从它的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出它的版本。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。 #+END_QUOTE *** 18.3.4 虚继承 尽管在派生类列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过在它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。</p>
<p>在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。</p>
<p>在 C++语言中我们通过 <em>虚继承</em> 的机制解决上述问题。虚继承的目的是令某搞个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为 <em>虚基类</em> 。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。 #+END_QUOTE **** 使用虚基类 我们指定虚基类的方式是在派生列表中添加关键字 virtual：</p>
<p>#+BEGIN_SRC C++ // 关键字public和virtual的顺序随意 class Raccoon : public virtual ZoonAnimal { /* … <em>/ }; class Bear : virtual public ZooAnimal { /</em> … */ }; #+END_SRC</p>
<p>通过上面的代码我们将 ZooAnimal 定义为 Raccoon 和 Bear 的虚基类。</p>
<p>virtual 说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。置于什么样的类能够作为虚基类并没有特殊规定。</p>
<p>如果某个类指定了虚基类，则该类的派生仍按常规方式进行：</p>
<p>#+BEGIN_SRC C++ class Panda : public Bear, public Raccoon, public Endangered { }; #+END_SRC</p>
<p>Panda 通过 Raccoon 和 Bear 继承了 ZooAnimal，因为 Raccoon 和 Bear 继承 ZooAnimal 的方式都是虚继承，所以在 Panda 中只有一个 ZooAnimal 基类部分。 **** 支持向基类的常规类型转换 不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。 **** 虚基类成员的可见行 因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并不会产生二义性。此外，如果虚基类的成员只被一条派生路径负该，则我们仍然可以直接访问这个被覆盖的成员。但是如果成员被多余一个虚类覆盖，则一半情况下派生类必须为该成员自定义一个新的版本。</p>
<p>例如，假定类 B 定义了一个名为 X 的成员，D1 和 D2 都是从 B 虚继承得到的，D继承了 D1 和 D2，则在 D 的作用域中，X通过 D 的两个基类都是可见的。如果我们通过 D 的对象使用了 X，有三种可能性： - 如果在 D1 和 D2 中都没有 X 的定义，则 X 将被解析为 B 的成员，此时不存在二义性，一个 D 的对象只含有 X 的一个实例。 - 如果 X 是 B 的成员，同时是 D1 和 D2 中某一个的成员，则同样没有二义性，派生类的 X 比共享虚基类 B 和 X 的优先级更高。 - 如果在 D1 和 D2 中都有 X 的定义，则直接访问 X 将产生二义性问题。</p>
<p>与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自动以新的实例。 *** 18.3.5 构造函数与虚继承 在虚派生中，虚基类是由最低层的派生类初始化的。以我们的程序为例，当创建 Panda 对象时，由 Panda 的构造函数独自控制 ZooAnimal 的初始化过程。</p>
<p>为了理解这一规则，我们不妨假设当以普通规则处理初始化任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以 ZooAnimal 为例，如果应用普通规则，则 Raccoon 和 Bear 都会试图初始化 Panda 对象的 ZooAnimal 部分。</p>
<p>当然，继承体系中的每个类都可能在某个时刻称为“最低层的派生类”。只要我们能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。 **** 虚继承的对象的构造方式 含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接虚类在派生列表中出现的次序一次对其进行初始化。</p>
<p>例如，当我们创建一个 Panda 对象时： - 首先使用 Panda 的构造函数初始值列表中提供的初始值构造虚基类 ZooAnimal 部分。 - 接下来构造 Bear 部分。 - 然后构造 Raccoon 部分。 - 然后构造第三个直接基类 Endangered。 - 最后构造 Panda 部分</p>
<p>如果 Panda 没有显示地初始化 ZooAnimal 基类，则 ZooAnimal 的默认构造函数被调用。如果 ZooAnimal 没有默认构造函数，则代码将发生错误。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。 #+END_QUOTE **** 构造函数与析构函数的次序 一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。</p>
<p>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。</p>
<p>合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象 d 额销毁顺序与构造顺序正好相反。 * 第 19 章 特殊工具与技术 ** 19.1 控制内存分配 *** 19.1.1 重载 new 和 delete 要想真正掌握 new 和 delete 的方法，首先要对 new 表达式和 delete 表达式的工作机理有更多了解。</p>
<p>当我们使用一条 new 表达式时，实际执行了三步操作。第一步，new 表达式调用一个名为 <em>operator new</em> （或者 <em>operator new[]</em> ）的标准库函数。该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象的数组）。第二步，编译器运行相应的构造函数以构造这些对象，并为其传入初始值。第三步，对象被分配了空间并构造完成，返回一个指向该对象的指针。</p>
<p>当我们使用一个条 delete 表达式删除一个动态分配的对象时：</p>
<p>#+BEGIN_SRC C++ delete sp; // 销毁*sp，然后释放sp指向的内存空间 delete [] arr; // 销毁数组中的元素，然后释放对应的内存空间 #+END_SRC</p>
<p>实际执行了两步操作。第一步，对 sp 所指的对象或者 arr 所指的数组中的元素执行对应的析构函数。第二部，编译器调用名为 <em>operator delete</em> （或者 <em>operator delete[]</em> ）的标准库函数释放内存空间。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>当自定义了全局的 operator new 函数和 operator delete 函数后，我们就担负起了控制动态内存分配的职责。这两个函数必须是正确的：因为它们是程序整个处理过程中至关重要的一部分。 #+END_QUOTE</p>
<p>应用程序可以在全局作用域中定义 operator new 函数和 operator delete 函数，也可以将他们定义为成员函数。当编译器发现一条 new 表达式或 delete 表达式后，将在程序中查找可供调用了 operator 函数。如果被分配（释放）的对象是类类型，则编译器首先在类及其基类的作用域中查找。此时如果该类含有 operator new 成员或 operator delete 成员，则相应的表达式将调用这些成员。否则，编译器在全局作用域查找匹配的函数。此时如果编译器找到了用户自定义的版本，则使用该版本执行 new 表达式或 delete 表达式；如果没有找到，则使用标准库函数定义的版本。 **** operator new 接口和 operator delete 接口 标准库定义了 operator new 函数和 operator delete 函数的 8 个重载版本。其中前 4 个版本可能抛出 bad_alloc 异常，后 4 个版本则不会抛出异常：</p>
<p>#+BEGIN_SRC C++ // 这些版本可能抛出异常 void <em>operator new(size_t); // 分配一个对象 void </em>operator new<a href="size_t"></a>; // 分配一个数组 void <em>operator delete(void</em>) noexcept; // 释放一个对象 void *operator delete<a href="void*"></a> noexcept; // 释放一个数组</p>
<p>// 这些版本承诺不会抛出异常，参见12.1.2节 void <em>operator new(size_t, nothrow_t&amp;) noexcept; void </em>operator new<a href="size_t,%20nothrow_t&amp;"></a> noexcept; void <em>operator delete(void</em>, nothrow_t&amp;) noexcept; void *operator delete<a href="void*,%20nothrow_t&amp;"></a> noexcept; #+END_SRC</p>
<p>类型 nothrow_t 是定义在 new 头文件中的一个 struct，这个类型中不包含任何成员。new 头文件还定义了一个名为 nothrow 的 const 对象，用户可以通过这个对象请求 new 的非抛出版本（参见 12.1.2 节）。与析构函数类似，operator delete 也不允许抛出异常（参见 18.1.1 节）。当我们重载这些运算符时，必须是一噢嗯 noexcept 异常说明符（参见 18.1.4 节）指定其不抛出异常。</p>
<p>应用程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于全局作用域或类作用域中。当我们将上述运算符函数定义成类的成员时，它们时隐式静态的（参见 7.6 节）。我们无须显示地声明 static，当然这么做也不会引发错误。因为 operator new 用在对象构造之前而 operator delete 用在对象销毁之后，所以这两个成员（new 和 delete）必须时静态的，而且它们不能操纵类的任何数据成员。</p>
<p>如果我们想要自定义 operator new 函数，则可以为它提供额外的形参。此时，用到这些自定义函数的 new 表达式必须使用 new 的定位形式（参见 12.1.2 节）将实参传递给新增的形参。尽管在一般情况下我们可以自定义具有任何形参的 operator new，但是下面这个函数却无论如何不能被用户重载：</p>
<p>~void <em>operator new(size_t, void</em>); // 不允许重新定义这个版本~</p>
<p>这种形式只供标准库使用，不能被用户重新定义。</p>
<p>当我们将 operator delete 或者 operator delete[]定义成类的成员时，该函数可以包含另外一个类型为 size_t 的形参。此时，该形参的初始值是第一个形参所指对象的字节数。size_t 形参可以用于删除继承体系中的对象。如果基类有一个虚析构函数（参见 15.7.1 节），则传递给 operator delete 的字节数将因待删除指针所指对象的动态类型不同而有所区别。而且，实际运行的 operator delete 函数版本也由对象的动态类型决定。 *** 19.1.2 定位 new 表达式 尽管 operator new 函数和 operator delete 函数一般用于 new 表达式，然而它们毕竟是标准库的两个普通函数，因此普通的代码也可以直接调用它们。</p>
<p>在 C++的早期版本中，allocator 类（参见 12.2.2 节）还不是标准库的一部分。应用程序如果想把内存分配与初始化分离开来的话，需要调用 operator new 和 operator delete。这两个函数的行为与 allocator 的 allocate 成员和 deallocate 成员非常类似，它们负责分配或释放内存空间，但是不会构造或销毁对象。</p>
<p>与 allocator 不同的是，对于 operator new 分配的内存空间来说我们无法使用 construct 函数构造对象。相反，我们应该使用 new 的 <em>定位 new</em> 形式（参见 12.1.2 节）构造对象。如我们所知，new 的这种形式为分配函数提供了额外的信息，我们可以使用定位 new 传递一个地址，此时定位 new 的形式如下所示：</p>
<p>#+BEGIN_EXAMPLE new (place_address) type new (place_address) type (initializers) new (place_address) type [size] new (place_address) type [size] { braced initializer list } #+END_EXAMPLE</p>
<p>其中 place_address 必须是一个指针，同时在 initializers 中提供一个（可能为空的）以逗号分配的初始值列表，该初始值列表将用于构造新分配的对象。</p>
<p>当仅通过一个地址值调用时，定位 new 使用 operator new(size_t, void*)“分配”它的内存。这是一个我们无法自定义的 operator new 版本（参见 19.1.1 节）。该函数不分配任何内存，它只是简单第返回指针实参；然后由 new 表达式负责在指定的地址初始化对象以完成整个工作。事实上，定位 new 允许我们在一个特定的、预先分配的内存地址上构造对象。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当只传入一个指针类型的实参时，定位 new 表达式构造对象但是不分配内存。 #+END_QUOTE</p>
<p>尽管在很多时候使用定位 new 与 allocator 的 construct 成员非常相似，但在它们之间也有一个重要的区别。我们传给 construct 的指针必须指向同一个 allocator 对象分配的空间，但是传给定位 new 的指针无须指向 operator new 分配的内存。实际上如我们将在 19.6 节介绍的，传给定位 new 表达式的指针甚至不需要指向动态内存。 **** 显示的析构函数调用 和调用 destroy 类似，调用析构函数可以清楚给定的对象但是不会释放该对象所在的空间。如果需要的话，我们可以重新使用该空间。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>调用析构阿訇所农户会销毁对象，但是不会释放内存。 #+END_QUOTE ** 19.2 运行时类型识别 <em>运行时类型识别（run-time type identification，RTTI）</em> 的功能由两个运算符实现： - typeid 运算符，用于返回表达式的类型。 - dynamic_cast 运算符，用于将基类的指针或引用安全第转换成派生类的指针或引用。</p>
<p>这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某搞个派生类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量是一噢嗯虚函数。当操作被定义成虚函数时，编译器将根据对象的地噢地嗯太类型自动地选择正确的函数版本。</p>
<p>然而，并非任何时候都能定义一个虚函数。假设我们无法使用虚函数，则可以使用一个 RTTI 运算符。另一方面，与虚成员函数相比，使用 RTTI 运算符蕴含着更多潜在的风险：程序员必须清楚地直到转换的目标类型并且检查类型转换是否被成功执行。 *** 19.2.1 dynamic_cast 运算符 <em>dynamic_cast 运算符</em> 的使用形式如下所示：</p>
<p>#+BEGIN_EXAMPLE dynamic_cast&lt;type*&gt;(e) dynamic_cast&lt;type&amp;&gt;(e) dynamic_cast&lt;type&amp;&amp;&gt;(e) #+END_EXAMPLE</p>
<p>其中，type 必须是一个类类型，并且通常情况下该类型应该含有虚函数。地一种形式中，e必须是一个有效的指针；在第二种形式中，e必须时一个左值；在第三种形式中，e不能是左值。</p>
<p>在上面的所有形式中，e的类型必须符合以下三个条件中的任意一个：e的类型是目标 type 的公有派生类、e的目标类型是 type 的公有基类或者 e 的类型就是目标 type 的类型。如果符合，则类型转换可以成功。否则，转换失败。如果一条 dynamic_cast 语句的转换目标是指针类型并且失败了，则结果为 0。如果转换目标是引用类型并且失败了，则 dynamic_cast 运算符将抛出一个 bad_cast 异常。 **** 指针类型的 dynamic_cast #+BEGIN_QUOTE Note：</p>
<p>我们可以对一个空指针执行 dynamic_cast，结果是所需类型的空指针。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE Best Practies：</p>
<p>在条件部分执行 dynmaic_cast 操作可以确保类型转换和结果检查在同一条表达式中完成。 #+END_QUOTE **** 引用类型的 dynamic_cast 引用类型的 dynamic_cast 与指针类型的 dynamic_cast 在表示错误发生的地方上略有不同。因为不存在所谓的空引用，所以对于引用类型来说无法使用与指针类型完全相同的错误报告策略。当对引用的类型转换失败时，程序抛出一个名为 std::bad_cast 的异常，该异常定义在 typeinfo 标准库头文件中。 *** 19.2.2 typeid 运算符 为 RTTI 提供的第二个运算符是 <em>typeid 运算符</em> ，它允许程序向表达式问：你的对象是什么类型？</p>
<p>typeid 表达式的形式是 typeid(e)，其中 e 可以是任意表达式或类型的名字。typeid 操作的结果是一个常量对象的引用，该对象的类型是标准库类型 type_info 或者 type_info 的公有派生类。type_info 类定义在 typeinfo 头文件中，19.2.4 节将介绍更多关于 type_info 的细节。</p>
<p>typeid 运算符可以作用于任意类型的表达式。和往常一样，顶层 const 被忽略，如果表达式是一个引用，则 typeid 返回该引用所引对象的类型。不过当 typeid 作用于数组或函数时，并不会执行向指针的标准类转换（参见 4.11.2 节）。也就是说，如果我们对数组 a 执行 typeid(a)，则所得到的结果是数组类型而非指针类型。</p>
<p>当运算符对象不属于类类型或者是一个不包含任何虚函数的类时，typeid 运算符指示的是运算对象的静态类型。而当运算对象是定义了至少一个虚函数的类的左值时，typeid 的结果直到运行时才会求得。 **** 使用 typeid 运算符 #+BEGIN_QUOTE WARNING：</p>
<p>当 typeid 作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。 #+END_QUOTE</p>
<p>typeid 是否需要运行时检查决定了表达式是否会被求值。只有当类型含有虚函数时，编译器才会对表达式求值。反之，如果类型不含有虚函数，则 typeid 返回表达式的静态类型；编译器无须对表达式求值也能直到表达式的静态类型。</p>
<p>如果表达式的动态类型可能与静态类型不同，则必须在运行时对表达式求值以确定返回的类型。这条规则适用于 typeid(<em>p)的情况。如果指针 p 所指的类型不含有虚函数，则 p 不必非得是一个有效的指针。否则，</em>p 将在运行时求值，此时 p 必须是一个有效的指针。如果 p 是一个空指针，则 typeid(<em>p)将抛出一个名为 bad_typeid 的异常。 </em>** 19.2.4 type_info 类 <em>type_info</em> 类的精确定义随着编译器的不同而略有差异。不过，C++标准规定 type_info 类必须定义在 typeinfo 头文件中，并且至少提供下表所列的操作。</p>
<p>#+CAPTION: type_info 的操作 | t1 == t2 | 如果 type_info 对象 t1 和 t2 表示同一种类型，则返回 true；否则返回 false | | t1 != t2 | 如果 type_info 对象 t1 和 t2 表示不同的类型，则返回 true；否则返回 false | | t.name() | 返回一个 C 风格字符串，表示类型名字的可打印形式。类型名字的生成方式因系统而异 | | t1.before(t2) | 返回一个 bool 值，表示 t1 是否位于 t2 之前。before 所再用的顺序关系依赖于编译器的 |</p>
<p>除此之外，因为 type_info 类一般是作为一个基类出现的，所以它还应该提供一个公有的虚析构函数。当编译器希望提供额外的类型信息时，通常在 type_info 的派生类中完成。</p>
<p>type_info 类没有默认构造函数，而且它的拷贝和移动构造函以及赋值运算符都是被定义成删除的。因此，我们无法定义或拷贝 type_info 类型的对象，也不能为 type_info 类型的对象赋值。创建 type_info 对象的唯一途径是使用 typeid 运算符。</p>
<p>type_info 类的 name 成员函数返回一个 C 风格字符串，表示对象的类型名字。对于某种给定的类型来说，name 的返回值因编译器而异并且不一定于程序中使用的名字一致。对于 name 返回值的唯一要求是，类型不同则返回的字符串必须有所区别。 ** 19.3 枚举类型 <em>枚举类型</em> 使我们可以将一组整型常量组织在一起。和类一样，每个枚举类型定义了一种新的类型。枚举隶属于字面值常量类型（参见 7.5.6 节）。</p>
<p>C++包括两种枚举：限定作用域和不限定作用域的。C++11 新标准引入了 <em>限定作用域的枚举类型</em> 。定义限定作用域的枚举类型的一般形式是：首先是关键字 enum class（或者等价地使用 enum struct），随后是枚举类型名字以及用花括号括起来的以逗号分隔的 <em>枚举成员</em> 列表，最后是一个分号：</p>
<p>~enum class open_modes (input, output, append);~</p>
<p>定义 <em>不限于作用域的枚举类型</em> 时省略掉关键字 class（或 struct），枚举类型的名字是可选的：</p>
<p>#+BEGIN_SRC C++ enum color {red, yellow, green}; // 不限定作用域的枚举类型 // 未命名的，不限定作用域的枚举类型 enum {floatPrec = 6, doublePrec = 10, double_doublePrec = 10}; #+END_SRC</p>
<p>如果 enum 是未命名的，则我们只能在定义该 enum 时定义它的对象。和类的定义类似，我们需要在 enum 定义的右侧花括号和最后的分号之间提供逗号分隔的声明列表（参见 2.6.1 节）。 **** 枚举成员 在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域准则，并且在枚举类的作用域外是不可访问的。与之相反，在不限定作用域的枚举类型中，枚举成员的作用域于枚举本身的作用域相同：</p>
<p>#+BEGIN_SRC C++ enum color {red, yellow, green}; // 不限定作用域的枚举类型 enum stoplight {red, yellow, green}; // 错误：重复定义了枚举成员 enum class peppers {red, yellow, green}; // 正确：枚举成员被隐藏了 color eyes = green; // 正确：不限定作用域的枚举类型的枚举成员位于有效的作用域中 peppers p = green; // 错误：preppers的枚举成员不在有效的作用域中 // color::green在有效的作用域中，但是类型错误 color hair = color::red; // 正确：允许显式地访问枚举成员 peppers p2 = peppers::red; // 正确：使用pappers的red #+END_SRC</p>
<p>默认情况下，枚举值从 0 开始，依次加 1。不过我们也能未一个或几个枚举成员指定专门的值：</p>
<p>#+BEGIN_SRC C++ enum class intTypes { charTyp = 8, shortTyp = 16, intTyp = 16, longTyp = 32, long_longTyp = 64; }; #+END_SRC 由枚举成员 intTyp 和 shortTyp 可知，枚举值不一定唯一。如果我们没有显示地提供初始值，则当前枚举成员的值等于之前枚举成员的值加 1.</p>
<p>枚举成员是 const，因此在初始化枚举成员时提供的初始值必须是常量表达式（参见 2.4.4 节）。也就是说，每个枚举成员本身就是一条常量表达式，我们可以在任何需要常量表达式的地方使用枚举成员。例如，我们可以定义枚举类型的 constexpr 变量：</p>
<p>~constexpr intTypes charbits = intTypes::charTyp;~</p>
<p>类似的，我们也可以将一个 enum 作为 switch 语句的表达式，而将枚举值作为 case 标签。出于同样的原因，我们还能将枚举类型作为一个非类型模板形参使用（参见 16.1.1 节）；或者在类的定义中初始化枚举类型的静态数据成员（参见 7.6 节）。</p>
<p>**** 和类一样，枚举也定义新的类型</p>
<p>只要 enum 有名字，我们就能定义并初始化该类型的成员。要想初始化 enum 对象或者未 enum 对象赋值，必须使用该了西 ingde 一个枚举成员或者该类型的另一个对象：</p>
<p>#+BEGIN_SRC C++ open_modes om = 2; // 错误：2不属于类型open_modues om = open_modes::input; // 正确：input是open_modes的一个枚举成员 #+END_SRC</p>
<p>一个不限定作用域的枚举类型的对象或枚举成员自动地转换成整型。因此，我们可以在任何需要整型值的地方使用它们：</p>
<p>#+BEGIN_SRC C++ int i = color::red; // 正确：不限定作用域的枚举类型的枚举成员隐式地转换成int int j = peppers::red; // 错误：限定作用域地枚举类型不会进行隐式转换 #+END_SRC **** 指定 enum 的大小 尽管每个 enum 都定义了唯一的类型，但实际上 enum 是由某种整数类型表示的。在 C++11 新标准中，我们可以在 enum 的名字后面加上冒号以及我们想在该 enum 中使用的类型：</p>
<p>#+BEGIN_SRC C++ enum intValues : unsigned long long { charTyp = 255, shortType = 65535, intTyp = 65535, longTyp = 4294967295UL, long_longTyp = 18446744073709551615ULL }; #+END_SRC</p>
<p>如果我们没有指定 enum 的潜在类型，则默认情况下限定作用域的 enum 成员是 int，对于不限定作用域的枚举类型来说，其枚举成员不存在默认类型，我们只知道成员的潜在类型足够大，肯定能容纳枚举值。如果我们指定了枚举值的潜在类型（包括对限定作用域的 enum 的隐式指定），则一旦某个枚举成员的值超出了该类型所能容纳的范围，将引发程序错误。</p>
<p>指定 enum 潜在类型的能力时的我们可以控制不同实现环境中使用的类型，我们将可以确保在一种实现环境中编译桶鼓噢的程序所生成的代码于其他实现环境中生成的代码一致。 **** 枚举类型的前置声明 在 C++11 新标准中，我们可以提前声明 enum。enum 的前置声明（无论隐式地还是显示地）必须指定其成员的大小：</p>
<p>#+BEGIN_SRC C++ // 不限定作用域的枚举类型intValues的前置声明 enum intValues : unsigned long long; // 不限定作用域的，必须指定成员类型 enum class open_modes; // 限定作用域的枚举类型可以使用默认成员类型int #+END_SRC</p>
<p>因为不限定作用域的 enum 未指定成员的默认大小。因此每个声明必须指定成员的大小。对于限定作用域的 enum 来说，我们可以不指定其成员大小，这个值被隐式地定义成 int。</p>
<p>和其他声明语句一样，enum 地声明和定义必须匹配，这意味着在该 enum 的所有声明和定义中成员的大小必须一致。而且，我们不能在同一个上下文中先声明一个不限定作用域的 enum 名字，然后再声明一个同名的限定作用域的 enum。 **** 形参匹配与枚举类型 要想初始化一个 enum 对象，必须使用该 enum 类型的另一个对象或者它的一个枚举成员。因此，即使某个整型值恰好与枚举成员的值相等，它也不能作为函数的 enum 实参使用。 ** 19.4 类成员指针 <em>成员指针</em> 是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员，而非类的对象。类的静态成员不属于任何对象，因此无须特殊的指向静态成员的指针，指向静态成员的指针与普通指针没有什么区别。</p>
<p>成员指针的类型囊括了类的类型以及成员的类型。当初始化一个这样的指针时，我们令其指向类的某个成员，但是不确定该成员所属的对象；知道使用成员指针时，才提供成员所属的对象。</p>
<p>为了解释成员指针的原理，不妨使用 7.3.1 节的 Screen 类：</p>
<p>#+BEGIN_SRC C++ class Sceen { public: typedef std::string::size_type pos; char get_cursor() const { return contents[cursor]; } char get() const; char get(pos ht, pos wd) const; private: std::string contents; pos cursor; pos height, width; }; #+END_SRC *** 19.4.1 数据成员指针 和其他指针一样，在声明成员指针时我们也使用<em>来表示当前声明的名字是一个指针。与普通指针不同的是，成员指针还必须包括成员所属的类。因此，我们必须在</em>之前添加 classname::以表示当前定义的指针可以指向 classname 的成员。例如：</p>
<p>#+BEGIN_SRC C++ // pdata可以指向一个常量（非常量的）Screen对象的string成员 const string Screen::*pdata; #+END_SRC</p>
<p>上述语句将 pdata 声明成“一个指向 Screen 类的 const string 成员的指针”。</p>
<p>当我们初始化一个成员指针（或者向它赋值）时，需指定它所指向的成员。例如，我们可以令 pdata 指向某个非特定 Screen 对象的 contents 成员：</p>
<p>~pdata = &amp;Screen::contents;~</p>
<p>其中，我们将取地址运算符作用于 Screen 类的成员而非内存种的一个该类对象。</p>
<p>当然，在 C++11 新标准中声明成员指针最简单的方法是使用 auto 或 decltype：</p>
<p>~auto pdata = &amp;Screen::contents;~ **** 使用数据成员指针 读者必须清楚的一点是，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针制定了成员而非该成员所属的对象，只有当解引用成员指针时我们才提供对象的信息。</p>
<p>#+BEGIN_SRC C++ Screen myScreen, <em>pScreen = &amp;myScreen; // .</em>解引用pdata以获得myScreen对象的contents成员 auto s = myScreen.<em>pdata; // -&gt;</em>解引用<em>pdata以获得pScreen所指对象的contents成员 s = pScreen-&gt;</em>pdata; #+END_SRC</p>
<p>从概念上来说，这些运算符执行两步操作：它们首先解引用成员指针以得到所需的成员；然后像成员访问运算符一样，通过对象（.<em>）或指针（-&gt;</em>）获取成员。 **** 返回数据成员指针的函数 常规的访问控制规则对成员指针同样有效。例如，Screen 的 contents 成员是私有的，因此之前对于 pdata 的使用必须位于 Screen 类的成员或友元内部，否则程序将发生错误。</p>
<p>因为数据成员一般勤恳光下是私有的，所以我们通常不能直接获得数据成员地指针。如果一个像 Screen 这样的类希望我们可以访问它的 contents 成员，最好定义一个函数，令其返回值是指向该成员的指针：</p>
<p>#+BEGIN_SRC C++ class Screen { public: // data是一个静态成员，返回一个成员指针 static const std::string Screen::<em>data() { return &amp;Screen::contents; } }; #+END_SRC </em>** 19.4.2 成员函数指针 我们也可以定义指向类的成员函数的指针。与指向数据成员的指针类似 ，对于我们来说要想创建一个指向成员函数的指针，最简单的方法是使用 auto 来推断类型：</p>
<p>#+BEGIN_SRC C++ // mpf是一个指针，它可以指向Screen的某个常量函数 // 前提是该函数不接受任何实参，并且返回一个char auto pmf = &amp;Screen::get_cursor; #+END_SRC</p>
<p>和指向数据成员的指针一样，我们使用 classname::*的形式声明一个指向成员函数的指针。类似于任何其他函数指针（参见 6.7 节），指向成员函数的指针也需要指定目标函数和返回类型的形参列表。如果函数成员是 const 成员或引用成员，则我们必须将 const 限定符或引用限定符包含进来。</p>
<p>和普通的函数指针类似，如果成员函数存在重载的问题，则我们必须显式地声明函数类型以明确指出我们想要使用的是哪个函数（参见 6.7 节）。例如，我们可以声明一个指针，令其指向含有两个形参的 get：</p>
<p>#+BEGIN_SRC C++ char (Screen::*pmf2)(Screen::pos, Screen::pos) const; pmf2 = &amp;Screen::get; #+END_SRC</p>
<p>c 出于优先级的考虑，上述声明中的 Screen::*两端的括号必不可少。如果没有这对括号的话，编译器将认为该声明是一个（无效的）函数声明。</p>
<p>和普通函数指针不同的是，在成员函数和指向该成员的指针之间不存在自动转换规则：</p>
<p>#+BEGIN_SRC C++ // pmf指向一个Screen成员，该成员不接受任何实参且返回类型是char pmf = &amp;Screen::get; // 必须显式地使用取地址运算符 pmf = Screen::get; // 错误：在成员函数和指针之间不存在自动转换规则 #+END_SRC **** 使用成员函数指针 和使用指向数据成员的指针一样，我们使用.<em>或者-&gt;</em>运算符作用于指向成员函数的指针，以调用类的成员函数：</p>
<p>#+BEGIN_SRC C++ Screen myScreen, <em>pScreen = &amp;myScreen; // 通过pScreen所指的对象调用pmf所指的函数 char c1 = (pScreen-&gt;</em>pmf)(); // 通过myScreen对象将实参0，0传给含有两个形参的get函数 char c2 = (myScreen.*pmf2)(0, 0); #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>因为函数调用运算符的优先级较高，所以在声明指向成员函数的指针并使用这样的指针进行函数调用时，括号必不可少：(C::<em>p)(parms)和(ojb.</em>p)(args)。 #+END_QUOTE **** 使用成员指针的类型别名 使用类型别名或 typedef 可以让成员指针更容易理解。例如，下面的类型别名将 Action 定义为两参数 get 函数的同义词：</p>
<p>#+BEGIN_SRC C++ // Action是一种可以指向Screen成员函数的指针，它接受两个post实参，返回一个char using Action = char (Screen::*)(Screen::pos, Screen::pos) const;</p>
<p>// 通过使用Action，我们可以简化指向get的指针定义 Action get = &amp;Screen::get; #+END_SRC **** 成员指针函数表 对于普通函数指针和指向成员函数的指针来说，一种常用的用法是将其存入一个函数表当中（参见 14.8.3 节）。如果一个类含有几个相同类型的成员，则这样一张函数表可以帮助我们从这些成员中选择一个。假定 Screen 类含有几个成员函数，每个函数负责将光标指向的方向移动：</p>
<p>#+BEGIN_SRC C++ class Screen { public: // 其他接口和实现成员之前一致 Screen&amp; home(); // 光标移动函数 Screen&amp; forward(); Screen&amp; back(); Screen&amp; up(); Screen&amp; down(); }; #+END_SRC</p>
<p>这几个新函数有一个共同点：它们都不接受任何参数，并且返回值是发生光标移动的 Screen 的引用。</p>
<p>我们希望定义个 move 函数，使其可以调用上面的任意一样函数并执行对应的操作。为了支持这个新函数，我们将在 Screen 中添加一个静态成员，该成员是指向光标移动函数的指针的数组：</p>
<p>#+BEGIN_SRC C++ class Screen { public: // 其他接口和实现成员之前一致 // Action是一个指针，可以用任意一个光标移动函数对其赋值 using Action = Screen&amp; (Screen::*)(); // 指定具体要g一对哦那的方向，其中enum参见19.3节 enum Directions { HOME, FORARD, BACK, UP, DOWN }; Screen&amp; move(Directions); private: static Action Menu(); // 函数表 }; #+END_SRC</p>
<p>数组 Menu 依次保存每个光标移动函数的指针，这些函数按照 Directions 中枚举成员对应的偏移量存储。move 函数接受一个枚举成员并调用相应的函数：</p>
<p>#+BEGIN_SRC C++ Screen&amp; Screen::move(Directions cm) { // 运行this对象中索引值为cm的元素 return (this-&gt;*Menu[cm])(); // Menu[cm]指向一个成员函数 } #+END_SRC</p>
<p>move 中的函数调用的原因里：首先获取索引值为 cm 的 Menu 元素，该元素指向 Screen 成员函数的指针，我们根据 this 所指的对象调用该元素所指的成员函数。</p>
<p>当我们调用 move 函数时，给它传入一个表示光标移动方向的枚举成员</p>
<p>#+BEGIN_SRC C++ Screen myScreen; myScreen.move(Screen::HOME); // 调用mySreen.home myScreen.move(Screen::DOWN); // 调用mySreen.down #+END_SRC</p>
<p>剩下的工作就是定义并初始化函数表本身了：</p>
<p>#+BEGIN_SRC C++ Screen::Action Screen::Menu[] = { &amp;Screen::home, &amp;Screen::forward, &amp;Screen::back, &amp;Screen::up, &amp;Screen::down, }; #+END_SRC *** 19.4.3 将成员函数用作可调用对象 如我们所知，要想通过一个指向成员函数的指针进行函数调用，必须首先利用.<em>运算符或-&gt;</em>运算符将该指针绑定到特定的对象上。因此与普通的函数指针不同，成员指针不是一个可调用对象，这样的指针不支持函数调用运算符（参见 10.3.2 节）。</p>
<p>因为成员指针不是可调用对象，所以我们不能直接将一个指向成员函数的指针传递给算符。 **** 使用 function 生成一个可调用对象 从指向成员函数的指针获取可调用对象的一种方式是使用标准库模板 function（参见 14.8.3 节）：</p>
<p>#+BEGIN_SRC C++ function&lt;bool (const string&amp;)&gt; fcn = &amp;string::empty; find_id(svec.begin(), svec,end(), fcn); #+END_SRC</p>
<p>我们告诉 function 一个事实：即 empty 是一个接受 string 参数并返回 bool 值的函数。通常情况下，执行成员函数的对象将被传给隐式的 this 形参。当我们想要使用 function 为成员函数生成一个可调用对象时，必须首先“翻译”该代码，使得隐式的形参编程显示的。</p>
<p>当一个 function 对象包含有一个指向成员函数的指针时，function 类知道它必须使用正确的指向成员的指针运算符来执行函数调用。也就是说，我们可以认为在 find_if 当中含有类似于如下形式的代码：</p>
<p>#+BEGIN_SRC C++ // 假设it时find_if内部的迭代器，则<em>it是给定范围内的一个对象 if (fcn(</em>it)) // 假设fcn是find_if内部的一个可调用对象的名字 #+END_SRC</p>
<p>其中，function 将使用正确的指向成员的指针运算符。从本质上来看，function 类将函数调用转换成了如下形式：</p>
<p>#+BEGIN_SRC C++ // 假设it是find_if内部的迭代器，则<em>it是给定范围内的一个对象 if (((</em>it).*P)()) //假设p是fcn内部的一个指向成员函数的指针 #+END_SRC</p>
<p>当我们定义一个 function 对象时，必须指定该对象所能表示的函数类型，即可调用对象的形式。如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在哪个（一般是隐式的）对象上执行的。同时，我们提供给 function 的形式中还必须指明对象是否是以指针或引用的形式传入的。 **** 使用 mem_fn 生成一个可调用对象 可以采取另一种方法，通过使用标准库功能 <em>mem_fn</em> 来让编译器负责推断成员的类型。和 function 一样，mem_fn 也定在 functional 头文件中，并且可以从成员指针生成一个可调用对象；和 function 不同的是，mem_fn 可以根据成员指针的类型推断可调用对象的类型，而无须用户显示指定：</p>
<p>~find_if(svec.begin(), svec.end(), mem_fn(&amp;string::empty));~</p>
<p>我们使用 mem_fn(&amp;string::empty)生成一个可调用对象，该对象接受一个 string 实参，返回一个 bool 值。</p>
<p>mem_fn 生成的可调用对象可以通过对象调用，也可以通过指针调用：</p>
<p>#+BEGIN_SRC C++ auto f = mem_fn(&amp;string::empty); // f接受一个string或者一个string<em> f(</em>svec.begin()); // 正确：传入一个string对象，f使用.<em>调用empty f(&amp;sev[0]); // 正确：传入一个string的指针，f使用-&gt;</em>调用empty #+END_SRC</p>
<p>实际上，我们可以认为 mem_fn 生成的可调用对象含有一对重载的函数调用运算符：一个接受 string<em>，另一个接受 string&amp;。 </em>*** 使用 bind 生成一个可调用对象 出于完整性的考虑，我们还可以使用 bind（参见 10.3.4 节）从成员函数生成一个可调用对象：</p>
<p>#+BEGIN_SRC C++ // 选择范围中的每个string，并将其bind到empty的第一个隐式实参上 auto it = find_if(svec.begin(), svec.end(), bind(&amp;string::empty, _1)); #+END_SRC</p>
<p>和 functinon 类似的地方是，当我们使用 bind 时，必须将函数中用于表示执行对象的隐式形参转换成显式的。和 mem_fn 类似的地方是，bind 生成的可调用对象的第一个实参既可以时 string 的指针，也可以时 string 的引用。 ** 19.5 嵌套类 一个类可以定义在另一个类的内部，前着称为 <em>嵌套类</em> 或 <em>嵌套类型</em> 。嵌套类常用于定义作为实现部分的类。</p>
<p>嵌套类是一个独立的类，与外层类基本没什么关系。特别是，外层类的对象和嵌套的对象是互相独立的。在嵌套类的对象中不包含任何外层类定义的成员：类似的，在外层类的对象中也不包含任何嵌套类定义的成员。</p>
<p>嵌套类的名字在外层作用于是可见的，在外层作用域之外不可见。和其他嵌套的名字一样，嵌套类的名字不会和别的作用域中的同一个名字冲突。</p>
<p>嵌套类中成员的种类与非嵌套类是一样的。和其他类类似，嵌套类也使用访问限定符来控制外界成员对其成员的访问权限。外层类对嵌套类的成员没有特殊的访问权限，同样，嵌套类对外层类的成员也没有特殊的访问权限。</p>
<p>嵌套类在其外层类中定义了一个类型成员。和其他成员类似，该类型的访问权限由外层类决定。位于外层类 public 部分的嵌套类实际上定义了一种可以随处访问的类型：位于外层类 protected 部分的嵌套类定义的只能被外层类及其友元和派生类访问；位于外层类 private 部分的嵌套类定义的类型只能被外层的成员和友元访问。 **** 在外层类之外定义一个嵌套类 和成员函数一样，嵌套类必须声明在类的内部，但是可以定义在类的内部或者外部。</p>
<p>当我们在外层类之外定义一个嵌套类时，必须以外层的名字限定嵌套类的名字。 **** 嵌套类作用域中的名字查找 名字查找的一般规则（参见 7.4.1 节）在嵌套类中同样使用。当然，因为嵌套类本身是一个嵌套组作用域，所以还必须查找嵌套类外层作用域。</p>
<p>如我们所知，嵌套类是其外层类的一个类型成员，因此外层类的成员可以像使用任何其他类型成员一样使用嵌套类的名字。 ** 19.6 union：一种节省空间的类 <em>联合（union）</em> 是一种特殊的类。一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当我们给 union 的某个成员赋值之后，该 union 的其他成员就变成未定义的状态了。分配给一个 union 对象的存储空间至少要能容纳它的最大数据成员。和其他类一样，一个 union 定义了一种新类型。</p>
<p>类的某些特性对 union 同样使用，但并非所有特性都如此。union 不能含有引用类型的成员，除此之外，它的成员可以是绝大多数类型。在 C++11 新标准中，含有构造函数或析构函数的类类型也可以作为 union 的成员类 ixngunion 可以为其成员指定 public、protected 和 private 等保护标记。默认情况下，union 的成员都是公有的，这一点与 struct 相同。</p>
<p>union 可以定义包括构造函数和析构函数在内的成员函数。但是由于 union 既不能继承自其他类，也不能作为基类使用，所以在 union 中不能含有虚函数。 **** 定义 union 在定义一个 union 时，首先是关键字 union，随后是该 union 的（可选的）名字以及花括号内的一组成员声明。 **** 使用 union 类型 union 的名字是一个类型名。和其他内置类型一样，默认情况下 union 是未初始化的。我们可以像显式的初始化聚合类（参见 7.5.5 节）一样使用一对花括号内的初始值显示地初始化一个 union：</p>
<p>#+BEGIN_SRC C++ Token first_token = {‘a’}; // 初始化cval成员 Token last_token; // 未初始化的Token对象 Token *pt = new Token; // 指向一个未初始化的Token对象的指针 #+END_SRC</p>
<p>如果提供了初始值，则该初始值被用于初始化第一个成员。</p>
<p>我们使用通用的成员访问运算符访问一个 union 对象的成员：</p>
<p>#+BEGIN_SRC C++ last_token.cval = ‘z’; pt-&gt;ival = 42; #+END_SRC</p>
<p>为 union 的一个数据成员赋值会令其他数据成员变成未定义的状态。因此，当我们使用 union 时，必须清楚地知道当前存储在 union 中的值到底时什么类型。如果我们使用错误的数据成员或者未错误的数据成员赋值，则程序可能崩溃或出现异常的行为，具体的情况根据成员的类型而有所不同。 **** 匿名 union <em>匿名 union</em> 时一个未命名的 union，并且在右花括号和分号之间没有任何声明（参见 2.6.1 节）。一个我们定义了一个匿名 union，编译器就自动地未该 union 创建一个未命名对象：</p>
<p>#+BEGIN_SRC C++ union { // 匿名union char cval; int ival; double dval; }; // 定义一个未命名的对象，我们可以直接访问它的成员 cval = ‘c’; // 未刚刚定义的未命名的匿名union对象赋一个新值 ival = 42; // 该对象当前保存的值是42 #+END_SRC</p>
<p>在匿名 union 的定义所在的作用域内该 union 的成员都是可以直接访问的。</p>
<p>#+BEGIN_SRC C++ 匿名union不能包含受保护的成员或私有成员，也不能定义成员函数。 #+END_SRC **** 含有类类型成员的 union C++早期版本规定，在 union 中不能含有定义了构造函数或拷贝控制成员的类类型成员。C++11 新标准取消了这一限制。不过，如果 union 的成员类型定义了自己的构造函数和/或空呗控制成员，则该 union 的用法要比只含有内置类型成员的 union 复杂的多。</p>
<p>当 union 包含的是内置类型的成员时，我们可以使用普通的赋值语句改变 union 保存的值。但是对于含有特殊类类型成员的 union 就没有这么简单了。如果我们想要将 union 的值改变未类类型成员对应的值，或者将类类型成员的值改为一个其他其值，则必须构造或析构该类类型的成员：当我们将 union 的值改为类类型成员对应的值时，必须运行该类型的构造函数；反之，当我们将类类型成员的值改为一个其他值时，必须运行该类型的析构函数。</p>
<p>当 union 包含的是内置类型的成员时，编译器将按照成员的次序依次合成默认构造函数或拷贝控制成员。但是如果 union 含有类类型的成员，并且该类型自定义了默认构造函数或拷贝控制成员，则编译器将为 union 合成对应的版本并将其声明为删除的。 ** 19.7 局部类 类可以定义在某个函数的内部，我们称这样的类为 <em>局部类</em> 。局部类定义的类型只在定义它的作用域内可见。和嵌套类不同，局部类的成员受到严格限制。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>局部类的所有成员（包括函数在内）都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。 #+END_QUOTE</p>
<p>在实际编程的过程中，因为局部类的成员必须完整定义在类的内部，所以成员函数的复杂性不可能太高。局部类的成员函数一般只有几行，否则我们就很难读懂它了。</p>
<p>类似的，在局部类也不允许声明静态数据成员，因为我们没法定义这样的成员。 **** 局部类不能使用函数作用域中的变量 局部类对其外层作用域中名字的访问权限受到很多限制，局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员。如果局部类定义在某个函数内部，则该函数的普通局部变量不能被改局部类使用。 **** 常规的访问保护规则对局部类同样适用 外层函数对局部类的私有成员没有任何访问权限。当然，局部类可以将外层函数声明为友元；或者更常见的情况是局部类将其成员声明成公有的。在程序中有权访问局部类的代码非常有限。局部类已经封装在函数的作用域中，通过信息隐藏进一步封装就显得没什么必须了。 **** 局部类中的名字查找 局部类内部的名字查照次序与其他类相似。在声明类的成员时，必须显确保用到的名字位于作用域中，然后再使用该名字。定义成员时用到的名字可以出现在类的任意位置。如果某个名字不是局部类的成员，则继续在外层函数作用域中查找；如果还没有找到，则在外层函数所在的作用域中查找。 **** 嵌套的局部类 可以在局部类的内部再嵌套一个类。此时，嵌套类的定义可以出现在局部类之外。不过，嵌套类必须定义在与局部类相同的作用域中。</p>
<p>局部类内的嵌套类也是一个局部类，必须遵循局部类的各种规定。嵌套类的所有成员都必须定义在嵌套类的内部。 ** 19.8 固有的不移植的特性 为了支持低层编程，C++定义了一些固有的 <em>不可移植</em> 的特性。所谓不可移植的特性是指因机器而已的特性，当我们将含有不可移植特性的程序从一台及其转移到另一台机器上时，通常需要重新编写该程序。 *** 19.8.1 位域 类可以将其（非静态）数据成员定义成 <em>位域</em> ，在一个位域中含有一定数量的二进制位。当一个程序需要像其他程序或硬件设备传递二进制数据时，通常会使用到位域。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>位域在内存中的布局是与机器相关的。 #+END_QUOTE</p>
<p>位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，所以在通常情况下我们使用无符号类型保存一个位域。位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该表达式用于指定成员所占的二进制位数：</p>
<p>#+BEGIN_SRC C++ typedef unsigned int Bit; class File { Bit mode: 2; // mode站2位 Bit modified:1; // modified占1位 Bit prot_owner: 3; // prot_owner占3位 Bit prot_group: 3; // prot_group占3位 Bit prot_world: 3; // prot_world占3位 // File的操作和数据成员 public: // 文件类型以八进制的形式表示 enum modes { READ = 01, WRITE = 02, EXECUTE = 03 }; File &amp;open(modes); void close(); void write(); bool isRead() const; void setWrite(); }; #+END_SRC *** 19.8.2 volatile 限定符 #+BEGIN_QUOTE WARNING：</p>
<p>volatile 的确切含义与机器有关，只能通过阅读编译器文档来理解。要想让使用了 volatile 的程序在移植到新机器或新编一起后仍然有效，通常需要对该程序进行某些改变。 #+END_QUOTE</p>
<p>直接处理硬件的程序常常包含这样的数据元素，它们的值由程序直接控制之外的过程控制。例如，程序可能包含一个由系统时钟定时更新的变量。当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 <em>volatile</em> 。关键字 volatile 告诉编译器不应该对这样的对象进行优化。</p>
<p>就像一个类可以定义 const 成员函数一样，它也可以将成员函数定义成 volatile 的。只有 volatile 的成员函数才能被 volatile 的对象调用。</p>
<p>2.4.2 节描述了 const 限定符和指针的互相作用，在 volatile 限定符和指针之间也存在类似的关系。我们可以声明 volatile 指针、指向 volatile 对象的指针以及指向 volatile 对象的 volatile 指针。</p>
<p>和 const 一样，我们只能将一个 volatile 对象的地址（或者拷贝一个指向 vloatile 类型的指针）赋给一个指向 volatile 的指针。同时，也只有当某个引用时 volatile 的时，我们才能使用一个 volatile 对象初始化给引用。 **** 合成的拷贝对 volatile 对象无效 const 和 volatile 的一个重要区别是我们不能使用合成的拷贝/移动构造函数及赋值运算符初始化 volatile 对象或从 volatile 对象赋值。合成的成员接受的形参列表是（非 volatile）常量引用，显然我们不能把一个非 volatile 引用绑定到一个 vloatile 对象上。</p>
<p>如果一个类希望拷贝、移动或赋值它的 volatile 对象，则该类必须自定义拷贝或移动操作。</p>
<p>尽管我们可以为 vloatile 对象定义拷贝和赋值操作，但是一个更深层次的问题是拷贝 volatile 对象是否有意义呢？不同程序使用 volatile 的目的各不相同，对上述问题的回答与具体的是一噢嗯目的密切相关。 *** 19.8.3 链接指示：extern “C” C++程序有时需要调用其他语言编写的函数，最常见的是调用 C 语言编写的函数，像所有其他名字一样，其他语言中的函数名字也必须在 C++中进行声明，并且该声明必须指定返回类型和形参列表。对于其他语言编写的函数来说，编译器检查其调用的方式与处理普通 C++函数相同，但是生成的代码有所区别。C++使用 <em>链接指示</em> 指出任意非 C++函数所用的语言。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>要想把 C++代码和其他语言（包括 C 语言）编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的 C++编译器是兼容的。 #+END_QUOTE **** 声明一个非 C++的函数 链接指示可以有两种方式：单个的或复合的。链接指示不能出现在类定义或函数定义的内部。同样的链接指示必须在函数的每个声明中都出现。</p>
<p>举个例子，接下来的声明显示了 cstring 头文件的某些 C 函数是如何声明的：</p>
<p>#+BEGIN_SRC C++ // 可能出现在C++头文件<cstring>中的链接指示 // 单句链接指示 extern “C” size_t strlen(const char <em>); // 复合语句链接指示 extern “C” { int strcmp(const char</em>, const char<em>); char </em>strcat(char<em>, const char</em>); } #+END_SRC</p>
<p>链接指示的地一种形式包括一个关键字 extern，后面是一个字符串字面值常量以及一个“普通的”函数声明。</p>
<p>其中的字符串字面值常量指出了编写函数所用的语言。编译器应该支持 C 语言的链接指示。此外编译器也可能会支持其他语言的链接指示，如 extern “Ada”、extern “FORTRAN”等。 **** 链接指示与头文件 当一个#include 指示被放置在复合链接指示的花括号中时，头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。链接指示可以嵌套，因此如果头文件包含带自带链接指示的函数，则该函数的链接不受影响。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>C++从 C 语言继承的标准库函数可以定成 C 函数，但并非必须：决定使用 C 还是 C++实现 C 标准库，是每个 C++实现的事情。 #+END_QUOTE</p>
<p>**** 指向 extern “C”函数的指针 编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数来说，它的每个声明都必须使用相同的链接指示。而且，指向其他语言编写的函数的指针必须与函数本身使用相同的链接指示：</p>
<p>#+BEGIN_SRC C++ // pf指向一个C函数，该函数接受一个int返回void extern “C” void (*pf)(int); #+END_SRC</p>
<p>当我们使用 pf 调用函数时，编译器认定当前调用的是一个 C 函数。</p>
<p>指向 C 函数的指针与指向 C++函数的指针是不一样的类型，一个指向 C 函数的指针不能用在执行初始化或赋值操作后指向 C++函数，反之亦然。就像其他类型不匹配的问题一样，如果我们试图在两个链接指示不同的指针之间进行赋值操作，则程序将发生错误。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>有的 C++编译器会接受之前的这种赋值操作并将其作为对语言的扩展，监管从严格意义上来看它是非法的。 #+END_QUOTE **** 链接指示对整个声明都有效 当我们使用链接指示时，它不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效。</p>
<p>因为链接指示同时作用于声明语句中的所有函数，所以如果我们希望给 C++函数传入一个指向 C 函数的指针，则必须使用类型别名：</p>
<p>#+BEGIN_SRC C++ // FC是一个指向C函数的指针 extern “C” typedef void FC(int); // f2是一个C++函数，该函数的形参是指向C函数的指针 void f2(FC <em>); #+END_SRC </em>*** 导出 C++函数到其他语言 通过使用链接指示对函数进行定义，我们可以令一个 C++函数在其他语言编写的程序中可用：</p>
<p>#+BEGIN_SRC C++ // calc函数可以被C程序调用 extern “C” double calc(double dparm) { /* … */ } #+END_SRC</p>
<p>编译器将为该函数生成适合于指定语言的代码。</p>
<p>值得注意的是，可被多种语言共享的函数的返回类型或形参类型受到很多限制。例如，我们不太可能把一个 C++类的对象传给 C 程序，因为 C 程序根本无法理解构造函数、析构函数以及其他其类特有的操作。</p>
<p>#+BEGIN_QUOTE 对链接到 C 的预处理器的支持</p>
<p>有时候需要在 C 和 C++中编译同一个源文件，为了实现这一目的，在编译 C++版本的程序时预处理器定义__cplusplus（两个下划线）。利用这个变量，我们可以在编译 C++程序的时候有条件地包括进来一些代码：</p>
<p>#ifdef __cplusplus // 正确：我们正在编译 C++程序 extern “C” #endif int strcmp(const char<em>, const char</em>); #+END_QUOTE **** 重载函数与链接指示 链接指示与重载函数的互相作用依赖于目标语言。如果目标语言支持重载函数，则为该语言实现链接指示的编译器很可能也支持重载这些 C++的函数。</p>
<p>C 语言不支持函数重载，因此也就不难理解为什么一个 C 链接指示只能用于说明一组重载函数中的某一个了。</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[C/C++ Primer 第 I 部分 C++基础]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/C++/C++%20Primer%20Part%20I.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/C++/C++%20Primer%20Part%20I.html</guid>
    <description><![CDATA[<p>#+TITLE: C/C++ Primer 第 I 部分 C++基础 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>第 2 章 变量和基本类型 ** 2.1 基本内置类型 *** 2.1.1 算术类型 wchat_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符，类型 char16_t 和 char32_t 则为 Unicode 字符集服务（Unicode 用于表示所有自然语言中字符的标准）。</li>
</ul>
<p>#+BEGIN_QUOTE 大多数计算机以 2 的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节(byte）”，存储的基本单元称为“字（word）“，它通常由几个字节组成。 #+END_QUOTE **** 带符号类型和无符号类型 特别需要注意的是：类型 char 和类型 signed char 并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型 char 实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。 *** 2.1.2 类型转换 当我们赋给无符号类型一个超出它表示范围的值时，结果时初始值对无符号类型表示数值总数取模后的余数。 **** 含有无符号类型的表达式 当一个算术表达式中既有无符号数又有 int 值时，那个 int 值就会转换成无符号数。 *** 2.1.3 字面值常量 **** 整型和浮点型字面值 尽管整型字面值可以存储在带符号类型中，但严格来说，十进制字面值不会时负数。如果我们适用了一个形如-42 的负十进制字面值，那个负号并不在字面值之内，它的作用仅仅是对字面值取负值而已。 **** 字符和字符串字面值 由单引号括起来的一个字符称为 char 型字面值，双引号括起来的零个或多个字符则构成字符串字面值。</p>
<p>#+BEGIN_SRC C++ ‘a’ // 字符字面值 “Hello World!” // 字符串字面值 #+END_SRC</p>
<p>如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分割，则它们实际上时一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：</p>
<p>#+BEGIN_SRC C++ // 分多行书写的字符串字面值 std::cout &lt;&lt; “a really, really long string literal” “that spans two lines” &lt;&lt; std::endl; #+END_SRC **** 指定字面值类型 #+CAPTION: 字符和字符串字面值 | 前缀 | 含义 | 类型 | |——+——————————-+———-| | u | Unicode16 字符 | char16_t | | U | Unicode32 字符 | char32_t | | L | 宽字符 | wchar_t | | u8 | UTF-8（仅用于字符串字面常量） | char |</p>
<p>#+CAPTION: 整型字面值 | 后缀 | 最小匹配类型 | |———-+————–| | u or U | unsigned | | l or L | long | | ll or LL | long long |</p>
<p>#+CAPTION: 浮点型字面值 | 后缀 | 类型 | |——–+————-| | f or F | float | | l or L | long double | ** 2.2 变量 *** 2.2.1 变量定义 **** 初始值 当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。因此在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。</p>
<p>#+BEGIN_QUOTE WARNING</p>
<p>初始化不是赋值，初始化的含义时创建变量时赋予其一个初始值，而赋值的含义时把对象的当前值擦除，而以一个新值来替代。 #+END_QUOTE **** 列表初始化 作为 C++11 新标准的一部分，用花括号来初始化变量得到了全面应用，而在此之前这种初始化形式仅在某些收线场合才能适用。这种初始化的形式被称为 <em>列表初始化</em> 。现在，无论时初始化对象还是某些时候为对象赋新值，都可以适用这样一组由花括号括起来的初始值了。</p>
<p>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错：</p>
<p>#+BEGIN_SRC C++ long double ld = 3.1415926536; int a{ld}, b = {ld}; // 错误：转换未执行，因为存在丢失信息的风险 int c(ld), d = ld; // 正确：转换执行，切确实丢失了部分值 #+END_SRC **** 默认初始化 如果定义变量时没有执行初值，则变量被 <em>默认初始化</em> ，此时变量被赋予了”默认值“。默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</p>
<p>定义于任何函数体之外的内置类型的变量都被初始化未 0，定义在函数体内部的内质类型变量将 <em>不被初始化</em> 。 *** 2.2.4 名字的作用域 **** 嵌套作用域 因为全局作用域本身没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p>
<p>#+BEGIN_SRC C++ #include <iostream> // 该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量 int reused = 42;</p>
<p>int main() { // 42 std::count &lt;&lt; reused &lt;&lt; std::endl; int reused = 0; // 0 std::cout &lt;&lt; reused &lt;&lt; std::endl; // 42 std::count &lt;&lt; ::reused &lt;&lt; std::end; } #+END_SRC ** 2.3 复合类型 *** 2.3.3 理解复合类型的声明 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。 ** 2.4 const 限定符 *** 2.4.3 顶层 const <em>顶层 const</em> 表示指针本身是个常量，而 <em>底层 const</em> 表示指针所指的对象是一个常量。</p>
<p>更一般的，顶层 const 可以表示任意对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层 const 则与指针和引用等复合类型的基本类型部分有关。</p>
<p>#+BEGIN_QUOTE As we’ve seen, a pointer is an object that can point to a different object. As a result,we can talk independently about whether a pointer is const and whether the objectsto which it can point are const. We use the term top-level const to indicate that thepointer itself is a const. When a pointer can point to a const object, we refer tothat const as a low-level const. #+END_QUOTE</p>
<p>https://www.zhihu.com/question/24785843 *** 2.4.4 constexpr 和常量表达式 <em>常量表达式</em> 是指不会改变并且在编译过程就能得到计算结果的表达式。 **** constexpr 变量 C++11 新标准规定，允许将变量声明为 <em>constexpr</em> 类型以便由编译器来验证变量值是否是一个常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化 ** 2.5 处理类型 *** 2.5.1 类型别名 有两种方法可用于定义类型别名。传统的方法是使用关键字 <em>typedef</em> 。</p>
<p>新标准规定了一种新的方法，使用 <em>别名声明</em> 来定义类型的别名：</p>
<p>~using SI = Sales_item; // SI是Sales_item的同义词~</p>
<p>这种方法用关键词 using 作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。 *** 2.5.2 auto 类型说明符 C++11 新标准引入了 auto 类型说明符，用它就能让编译器替我们去分析表达式所属的类型。</p>
<p>因为一条语句只能有一个数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：</p>
<p>#+BEGIN_SRC C++ auto i = 0, *p = &amp;i; // 正确：i是整数、p是类型指针 auto sz = 0, pi = 3.14; // 错误：sz和pi的类型不一致 #+END_SRC</p>
<p>**** 复合类型、常量和 auto</p>
<p>auto 一般会忽略掉顶层 const，同时底层 const 则会保留下来，比如当初始值是一个指向常量的指针时。如果希望推断出 auto 类型时一个顶层 const，则需要明确指出：</p>
<p>~const auto f = ci; // ci的推演类型时int， f是const int~</p>
<p>还可以将引用类型设为 auto，此时原来的初始化规则仍然适用。 *** 2.5.3 decltype 类型指示符 C++11 新标准引入了第二种类型说明符 <em>decltype</em> ，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：</p>
<p>~decltype(f()) sum = x; // sum的类型就是函数f的返回类型~</p>
<p>编译器并不实际调用函数 f，而且适用当调用发生时 f 的返回类型作为 sum 的类型。</p>
<p>decltype 处理顶层 const 和引用的方式与 auto 有些许不同。如果 decltype 使用的表达式时一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内）。</p>
<p>**** decltype 和引用 如果 decltype 适用的表达式不是一个变量，则 decltype 返回表达式对应的类型。</p>
<p>另一方面，如果表达式的内容是解引用，则 decltype 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype (*p)的结果类型就是 int&amp;，而非 int。</p>
<p>对于 decltype 所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果 decltype 使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 decltype 就会得道引用类型。</p>
<p>#+BEGIN_QUOTE WARNING</p>
<p>切记：decltype((variable))（注意是双层括号）的结果永远是引用，而 decltype(variable)结果只有当 variable 本身就是一个引用时才是引用。 #+END_QUOTE ** 2.6 自定义数据结构 类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少：</p>
<p>#+BEGIN_SRC c++ struct Sales_date { /* … <em>/ } accum, trans, </em>salesptr; // 与上一条语句等价，但可能更好一些 struct Sales_date { /* … <em>/ }; Sales_date accum, trans, </em>salesptr; #+END_SRC</p>
<p>分号表示声明符（通常为空）的结束。一般来说，最好不要把对象的定义和类的定义放在一起。这么做无异吧两种不同实体的定义混在了一条语句里，一会儿定义类，一会儿又定义变量，显示这是一种不被建议的行为。</p>
<p>**** 类数据成员 C++11 新标准规定，可以为数据成员提供一个 <em>类内初始值</em> 。创建对象时，雷内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p>
<p>对类内初始值的限制与之前介绍的类似（参见 2.2.1 节）：或者放在花括号里，或者放在等号右边，记住不能使用圆括号。 * 第 3 章 字符串、向量和数组 ** 3.1 命名空间和 using 声明 有了 using 声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。 using 声明具有如下的形式：</p>
<p>~using namespace::name;~</p>
<p>#+BEGIN_SRC C++ #include <iosteam> using std::cin;</p>
<p>int main() { int i; cin &gt;&gt; i; std::cout &lt;&lt; i; return 0; } #+END_SRC *** 头文件不应包含 using 声明 位于头文件的代码一般来说不应该使用 using 声明。这是因为头文件的内容会拷贝到所有引导它的文件中，如果头文件里有某个 using 声明，那么每个使用了该文件的文件都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。 ** 3.2 标准库类型 string 标准库类型 <em>string</em> 表示可变长的字符序列。作为标准库的一部分，string 定义在命名空间 std 中。</p>
<p>#+BEGIN_SRC C++ #include <string> using std::string; #+END_SRC *** 3.2.1 定义和初始化 string 对象 #+CAPTION: 初始化 string 对象的方式 | string s1 | 默认初始化，s1 是一个空串 | | string s2(s1) | s2 是 s1 的副本 | | string s2 = s1 | 等价于 s2(s1) | | string s3(“value”) | s3 是字面值“values”副本，除了字面值最后的那个空字符外 | | string 3 = “value” | 等价于 s3(“value”) | | string s4(n, ‘c’) | 把 s4 初始化为由连续 n 个字符 c 组成的串 | **** 直接初始化和拷贝初始化 如果使用等号（=）初始化一个变量，实际上执行的是 <em>拷贝初始化</em> ，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是 <em>直接初始化</em> 。</p>
<p>#+BEGIN_SRC C++ string s5 = “hiya”; // 拷贝初始化 string s6(“hiya”); // 直接初始化 #+END_SRC *** 3.2.2 string 对象上的操作 #+CAPTION: string 的操作 | os&lt;&lt;s | 将 s 写道输出流 os 当中，返回 os | | is &gt;&gt; s | 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is | | getline(is, s) | 从 is 中读取一行赋给 s，返回 is | | s.empty() | s 为空返回 true，否则返回 false | | s.size() | 返回 s 中字符的个数 | | s[n] | 返回 s 中第 n 个字符的引用，位置 n 从 0 计起 | | S1+s2 | 返回 s1 和 s2 连接后的结果 | | s1=s2 | 用 s2 的副本代替 s1 原来的字符 | | s1==s2 | 如果 s1 和 s2 中所含字符完全一样，则它们相等； | | s1!=s2 | string 对象的相等性判断对字母的大小写敏感 | | &lt;, &lt;=, &gt;, &gt;= | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 | **** 读写 string 对象 在执行读取操作时，string 对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。</p>
<p>#+BEGIN_SRC C++ int main() { string s; cin &gt;&gt; s; cout &lt;&lt; s &lt;&lt; endl; return 0; } #+END_SRC</p>
<p>例如上述程序输入 <em>" Hello World! "</em> ，则输出为 <em>“Hello”</em> ，输出结果中没有任何空格。 **** 使用 getline 读取一整行 如果希望能在最终得道的字符串中保留输入时的空白字符串，这时应该用 <em>getline</em> 函数替代原来的&gt;&gt;运算符。getline 只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空 string。（注意 getline 只读取而不存储换行符）。</p>
<p>#+BEGIN_QUOTE Note:</p>
<p>触发 getline 函数返回的那个换行符实际上被丢掉了，得到的 string 对象并不包含换行符。 #+END_QUOTE **** string::size_type 类型 其是 size 函数返回的时一个 string::size_type 类型的值。</p>
<p>string 类及其他大多数标准库类型都定义了几种配套的类型。这些配套类型体验了标准库类型与机器无关的特性。类型 <em>size_type</em> 即是其中一种。</p>
<p>尽管我们不太清除 string::size_type 类型的细节，但有一点是肯定的：它是一个无符号类型的值而且能足够存放下任何 string 对象的大小。所有用于存放 string 类的 size 函数返回值的变量，都应该是 string::size_type 类型的。</p>
<p>#+BEGIN_QUOTE Tip:</p>
<p>如果一条表达式中已经有了 size（）函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。 #+END_QUOTE **** 字面值和 string 对象相加 当把 string 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个时 string：</p>
<p>#+BEGIN_SRC C++ string s4 = s1 + “,”; // 正确 string s5 = “hello” + “,”; // 错误：两个运算对象都不是string string s6 = s1 + “,” + “world”; // 正确：每个加发运算符都一个运算对象是string string s7 = “hello” + “,” + s2; // 错误：不能把字面值直接相加 #+END_SRC</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>因为某些历史原因，也为了与 C 兼容，所以 C++语言中的字符串字面值并不是标准库类型 string 的对象。切记，字符串字面值与 string 是不同的类型。 #+END_QUOTE **** 使用 C++版本的 C 标准库头文件 C++标准库中除了定义 C++语言特有的功能外，也兼容了 C 语言的标准库。C语言的头文件形如 name.h，C++则将这些文件命名为 cname。也就是去掉了.h 后缀，而在文件名 name 之前添加了字母 c，这里的 c 表示这是一个属于 C 语言标准库的头文件。</p>
<p>因此，cctype 头文件和 ctype.h 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++语言的要求。特别的，在名为 cname 的头文件中定义的名字从属于命名空间 std，而定义在名为.h 的头文件中的则不然。</p>
<p>一般来说，C++程序应该使用名为 cname 的头文件而不使用 name.h 的形式，标准库中的名字总能在命名空间 std 中找到。如果使用.h 形式的头文件，程序员就不得不时刻牢记哪些是从 C 语言那儿继承过来的，哪些又是 C++语言所独有的。 **** 处理每个字符？使用基于范围的 for 语句 如果想对 string 对象中的每个字符做点什么操作，目前最好的办法是使用 C++11 新标准提供的一种语句： <em>范围 for</em> 语句。这种语句遍历给定序列中的每个元素并对序列的每个值执行某种操作，其语法形式是：</p>
<p>#+BEGIN_SRC for (declaration : expression) statement #+END_SRC</p>
<p>其中，expression 部分是一个对象，用于表示一个序列。declaration 部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration 部分的变量会被初始化为 expression 部分的 i 想啊一个元素。</p>
<p>#+BEGIN_SRC C++ string str(“some string”); for (auto c : str) cout &lt;&lt; c &lt;&lt; endl; #+END_SRC **** 使用范围 for 语句改变字符串中的字符 如果想要改变 string 对象中的字符的值，必须把循环变量定义成引用类型。记住所谓引用值是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。 **** 只处理一部分字符？ <em>下表运算符</em> （[ ]）接收的输入参数时 string::size_type 类型的值。string 对象的下表从 0 计起。 ** 3.3 标准库类型 vector 标准库类型 vector 表示对象集合，其中所有对象的类型都相同。集合中的每个对象都一个与之对应的索引，索引用于访问对象。因为 vector“容纳着”其他对象，所以它 也常被称为 <em>容器</em> 。第 II 部分将对容器进行更为详细的介绍。</p>
<p>模板本身不是类或函数，相反可以将模板模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为 <em>实例化</em> ，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。</p>
<p>vector 能容纳绝大多数类型的对象作为其元素，但时因为引用不是对象（参见 2.3.1 节），所以不存在包含引用的 vector。 *** 3.3.1 定义和初始化 vector 对象 #+CAPTION: 初始化 vector 对象的方法 | vector<T> v1 | v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化 | | vector<T> v2(v1) | v2 中包含有 v1 所有元素的副本 | | vector<T> v2 = v1 | 等级于 v2(v1)，v2 中包含有 v1 所有元素的副本 | | vector<T> v3(n, val) | v3 包含了 n 个重复的元素，每个元素的值都是 val | | vector<T> v4(n) | v4 包含了 n 个重复地执行了值初始化的对象 | | vector<T> v5{a,b,c…} | v5 包含了初始值个数的元素，每个元素被赋予相应的初始值 | | vector<T> v5={a,b,c…} | 等价于 v5{a,b,c…} | **** 值初始化 通常情况下，可以只提供 vector 对象容纳的元素数量而不用略去初始值。此时库会创建一个 <em>值初始化</em> 元素初值，并把它赋给容器中的所有元素。这个初值由 vector 对象中元素的类型决定。</p>
<p>如果 vector 对象的元素是内置类型，比如 int，则元素初始值自动设为 0.如果元素是某种类型，比如 string，则元素由类默认初始化。</p>
<p>对这种初始化的方式有两个特殊限制：其一，有些类要求必须明确地提供初始值（参见 2.2.1 节），如果 vector 对象中元素的类型不支持默认初始化，我们就必须提供初始化的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。</p>
<p>其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化。 **** 列表初始化还是元素数量？ #+BEGIN_SRC C++ vector<int> v1(10); // v1有10个元素，每个值都是0 vector<int> v2{10}; // v2有1个元素，该元素的值是10</p>
<p>vector<int> v3(10, 1); // v3有10个元素，每个的值都是1 vector<int> v4{10, 1}; // v4有2个元素，值分别是10和1 #+END_SRC</p>
<p>如果用的是圆括号，可以说提供的值用来构造 vector 对象的。 如果用的是花括号，可以表述成我们想列表初始化该 vector 对象。</p>
<p>另一方面，如果初始化时使用了花括号的形式但提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象了。</p>
<p>#+BEGIN_SRC C++ vector<string> v5{“hi”}; // 列表初始化，：v5有一个元素 vector<string> v6(“hi”); // 错误：不能使用字符串字面值构建vector对象 vector<string> v7{10}; // v7有10个默认初始值的元素 vector<string> v8{10, “hi”} // v8有10个值为“hi”的元素 #+END_SRC *** 3.3.2 向 vector 对象中添加元素 更好的处理方法是先创建一个空 vector，然后在运行时再利用 vector 的成员函数 <em>push_back</em> 向其中添加元素。push_back 负责把一个值当成 vector 对象的尾元素”压到（push）“vector 对象的”尾端（back）“。 **** 向 vector 对象添加元素蕴含的编程假定 如果徐缓体内部包含有向 vector 对象添加元素的语句，则不能使用范围 for 循环，具体原因将在 5.4.3 节详细解释。</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>方位 for 语句体内不应改变其所遍历序列的大小。 #+END_QUOTE *** 3.3.3 其他 vector 操作 #+CAPTION: vector 支持的操作 | v.empty() | 如果 v 不含任何元素，返回真；否则返回假 | | v.size() | 返回 v 中元素的个数 | | v.push_back(t) | 向 v 的尾端添加一个值为 t 的元素 | | v[n] | 返回 v 中第 n 个位置上元素的引用 | | v1 = v2 | 用 v2 中元素的拷贝替换 v1 中的元素 | | v1 = {a,b,c…} | 用列表中元素的拷贝替换 v1 的元素 | | v1 == v2 | v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 | | v1 !+ v2 | | | &lt;, &lt;=, &gt;, &gt;= | 顾名思义，以字典顺序进行比较 |</p>
<p>#+BEGIN_QUOTE Note:</p>
<p>要使用 size_type，需首先指定它是由哪种类型定义的。vector 对象类型总是包含着元素的类型（参见 3.3 节）</p>
<p>vector<int>::size_type // 正确 vector::size_type // 错误 #+END_QUOTE **** 不能用下标形式添加元素 刚接触 C++语言的程序员也许会认为可以通过 vector 对象的下标形式来添加元素，事实并非如此。如前所述，正确的方式是使用 push_back。</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>vector 对象（以及 string 对象）的下标运算符可用于方位已存在的元素，而不能用于添加元素。 #+END_QUOTE ** 3.4 迭代器介绍 我们已经知道可以使用下标运算符来访问 string 对象的字符或 vector 对象的元素，还有另外一种更通用的机制也可以实现同样的目的，这就是 <em>迭代器</em> 。</p>
<p>类似于指针类型，迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或 string 对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素。迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。 *** 3.4.1 使用迭代器可以访问某个元素 和指针不一样的是，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为 <em>begin</em> 和 <em>end</em> 的成员，其中 begin 成员负责范围指向第一个元素的迭代器，end 成员则负责返回指向容器”尾元素的下一位置“的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“ <em>尾后</em>”元素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end 成员返回的迭代器常被称作 <em>尾后迭代器</em> 或者简称尾迭代器。特殊情况下如果容器为空，则 begin 和 end 返回的是同一个迭代器。</p>
<p>~auto b = v.begin(), e = v.end();~</p>
<p>**** 迭代器运算符 #+CAPTION: 标准容器迭代器的运算符 | <em>iter | 返回迭代器 iter 所指元素的引用 | | iter-&gt;mem | 解引用 iter 并获取该元素的名为 mem 的成员，等价于(</em>iter).mem | | ++iter | 令 iter 指示容器中的下一个元素 | | –iter | 令 iter 指示容器中的上一个元素 | | iter1 == iter2 | 判断两个迭代器是否相等（不相等），如果两个迭代器指针的是同一个元素 | | iter1 != iter2 | 或者它们是同一个容器的尾后迭代器，则相等；反之，则相等 | **** 将迭代器从一个元素移动到另一个元素 迭代器使用递增（++）运算符来从一个元素移动到一下元素。从逻辑上来说，迭代器的递增和整数的递增类似，整数的递增是在整数值上”加 1“，迭代器的递增则是将迭代器”向前移动一个位置“。</p>
<p>#+BEGIN_QUOTE NOTE:</p>
<p>因为 end 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE 关键概念：泛型编程</p>
<p>之前已经说过，只有 string 和 vector 等一些标准库类型有下标运算符，而并非全都如此。与此类似，所有标准库容器和迭代器都定义了==和!=，但它们中的大多数都没有定义&lt;运算符。因此，只要我们养成使用迭代器和!=的习惯，就不用太再一用的到底是哪种容器类型。 #+END_QUOTE **** 迭代器类型 就像不知道 string 和 vector 的 size_type 成员到底是什么类型一样，一般来说我们也不知道（其实也无需知道）迭代器的精准类型。而实际上，哪些拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型：</p>
<p>#+BEGIN_SRC C++ vector<int>::iterator it; // it 能读写vector<int>的元素 string::iterator it2; // it2能读写string对象中的字符</p>
<p>vector<int>::const_iterator it3; // it3只能读元素，不能写元素 string::const_iterator it4; // it4只能读元素，不能写元素 #+END_SRC **** begin 和 end 运算符 为了便于专门得到 const_iterator 类型的返回值，C++新标准引入了两个新函数，分别是 cbegin 和 cend： ~auto it3 = v.cbegin(); // it3 的类型是 vector<int>::const_iterator **** 某些对 vector 对象的操作会使迭代器失效 虽然 vector 对象可以动态的增长，但是也会有一些副作用。已知的一个限制是不能在范围 for 循环中向 vector 对象添加元素。另外一个限制是任何一种可能改变 vector 对象容量的操作，比如 push_back，都会使该 vector 对象的迭代器失效。9.3.6 节将详细解释迭代器是如何失效的。</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>谨记，但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。 #+END_QUOTE *** 3.4.2 迭代器运算符 #+CAPTION: vector 和 string 迭代器支持的运算 | iter + n | 迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器其内的一个元素，或者指示容器尾元素的下一位置 | | iter - n | 迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或者指示容器其内的一个元素，或者指示容器尾元素的下一位置 | | iter += n | 迭代器加法的复合赋值语句，将 iter1 加 n 的结果赋给 iter1 | | iter -= n | 迭代器加法的复合赋值语句，将 iter1 减 n 的结果赋给 iter1 | | iter1 - iter2 | 两个迭代器相减的结构就是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向大是同一个容器中的元素或尾元素的下一位置 | | &gt;、 &gt;=、 &lt;、 &lt;= | 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向大是同一个容器中的元素或尾元素的下一位置 | **** 迭代器的算术运算 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧迭代器，其类型是名为 <em>different_type</em> 的带符号整数。string 和 vector 都定义了 different_type，因为这个距离可正可负，所以 different_type 是带符号类型的。 ** 3.5 数组 与 vector 相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置方位。与 vector 不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。</p>
<p>#+BEGIN_QUOTE Tip:</p>
<p>如果不清楚元素的确切个数，请使用 vector。 #+END_QUOTE *** 3.5.1 定义和初始化内置数组 定义数组的时候必须指定数组的类型，不允许用 auto 关键字由初始值的列表推断类型。另外和 vector 一样，数组的元素为对象，因此不存在引用的数组。 **** 不允许拷贝和赋值 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值：</p>
<p>#+BEGIN_SRC C++ int a[] = {0, 1, 2}; int a2[] = a; // 错误：不允许使用一个数组初始化另一个数组 a2 = a; // 错误，不能把一个数组直接赋给另一个数组 #+END_SRC</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>一些编译器支持数组的赋值，这就是所谓的 <em>编译器扩展</em> 。但一般来说，最好避免使用非标准特性，因为含有非标准它诶嗯的程序很可能在其他编译器上无法正常工作。 #+END_QUOTE **** 理解复杂的数组声明 和 vector 一样，数组能存放大多数类型的对象。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了：</p>
<p>#+BEGIN_SRC C++ int <em>ptrs[10]; // ptrs是含有10个整型指针的数组 int &amp;refs[10] = /</em> ? <em>/; // 错误：不不存在引用的数组 int (</em>Parray)[10] = &amp;arr; // Parray指向一个含有10个整数的数组 int (&amp;arrRef)[10] = arr; // arrRef引用一个含有10个整数的数组 #+END_SRC</p>
<p>#+BEGIN_QUOTE Tip:</p>
<p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 #+END_QUOTE *** 3.5.2 访问数组元素 在使用数组下标的时候，通常将其定义为 <em>size_t</em> 类型。size_t 是一种机器相关的无符号类型，它被设计的足够大一遍能表示内容中任意对象的大小。 *** 3.5.3 指针和数组 数组还有一个特定：在很多用到数组名字的地方，编译器都会自动将其替换为一个指向数组首元素的指针：</p>
<p>~string *p2 = nums; // 等价于p2 = &amp;nums[0]~</p>
<p>#+BEGIN_QUOTE Note:</p>
<p>在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。 #+END_QUOTE</p>
<p>#+BEGIN_SRC C++ int ia[] = {0,1,2,3,4,5,6,7,8,9}; auto ia2(ia); // ia2是一个整型指针，指向ia的第一个元素 ia2 = 43; // 错误：ia2是一个指针，不能用int值给指针赋值 #+END_SRC</p>
<p>尽管 ia 是由 10 个整数构成的数组，但当使用 ia 作为初始值时，编译器实际执行的初始化过程类型于下面的形式：</p>
<p>~auto ia2(&amp;ia[0]); // 显然ia2的类型是int *~</p>
<p>必须指出的是，当使用 decltype 关键字时上述转换不会发生，decltype(ia)返回的类型时由 10 个整数构成的数组：</p>
<p>#+BEGIN_SRC C++ // ia3时一个含有10个整数的数组 decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; ia3 = p; // 错误：不哪能用整型指针给数组赋值 ia3[4] = i; //正确：把i的值赋给ia3的一个元素 #+END_SRC **** 标准库函数 begin 和 end C++11 新标准引入了两个名为 begin 和 end 的函数。这两个函数与容器中的两个同名成员功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式时将数组作为它们的参数：</p>
<p>#+BEGIN_SRC C++ int ia[] = {0,1,2,3,4,5,6,7,8,9}; int <em>beg = begin(ia); // 指向ia首元素的指针 int </em>end = end(ia); // 指向arr尾元素的下一位置的指针 #+END_SRC</p>
<p>#+BEGIN_QUOTE Note:</p>
<p>一个指针如果指向了某种内置类型数组的尾元素的“下一个位置”，则其具备与 vector 的 end 函数返回的迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。 #+END_QUOTE **** 指针运算 两个指针相减的结果的类型时一种名为 <em>ptrdiff_t</em> 的标准库类型，和 size_t 一样，ptrdiff_t 也是一种定义在 cstddef 头文件中的机器相关类型。因为差值可能为负值，所以 ptrdiff_t 时一种带符号类型。 **** 下标和指针 标准库类型限定使用的下标必须粗时无符号类型，而内置的下标运算无此要求。</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>内置的下标运算符所用的索引值不是无符号类型，这一点与 vector 和 string 不一样。 #+END_QUOTE *** 3.5.5 与旧代码的接口 **** 混用 string 对象和 C 风格字符串 任何出现字符串字面值的地方都可以用以空字符串结束的字符数组来替代：</p>
<ul>
<li>允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。</li>
<li>在 string 对象的加法运算中允许使用以空字符串结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在 string 对象的复合赋值运算中允许使用以空字符结束的字符串数组作为右侧的运算对象。</li>
</ul>
<p>上述性质反过来就不成立了。为了完成该功能，string 专门提供了一个名为 c_str 的成员函数：</p>
<p>#+BEGIN_SRC C++ char <em>str = s; // 错误：不能用string对象初始化char</em> const char *str = s.c_str(); // 正确 #+END_SRC</p>
<p>我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前的数组失去效用。</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>如果执行完 c_str()函数后程序想一直都能使用其返回数组，最好将该数组重新拷贝一份。 #+END_QUOTE **** 使用数组初始化 vector 对象 可以使用数组来初始化 vector 对象。要实现这一亩的，只需要指明需要拷贝区域的首元素地址和尾后地址就可以了：</p>
<p>#+BEGIN_SRC C++ int int_arr[] = {0,1,2,3,4,5}; vector<int> ivec(begin(int_arr), end(int_arr)); #+END_SRC ** 3.6 多维数组 #+BEGIN_SRC C++ for (const auto &amp;row : ia) for (auto col : row) cout &lt;&lt; col &lt;&lt; endl; #+END_SRC</p>
<p>这个循环中并没有任何写操作，可是我们还是将外侧循环的控制变量声明成了引用类型，这是为了避免数组被自动转成指针（参见 3.5.3 节）</p>
<p>#+BEGIN_QUOTE Note:</p>
<p>要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该时引用类型。 #+END_QUOTE * 第 4 章 表达式 ** 4.1 基础 *** 4.1.1 基本概念 **** 左值和右值 C++的表格是要不然是 <em>右值</em> ，要不然就是 <em>左值</em> 。这两个名词是从 C 语言继承过来的，原本是为了帮助记忆：左值可以位于赋值语句的左侧，右值则不能。</p>
<p>在 C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表示的求值结果是对象，但它们是右值而非左值。可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</p>
<p>一个重要的原则（参见 13.6 节将介绍一种例外的情况）是在需要右值的地方可以用左值来替代，但是不能把右值当成左值（也就是位置使用）。当一个左值被当成右值使用时，实际使用的时它的内容（值）。 ** 4.4 赋值运算符 *** 赋值运算满足右结合律 赋值运算满足右结合律，这一点与其他二元运算烦不太一样。</p>
<p>#+BEGIN_SRC C++ int ival, jval; ival = jval = 0; // 正确：都被赋值为0 #+END_SRC</p>
<p>因为赋值运算符满足右结合律，所以靠右的赋值运算 jval=0 作为靠左的赋值运算符的右侧运算对象。又因为赋值运算返回的时其左侧运算对象，所以靠右的赋值运算结果（即 jval）被赋给了 ival。</p>
<p>对于多重赋值语句中的每一个对象，它的类型或者与右边对象的类型相同、或者可由右边对象的类型转换得到（参见 4.11 节）：</p>
<p>#+BEGIN_SRC C++ int ival, <em>pval; // ival的类型时int；pval时指向int的指针 ival = jval = 0; // 错误：不能把真值的值赋给int string s1, s2 s1 = s2 = “OK” // 字符串字面值“OK”转换成string对象 #+END_SRC </em>** 赋值运算优先级较低 #+BEGIN_QUOTE Note:</p>
<p>因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。 #+END_QUOTE *** 复合赋值运算符 任何一种复合运算符都完全等价于</p>
<p>~a = a op b;~</p>
<p>以为的区别是左侧运算对象的求值次数：使用复合运算符只求值一次，使用普通的运算符则求值两次。这两次包括：一次是作为右边子表达式的一部分求值，另一次是作为赋值运算的左侧运算对象求值。其实在很多地方，这种区别除了对程序性能有些许影响外几乎可以忽略不计。 ** 4.5 递增和递减运算符 递增和递减运算符有两种形式：前置版本和后只版本。到目前位置，本书使用的都是前置版本，这种形式的运算符首先将运算对象加 1（或减 1），然后将改变后的对象作为求值结果。后置版本也会将运算对象加 1（或减 1），但是求值结果是运算对象改变之前那个值的副本：</p>
<p>#+BEGIN_SRC C++ int i = 0, j; j = ++i; // j = 1, i = 1：前置版本得到递增之后的值 j = i++; // j = 1, i = 2：后置版本得到递增之前的值 #+END_SRC</p>
<p>建议：除非必须，否则不用递增递减运算符的后置版本 *** 运算对象可按任意顺序求值 大多数运算符都没有规定运算对象的求值顺序（参见 4.1.3 节），这在一般情况下不会有什么印象。然而，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错误这两个运算符。</p>
<p>#+BEGIN_SRC C++ // 该循环的行为是未定义的 while (beg != s.end() &amp;&amp; !isspace(<em>beg)) </em>beg = toupper(*beg++) // 错误：该赋值语句未定义 #+END_SRC</p>
<p>赋值运算符左右两端的运算对象都用到了 beg，并且右侧的运算对象还改变了 beg 的值，所以该赋值语句是未定义的。编译器可能按照下面任意一种思路处理该表达式：</p>
<p>#+BEGIN_SRC C++ <em>beg = toupper(</em>beg); // 如果先求左侧的值 <em>(beg + 1) = toupper(</em>beg); // 如果先求右侧的值 #+END_SRC</p>
<p>也可能采取别的什么方式处理它。 ** 4.7 条件运算符 条件运算符按照如下形式使用：</p>
<p>~cond ? expr1 : expr2~</p>
<p>当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果时左值；否则运算的结果时右值。 *** 嵌套条件运算符 条件运算符满足右结合律，意味着运算对象（一般）按照从右向左的顺序结合。 *** 在输出表达式中使用条件运算符 条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。 ** 4.8 位运算符 #+CAPTION: 位运算符（左结合律） | 运算符 | 功能 | 用法 | |——–+——–+—————–| | ~ | 位求反 | ~ expr | | &lt;&lt; | 左移 | expr1 &lt;&lt; expr2 | | &gt;&gt; | 右移 | expr1 &gt;&gt; expr2 | | &amp; | 位与 | expr &amp; expr | | ^ | 位异或 | expr ^ expr | | | 位或 | expr expr |</p>
<p>如果运算对象时带符号的且它的值为负，那么位运算符如果处理运算对象的“符号位”依赖于机器。而且，此时的左移操作可能会改变符号位的值，因此时一种未定义的行为。</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。 #+END_QUOTE *** 移位运算符 <em>左移运算符</em> ( =&lt;&lt;= )在右侧插入值为 0 的二进制位。 <em>右移运算符</em> ( =&gt;&gt;= )的行为则依赖于其左侧运算对象的类型：如果该运算对象时无符号类型，在左侧插入值为 0 的二进制位；如果该运算对象时带符号类型，在左侧插入符号位的副本或值为 0 的二进制位，如何选择要视具体环境而定。 *** 位与、位或、位异或运算符 对于 <em>位与运算符</em> (&amp;)来说，如果两个运算对象的对应位置都是 1 则运算结果中该位为 1，否则为 0。对于 <em>位或运算符</em> (|)来说，如果两个运算符对象的对应位置至少有一个为 1 则运算结果中该位为 1，否则为 0。对于 <em>位异或运算符</em> (^)来说，如果两个运算对象的对应位置有且仅有一个为 1 则运算结果中该位为 1，否则为 0。 *** 移位运算符（又叫 IO 运算符）满足左结合律 移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。因此在一次使用多个运算符时，有必要在适当的地方加上括号使其满足我们的要求。 ** 4.9 sizeof 运算符 sizeof 运算符返回一条表达式或一个类型名字所占的字节数。sizeof 运算符满足右结合律，其所得的值是一个 size_t 类型（参见 3.5.2 节）的常量表达式（参见 2.4.4 节）。运算符的运算对象有两种形式：</p>
<p>#+BEGIN_SRC sizeof (type) sizeof expr #+END_SRC</p>
<p>在第二种形式中，sizeof 返回的时表达式结果类型的大小。与众不同的一点时，sizeof 并不实际计算其运算对象的值。</p>
<p>C++新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但 sizeof 运算符无须我们提供一个具体的对象，因为要想知道类成员的大小无须真的获取该成员。 ** 4.10 逗号运算符 对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果时右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 ** 4.11 类型转换 在 C++语言中，某些类型之间有关联。如果两种类型有关联，那么当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代。换句话说，如果两种类型可以 <em>相互转换</em> ，那么它们就是关联的。</p>
<p>C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一后再求值。上述的类型转换时自动执行的，无须程序的接入，有时甚至不需要程序员了解。因此，它们被称作 <em>隐式转换</em> 。 *** 4.11.1 算术转换 <em>算术转换</em> 的含义是把一种算术类型转换成另外一种算术类型，这一点在 2.1.2 节中已有介绍。算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。 **** 整型提升 <em>整型提升</em> 负责把小整数类型转换成较大的整数类型。 **** 无符号类型的运算对象 如果一个运算对象是无符号类型、另一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。</p>
<p>剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号的类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。 *** 4.11.2 其他隐式类型转换 <em>数组转换成指针</em> ：在大多数用到数组的表达式中，数组字的自动转换成指向数组首元素的指针：</p>
<p>当数组被用多 decltype 关键字的参数，或者作为取地址符（&amp;）、sizeof 及 typeid 等运算符的运算对象时，上述转换不会发生。</p>
<p><em>指针的转换</em> ：C++还规定了几种其他的指针转换方式，包括常量整数值 0 或者字面值 nullptr 能转换成任意指针类型；指向任意非常量的指针能转换成 void<em>；指向任意对象的指针能转换成 const void</em>。</p>
<p><em>转换成常量</em> ： 允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。也就是说，如果 T 时一种类型，我们就能将指向 T 的指针或引用分别转换成指向 const T 的指针或引用。相反的转换并不存在，因为它试图删掉底层 const。</p>
<p><em>类类型定义的转换</em> ：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。 *** 4.11.3 显式转换 #+BEGIN_QUOTE WARNING:</p>
<p>虽然有时不得不使用强制类型转换，但这种方法本质上时非常危险的。 #+END_QUOTE **** 命名的强制类型转换 一个命名的强制类型转换具有如下形式：</p>
<p><sub>cast-name<type>(expression);</sub></p>
<p>其中 type 是转换的目标类型而 expression 是要转换的值。如果 type 是引用类型，则结果是左值。cast-name 是 <em>static_cast</em> 、 <em>dynamic_cast</em> 、 <em>const_cast</em> 、 <em>reinterpret_cast</em> 中的一种 dynamic_cast 支持类型识别，我们将在 19.2 节对其左更详细的介绍。cast-name 指定了执行的是哪种转换。 **** static_cast 任何具有明确定义的类型转换，只要不包含底层 const，都可以使用 static_cast。 **** const_cast const_cast 只能改变运算对象的底层 const（参见 2.4.3 节）。</p>
<p>对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉 const 性质” **** reinterpret_cast reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。例如：</p>
<p>#+BEGIN_SRC C++ int <em>ip; char </em>pc = reinterpret_cast&lt;char*&gt;(ip); #+END_SRC</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>reinterpret_cast 本质上依赖于机器。要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解。 #+END_QUOTE **** 旧式的强制类型转换 在早期版本的 C++语言中，显式地进行强制类型转换包含两种形式：</p>
<p>#+BEGIN_EXAMPLE type (expr); // 函数形式的强制类型转换 (type) expr; // C语言风格的强制类型转换 #+END_EXAMPLE</p>
<p>根据所涉及的类型不同，旧式的强制类型转换分别具有于 const_cast、 static_cast 或 reinterpret_cast 相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成 const_char 和 static_cast 也合法，则其行为与对应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与 reinterpret_cast 类似的功能：</p>
<p>~char <em>pc = (char</em>) ip; // ip是指向整数的指针~</p>
<p>的效果与使用 reinterpret_cast 一样。</p>
<p>#+BEGIN_QUOTE WARNING:</p>
<p>于命名的强制类型转换相比，旧式的强制类型转换从表现形式来说不是那么清晰明了，容易被看漏，所以一旦转换过程出现问题，追踪起来也更加困难。 #+END_QUOTE * 第 5 章 语句 ** 5.1 简单语句 *** 复合语句（块） <em>复合语句</em> 是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作 <em>块</em> 。一个块就是一个作用域（参见 2.2.4 节），再块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在的（最内层）块的节为为止。 ** 5.2 语句作用域 定义在控制结构中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了。 ** 5.3 条件语句 *** 5.3.1 if 语句 **** 悬垂 else 当一个 if 语句嵌套在另一个 if 语句内部时，很可能 if 分支会多于 else 分支。这时候问题出现了：我们怎么知道某个给定 else 是和哪个 if 匹配呢？</p>
<p>这个问题通常称作 <em>悬垂 else</em> ，在那些即有 if 语句又有 if else 语句的编程语句中是个普遍存在的问题。不同语言解决该问题的思路也不同，就 C++而言，它规定 else 与离它最近的尚未匹配的 if 匹配，从而消除了程序的二义性。 *** 5.3.2 switch 语句 case 关键字和它对象的值一起被称为 <em>case 标签</em> 。case 标签必须是整型常量表达式（参见 2.4.4 节）：</p>
<p>#+BEGIN_SRC C++ char ch = getVal(); int ival = 42; switch(ch) { case 3.14; // 错误：case标签不是一个整数 case ival; // 错误：case标签不是一个常量 } #+END_SRC **** switch 内部的变量定义 如前所述，siwtch 的执行流程有可能会跨过某些 case 标签。如果程序跳转到了某个特定的 case，则 switch 结果中该 case 标签之前的部分会被忽略掉。这种忽略掉一部分代码的行为引出了一个有趣的问题：如果被略过的代码中含有变量的定义该怎么办？</p>
<p>答案是：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。</p>
<p>#+BEGIN_SRC C++ case true: // 因为程序的执行流程可能绕开下面的初始化语句，所以该switch语句不何方 string file_name; // 错误：控制流绕过一个隐式初始化的变量 int ival = 0; // 错误：控制流绕过一个显示初始化的变量 int jval; // 正确：因为jval没有初始化 break; case false: // 正确：jval虽然在作用域内，但它没有被初始化 jval = next_num(); // 正确：给jval赋一个值 #+END_SRC</p>
<p>C++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。 ** 5.4 迭代语句 *** 5.4.1 while 语句 #+BEGIN_QUOTE Note:</p>
<p>定义在 while 条件部分或者 while 循环体内的变量每次迭代都经历从创建到销毁的过程。 #+END_QUOTE *** 5.4.2 传统的 for 语句 #+BEGIN_QUOTE Note：</p>
<p>牢记 for 语句头中定义的对象只在 for 循环体内可见。 #+END_QUOTE *** 5.4.3 范围 for 语句 C++11 新标准引入了一种更简单的 for 语句，这种语句可以遍历容器或其他序列的所有元素。 <em>范围 for 语句</em> 的语法形式是：</p>
<p>#+BEGIN_EXAMPLE for (declaration : expression) statement #+END_EXAMPLE</p>
<p>expression 表示的必须是一个序列，比如用花括号或起来的初始值列表（参见 3.3.1 节）、数组或者 vector 或 string 等类型的对象，这些类型的共同特点是拥有能返回迭代器的 begin 和 end 成员（参见 3.4 节）。</p>
<p>declaration 定义一个变量，序列中的每个元素都能转换成该变量的类型（参见 4.11 节）。确保类型相容最简单的办法是使用 auto 类型说明符（参见 2.5.2 节），这个关键字可以令编译器帮助我们指定合适的类型。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。</p>
<p>每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行 statement。像往常一样，statement 可以是一条单独的语句也可以是一个块。所有元素都处理完毕后循环终止。 *** 5.4.4 do while 语句 #+BEGIN_EXAMPLE do statement while (condition); #+END_EXAMPLE</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>do while 语句应该在括号包围起来的条件后面用一个分号表示语句结束。 #+END_QUOTE</p>
<p>condition 使用的变量必须定义在循环体之外。 ** 5.5 跳转语句 *** 5.5.3 goto 语句 goto 语句的语法形式是</p>
<p>~goto label;~</p>
<p>其中，label 是用于标识一条语句的标识符。 <em>带标签语句</em> 是一种特殊的语句，在它之前有一个标识符以及一个冒号：</p>
<p>~end: return; // 带标签语句，可以作为goto的目标~</p>
<p>标签提示符独立于变量和其他提示符的名字，因此，标签提示符可以和程序中其他实体的提示符使用同一个名字而不会互相干扰。goto 语句和控制权专项的那条代表前的语句必须位于同一个函数内。</p>
<p>和 switch 语句类型，goto 语句也不能将程序的控制权从变量的作用域之外转义到作用域之内：</p>
<p>#+BEGIN_SRC C++ // … goto end; int ix = 10; // 错误：goto语句绕过了一个带初始化的变量定义 end: // 错误：此处的代码需要使用ix，但是goto语句绕过了它的声明 ix = 42; #+END_SRC</p>
<p>向后跳过一个已经执行的定义是合法的。跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：</p>
<p>#+BEGIN_SRC C++ // 向后跳过一个带初始化的变量定义是合法的 begin: int sz = get_size(); if (sz &lt;= 0) { goto begin; } #+END_SRC ** 5.6 try 语句块和异常处理 异常处理机制为程序中异常检测的异常处理这两部分的协作提供支持。在 C++语言中，异常处理包括： - <em>throw 表达式</em> ，异常检测部分使用 throw 表达式来表示它遇到了无法处理的问题。我们说 trhow <em>引发</em> 了异常。 - <em>try 语句块</em> ，异常处理部分使用 try 语句块处理异常。try 语句块以关键字 try 开始，并以一个或多个 <em>catch 子句</em> 结束。try 语句块中代码抛出的异常通常会被某个 catch 子句处理。因为 catch 子句“处理”异常，所以它们也被称作 <em>异常处理代码</em> 。 - 一套 <em>异常类</em> ，用于在 throw 表达式和相关的 catch 子句之间传递异常的具体信息 *** 5.6.1 throw 表达式 程序的异常检测部分使用 throw 表达式引发一个异常。throw 表达式包含关键字 throw 和紧随其后的一个表达式，其中表的是的类型就是抛出的异常类型。 *** 5.6.2 try 语句块 try 语句块的通用语法形式是</p>
<p>#+BEGIN_SRC C++ try { program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } // … #+END_SRC</p>
<p>跟在 try 块之后的是一个或多个 catch 子句。catch 子句包括三个部分：关键字 catch、括号内的一个（可能未命名的）对象的声明（称作 <em>异常声明</em> ）以及块。当选中了某个 catch 子句处理异常之后，执行与之对应的块。catch 一旦完成，程序跳转到 try 语句块最后一个 catch 子句之后的那条语句继续执行。</p>
<p>try 语句块中的 program-statements 组成程序的正常逻辑，像其他任何块一样，program-statements 可以有包括声明在内的任意 C++语句。一如往常，try 语句块内声明的变量在块外部无法访问，特别是在 catch 子句内也无法访问。 **** 函数在寻找处理代码的过程中退出 在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个 try 语句块。例如，一个 try 语句块可能调用了包含另一个 try 语句块的函数，新的 try 语句块可能调用了包含又一个 try 语句块的新函数，以此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没有找到匹配的 catch 子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着调成的执行路径逐层回退，知道找到适当类型的 catch 子句为止。</p>
<p>如果最终还是没能找到匹配的 catch 子句，程序转到名为 <em>terminate</em> 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。 *** 5.6.3 标准异常 C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在 4 个头文件中： - exception 头文件定一个了最通用的异常类 exception。它只报告异常的发生，不提供任何额外信息。 - stdexcept 头文件定义几种常用的异常类，详细信息在下表中列出。 - new 头文件定义了 bad_alloc 异常类型，这种类型将在 12.1.2 节详细介绍 - type_info 头文件定义了 bad_cast 异常类型，这种类型将在 19.2 节详细介绍。</p>
<p>#+CAPTION: <stdexcept>定义的异常类 | exception | 最常见的问题 | | runtime_error | 只有在运行时才能检测出问题 | | range_error | 运行时错误：生成的结果超出了有意义的值域范围 | | overflow_error | 运行时错误：计算上溢 | | underflow_error | 运行时错误：计算下溢 | | logic_error | 程序逻辑错误 | | domain_error | 逻辑错误：参数对应的结果只不存在 | | invalid_argument | 逻辑错误：无效参数 | | length_error | 逻辑错误：试图创建一个超出该类型最大长度的对象 | | out_of_rang | 逻辑错误：使用一个超出有效范围的值 |</p>
<p>我们只能以默认初始化（参见 2.2.1 节）的方式初始化 exception、bad_alloc 和 bad_cast 对象，不允许为这些对象提供初始值。</p>
<p>其他异常类型的行为则恰好相反：应该使用 string 对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方法。当创建此类对象时，必须提供初始化值，该初始值含有错误相关的信息。</p>
<p>异常类型只定义了一个名为 what 的成员函数，该函数没有任何参数，返回值时一个指向 C 风格字符串（参见 3.5.4 节）的 const char*。该字符串的亩的时提供关于异常的一些文本信息。</p>
<p>what 函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则 what 返回该字符串。对于其他无初始值的异常类型来说，what 返回的内容由编译器决定。 * 第 6 章 函数 ** 6.1 函数基础 我们通过 <em>调用运算符</em> 来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号之内是一个用逗号隔开的实参列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。 *** 6.1.1 局部对象 **** 自动对象 对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在块末尾时销毁它。我们把只存在于块执行期间的对象称为 <em>自动对象</em> 。当块的执行结束后，块中创建的自动对象的值就编程未定义的了。 **** 局部静态对象 <em>局部静态对象</em> 在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，再次期间即使对象所在的函数结束也不会对它有影响。 *** 6.1.2 函数声明 因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字还是有用初的，它可以帮助使用者更好地理解函数的功能：</p>
<p>#+BEGIN_SRC C++ void print(vector<int>::const_iterator beg, vector<int>::const_iterator end); #+END_SRC</p>
<p>函数的三要素（返回类型、函数名、形参类型）描述的函数的接口，说明了调用该函数所需的全部信息。函数声明也被称作 <em>函数原型</em> 。 ** 6.2 参数传递 当形参时引用类型时，我们说它对应的实参被 <em>引用调用</em> 或者函数被 <em>传引用调用</em> 。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参时它对应的实参的别名。</p>
<p>当实参的值被拷贝给形参时，形参和实参时两个互相独立的对象。我们说这样的实参被 <em>值传递</em> 或者函数被 <em>传值调用</em> 。 *** 6.2.2 传引用参数 **** 使用引用避免拷贝 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括 IO 类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p>
<p>#+BEGIN_QUOTE Best Practies:</p>
<p>如果函数无须改变引用形参的值，最好将其声明为常量引用。 #+END_QUOTE *** 6.2.4 数组形参 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组（参见 3.5.1 节）以及使用数组时（通常）会将其转换成指针（参见 3.5.3 节）。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</p>
<p>尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p>
<p>#+BEGIN_SRC C++ // 进款形式不同，但这三个print函数是等价的 // 每个函数都有一个const int<em>类型的形参 void print(const int</em>); void print(const int[]); // 可以看出来，函数的意图是作用域一个数组 void print(const int[10]); // 这里的维度表示我们期望数组含有多少元素，实际不一定 #+END_SRC</p>
<p>如果我们传给 print 函数的是一个数组，则实参自动低转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。 **** 数组引用形参 C++语言允许将变量定义成数组的引用（参见 3.5.1 节），基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定对应的实参上，俄语就是绑定到数组上：</p>
<p>#+BEGIN_SRC C++ // 正确：形参是数组的引用，未读是类型的一部分 void print(int (&amp;arr)[10]) { for (auto elem : arr) cout &lt;&lt; elem &lt;&lt; endl; } #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>&amp;arr 两端的括号必不可少（参见 3.5.1 节）</p>
<p>f(int &amp;arr[10]) // 错误：将 arr 声明成了引用的数组 f(int (&amp;arr)[10]) // 正确：arr 是具有 10 个整数的整型数组的引用 #+END_QUOTE **** 传递多维数组 和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针（参见 3.6 节）。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略：</p>
<p>#+BEGIN_SRC C++ // matrix指向数组的有元素，该数组的元素是由10个整数构成的数组 void print(int (<em>matrix)[10], int rowSize) { /</em> … */ } #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>再一次强调，<em>matrix 两端的括号必不可少： int </em>matrix[10]; // 10 个指针构成的数组 int (*matrix)[10]; // 指向含有 10 个整数的数组的指针 #+END_QUOTE</p>
<p>我们也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内：</p>
<p>#+BEGIN_SRC C++ // 等价定义 void print(int matrix[][10], int rowSize) { /* … */ } #+END_SRC</p>
<p>matrix 的声明看起来是一个二维数组，实际上形参是指向含有 10 个整数的数组的指针。 *** 6.2.6 含有可变形参的函数 为了编写能处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：如果所有的实参类型型钢，可以传递一个名为 initializer_list 的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在 16.4 节介绍。 **** initializer_list 形参 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用 <em>initializer_list</em> 类型的形参。initializer_list 是一种标准库类型，用于表示某种特定类型的值的数组（参见 3.5 节）。initializer_list 类型定义在同名头文件中，它提供的操作如下表所示。</p>
<p>#+CAPTION: initializer_list 提供的操作 | initializer_list<T> lst; | 默认初始化；T类型元素的空列表 | | initializer_list<T> lst{a,b,c…}; | lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const | | lst2(lst) | 拷贝或赋值一个 initializer_list 对象不会拷贝列表中的元素； | | lst2 = lst | 拷贝后原是列表和副本共享元素 | | lst.size() | 列表中的元素数量 | | lst.begin() | 返回指向 lst 中首元素的指针 | | lst.end() | 返回 lst 中尾元素下一位置的指针 |</p>
<p>和 vector 一样，initializer_list 也是一种模板类型（参见 3.3 节）。和 vector 不一样的是，initializer_list 对象中的元素永远是常量值，我们无法改变 initializer_list 对象中元素的值。 **** 省略符形参 省略符形参是为了便于 C++程序访问某些特殊的 C 代码而设置的，这些代码使用了名为 varargs 的 C 标准库功能。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>省略符形参硬仅仅用于 C 和 C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。 #+END_QUOTE</p>
<p>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：</p>
<p>#+BEGIN_SRC C++ void foo(parm_list, …); void foo(…); #+END_SRC ** 6.3 返回类型和 return 语句 *** 6.3.2 有返回值函数 return 语句返回值的类型必须与函数的返回值类型相同，或能隐式的转换成（参见 4.11 节）函数的返回类型。 **** 值时如何被返回的 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。 **** 不要返回局部对象的引用或指针 函数完整后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。</p>
<p>如前所述，返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。 **** 引用返回左值 函数的返回类型决定函数调用是否是左值（参见 4.1.1 节）。调用一个返回引用的函数得到左值，其他返回了类型得到右值。可以像使用其他左值那样来使用返回引用的函数调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值：</p>
<p>#+BEGIN_SRC C++ char &amp;get_val(string &amp;str, string::size_type ix){ return str[ix]; // get_val假定索引值是有效的 }</p>
<p>int main { string s(“a value”); cout &lt;&lt; s &lt;&lt; endl; // 输出a value get_val(s, 0) = ‘A’; // 将s[0]的值改为A cout &lt;&lt; s &lt;&lt; endl; // 输出A value</p>
<p>return 0; } #+END_SRC</p>
<p>把函数调用放在赋值语句的左侧可能看起来有点奇怪，但其实这没什么特别的。返回值是引用，因此调用是个左值，和其他左值一样它也能出现在赋值运算符的左侧。 **** 列表初始化返回值 C++11 新标准规定，函数可以返回花括号的值的列表。类似于其他返回结果，此初的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化（参见 3.3.1 节）；否则，返回的值由函数的返回类型决定。</p>
<p>如果函数返回的内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间（参见 2.2.1 节）。如果函数返回的是类类型，由类本身定义初始值如何使用（参见 3.3.1 节）。 *** 6.3.3 返回数组指针 因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。虽然从语法上来说，要想定义个返回数组的指针或引用的函数比较凡所，但是有一些方法可以简化这一任务，其中最直接的办法是使用类型别名（参见 2.5.1 节）：</p>
<p>#+BEGIN_SRC C++ typedef int arrT[10]; // arrT是一个类型比诶嗯，它表示的类型是含有10个整数的数组 using arrT = int[10]; // arrT的等价声明 arrT* func(int i); // func返回一个指向含有10个整数的数组指针 #+END_SRC **** 声明一个返回数组指针的函数 要想在声明 func 时不适用类型别名，我们必须牢记被定义的名字后面数组的维度：</p>
<p>#+BEGIN_SRC C++ int arr[10]; // arr时一个含有10个整数的数组 int <em>p1[10]; // p1时一个函数10个指针的数组 int (</em>p2)[10] = &amp;arr // p2时一个指针，它指向含有10个整数的数组 #+END_SRC</p>
<p>和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：</p>
<p>~Type (*function(parameter_list))[dimension]~</p>
<p>类似于其他数组的声明，Type 表示元素的类型，dimension 表示数组的大小。(*function(parameter_list))两端的扩招 i 必须存在，就像我们定义 p2 时两端必须有括号一样。如果没有这对括号，函数的返回类型将是指针的函数。</p>
<p>举个具体点的例子。下面这个 func 函数的声明没有使用类型别名：</p>
<p>~int (*func(int i))[10];~</p>
<p>可以按照以下的顺序来逐层理解该声明的含义：</p>
<ul>
<li>func(int i)表示调用 func 函数时需要一个 int 类型的实参。</li>
<li>(*func(int i))意味着我们可以对函数调用的结果执行解引用操作。</li>
<li>(*func(int i))[10]表示解引用 func 的调用将得到一个大小时 10 的数组。</li>
<li>int (<em>func(int i))[10]表示数组中的元素时 int 类型。 </em>*** 使用尾置返回类型 在 C++11 标准中还有一种可以简化上述 func 声明的方法，就是使用 <em>尾置返回类型</em> 。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是函数的指针或数组的引用。尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个 auto：</li>
</ul>
<p>#+BEGIN_SRC C++ // func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组 auto func(int i) -&gt; int(<em>)[10]; #+END_SRC </em>*** 使用 decltype 还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用 decltype 关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数 i 的不同指向两个已知数组中的一个：</p>
<p>#+BEGIN_SRC C++ int odd[] = {1,3,5,7,9}; int even[] = {0,2,4,6,8}; // 返回一个指针，该指针指向含有5整数的数组 decltype(odd) *arrPtr(int i) { return {i % 2} ? &amp;odd : &amp;even; // 返回一个指向数组的指针 } #+END_SRC</p>
<p>有一个地方需要注意：decltype 并不负责把数组类型转换成对应的指针，所以 decltype 的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个*符号。 <strong> 6.4 函数重载 如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为 <em>重载函数</em> 。 </strong>** 定义重载函数 不允许两个函数除了返回类型外其他所有的要素都相同。假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的：</p>
<p>#+BEGIN_SRC C++ Record looksup(const Account&amp;); bool looksup(const Account&amp;); // 错误：与上一个函数相比只有返回类型不同 #+END_SRC **** 重载和 const 形参 如果 6.2.3 节介绍的，顶层 const 不影响传入函数的对象。一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来。</p>
<p>#+BEGIN_SRC C++ Record looksup(Phone); Record looksup(Const Phone); // 重复声明了Record looksup(Phone)</p>
<p>Record looksup(Phone<em>); Record looksup(Phone</em> const); // 重复声明了Record looksup(Phone*) #+END_SRC</p>
<p>另一个方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的 const 是底层的。</p>
<p>#+BEGIN_SRC C++ // 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同 // 定义4个独立的重载函数 Record looksup(Account&amp;); // 函数作用于Account的引用 Record looksup(const Account&amp;); // 新函数，作用于常量引用</p>
<p>Record looksup(Account<em>); // 新函数，作用域指向Account的指针 Record looksup(const Account</em>); // 新函数，作用于指向常量的指针 #+END_SRC</p>
<p>在上面的例子中，编译器可以通过实参是否是常量来推断应该调用哪个函数。因为 const 不能转换成其他其类型（参见 4.11.2 节），所以我们只能把 const 对象（或指向 const 的指针）传递给 const 形参。相反的，因为非常量可以转换成 const，所以上面的 4 个函数都能作用于非常量对象或指向非常量对象的指针。不过，如 6.6.1 节降妖介绍的，当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。 **** const_cast 和重载 #+BEGIN_SRC C++ const string &amp;shorterString(const string &amp;s1, const string &amp;s2) { return s1.size() &lt;= s2.size() ? s1 : s2; } #+END_SRC</p>
<p>#+BEGIN_SRC C++ string &amp;shorterString(string &amp;s1, string &amp;s2) { auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1), const_cast&lt;const string&amp;&gt;(s2));</p>
<p>return const_cast&lt;string&amp;&gt;(r); } #+END_SRC</p>
<p>在这个版本的函数中，首先将它的实参强制转换成对 const 的引用，然后调用了 shorterString 函数的 const 版本。const 版本返回对 const string 的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的 string&amp;，这显示是安全的。 **** 调用重载的函数 <em>函数匹配</em> 是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做 <em>重载确定</em> 。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。</p>
<p>现在我们需要章武的是，当调用重载函数时有三种可能的结果：</p>
<ul>
<li>编译器找到一个与实参 <em>最佳匹配</em> 的函数，并声称调用该函数的代码。</li>
<li>找不到任何一个函数与调用的实参匹配，此时编译器发出 <em>无匹配</em> 的错误信息 *** 6.4.1 重载与作用域 一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。剩下的工作就是检查函数是否有效了。</li>
</ul>
<p>#+BEGIN_QUOTE Note：</p>
<p>在 C++语言中，名字找查发生在类型检查之前。 #+END_QUOTE ** 6.5 特殊用途语言特性 **** 默认实参声明 对于函数的声明来说，通常的习惯时将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为值前那些没有默认值的形参添加默认实参，而且该形参右侧所有形参必须都有默认值。 **** 默认实参初始值 局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：</p>
<p>#+BEGIN_SRC C++ // wd、def和ht的声明必须出现在函数之外 sz wd = 80; char def = ’ ‘; sz ht(); string screen(sz = ht(), sz = wd, char = def); string window = screen(); // 调用screen(ht(), 80,’ ’) #+END_SRC</p>
<p>用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时。 *** 6.5.2 内联函数和 constexpr 函数 **** 内联函数可避免函数调用的开销 将函数指定为 <em>内联函数</em> ，通常就是将它在每个调用点上“内联地”展开。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 #+END_QUOTE</p>
<p>一般来说，内联机制用于优化规模较小，流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个 75 行的函数也不大可能在调用点内联地展开。 **** constexpr 函数 <em>constexpr 函数</em> 是指能用于常量表达式（参见 2.4.4 节）的函数。定义 constexpr 函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型（参见 2.4.4 节），而且函数体中必须有且只有一条 return 语句：</p>
<p>#+BEGIN_SRC C++ constexpr int new_sz() { return 42; } constexpr int foo = new_sz(); // 正确：foo是一个常量表达式 #+END_SRC</p>
<p>执行该初始化任何时，编译器把对 constexpr 函数的调用替换成其结果只。为了能在编译过程中随时展开，constexpr 函数被隐式地指定为内联函数。</p>
<p>constexpr 函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr 函数中可以有空语句、类型别名（参见 2.5.1 节）以及 using 声明。</p>
<p>#+BEGIN_QUOTE Note:</p>
<p>constexpr 函数不一定返回常量表达式。 #+END_QUOTE **** 把内联函数和 constexpr 函数放在头文件内 和其他函数不一样，内联函数的 constexpr 函数可以在程序中多次定义。毕竟，编译器想展开函数仅有函数声明是不够的，还需要函数的定义。不过对于某个给定的内联函数或者 constexpr 函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和 constexpr 函数通常定义在头文件中。 *** 6.5.3 调试帮助 **** assert 预处理宏 <em>assert</em> 是一种 <em>预处理宏</em> 。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert 宏使用一个表达式作为它的条件：</p>
<p><sub>assert(expr);</sub></p>
<p>首先对 expr 求值，如果表达式为假（即 0），assert 输出信息并终止程序的执行。如果表达式为真（即非 0），assert 什么也不做。 **** NDEBUG 预处理变量 assert 的行为依赖于一个名为 NDEBUG 的预处理变量的状态。如果定义了 NDEBUG，则 assert 什么也不做。默认状态下没有定义 NDEBUG，此时 assert 将执行运行时检查。</p>
<p>我们可以使用一个#define 语句定义 NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：</p>
<p>~$ CC -D NDEBUG main.c~</p>
<p>这条命令的作用等级与在 main.c 文件的一开始写#define NDEBUG。</p>
<p>除了用于 assert 外，也可以使用 NDEBUG 编写自己的条件调试代码。如果 NDEBUG 未定义，将执行#ifndef 和#endif 之间的代码；如果定义了 NDEBUG，这些代码将被忽略掉：</p>
<p>#+BEGIN_SRC C++ void print(const int ia[], size_t size) { #ifndef NDEBUG // <strong>func</strong> 是编译器定义的一个局部静态变量，用于存放函数的名字 cerr &lt;&lt; <strong>func</strong> &lt;&lt; “: array size is” &lt;&lt; size &lt;&lt; endl; #endif // … } #+END_SRC</p>
<p>除了 C++编译器定义的__func__之外，预处理器还定义了另外 4 个对于程序调试很有用的名字：</p>
<p>=<strong>FILE</strong>= 存放文件名的字符串字面值</p>
<p>=<strong>LINE</strong>= 存放当前行号的整型字面值。</p>
<p>=<strong>TIME</strong>= 存当文件编译时间的字符串字面值。</p>
<p>=<strong>DATE</strong>= 存放文件编译时期的字符串字面值。 ** 6.6 函数匹配 **** 确定候选函数和可行函数 函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为 <em>候选函数</em> 。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。</p>
<p>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为 <em>可行函数</em> 。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。 **** 寻找最佳匹配（如果有的话） 函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。下一节将介绍“最匹配”的细节，它的基本思想是，实参类型与形参类型越接近，它们匹配得越好。 **** 含有多个形参的函数匹配 当实参的数量有两个或更多时，函数匹配就比较复杂了。</p>
<p>选择可行函数的方法和只有一个实参时一样，编译器选择那些形参数量满足要求且实参类型和形参类型能够匹配的函数。</p>
<p>如果有且只有一个函数满足下列条件，则匹配成功：</p>
<ul>
<li>该函数每个实参的匹配都不劣于其他可行函数需要的匹配</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
</ul>
<p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用时错误的。编译器将报告二义性调用的信息。</p>
<p>#+BEGIN_QUOTE Best Practies：</p>
<p>调用函数时应仅两避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。 #+END_QUOTE *** 6.6.1 实参类型转换 为了确定最佳匹配，编译器将实参类型到形参类型的转换划分称为几个等级，具体排序如下所示：</p>
<ol type="1">
<li>精确匹配，包括以下情况：
<ul>
<li>实参类型和形参类型相同。</li>
<li>实参从数组类型或函数类型转换成对应的指针。</li>
<li>向实参添加顶层 const 或者从实参中删述顶层 const。</li>
</ul></li>
<li>通过 const 转换实现的匹配（参见 4.11.2 节）。</li>
<li>通过类型体呈实现的匹配（参见 4.11.1 节）。</li>
<li>通过算术类型转换（参见 4.11.1 节）或者指针转换（参见 4.11.2 节）实现的匹配。</li>
<li>通过类类型转换实现的匹配（参见 14.9 节） **** 需要类型提供和算术类型转换的匹配 所有算术类型转换的级别都一样。例如，从 int 向 unsigned int 的转换并不比从 int 向 double 的转换级别高。 ** 6.7 函数指针 函数的类型由它的返回类型和形参类型共同决定，与函数名无关。例如：</li>
</ol>
<p>~bool lengthCompare(const string &amp;, const string &amp;);~</p>
<p>该函数的类型时 bool(const string&amp;, const string&amp;)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：</p>
<p>#+BEGIN_SRC C++ // pf指向一个函数，该函数的参数时两个const string的引用，返回值是bool类型 bool (*pf)(const string &amp;, const string &amp;); /// 未初始化 #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>*pf 两端的括号必不可少。如果不写这对括号，则 pf 是一个返回值为 bool 指针的函数：</p>
<p>bool <em>pf(const string &amp;, const string &amp;); #+END_QUOTE </em>*** 使用函数指针 当我们把函数名作为一个值使用时，该函数自动地转换成指针。</p>
<p>#+BEGIN_SRC C++ pf = lengthCompare; // pf指向名为lengthCompare的函数 pf = &amp;lengthCompare; // 等于的赋值语句：取地址符时可选的 #+END_SRC</p>
<p>此外，我们还可能着接使用指向函数的指针调用该函数，无须提前解引用指针：</p>
<p>#+BEGIN_SRC C++ bool b1 = pf(“hello”, “goodbye”); // 调用lengthCompare函数 bool b2 = (<em>pf)(“hello”, “goodbye”); // 一个等价的调用 bool b3 = lengthCompare(“hello”, “goodbye”); // 另一个等价的调用 #+END_SRC </em>*** 重载函数的指针 当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。 **** 函数指针形参 和数组类型，虽然不能定义函数类型的形参，但形参可以时指向函数的指针。此时，形参看起来是函数类型，但实际上确实当成指针使用：</p>
<p>#+BEGIN_SRC C++ // 第三个形参是函数类型，它会自动地转换成指向函数的指针 void useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;)); // 等价的声明，显式地将形参定义成指向函数的指针 void useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;)); #+END_SRC</p>
<p>直接使用函数指针类型显得于冗长烦琐。类型别名（参见 2.5.1 节）和 decltype 能让我们简化使用了函数指针的代码：</p>
<p>#+BEGIN_SRC C++ // Func和Func2是函数类型 typedef bool Func(const string&amp;, const string&amp;); typedef decltype(lengthCompare) Func2 // 等价的类型</p>
<p>// FuncP和FuncP2是指向函数的指针 typedef bool(<em>FuncP)(const string&amp;, const string&amp;); typedef decltype(lengthCompare) </em>FuncP2; // 等价的类型 #+END_SRC</p>
<p>需要注意的是，decltype 返回函数类型，此时不会将函数类型自动转换成指针类型。因为 decltype 的结果是函数类型，所以只有在结果前面加上<em>才能得到指针。 </em>*** 返回指向函数的指针 和数组类型，虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把函数类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。</p>
<p>~int (<em>f1(int))(int</em>, int);~</p>
<p>按照由内向外的顺序阅读这条声明语句：我们看到 f1 有形参列表，所以 f1 是个函数；f1 前面有*，所以 f1 返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是 int。</p>
<p>出于完整性考虑，有必要提醒读者我们还可以使用尾置返回类型的方式（参见 6.3.3 节）声明一个返回函数指针的函数：</p>
<p>~auto f1(int) -&gt; int (<em>)(int</em>, int);~ * 第 7 章 类 类的基本思想是 <em>数据抽象</em> 和 <em>封装</em> 。数据抽象是一种依赖于 <em>接口</em> 和 <em>实现</em> 分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义累所需的各种私有函数。</p>
<p>封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现的部分。</p>
<p>类要想实现数据抽象和封装，需要首先定义一个 <em>抽象数据类型</em> 。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。 ** 7.1 定义抽象数据类型 *** 7.1.2 定义该进的 Sales_data 类 #+BEGIN_SRC C++ struct Sales_data { std::string isbn() const ( return bookNo; ) Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const;</p>
<p>std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; }; #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>定义在类内部的函数是隐式的 inline 函数。 #+END_QUOTE **** 定义成员函数 尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。 **** 引入 this 成员函数通过一个名为 <em>this</em> 的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化 this。例如，如果调用</p>
<p><sub>total.isbn()</sub></p>
<p>则编译器负责把 total 的地址传递给 isbn 隐式形参 this，可以等价地认为编译器将该调用重写成了如下的形式：</p>
<p><sub>Sales_date::isbn(&amp;total)</sub></p>
<p>在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为 this 所指的正是这个对象。任何对类成员的直接访问都被看作 this 的隐式引用。也就是说，当 isbn 使用 bookNo 时，它隐式第使用 this 指向的成员，就像我们书写了 this-&gt;bookNo 一样。</p>
<p>因为 this 的亩的总是指向“这个”对象，所以 this 是一个常量指针，我们不允许改变 this 中保存的地址。 **** 引入 const 成员函数 isbn 函数的另一个关键之处时紧随参数列表之后的 const 关键字，这里，const 的作用是修改隐式 this 指针的类型。</p>
<p>默认情况下，this 的类型是指向类类行非常量版本的常量指针。例如在 Sales_data 成员函数中，this 的类型是 Sales_data *const。尽管 this 是隐式的，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把 this 绑定到一个常量对象上。这一情况也使得我们不能在一个常量对象上调用普通的成员函数。</p>
<p>如果 isbn 是一个普通函数而且 this 是一个普通的指针参数，则我们应该把 this 声明称 const Sales_data *const。毕竟，在 isbn 的函数体内不会改变 this 所指的对象，所以把 this 设置为指向常量的指针有助于提高函数的灵活性。</p>
<p>然而，this 是隐式的并且不会出现在参数列表中，所以在哪儿将 this 声明成指向常量的指针成为我们必须面对的问题。C++语言的做法是允许把 const 关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的 const 表示 this 是一个指向常量的指针，像这样使用 const 的成员函数被称作 <em>常量成员函数</em> 。</p>
<p>可以把 isbn 的函数体想像成如下的形式：</p>
<p>#+BEGIN_SRC C++ // 伪代码，说明隐式的this指针是如何使用的 // 下面的代码是非法的：因为我们不能显式地定义自己的this指针 // 谨记此处的this是一个指向常量的指针，因为isbn是一个常量指针 std::string Sales::isbn(const Sales_data *const this) { return this-&gt;isbn; } #+END_SRC</p>
<p>因为 this 是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，sibn 可以读取调用它的对象的数据成员，但是不能写入新值。 **** 在类的外部定义成员函数 像其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员被声明成常量函数，那么它的定义也必须在参数列表后面指定 const 属性。同时，类外外部定义的成员的名字必须包含它所属的类名：</p>
<p>#+BEGIN_SRC C++ double Sales_data::avg_price() const { if (units_sold) return revenue/units_sold; else return 0; } #+END_SRC *** 7.1.3 定义类相关的非成员函数 #+BEGIN_QUOTE Note：</p>
<p>一般来说，如果非成员函数时类接口的组成部分，则这些函数声明应该与类在同一个头文件内。 #+END_QUOTE *** 7.1.4 构造函数 每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做 <em>构造函数</em> 。构造函数的任务时初始化类的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</p>
<p>构造函数的名字和类名相同。和其他函数不一样的时，构造函数没有返回类型；除此之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的函数体）。类可以包括多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。</p>
<p>不同于其他函数成员，构造函数不能声明成 const 的（参见 7.1.2 节）。当我们创建一类的一个 const 对象时，知道构造函数完成初始化过程，对象才能真正取得其“常量属性”。因此，构造函数在 const 对象的构造过程中可以向其写值。 **** 合成的默认构造函数 #+BEGIN_SRC C++ Sales_data total; Sales_data trans; #+END_SRC</p>
<p>我们没有为这些对象提供初始值，因此我们知道它们执行了默认初始化（参见 2.2.1 节）。类通过一个特殊的构造函数来控制默认值初始化过程，这个函数叫做 <em>默认构造函数</em> 。默认构造函数无须任何实参。</p>
<p>如我们所见，默认构造函数有很多方便都有其特殊性。其中之一时，如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。</p>
<p>编译器创建的构造函数又被称为 <em>合成的默认构造函数</em> 。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员： - 如果存在类内的初始值（参见 2.6.1 节），则用它来初始化成员 - 否则，默认初始化（参见 2.2.1 节）该成员。 **** 某些类不同依赖于合成的默认构造函数 合成的默认构造函数适合非常简单的类。对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：第一个原因也是最容易理解的一个原因就是编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。这条规则的依据时，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。</p>
<p>第二个原因是对于某些类来说，合成的默认构造函数可能执行错误的操作。回忆我们值前介绍过的，如果定义在块中的内置类型或者复合类型（比如数组和指针）的对象被默认初始化（参见 2.2.1 节），则它们的值是未定义的。该准则同样适用于默认初始化的内置类型成员。因此，含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时可能得到未定义的值。</p>
<p>第三个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的函数，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。 **** = default 的含义 我们从解释默认构造函数的含义开始：</p>
<p>~Sales_data() = default~</p>
<p>首先请明确一点：因为该构造函数不接受任何实参，所以它是一个默认构造函数。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望这个函数的作用完全等同于值前使用的合成默认构造函数。</p>
<p>在 C++新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 <em>= defualt</em> 来要求编译器生成构造函数。其中，= default 既可以和声明一起出现在类的内部，也可以作用定义出现在类的外部。和其他函数一样，如果= default 在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。 **** 构造函数的初始值列表 #+BEGIN_SRC C++ Sales_data(const std::string &amp;s) : bookNo(s) { } Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } #+END_SRC</p>
<p>这两个定义中出现了新的部分，即冒号以及冒号和花括号之间的代码，其中花括号定义了（空的）函数体。我们把新出现的部分称为 <em>构造函数初始值列表</em> ，它负责为新创建的对象的一个或几个数据成员赋初值，构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。</p>
<p>当某个数据成员被构造函数初始值列表忽略时，它将以于合成默认构造函数相同的方式隐式初始化。</p>
<p>#+BEGIN_QUOTE Best Practies:</p>
<p>构造函数不应该轻易覆盖掉类内初始值，除非新赋值的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。 #+END_QUOTE</p>
<p>有一点需要注意，在上面的两个构造函数中函数体都是空的。这是因为这些构造函数的唯一目的就是为数据成员赋初值，一旦没有其他任务需要执行，函数体也就为空了。 **** 在类的外部定义构造函数 构造函数没有返回类型，所以定义从指定的函数名字开始。和其他成员函数一样，当我们在类的外部定义构造函数时，必须指明该构造函数时哪个类的成员。</p>
<p>没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始值。 *** 7.1.5 拷贝、赋值和析构 除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。对象在几种情况下会被拷贝，如我们初始化变量以及以值的方式传递或返回一个对象等（参见 6.2.1 节和 6.3.2 节）。当我们使用赋值运算符（参见 4.4 节）时会发生对象的赋值操作。当对象不再存在时执行销毁的操作，比如一个局部对象会在创建它的块结束时被销毁，当 vector 对象（或者数组）销毁时存储在其中的对象也会被销毁。</p>
<p>如果我们不主动定义这些操作，则编译器将替我们合成它们，一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。</p>
<p>我们将在第 13 章中介绍如何自定义上述操作。 **** 某些类不能依赖于合成的版本 尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。</p>
<p>不过值的注意的是，很多需要动态内存的类能（而且应该）使用 vector 对象或者 string 对象管理必要的存储空间。使用 vector 或者 string 的类能避免分配和释放内存带来的复杂性。 ** 7.2 访问控制与封装 在 C++语言中，我们使用 <em>访问说明符</em> 加强类的封装行： - 定义在 <em>public</em> 说明符之后的成员在整个程序内可被访问，public 成员定义类的接口 - 定义在 <em>private</em> 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private 部分封装了（即隐藏了）类的实现细节。</p>
<p>每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者达到类的结尾为止。 **** 使用 class 或 struct 关键字 类可以在它第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用 struct 关键字，则定义在一个访问说明符之前的成员是 public 的；相反，如果我们使用 class 关键字，则这些成员是 private 的。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>使用 class 和 struct 定义类唯一的区别就是默认访问权限。 #+END_QUOTE *** 7.2.1 友元 类可以允许其他类或者函数访问它的非共有成员，方法是令其他其类或者函数成为它的 <em>友元</em> 。如果类想把一个函数作为它的友元，只要添加一条 friend 关键字开始的函数声明语句即可：</p>
<p>#+BEGIN_SRC C++ class Sales_data { // 为Sales_data的非成员函数所做的友元声明 friend Sales_data add(const Sales_data&amp;, const Sales_data&amp;); friend std::istream &amp;read(std::istream&amp;, Sales_data&amp;); friend std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;);</p>
<p>public: Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } Sales_data(const std::string &amp;s): bookNo(s) { } Sales_data(std::istream&amp;); std::string isbn() const { return bookNo; } Sales_data &amp;combine(const Sales_data&amp;); private: std::string bookNo; unsigned units_sold = 0; double revenue = 0.0; };</p>
<p>// Sales_data接口的非成员组成部分的声明 Sales_data add(const Sales_data&amp;, const Sales_data&amp;); std::istream &amp;read(std::istream&amp;, Sales_data&amp;); std::ostream &amp;print(std::ostream&amp;, const Sales_data&amp;); #+END_SRC</p>
<p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>一般来说，最好在类定义开始或结束前的位置几种声明友元。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE 关键概念：封装的益处</p>
<p>封装有两个重要的优点： - 确保用户代码不会无意间破坏封装对象的状态。 - 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。 #+END_QUOTE **** 友元的声明 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>
<p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置再同一个头文件中（类的外部）。 ** 7.3 类的其他特性 *** 7.3.1 类成员再探 **** 定义一个类型成员 除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存当访问限制，可以是 public 或者 private 中的一种：</p>
<p>#+BEGIN_SRC C++ class Screen { public: typedef std::string::size_type pos; private: pos curosr = 0; pos heigh = 0, width = 0; std::string contents; }; #+END_SRC</p>
<p>用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，具体原因将在 7.4.1 节解释。因此，类型成员通常出现在类开始的地方。 **** 令成员作为内联函数 我们可以在类的内部把 inline 作用声明的一部分显式地声明成员函数，同样的，也能在类的外部用 inline 关键字修时函数的定义。</p>
<p>虽然我们无须在声明和定义的地方同时说明 inline，但这么做其实是合法的。不过，最好只在类外部定义的地方说明 inline，这样可以使类更加容易理解。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>和我们在头文件中定义 inline 函数的原因一样（参见 6.5.2 节），inline 成员函数也应该与相应的类定义在同一个头文件中。 #+END_QUOTE **** 可变数据成员 有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即是在一个 const 成员函数内。可以通过在变量的声明中加入 mutable 关键字做到这一点。</p>
<p>一个 <em>可变数据成员</em> 永远不会是 const，即是它是 const 对象的成员。因此，一个 const 成员函数可以改变一个可变成员的值。</p>
<p>#+BEGIN_SRC C++ class Screen { public: void some_member() const; private: mutable size_t access_ctr; // 即是在一个const对象内也能呗修改 // … };</p>
<p>void Screen::some_member() const { ++access_ctr; // … } #+END_SRC **** 类数据成员的初始值 #+BEGIN_QUOTE Note：</p>
<p>当我们提供一个类内初始值时，必须以符号=或者花括号表示 #+END_QUOTE **** 从 const 成员函数返回*this #+BEGIN_QUOTE Note：</p>
<p>一个 const 成员函数如果以引用的形式返回<em>this，那么它的返回类型将是常量引用。 #+END_QUOTE </em>** 7.3.3 类类型 #+BEGIN_QUOTE Note：</p>
<p>即使两个类的成员列表完全一致，他们也不是不同的类型。对于一个类来说，它的成员和其他任何类（或者任何其他其作用域）的成员都不是一回事儿。 #+END_QUOTE **** 类的声明 就像可以把函数的声明和定义完全分离开来（参见 6.1.2 节），我们也能仅仅声明类而暂时不定义它：</p>
<p>~class Screen; // Screen类的声明~</p>
<p>这种声明有时被称作 <em>前向声明</em> ，它向程序中引入了名字 Screen 并且指明 Screen 时一种类类型。对于类型 Screen 来说，在它声明之后定义之前时一个 <em>不完全类型</em> ，也就是说，此时我们已知 Screen 时一个类类型，但时不清楚它刀第包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。</p>
<p>在 7.6 节中我们将描述一种例外的情况：直到类被定义之后数据成员才能被声明成这种类类型。换句话说，我们必须首先完成类的定义，然后编译器才能直到存储该数据成员需要多少空间。因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦以各类的名字出现后，它就是被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针：</p>
<p>#+BEGIN_SRC C++ class Link_screen { Screen window; Link_screen <em>next; Link_screen </em>prev; }; #+END_SRC *** 7.3.4 友元再探 **** 类之间的友元关系 #+BEGIN_SRC C++ class Screen { // Windows_mgr的成员可以访问Screen类的私有部分 friend class Windows_mgr; // … }; #+END_SRC</p>
<p>如果一个类指定了友元类，则友元类的成员函数可以访问词类包括非公有成员在内的所有成员。</p>
<p>必须要注意的一点是，友元关系不存在传递性。也就是说，如果 Windows_mgr 有它自己的友元，则这些友元并不能理所当然地具有访问 Screen 的特权。</p>
<p>#+BEGIN_SRC C++ Note：</p>
<p>每个类负责控制自己的友元类或友元函数。 #+END_SRC **** 令成员函数作为友元 当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：</p>
<p>#+BEGIN_SRC C++ class Screen { // Windows_mgr::clear必须在Sceen类之前被声明 friend void Windows_mgr::clear(ScreenIndex); // …. }; #+END_SRC</p>
<p>要想令某个成员函数作为友元，我们必须仔细组织程序的结果以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序： - 首先定义 Window_mgr 类，其中声明 clear 函数，但是不定义它。在 clear 使用 Screen 的成员之前必须先声明 Screen。 - 接下来定义 Screen，包括对于 clear 的友元声明 - 最后定义 clear，此时它才可以使用 Screen 的成员。 **** 函数重载和友元 尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每个分别声明。 **** 友元声明和作用域 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中（参见 7.2.1 节）。</p>
<p>甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：</p>
<p>#+BEGIN_SRC C++ struct X { friend void f() { /* 友元函数可以定义在类的内部 */ } X() { f(); } // 错误：f还没又被声明 void g(); void h(); }; void X::g() { return f(); } // 错误：f还没又被声明 void f(); // 声明那个定义在X中的函数 void X::h() { return f(); } // 正确：现在f声明在作用域中了 #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>请注意，有的编译器并不强制执行上述有关友元的限制规则（参见 7.2.1 节）。 #+END_QUOTE ** 7.4 类的作用域 **** 作用域和定义在类外部的成员 一个类就是一个作用域的事实能够很好地解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名（参见 7.1.2 节）。在类的外部，成员的名字被隐藏起来了。</p>
<p>一旦与到了类名，定义的剩余部分就在类的作用域之内的，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无法再次授权了。</p>
<p>另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这是，返回类型必须指明它是哪个类的成员。</p>
<p>#+BEGIN_SRC C++ class Window_mgr { public: ScreenIndex addScreen(const Screen&amp;); // … };</p>
<p>// 首先处理返回类型，之后我们才进入Window_mgr的作用域 Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &amp;s) { screens.push_back(s); return screens.size() - 1; } #+END_SRC *** 7.4.1 名字查找与类的作用域 在目前为止，我们编写的程序中， <em>名字查找</em> （寻找与所用名字最匹配的声明的过程）的过程比较直接了当： - 首先，在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。 - 如果没有找到，继续查找外层作用域。 - 如果最终没有找到匹配的声明，则程序报错。</p>
<p>对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别，不过在当前的这个例子中体现得不太明显。类的定义分两步处理： - 首先，编译成员的声明。 - 直到类全部可见后才编译函数体。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>编译器处理完类中的全部声明后才会处理成员函数的定义。 #+END_QUOTE</p>
<p>按照这种两阶段的方式处理类可以简化类代码的组织方式。因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字。相反，如果函数的定义和成员的声明被同时处理，那么我们将不得不在成员函数中只使用那些已经出现的名字。 **** 用于类成员声明的名字查找 这两种阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。 **** 类型名要特殊处理 一般来说，内层作用域可以重新定义外层作用域中的名字，即是该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。</p>
<p>#+BEGIN_QUOTE Tip:</p>
<p>类型名的定义通常出现在类的开始初，这样就能确保所有使用该类的成员都出现在类名的定义之后。 #+END_QUOTE **** 成员定义中的普通块作用域的名字查找 成员函数中使用的名字按照如下方式解析： - 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。 - 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员函数都可以被考虑。 - 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。 **** 在文件中名字的出现处对其进行解析 当成员定义在类的外部时，名字查找的第三不不仅要考虑定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。 ** 7.5 构造函数再探 *** 7.5.1 构造函数初始值列表 当我们定义变量时习惯于立即对其进行初始化，而非先定义、再赋值。就对象的数据成员而言，初始化和赋值也有类似的区别。如果没有再构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。例如：</p>
<p>#+BEGIN_SRC C++ // Sales_data构造函数的一种写法，虽然合法但比较草率：没有使用构造函数初始值 Sales_data::Sales_data(const string &amp;s, unsigned cnt, double price) { bookNo = s; units_sold = cnt; revenue = cnt * price; } #+END_SRC</p>
<p>这段代码和我们在 7.1.4 节的原始定义效果是相同的：当构造函数完成后，数据成员的值相同。区别是原来的版本初始化了它的数据成员，而这个版本是对数据成员执行了赋值操作。这一区别刀第会有什么深层次的影响完全依赖于数据成员的类型。 **** 构造函数的初始值有时必不可少 有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是 const 或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员函数初始化。</p>
<p>随着构造函数体一开始执行，初始化就完成了。我们初始化 const 或者引用类型的数据成员的唯一机会就是通过构造函数初始值。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果成员是 const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE 建议：使用构造函数初始值</p>
<p>在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。</p>
<p>除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。 #+END_QUOTE **** 成员初始化的顺序 成员的初始化顺序与它们在类定义中出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p>
<p>#+BEGIN_QUOTE Best Practies：</p>
<p>最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。 #+END_QUOTE **** 默认实参和构造函数 #+BEGIN_QUOTE Note：</p>
<p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。 #+END_QUOTE *** 7.5.2 委托构造函数 C++11 新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的 <em>委托构造函数</em> 。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。</p>
<p>和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。</p>
<p>#+BEGIN_SRC C++ class Sales_data { public: // 非委托构造函数使用对应的实参初始化成员 Sales_data(std::string s, unsigned cnt, double price): bookNo(s), units_sold(cnt), revenue(cnt<em>price) { } // 其余构造函数全都委托给另一个构造函数 Sales_data(): Sales_data("", 0, 0) { } Sales_data(std::string s): Sales_data(s, 0, 0) { } Sales_data(std::istream &amp;is): Sales_data() { read(is, </em>this); } }; #+END_SRC</p>
<p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。 *** 7.5.3 默认构造函数的作用 当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生： - 当我们在块作用域内不适用任何初始值定义一个非静态变量或数据时。 - 当一个类本身含有类类型的成员且使用合成的默认构造函数时。 - 当类类型的成员没有在构造函数列表中显式地初始化时。</p>
<p>值初始化在以下情况下发生： - 在数组初始化的过程中我们提供的初始值数量少于数组的大小时。 - 当我们不适用初始值定一个局部静态变量时 - 当我们通过书写形如 T( )的表达式显式地请求值初始化时，其中 T 时类型名（vector 的一个构造函数只接受一个实参用于说明 vector 大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。</p>
<p>类必须包含一个默认构造函数以便在上述情况下使用，其中大多数情况非常容易判断。</p>
<p>#+BEGIN_QUOTE Best Practies：</p>
<p>在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数 #+END_QUOTE *** 7.5.4 隐式的类类型转换 我们也能为类定义隐式转换规则。如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作 <em>转换构造函数</em> 。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>能通过一个实参调用的构造函数定义了一条从构造函数的类型参数向类类型隐式转换的规则。 #+END_QUOTE</p>
<p>在 Sales_data 类中，接受 string 的构造函数和接受 istream 的构造函数分别定义了从这两种类型向 Sales_data 隐式转换的规则。也就死后说，在需要使用 Sales_data 的地方，我们可以使用 string 或者 istream 作为替代：</p>
<p>#+BEGIN_SRC C++ string null_book = “9-999-99999-9”; // 构造一个临时的Sales_data对象 // 该对象的units_sold和revenue等于0,bookNo等于null_book item.combine(null_book); #+END_SRC</p>
<p>在这里我们用一个 string 实参调用了 Sales_data 的 combine 成员。该调用是合法的，编译器用给定的 string 自动创建了一个 Sales_data 对象。新生成的这个（临时）Sales_data 对象被传递给 combine。因为 combine 的参数时一个常量引用，所以我们可以给该函数传递一个临时量。 **** 只允许一步类类型转换 在 4.11.2 节中我们指出，编译器只会自动地执行一步类型转换。 **** 抑制构造函数定义的隐式转换 在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为 <em>explicit</em> 加以阻止：</p>
<p>#+BEGIN_SRC C++ class Sales_data { public: Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) { } explicit Sales_data(const std::string &amp;s) : bookNo(s) { } explicit Sales_data(std::istream&amp;); // … }; #+END_SRC</p>
<p>此时，没有任何构造函数能用于隐式地创建 Sales_data 对象，之前的两种用法都无法通过编译：</p>
<p>#+BEGIN_SRC C++ item.combine(null_book); // 错误：string构造函数时explicit的 item.combine(cin); // 错误：istream构造函数时explicit的 #+END_SRC</p>
<p>关键字 explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于隐式转换，所以无法将这些构造函数指定为 explicit 的。只能在类内声明构造函数时使用 explicit 关键字，在类外部定义时不应重复。 **** explicit 构造函数只能用于直接初始化 发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）。此时，我们只能使用直接初始化而不能使用 explicit 构造函数。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当我们用 explicit 关键字声明构造函数时，它将只能以直接初始化的形式使用。而且编译器将不会在自动转换过程中使用该构造函数。 #+END_QUOTE **** 为转换显式地使用构造函数 尽管编译器不会将 explicit 的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制进行转换。 **** 标准库中含有显示构造函数的类 我们用过的一些标准库中的类含有单参数的构造函数： - 接受一个单参数的 const char<em>的 string 构造函数不是 explicit 的。 - 接受一个容量参数的 vector 构造函数时 explicit 的。 </em>** 7.5.5 聚合类 <em>聚合类</em> 时的用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的： - 所有成员都是 public 的 - 没有定义任何构造函数 - 没有类内初始值（参见 2.6.1 节） - 没有基类，也没有 virtual 函数。</p>
<p>例如，下面的类是一个聚合类：</p>
<p>#+BEGIN_SRC C++ struct Data { int ival; string s; }; #+END_SRC</p>
<p>我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：</p>
<p>~Data vall = { 0, “Anna” };~</p>
<p>初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。</p>
<p>与初始化数据元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。 *** 7.5.6 字面值常量类 数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类： - 数据成员必须都是字面值类型。 - 类必须至少有一个 constexpr 构造函数。 - 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式（参见 2.4.4 节）；或者如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 函数。 - 类必须使用析构函数的默认定义，该成员负责销毁类的对象。 **** constepxr 构造函数 尽管构造函数不能是 const 的，单字面值常量类的构造函数可以是 constexpr 函数。事实上，一个字面值常量类必须至少提供一个 constexpr 构造函数。</p>
<p>constexpr 构造函数可以声明称=default 的形式（或者是删除函数的形式）。否则，constexpr 构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又复合 constexpr 函数的要求（意味着它能拥有的唯一可执行语句就是返回语句（参见 6.5.2 节））。综合这两点可知，constexpr 构造函数体一般来说应该是空的。我们通过前置关键字 constexpr 就可以声明一个 constexpr 构造函数了。</p>
<p>constexpr 构造函数必须初始化所有数据成员，初始值或者使用 constexpr 构造函数，或者是一条常量表达式。 ** 7.6 类的静态成员 有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。 **** 声明静态成员 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</p>
<p>类似的，静态成员函数也不与任何对象绑定在一起，它们不包含 this 指针。作为结果，静态成员函数不能声明称 const 的，而且我们也不能在 static 函数体内使用 this 指针。这一限制既适用于 this 的显式使用，也对调用非静态成员的隐式使用有效。 **** 使用类的静态成员 我们使用作用域运算符直接访问静态成员：</p>
<p>~double r = Account::rate(); // 使用作用域运算符访问静态成员~</p>
<p>虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员：</p>
<p>#+BEGIN_SRC C++ Account ac1; Account *ac2 = &amp;ac1; // 调用静态成员函数rate的等价形式 r = ac1.rate(); r = ac2-&gt;rate(); #+END_SRC</p>
<p>成员函数不用通过作用域运算符就能直接使用静态对象。 **** 定义静态成员 和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复 static 关键字，该关键字只出现在类内部的声明语句。</p>
<p>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态成员只能定义一次。</p>
<p>类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一致存在于程序的整个声明周期。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>要想确保对象只定义一次，最好的办法就是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。 #+END_QUOTE **** 静态成员的类内初始化 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供 const 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 constexpr（参见 7.5.6）。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能在所有适合于常量表达式的地方。</p>
<p>#+BEGIN_QUOTE Best Practies：</p>
<p>即使一个常量静态成员在类内部被初始化了，通常情况下也应该在类的外部定义以下该成员。 #+END_QUOTE **** 静态成员能用于某些场景，而普通成员不能 如我们所见，静态成员独立于任何对象。因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常地使用。举个例子，静态数据成员可以是不完全类型（参见 7.3.3）。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明称它所属类的指针或引用：</p>
<p>#+BEGIN_SRC C++ class Bar { public: // … private: static Bar mem1; // 正确：静态成员可以是不完整类型 Bar *mem2; // 正确：指针成员可以是不完全类型 Bar mem3; // 错误：数据成员必须是完全类型 }; #+END_SRC</p>
<p>静态成员和普通成员的另一个区别是我们可以使用静态成员作为默认实参（参见 6.5.1 节）。</p>
<p>非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[C++ Primer 第 II 部分 C++标准库]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/C++/C++%20Primer%20Part%20II.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/C++/C++%20Primer%20Part%20II.html</guid>
    <description><![CDATA[<p>#+TITLE: C++ Primer 第 II 部分 C++标准库 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>第 8 章 IO 库 ** 8.1 IO 类 #+CAPTION: IO 库类型和头文件 | 头文件 | 类型 | |———-+———————————————–| | iostream | istream, wistream 从流读取数据 | | | ostream, wostream 向流先入数据 | | | iostream, wiostream 读写流 | | fstream | ifstream, wifstream 从文件读取数据 | | | ofstream, wofstream 向文件写入数据 | | | fstream, wfstream 读写文件 | | sstream | istringstream, wistringstream 从 string 读取数据 | | | ostringstream, wostringstream 向 string 写入数据 | | | stringstream, wstringstream 读写 string |</li>
</ul>
<p>为了支持使用宽字符的语言，标准库定义了一组类型和对象来操作 wchar_t 类型的数据（参见 2.1.1 节）。宽字符版本的类型和函数名字以一个 w 开始。 *** 8.1.1 IO 对象无拷贝或赋值 由于不能拷贝 IO 对象，因此我们也不能将形参或返回类型设置为流类型（参见 6.2.1 节）。进行 IO 操作的函数通常以引用方式传递和返回流。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 const 的。 *** 8.1.2 条件状态 IO 操作一个与生俱来的问题是可能发生错误。一些错误是可恢复的，而其他错误则发生在系统深处，已经超出了应用程序可以修正的范围。下表列出了 IO 类所定义的一些函数和标志，可以帮助我们访问和操纵流的 <em>条件状态</em> 。 #+CAPTION: IO 库条件状态 | strm::iostate | strm 是一种 IO 类型。iostate 是一种机器相关的类型，提供了表达条件状态的完整功能 | | strm::badbit | strm::badbit 用来指出流已崩溃 | | strm::failbit | strm::failbit 用来指出一个 IO 操作失败了 | | strm::eofbit | strm::eofbit 用来指出流到达了文件结束 | | strm::goodbit | strm::goodbit 用来指出流未处于错误状态。此值保证为零 | | s.eof() | 若流 s 的 eofbit 置位，则返回 true | | s.fail() | 若流 s 的 failbit 或 badbit 置位，则返回 true | | s.bad() | 若流 s 的 badbit 置位，则返回 true | | s.good() | 若流 s 处于有效状态，则返回 true | | s.clear() | 若流 s 中所有条件状态复位，将流的状态设置为有效。返回 void | | s.clear(flags) | 根据给定 flags 标志位，将流 s 中对应条件状态位复位。flags 的类型为 strm::iostate。返回 void | | s.setstate(flags) | 根据给定 flags 标志位，将流 s 中对应条件状态位复位。flags 的类型为 strm::iostate。返回 void | | s.rdstate() | 返回流 s 的当前条件状态，返回值类型为 strm::iostate |</p>
<p>一个流一旦发生错误，其上后续的 IO 操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的办法时将它当作一个条件来使用：</p>
<p>#+BEGIN_SRC C++ while (cin &gt;&gt; word) // OK：读操作成功 #+END_SRC</p>
<p>while 循环检查&gt;&gt;表达式返回的流的状态。如果输入操作成功，流保持有效状态，则条件为真。 **** 查寻流的状态 IO 库定义了一个与机器无关的 iostate 类型，它提供了表达流状态的完整功能。</p>
<p>标准库还定义了一组函数来查寻这些标志位的状态。操作 good 在所有位置错误位均未置位的情况下返回 true，而 bad、fail 和 eof 则在对应错误被位置时返回 true。此外，在 badbit 被置位时，fail 也会返回 true。这意味着，使用 good 或 fail 时确定流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于!fail()。而 eof 和 bad 操作只能表示特定的错误。 *** 8.1.3 管理输出缓冲 每个输出流都管理一个缓冲区，用来保存程序读写的数据。例如，如果执行下面的代码</p>
<p>~os &lt;&lt; “please enter a value:”;~</p>
<p>文本串可能立即大快银出来，但也有可能被操作系统保存在缓冲区中，随后再打印。有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。</p>
<p>导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多： - 程序正常结束，作为 main 函数的 retrun 操作的一部分，缓冲刷新被执行。 - 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。 - 我们可以使用操作符如 endl 来显式刷新缓冲区 - 在每个输出操作之后，我们可以用操纵符 unitbuf 设置流的内部状态，来清空缓冲区。默认情况下，对 cerr 时设置 unitbuf 的，因此写到 cerr 的内容都是立即率先那的 - 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin 和 cerr 都关联到 cout。因此读 cin 或写 cerr 都会导致 cout 的缓冲区被刷新。 **** 刷新输出缓冲区 我们已经使用过操纵符 endl，它完成换行并刷新缓冲区的工作。IO 库中还有两个类似的操纵符：flush 和 ends。flush 刷新缓冲区，但不输出任何额外的字符：ends 向缓冲区插入一个空字符，然后刷新缓冲区。</p>
<p>#+BEGIN_SRC C++ cout &lt;&lt; “hi!” &lt;&lt; endl; cout &lt;&lt; “hi!” &lt;&lt; flush; cout &lt;&lt; “hi!” &lt;&lt; ends; #+END_SRC **** unitbuf 操纵符 如果想在每次输出操作后都刷新缓冲区，我们可以使用 unitbuf 操纵符。它告诉流在接下来的每次写操作之后都进行一次 flush 操作。而 nounitbuf 操作符则重值流，使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
<p>#+BEGIN_SRC C++ cout &lt;&lt; unitbuf // 任何输出都立即刷新，无缓冲 count &lt;&lt; nounitbuf #+END_SRC</p>
<p>#+BEGIN_QUOTE 警告：如果程序崩溃，输出缓冲区不会被刷新</p>
<p>如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p>
<p>当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量的时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。 #+END_QUOTE **** 关联输入和输出流 #+BEGIN_SRC C++ 交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读取操作之前被打印出来。 #+END_SRC</p>
<p>tie 有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie 的第二个版本接受一个指向 ostream 的指针。即，x.tie(&amp;o)将流 x 关掉到输出流 o。</p>
<p>每个流同时最多关联一个流，但多个流可以同时关联到同一个 ostream。 ** 8.2 文件输入输出 ifstream、ofstream 以及 fstream 提供的操作与我们之前已经使用过的 cin 和 cout 操作一样。特别是，我们可以用 IO 运算符（ =&lt;&lt;= 和 =&gt;&gt;= ）来读写文件，可以用 getline 从 ifstream 读取数据，包括 8.1 节中介绍的内容也都适用于这些类型。</p>
<p>#+CAPTION: fstream 特有的操作 | fstream fstrm; | 创建一个未绑定的文件流。fstream 是头文件 fstream 中定义的一个类型 | | fstream fstrm(s); | 创建一个 fstream，并打开名为 s 的文件。s可以是 string 类型，或者是一个指向 C 风格的字符串的指针。 | | | 这些构造函数都是 explicit 的。默认的问键模式 mode 依赖于 fstream 的类型 | | fstream fstrm(s, mode); | 与前一个构造函数类型，但按执行 mode 打开文件 | | fstrm.open(s) | 打开名为 s 的文件，并将文件与 fstrm 绑定。s可以是一个 string 或指向 C 风格字符串的指针。默认的文件 mode 依赖于 fstream 的类型。返回 void | | fstrm.close() | 关闭与 fstrm 绑定的文件。返回 void | | fstrm.is_open() | 返回一个 bool 值，指出与 fstrm 关联的文件是否成功打开且尚未关闭 | *** 8.2.1 使用文件流对象 创建文件流对象时，我们可以提供文件名（可以选的）。如果提供了一个文件名，则 open 会自动被调用：</p>
<p>#+BEGIN_SRC C++ ifstream in(ifile); ofstream out; #+END_SRC **** 成员函数 open 和 close 一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用 open 会失败，并会导致 failbit 被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另一个文件，必须首先关闭已经关联的文件。一旦文件成功关闭，我们可以打开新的文件。如果 open 成功，则 open 会设置流的状态，使得 good()为 true。 **** 自动构造和析构 #+BEGIN_QUOTE Note：</p>
<p>当一个 fstream 对象被销毁时，close 会被自动调用。 #+END_QUOTE *** 8.2.2 文件模式 每个流都有一个关联的 <em>文件模式</em> ，用来指出如果使用文件。下表列出了文件模式和它们的含义。</p>
<p>#+CAPTION: 文件模式 | in | 以读方式打开 | | out | 以写方式打开 | | app | 每次写操作前均定位到文件末尾 | | ate | 打开文件后立即定位到文件末尾 | | trunc | 截断文件 | | binary | 以二进制方式进行 IO |</p>
<p>无论用哪种方式打开文件，我们都可以指定文件模式，调用 open 打开文件时也可以，用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制： - 只可以对 ofstream 和 fstream 对象设定 out 模式。 - 只可以对 ifstream 和 fstream 对象设定 in 模式。 - 只有当 out 也被设定时才可设定 trunc 模式。 - 只要 trunc 没被设定，就可以设定 app 模式。在 app 模式下，即是没有显式指定 out 模式，文件也总是以输出方式被打开。 - 默认情况下，即是我们没有指定 trunc，以 out 模式打开的文件也会被截断。为了保留以 out 模式打开的文件的内容，我们必须同时指定 app 模式，这样只会将数据追加写到文件末尾；或者同时指定 in 模式，即打开文件同时进行读写操作。</p>
<p>每个文件流类型读定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与 ifstream 关联的文件默认以 in 模式打开；与 ofstream 关联的文件默认以 out 模式打开；与 fstream 关联的文件默认以 in 和 out 模式打开。 **** 以 out 模式打开文件会丢失已有数据 默认情况下，当我们打开一个 ofstream 时，文件的内容会被丢弃。阻止一个 ofstream 清空给定文件内容的方法是同时指定 app 模式：</p>
<p>~ofstream app(“file2”, ofstream::app); // 隐含为输出模式~</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>保留被 ofstream 打开的文件中已有数据的唯一方法是显式指定 app 或 in 模式。 #+END_QUOTE ** 8.3 string 流 #+CAPTION: stringstream 特有的操作 | sstream strm; | strm 是一个未绑定的 stringstream 对象。sstream 是头文件 sstream 中定义的一个类型 | | sstream strm(s); | strm 是一个 sstream 对象，保存 string s 的一个拷贝。此构造函数是 explicit 的 | | strm.str() | 返回 strm 所保存的 string 的拷贝 | | strm.str(s) | 将 string s 拷贝到 strm 中。返回 void | * 第 9 章 顺序容器 一个容器就是一些特定类型的集合。 <em>顺序容器</em> 为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。 ** 9.1 顺序容器概述 #+CAPTION: 顺序容器类型 | vector | 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 | | deque | 双端队列。支持快速随机访问。在头尾插入/删除速度很快 | | list | 双向链表。只支持双向顺序访问。在 list 中任何位置进行插入/删除操作速度都很快 | | forward_list | 单向列表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快 | | array | 固定大小数组。支持快速随机访问。不能添加或删除元素 | | string | 与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快 | **** 确定使用哪种顺序容器 #+BEGIN_QUOTE Tip：</p>
<p>通常，使用 vector 时最好的选择，除非你有很好的理由选择其他容器。 #+END_QUOTE</p>
<p>以下是一些选择容器的基本原则： - 除非你有很多的里有选择其他其容器，否则应该使用 vector。 - 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用 list 或 forward_list。 - 如果程序要求随机访问元素，应使用 vector 和 deque。 - 如果程序要求在容器的中间插入或删除元素，应使用 list 或 forward_list。 - 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用 deque。 - 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则 - 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 vector 追加数据，然后再调用标准库的 sort 函数来重排容器中的元素，从而避免在中间位置添加元素。 - 如果必须在中间位置插入元素，考虑在输入阶段使用 list，一旦输入完成，将 list 中的内容拷贝到一个 vector 中</p>
<p>如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那该怎么办？答案取决于在 list 或 forward_list 中访问元素与 vector 或 deque 中插入/删除元素的相对性能。一般来说，应用中占主导地方的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>如果你不确定应该使用哪种容器，那么可以在程序中只使用 vector 和 list 公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用 vector 或 list 都很方便。 #+END_QUOTE ** 9.2 容器库概览 #+CAPTION: 容器操作 | <em>类型别名</em> | | | iterator | 此容器类型的迭代器类型 | | const_iterator | 可以读取元素，但不能修改源的迭代器类型 | | size_type | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 | | difference_type | 带符号整数类型，足够保存两个迭代器之间的距离 | | value_type | 元素类型 | | reference | 元素的左值类型：与 value_type&amp;含义相同 | | const_reference | 元素的 const 左值类型（即，const value_type&amp;） | | <em>构造函数</em> | | | C c; | 默认构造函数，构造孔融其 | | C c1(c2); | 构造 c2 的拷贝 c1 | | C c(b, e); | 构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c（array 不支持） | | C c{a, b, c…} | 列表初始化 c | | <em>赋值与 swap</em> | | | c1 = c2 | 将 c1 种的元素替换为 c2 中元素 | | c1 = {a, b, c…} | 将 c1 中的元素替换为列表中的元素（不适用于 array） | | a.swap(b) | 交换 a 和 b 的元素 | | swap(a, b) | 与 a.swap(b)等价 | | <em>大小</em> | | | c.size() | c 中元素的数目（不支持 forward_list） | | c.max_size() | c 可保存的最大元素数据 | | c.empty() | 若 c 中存储了元素，返回 false，否则返回 true | | <em>添加/删除元素</em> （适用于 array） | | | | 注：在不同容器中，这些操作的接口都不同 | | c.insert(args) | 将 args 中的元素拷贝进 c | | c.emplace(inits) | 使用 inits 构造 c 中的一个元素 | | c.erase(args) | 删除 args 指定的元素 | | c.clear() | 删除 c 中的所有元素，返回 void | | <em>关系运算符</em> | | | <sub>==</sub> ， <sub>!=</sub> | 所有容器都支持相同（不等）运算符 | | &lt;, &lt;=, &gt;, &gt;= | 关系运算符（无序关联容器不支持） | | <em>获取迭代器</em> | | | c.begin(), c.end() | 返回指向 c 的首元素和尾元素之后位置的迭代器 | | c.cbegin(), c.end() | 返回 const_iterator | | <em>反向容器的额外成员</em> （不支持 forward_list） | | | reverse_iterator | 按逆序寻址元素的迭代器 | | const_reverse_iterator | 不能修改元素的逆序迭代器 | | c.rbegin(), c.rend() | 返回指向 c 的尾元素和首元素之前位置的迭代器 | | c.crbegin(), c.crend() | 返回 const_reverse_iterator | *** 9.2.4 容器定义和初始化 **** 将一个容器初始化为另一个容器的拷贝 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。</p>
<p>#+BEGIN_SRC C++ // 每个容器有三个元素，用给定的初始化器进行初始化 list<string> authors = {“Milton”, “Shakespeare”, “Austen”}; vector&lt;const char*&gt; articles = {“a”, “a”, “the”};</p>
<p>list<string> list2(authors); // 正确：类型匹配 deque<string> authList(authors); // 错误：容器类型不匹配 vector<string> words(articles); // 错误：容器类型必须匹配 // 正确：可以将const char<em>元素转换为string forward_list<string> words(articles.begin(), articles.end()); #+END_SRC </em>*** 与顺序容器大小相关的构造函数 除了与关联容器相同的构造函数外，顺序容器（array 除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器：</p>
<p>#+BEGIN_SRC C++ vector<int> ivec(10, -1); list<string> svec(10, “hi!”); forward_list<int> ivec(10); deque<string> svec(10); #+END_SRC **** 标准库 array 具有固定大小 与内置数组一样，标准库 array 的大小也是类型的一部分。当定一个 array 时，除了指定元素类型，还要真定容器大小：</p>
<p>#+BEGIN_SRC C++ array&lt;int, 42&gt; // 类型为：保存42个int的数组 array&lt;string, 10&gt; // 类型为：保存10个string的数组 #+END_SRC</p>
<p>为了使用 array 类型，我们必须同时指定元素类型和大小。</p>
<p>由于大小时 array 类型的一部分，array 不支持普通的容器构造函数。这些构造函数都会确定容器的大喜爱，要么隐式地，要么显式地。而允许用户向一个 array 构造函数传递大小参数，最好情况下也是多余的，而且容器出错。</p>
<p>值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但 array 无此限制。</p>
<p>#+BEGIN_SRC C++ int digs[10] = {0,1,2,3,4,5,6,7,8,9}; int cpy[10] = digs; // 错误：内置数组不支持拷贝或赋值 array&lt;int, 10&gt; digits = {0,1,2,3,4,5,6,7,8,9}; array&lt;int, 10&gt; copy = digits; // 正确：只要数组类型匹配即合法 #+END_SRC</p>
<p>与其他容器一样，array 也要求初始值的类型必须与要创建的容器类型相同。此外 array 要求元素类型和大小也都一样，因为大小时 array 类型的一部分。 *** 9.2.5 赋值和 swap #+CAPTION: 容器赋值运算 | c1=c2 | 将 c1 中的元素替换为 c2 中元素的拷贝。c1 和 c2 必须具有相同的类型 | | c={a,b,c…} | 将 c1 中元素替换为初始化列表中元素的拷贝（array 不适用） | | swap(c1,c2) | 交换 c1 和 c2 中的元素。c1 和 c2 必须具有相同的类型。swap 通常比从 c2 向 c1 拷贝元素快得多 | | | assign 操作不适用于关联容器和 array | | seq.assign(b,e) | 将 seq 中的元素替换为迭代器 b 和 e 所表示的范围中的元素。迭代器 b 和 e 不能指向 seq 中的元素 | | seq.assign(il) | 将 seq 中的元素替换为初始化列表 il 中的元素 | | seq.assign(n,t) | 将 seq 中的元素替换为 n 个值为 t 的元素 |</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而 swap 操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为 array 和 string 的情况除外。 #+END_QUOTE **** 使用 assign（仅顺序容器） 赋值运算符要求左边和右边的运算对象具有相同的类型。它将右边运算对象中所有元素拷贝到左边运算对象中。顺序容器（array 除外）还定义了一个名为 assign 的成员，允许我们从一个不同但相容的类型赋值，或者从容器的子序列赋值。assign 操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。 **** 使用 swap #+BEGIN_QUOTE Note：</p>
<p>除 array 外，swap 不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。 #+END_QUOTE</p>
<p>元素不会被移动的事实意味着，除 string 外，指向容器的迭代器、引用和指针在 swap 操作之后都不会失效。它们仍指向 swap 操作之前所指向的那些元素。但在 swap 之后，这些元素已经属于不同的容器了。与其他容器不同，对一个 string 调用 swap 会导致迭代器、引用和指针失效。</p>
<p>与其他容器不同，swap 两个 array 会真正交换它们的元素。因此，交换两个 array 所需的时间与 array 中元素的数目成正比。</p>
<p>因此，对于 array，在 swap 操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个 array 中对应元素的值进行了交换。 *** 9.2.7 关系运算符 每个容器类型都支持相等运算符（ <sub>==</sub> 和 <sub>!=</sub> ）；除了无须关联容器外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与 string 的关系运算类型： - 如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。 - 如果两个容器大小不同，但较小容器中每个元素都等于较大容器的对应元素，则较小容器小于较大容器。 - 如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。 *** 容器的关系运算符使用元素的关系运算符完成比较 容器的相等运算符实际上是使用元素的==运算符实现比较的，而其他关系运算符是使用元素的&lt;运算符。如果元素类型不支持所需运算符，那么保存这种元素的容器就不能使用相等的关系运算。 ** 9.3 顺序容器操作 顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同指出着接关系到了元素如果存储、访问、添加以及删除。 *** 9.3.1 向顺序容器添加元素 除 array 外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。下表列出了向顺序容器（非 array）添加元素的操作。 #+CAPTION: 向顺序容器添加元素的操作 | | 这些操作会改变容器的大小；array 不支持这些操作 | | | forward_list 有自己转有版本的 insert 和 emplace | | | forward_list 不支持 push_back 和 emplace_back | | | vector 和 string 不支持 push_front 和 emplace_front | | c.push_back(t) | 在 c 的尾部创建一个值为 t 或由 args 创建的元素。返回 void | | c.emplace_back(args) | | | c.push_front(t) | 在 c 的头部创建一个值为 t 或由 args 创建的元素。返回 void | | c.emplace_front(args) | | | c.insert(p,t) | 在迭代器 p 指向的元素之前创建一个值为 t 或由 args 创建的元素。返回指向新添加的元素的迭代器 | | c.emplace(p,args) | | | c.insert(p,n,t) | 在迭代器 p 指向的元素之前插入 n 个值为 t 的元素。返回指向新添加的第一个元素的迭代器；若 n 为 0，则返回 p | | c.insert(p,b,e) | 将迭代器 b 和 e 指定的范围内的元素插入到迭代器 p 指向的元素之前。b和 e 不能指向 c 中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回 p | | c.insert(p,il) | il 是一个花括号包围的元素值列表。将这些给定值插入到迭代器 p 指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回 p |</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>向 vector、string 或 deque 插入元素会使所有指向容器的迭代器、引用和指针失效。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE 关键概念：容器元素是拷贝</p>
<p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关系。随后对容器中的元素的任何改变都不会影响到原始对象，反之亦然。 #+END_QUOTE **** 在容器中的特定位置添加元素 #+BEGIN_QUOTE WARNING：</p>
<p>将元素插入到 vector、deque 和 string 中的任何位置都是合法的。然而，这样做可能很耗时。 #+END_QUOTE **** 插入范围内元素 新标准下，接受元素个数或范围 insert 版本返回指向第一个新加入元素的迭代器。（在旧版本的标准库中，这些操作返回 void）。如果范围为空，不插入任何元素，insert 操作会将第一个参数返回。 **** 使用 insert 的返回值 通过使用 insert 的返回值，可以在容器中一个特定位置反复插入元素：</p>
<p>#+BEGIN_SRC C++ list<string> lst; auto iter = lst.begin(); while (cin &gt;&gt; word) iter = iter.insert(iter, word); // 等价于调用push_front #+END_SRC **** 使用 emplace 操作 新标准引入了三个新成员——emplace_front、emplace 和 emplace_back，这些操作构造而不是拷贝元素。这些操作分别对应 push_front、insert 和 push_back，允许我们将元素防止在容器头部、一个指定位置之前或容器尾部。</p>
<p>当我们调用一个 emplace 成员函数时，则是将参数传递给元素类型的构造函数。emplace 成员使用这些参数在容器管理的内存空间中直接构造元素。例如，假定 c 保存 Sales_data（参见 7.1.4 节）元素：</p>
<p>#+BEGIN_SRC C++ // 在c的末尾构造一个Sales_data对象 // 使用三个参数的Sales_data构造函数 c.emplace_back(“978-0590353403”, 25, 15.99); // 错误：没有接受三个参数的push_back版本 c.push_back(“978-0590353403”, 25, 15.99); // 正确：创建一个临时的Sales_data对象传递给push_back c.push_back(Sales_data(“978-0590353403”, 25, 15.99)); #+END_SRC</p>
<p>其中对 emplace_back 的调用和第二个 push_back 调用都会创建新的 Sales_data 对象。在调用 emplace_back 时，会在容器管理的内存空间中直接创建对象。而调用 push_back 则会创建一个局部临时对象，并将其压入容器中。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>emplace 函数在容器中直接构造元素。传递给 emplace 函数的参数必须与元素类型的构造函数相匹配。 #+END_QUOTE *** 9.3.2 访问元素 #+CAPTION: 在顺序容器中访问元素的操作 | | at 和下表操作只适用于 string、vecotr、deque 和 array。 | | | back 不适用于 forward_list。 | | c.back() | 返回 c 中尾元素的引用。若 c 为空，函数行为未定义 | | c.front() | 返回 c 中首元素的引用。若 c 为空，函数行为未定义 | | c[n] | 返回 c 中下标为 n 的元素的引用，n时一个无符号整数。若 n&gt;=c.size()，则函数行为未定义 | | c.at(n) | 返回下标未 n 的元素的引用。如果下标越界，则抛出一 out_of_range 异常 |</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>对一个空容器调用 front 和 back，就像使用一个越界的下标一样，是一种验证的程序设计错误。 #+END_QUOTE **** 访问成员函数返回的时引用 在容器中访问元素的成员函数（即，front、back、下标和 at）返回的都是引用。</p>
<p>#+BEGIN_SRC C++ if (!c.empty()) { c.front() = 42; // 将42赋予c中的第一个元素 auto &amp;v = c.back(); // 获得指向最后一个元素的引用 v = 1024; // 改变c中的元素 auto v2 = c.back(); // v2不是一个引用，它是c.back()的一个拷贝 v2 = 0; // 未改变c中的元素 } #+END_SRC **** 下标操作和安全的随机访问 提供快速随机访问的容器（string、vector、deque 和 array）也都提供下标运算符。</p>
<p>如果我们希望确保下标时合法的，可以使用 at 成员函数。at 成员函数类似下标运算符，但如果下标越界，at 会抛出一个 out_of_range 异常。 *** 9.3.3 删除元素 #+CAPTION: 顺序容器的删除操作 | | 这些操作会改变容器的大小，所以不适用于 array。 | | | forward_list 有特殊版本的 erase，参见 9.3.4 节 | | | forward_list 不支持 pop_back；vector 和 string 不支持 pop_front | | c.pop_back() | 删除 c 中尾元素。若 c 为空，则函数行为未定义。函数返回 void | | c.pop_front() | 删除 c 中首元素。若 c 为空，则函数行为未定义。函数返回 void | | c.erase(p) | 删除迭代器 p 所指定的元素，返回一个指向被删元素之后元素的迭代器，若 p 指向尾元素，则返回尾后（off-the-end）迭代器。若 p 时尾后迭代器，则函数行为未定义 | | c.erase(b,e) | 删除迭代器 b 和 e 所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若 e 本身就是尾后迭代器，则函数也返回尾后迭代器 | | c.clear() | 删除 c 中的所有元素。返回 void |</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>删除 deque 中除首尾之外的任何元素都会使所有迭代器、引用和指针失效。指向 vector 和 string 中删除点之后位置的迭代器、引用和指针都会失效。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它（们）是存在的。 #+END_QUOTE *** 9.3.4 特殊的 forward_list 操作 [[file:../../../pics/C++/forward_list.png]]</p>
<p>当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生改变。为了添加或删除一个元素，我们需要添加其前驱，以便改变前驱的链接。单是，forward_list 是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。出于这个原因，在一个 forward_list 中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问被添加或删除操作所影响的元素。</p>
<p><em>首前</em> 迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。</p>
<p>#+CAPTION: 在 forward_list 中插入或删除元素的操作 | lst.before_begin() | 返回指向链表首元素之前的元素迭代器。此迭代器不能解引用。 | | lst.cbefore_begin() | cbefore_begin()返回一个 const_iterator | | lst.insert_after(p,t) | 在迭代器 p 之后的位置插入元素。t是一个对象，n是数量，b和 e 是表示范围的一对迭代器（b和 e 不能指向 lst 内），il 是一个花括号列表。 | | lst.insert_after(p,n,t) | 返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回 p。若 p 为尾后迭代器，则函数行为未定义 | | lst.insert_after(p,b,e) | | | lst.insert_after(p,il) | | | emplace_after(p,args) | 使用 args 在 p 指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数行为未定义 | | lst.erase_after(p) | 删除 p 指向的位置之后的元素，或删除从 b 之后直到但不包含）e之间的元素。 | | lst.erase_after(b,e) | 返回一个指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果 p 指向 lst 的尾元素或者一个尾后迭代器，则函数未定义 | *** 9.3.5 改变容器大小 #+CAPTION: 顺序容器大小操作 | | resize 不适用于 array | | c.resize(n) | 调整 c 的大小为 n 个元素。若 n&lt;c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化 | | c.resize(n,t) | 调整 c 的大小为 n 个元素。任何新添加的元素都初始化为值 t |</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>如果 resize 缩小容器，则指向被删除元素迭代器、引用和指针都会失效；对 vector、string 或 deque 进行 resize 可能导致迭代器、指针和引用失效。 #+END_QUOTE *** 9.3.6 容器操作可能使迭代器失效 在向容器添加元素后： - 如果容器是 vector 或 string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。 - 对于 deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。 - 对于 list 和 forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。</p>
<p>当我们从一个容器中删除元素后，指向被删除元素的迭代器、指针和引用会失效，这应该不会令人惊讶。毕竟，这些元素都已经被销毁了。当我们删除一个元素后： - 对于 list 和 forward_list，指向容器其他位置的迭代器（包或尾后迭代器和首前迭代器）、引用和指针仍有效。 - 对于 deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除 deque 的尾元素，则尾后迭代器也会失效，但其他前迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。 - 对于 vector 和 string，指向被删除元素之前的迭代器、引用和指针仍有效。注意：我们删除元素时，尾后迭代器总是会失效。</p>
<p>#+BEGIN_QUOTE 建议：管理迭代器</p>
<p>当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p>
<p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确当地重新定位迭代器。这个建议对 vector、string 和 deque 尤为有效。 #+END_QUOTE **** 不要保存 end 返回的迭代器 #+BEGIN_QUOTE Tip：</p>
<p>如果在一个循环中插入/删除 deque、string 或 vector 中的元素，不要缓存 end 返回的迭代器。 #+END_QUOTE ** 9.4 vector 对象是如何增长的 为了支持快速随机访问，vector 将元素连续存储——每个元素紧挨着前一个元素存储。通常情况下，我们不必关系一个标准库类型是如何实现的，而只需要关系它如何使用。然而，对于 vector 和 string，其部分实现渗透到了接口中。</p>
<p>假定容器中元素是连续存储的，且容器的大小是可变的，考虑向 vector 或 string 中添加元素会发生什么；如果没有空间容纳新元素，容器不可能简单地将它添加到内存中其他位置——因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。如果我们每添加一个新元素，vector 就执行一次这样的内存分配和释放操作，性能会慢到不可接受。</p>
<p>为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时，vector 和 string 的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。</p>
<p>这种分配策略比每次添加元素都重新分配容器内存空间的策略要高效得多。其实际性能也表现得足够好——虽然 vector 在每次重新分配内存空间时都要移动所有元素，但使用此策略后，其扩张操作通常比 list 和 dqeue 还要快。 *** 管理容量的成员函数 #+CAPTION: 管理容量和成员函数 | | shrink_to_fit 只适用于 vector、string 和 deque。 | | | capacity 和 reserve 只适用于 vector 和 string。 | | c.shrink_to_fit() | 请将 capacity()减少为与 size()相同大小 | | c.capacity() | 不重新分配内存空间的话，c可以保存多少元素 | | c.reserve(n) | 分配至少能容纳 n 个元素的内存空间 |</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>reserve 并不改变容器中元素的数量，它仅影响 vector 预先分配多大的内存空间 #+END_QUOTE</p>
<p>只有当需要的内存空间超过当前容量时，reserve 调用才会改变 vector 的容量。如果需求大小大于当前容量，reserve 至少分配与需求一样大的内存空间（可能更大）。</p>
<p>如果需求大小小于或等于当前容量，reserve 什么也不做。特别时，当需求大小小于当前容量时，容器不会退回内存空间。因此，在调用 reserve 之后，capacity 将会大于等于传递给 reserve 的参数。 ** 9.5 额外的 string 操作 *** 9.5.1 构造 string 的其他方法 #+CAPTION: 构造 string 的其他方法 | | n、len2 和 pos2 都是无符号值 | | string s(cp, n) | s 时 cp 指向的数组中前 n 个字符的拷贝。此数足至少应该包含 n 个字符 | | string s(s2,pos2) | s 时 string s2 从下标 pos2 开始的字符串的拷贝。若 pos2&gt;s2.size()，构造函数的行为未定义 | | string s(s2,pos2,len2) | s 是 string s2 从下标 pos2 开始 len2 个字符的拷贝。若 pos2&gt;s2.size()，构造函数的行为未定义。不管 len2 的值是多少，构造函数至多拷贝 s2.size()-pos2 个字符 |</p>
<p>通常当我们从一个 const char<em>创建 string 时，指针指向的数组必须以空字符串结尾，拷贝操作遇到空字符时停止。 </em>*** substr 操作 #+CAPTION: 子字符串操作 | s.substr(pos,n) | 返回一个 string，包含 s 中从 pos 开始的那个字符的拷贝、pos 的默认值为 0。即拷贝从 pos 开始的所有字符 | *** 9.5.2 改变 string 的其他方法 #+CAPTION: 修改 string 的操作 | s.insert(pos,args) | 在 pos 之前插入 args 指定的字符，pos 可以是一个下标或一个迭代器。接受下标的版本返回一个指向 s 的引用；接受迭代器的版本返回指向第一个插入字符的迭代器 | | s.erase(pos,len) | 删除从位置 pos 开始的 len 个字符。如果 len 被省略，则删除从 pos 开始直接 s 末尾的所有字符。返回一个指向 s 的引用 | | s.assign(args) | 将 s 中的字符替换为 args 指定的字符。返回一个指向 s 的引用 | | s.append(args) | 将 args 追加到 s。返回一个指向 s 的引用 | | s.replace(range,args) | 删除 s 中范围 range 内的字符，替换为 args 指定的字符。range 或者是一个下标和一个长度，或者是一对指向 s 的迭代器。返回一个指向 s 的引用 | | | args 可以是下列形式之一；append 和 assign 可以使用所有形式 | | | str 不能与 s 相同，迭代器 b 和 e 不能指向 s | | str | 字符串 str | | str,pos,len | str 从 pos 开始最多 len 个字 | | cp,len | 从 cp 指向的字符数组的前（最多）len 个字符 | | cp | cp 指向的以空字符结尾的字符数据 | | n,c | n 个字符 c | | b,e | 迭代器 b 和 e 指定的范围内的字符 | | 初始化列表 | 花括号包围的，以逗号分隔的字符列表 | *** 9.5.3 string 搜索操作 string 类每个搜索操作都返回一个 string::size_type 值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为 string::npos 和 static 成员。标准库将 npos 定义为一个 const string::size_type 类型，并初始化为-1.由于 npos 是一个 unsigned 类型，此初始值意味着 npos 等于任何 string 最大的可能大小。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>string 搜索函数返回 string::size_type 值，该类型是一个 unsigned 类型。因此用一个 int 或其他带符号类型来保存这些函数的返回值不是一个好注意。 #+END_QUOTE</p>
<p>#+CAPTION: string 搜索操作 | | 搜索操作返回指定字符差与显的下标，如果未找到噢啊则返回 npos | | s.find(args) | 查找 s 中 args 第一次出现的位置 | | s.rfind(args) | 查找 s 中 args 最后一次出现的位置 | | s.find_first_of(args) | 在 s 中查找 args 中任何一个字符第一次出现的位置 | | s.find_last_of(args) | 在 s 中查找 args 中任何一个字符最后一次出现的位置 | | s.find_first_not_of(args) | 在 s 中查找第一个不在 args 中的字符 | | s.find_last_not_of(args) | 在 s 中查找最后一个不在 args 中的字符 | | | <em>args 必须是以下形式之一</em> | | c.pos | 从 s 中位置 pos 开始查找字符 c，pos 默认未 0 | | s2,pos | 从 s 中位置 pos 开始查找字符串 s2，pos 默认为 0 | | cp,pos | 从 s 中位置 pos 开始查找指针 cp 指向的以空字符串结尾的 C 风格字符串 | | cp,pos,n | 从 s 中位置 pos 开始查找指针 cp 指向的数组的前 n 个字符，pos 和 n 无默认值 | *** 9.5.4 compare 函数 #+CAPTION: s.compare 的几种参数形式 | s2 | 比较 s 和 s2 | | pos1,n1,s2 | 将 s 中从 pos1 开始的 n1 个字符与 s2 进行比较 | | pos1,n1,s2,pos2,n2 | 将 s 中从 pos1 开始的 n1 个字符与 s2 中从 pos2 开始的 n2 个字符进行比较 | | cp | 比较 s 与 cp 指向的以空字符结尾的字符数组 | | pos1,n1,cp | 将 s 中从 pos1 开始的 n1 个字符与 cp 指向的以空字符串结尾的字符数组进行比较 | | pos1,n1,cp,n2 | 将 s 中从 pos1 开始的 n1 个字符与指针 cp 指向的地址开始的 n2 个字符进行比较 | *** 9.5.5 数值转换 #+BEGIN_QUOTE Note：</p>
<p>如果 string 不能转换为一个数值，这些函数抛出一个 invalid_argument 异常。如果转换得到的数值无法用任何类型来表示，则抛出一个 out_of_range 异常。 #+END_QUOTE</p>
<p>#+CAPTION: string 和数值之间的转换 | to_string(val) | 一组重载函数，返回数值 val 的 string 表示。val 可以是任何算术类型。 | | | 对每个负电类型和 int 或更大的整型，都有相应版本的 to_string。与往常一样，小整形会被提升 | | stoi(s, p, b) | 返回 s 的起始子串（表示整数内容）的数值，返回值类型分别是 int、long、unsigned long、long long、unsigned long long。 | | stol(s, p, b) | b 表示转换所用的基数，默认值为 10，。p是 size_t 指针，用来保存 s 中第一个非数值字符的下标，p默认为 0，即，函数不保存下标 | | stoul(s, p, b) | | | stoll(s, p, b) | | | stoull(s, p, b) | | | stof(s. p) | 返回 s 的起始子串（表示浮点数内容）的数据，返回值类型分别是 float、double 或 long double。 | | stod(s, p) | 参数 p 的作用与整数转换函数中的一样 | | stold(s, p) | | ** 9.6 容器适配器 除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue 和 priority_queue。 <em>适配器</em> 是标准库中的一个通用概念。容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack 适配器接受一个顺序容器，并使其操作起来像 stack 一样。</p>
<p>#+CAPTION: 所有容器适配器都支持的操作和类型 | size_type | 一种类型，足以保存当前类型的最大对象的大小 | | value_type | 元素类型 | | container_type | 实现适配器的底层容器类型 | | A a; | 创建一个名为 a 的空适配器 | | A a(c); | 创建一个名为 a 的适配器，带有容器 c 的一个拷贝 | | 关系运算符 | 每个适配器都支持所有关系运算符：==、!=、&lt;、&lt;=、&gt;和&gt;= | | | 这些运算符返回底层容器的比较结果 | | a.empty() | 若 a 包含任何元素，返回 false，否额发安徽 true | | a.size() | 返回 a 中的元素数目 | | swap(a,b) | 交换 a 和 b 的内容，a和 b 必须有相同的类型，包括底层容器也必须相同 | | a.swap(b) | |</p>
<p>对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在 array 之上。类似的，我们也不能用 forward_list 来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力。stack 只要求 push_back、pop_back 和 back 操作，因此可以使用除 array 和 forward_list 之外的任何之外的任何容器类型来构造 stack。queue 适配器要求 back、push_back、front 和 push_front，因此它可以构造于 list 或 deque 之上，但不能基于 vector 构造，priority_queue 除了 front、push_back 和 pop_back 操作之外还要求随机访问能力，因此它可以构造于 vector 或 deque 之上，但不能基于 list 构造。 **** 栈适配器 #+CAPTION: 未列出的栈操作 | | 栈默认基于 deque 实现，也可以在 list 或 vector 之上实现 | | s.pop() | 删除栈顶元素，但不返回该元素值 | | s.push(item) | 创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来，或者由 args 构造 | | s.emplace(args) | | | s.top() | 返回栈顶元素，但不将元素弹出栈 | **** 队列适配器 #+CAPTION: 未列出的 queue 和 priority_queue 操作 | | queue 默认基于 deque，priority_queue 默认基于 vector 实现； | | | queue 也可以使用 list 或 vector 实现，priority_queue 也可以用 deque 实现 | | q.pop() | 删除 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回此元素 | | q.front() | 返回首元素或尾元素，但不删除此元素 | | q.back() | 只适用于 queue | | q.top() | 返回最高优先级元素，但不删除该元素 | | | 只适用于 priority_queue | | q.push(item) | 在 queue 末尾或 priority_queue 中恰当的位置创建有高 ieyuansu，其值为 item，或者由 args 构造 | | q.emplace(args) | | * 第 10 章 泛型算法 顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代且。</p>
<p>我们可以向想像用户还希望做其他很多有用的操作：查找特定元素、替换或删除一个特定值、重排元素顺序等。</p>
<p>标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组 <em>泛型算法</em> ：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；成它们是”泛型的“，是因为它们可以用于不同类型的元素和多种容器类型（不仅包括标准库类型，如 vector 或 list，还包括内置的数组类型），以及我们将看到的，还能用于其他类型的序列。 ** 10.1 概述 大多数算法都定义在头文件 algorithm 中。标准库还在头文件 numeric 中定义了一组数值泛型算法。</p>
<p>一般情况下，这些算法并不值接操作容器，而是编译由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。 ** 10.2 初识泛型算法 *** 10.2.1 只读算法 一些算法只读取其输入范围内的元素，而从不改变元素。find 就是这样的一种反法，count 函数也是。</p>
<p>另一个只读算法是 accumulate，它定义在头文件 numeric 中。accumulate 函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>accumulate 的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型 #+END_QUOTE **** 算法和元素类型 #+BEGIN_QUOTE Best Practices：</p>
<p>对于只读取而不改变元素的算法，通常最好使用 cbegin()和 cend()。单是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用 begin()和 end()的结果作为参数。 #+END_QUOTE **** 操作两个序列的算法 #+BEGIN_QUOTE WARNING：</p>
<p>哪些值接受一个单一迭代器来表示第二序列的算法，都假定第二个序列至少与第一个序列一样长。 #+END_QUOTE *** 10.2.2 写容器元素的算法 一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。及诸，算法不会值形容其操作，因此它们自身不可能改变容器的大小。</p>
<p>一些算法会自己向输入范围写入元素。这些算法本质上并不未显，它们最多写入与给定序列一样多的元素。</p>
<p>#+BEGIN_QUOTE 关键概念：迭代器参数</p>
<p>一些算法从两个序列中读取元素。构成这两个序列的元素可以来自于不同类型的容器。而且，两个序列中元素的类型也不要求严格匹配。算法要求的只是能够比较两个序列中的元素。</p>
<p>操作两个序列的算法之间的区别在于我们如何传递第二个序列。一些算法，例如 equal，接受三个迭代器：前两个表示第一个序列的范围，第三个表示第二个序列中的首元素。其他算法接受四个迭代器：前两个表示第一个序列的范围，后两个表示第二个序列的范围。</p>
<p>用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个序列一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。 #+END_QUOTE **** 算法不检查写操作 #+BEGIN_QUOTE WARNING：</p>
<p>向亩的位置迭代器写入数据的算法假定目地位置足够大，能容纳要写入的元素。 #+END_QUOTE **** 介绍 back_inserter 一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，只被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到了容器中。</p>
<p>我们将在 10.4.1 节中详细介绍插入迭代器的内容。单是，为了展示如何用算法写入数据，我们现在将使用 <em>back_inserter</em> ，它是定义在头文件 interator 中的一个函数。</p>
<p>back_inserter 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用 push_back 将一个具有给定值的元素添加到容器中</p>
<p>#+BEGIN_SRC C++ vector<int> vec; // 空向量 auto it = back_inserter(vec); // 通过它赋值会将元素添加到vec中 *it = 42; // vec中现在有一个元素，值为42 #+END_SRC</p>
<p>我们常常使用 back_inserter 来创建一个迭代器，作为算法的目的位置来使用。 **** 拷贝算法 拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。</p>
<p>多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们防止在输入序列的末尾，而是创建一个新序列保存这些结果。 *** 10.2.3 重排容器元素的算法 #+BEGIN_QUOTE WARNING：</p>
<p>标准库算法对迭代器而不是容器进行操作，因此不能（直接）添加或删除元素。 #+END_QUOTE ** 10.3 定制操作 *** 10.3.1 向算法传递函数 **** 谓词 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库苏阿法所使用的谓词分为两类： <em>一元谓词</em> （意味着它们值接受单一参数）和 <em>二元谓词</em> （意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。 *** 10.3.2 lambda 表达式 **** 介绍 lambda 表达式 我们可以向一个算法传递任何类别的 <em>可调用对象</em> 。对于一个对象或一个表达式，如果可以对其使用调用运算符（参见 1.5.2），则称它为可调用的。</p>
<p>到目前为止，我们使用过的仅有的两种可调用对象是函数的函数指针。还有其他两种可调用的对象：重载了函数调用运算符的类，我们将在 14.8 节介绍，以及 <em>lambda 表达式</em> 。</p>
<p>一个 lambda 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个 lambda 具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda 可能定义在函数内部。一个 lambda 表达式具有如下形式</p>
<p>~<a href="parameter%20list">capture list</a> -&gt; return type { function body }~</p>
<p>其中，capture list（捕获列表）是一个 lambda 所在函数中定义的局部变量的列表（通常为空）；return type、parameter list 和 function body 与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，lambda 必须使用尾置返回来指定返回类型。</p>
<p>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p>
<p>~auto f = [] { return 42; };~</p>
<p>此列中，我们定义了一个可调用对象 f，它不接受参数，返回 42。</p>
<p>在 lambda 中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用 f 时，参数列表是空的。如果忽略返回类型，lambda 根据函数体中的代码推断出返回类型。如果函数体只是一个 return 语句，则返回类型从返回的表达式的类型推断而来，否则返回类型为 void。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果 lambda 的函数体包含任何单一 return 语句之外的内容，且未指定返回类型，则返回 void。 #+END_QUOTE **** 向 lambda 传递参数 与一个普通函数调用类型，调用一个 lambda 时给定的实参被用来初始化 lambda 的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，lambda 不能有默认参数。因此，一个 lambda 调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。 **** 使用捕获列表 虽然一个 lambda 可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个 lambda 通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引 lambda 在其内部包含访问局部变量所需的信息。</p>
<p>#+BEGIN_SRC C++ <a href="const%20string%20&amp;a">sz</a> { return a.size() &gt; sz; }; #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>一个 lambda 只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>捕获列表只有用于局部非 static 变量，lambda 可以值接使用局部 static 变量和它所在函数之外声明的名字。 #+END_QUOTE *** 10.3.3 lambda 捕获和返回 当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型。我们将在 14.8.1 节介绍这种类时如何生成的。目前，可以这样理解，当向一个函数传递一个 lambda 时，同时定义一个新类型和该类型的一个对象；传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用 auto 定义一个 lambda 初始化的变量时，定义了一个从 lambda 生成的类型的对象。</p>
<p>默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员。类似任何普通类的数据成员，lambda 的数据成员也在 lambda 对象创建时被初始化。 **** 值捕获 类似参数传递，变量捕获的方式也可以是值或引用。与传值参数类型，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值在 lambda 创建时拷贝，而不是调用时拷贝：</p>
<p>#+BEGIN_SRC C++ void fcn1 { size_t v1 = 42; // 局部变量 // 将v1拷贝到名为f的可调用对象 auto f = [v1] { return v1; }; v1 = 0; auto j = f(); // j为42；f保存了我们创建它时v1的拷贝 } #+END_SRC</p>
<p>由于被捕获变量的值是在 lambda 创建时拷贝，因此随后对其修改不会影响到 lambda 内对应的值。 **** 引用捕获 #+BEGIN_SRC C++ void fcn2 { size_t v1 = 42; // 局部变量 // 对象f2包含v1的引用 auto f2 = [&amp;v1] { return v1; }; v1 = 0; auto j = f2(); // j为0；f保存v1的引用，而非拷贝 } #+END_SRC</p>
<p>引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的。lambda 捕获的都是局部变量，这些变量在函数结果后就不复存在了。如果 lambda 可能在函数结束后执行，捕获的引用指向的局部变量已经消失。</p>
<p>我们也可以从一个函数返回 lambda。函数可以值接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个 lambda，则与函数不能返回一个局部变量的引用类型四，此 lambda 也不能包含引用捕获。</p>
<p>#+BEGIN_QUOTE 当以引用方式捕获一个变量时，必须保证在 lambda 执行时变量是存在的。 #+END_QUOTE **** 隐式捕获 除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据 lambda 体种的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。</p>
<p>如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获。</p>
<p>当我们混合使用隐式捕获和显式捕获时，捕获列表种的第一个元素必须时一个&amp;或=。此符号执行默认捕获方式为引用或值。</p>
<p>当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了&amp;），则显式捕获命名变量必须采用值方式，因此不能在其名字前使用&amp;。类型的，如果隐式捕获采用的值方式（使用了=），则显式捕获命名变量必须采用引用方式，即，在名字前使用&amp;。</p>
<p>#+CAPTION: lambda 捕获列表 | [] | 空捕获列表。lambda 不能使用所在函数种的变量。一个 lambda 只有捕获变量后才能使用它们 | | [names] | names 是一个逗号分隔的名字列表，这些名字都是 lambda 所在函数的局部变量。默认情况下，捕获列表种的变量都被拷贝。名字前如果使用了&amp;，则采用引用捕获方式 | | [&amp;] | 隐式捕获列表，采用引用捕获方式。lambda 体中所使用的来自所在函数的实体都采用引用方式使用 | | [=] | 隐式捕获列表，采用值捕获方式。lambda 体将拷所使用的来自所在函数的实体的值 | | [&amp;, identifier_list] | identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list 中的名字钱明不能使用&amp; | | [=, identifier_list] | identifier_list 中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。identifier_list 中的名字不能包括 this，且这些名字之前必须使用&amp; | **** 可变 lambda 默认情况下，对于一个值被拷贝的变量，lambda 不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字 mutable。因此可变 lambda 能省略参数列表：</p>
<p>#+BEGIN_SRC C++ void fcn3() { size_t v1 = 42; // 局部变量 // f可以改变它所捕获的变量的值 auto f = [v1] () mutable { return ++v1; } ; v1 = 0; auto j = f(); // j为42 } #+END_SRC **** 指定 lambda 返回类型 当我们需要为一个 lambda 定义返回类型时，必须使用尾置返回类型。 *** 10.3.4 参数绑定 对于哪种只在一两个地方使用的简单操作，lambda 表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的 lambda 表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。 **** 标准库 bind 函数 可以将 bind 函数看作一个通用的函数适配器（参见 9.6 节），它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。bind 定义在头文件 functional 中。</p>
<p>调用 bind 的一般形式为：</p>
<p>~auto newCallable = bind(callable, arg_list);~</p>
<p>其中，newCallable 本身是一个可调用对象，arg_list 是一个逗号分隔的参数列表，对应给定的 callable 的参数。即，当我们调用 newCallable 时，newCallable 会调用 callable，并传递给它 arg_list 中的参数。</p>
<p>arg_list 中的参数可能包含形如_n 的名字，其中 n 是一个整数。这些参数是“占位符”，表示 newCallable 的参数，他们占据了传递给 newCallable 的参数的“位置”。数值 n 表示生成的可调用对象中参数的位置：_1 为 newCallable 的第一个参数，_2 为第二个参数，依次类推。 **** 使用 placeholders 名字 名字_n 都定义在一个名为 placeholders 的命名空间中，而这个命名空间本身定义在 std 命名空间值中。为了使用这些名字，两个命名空间都要写上。与我们的其他例子类似，对 bind 的调用代码假定之前已经适当地使用了 using 声明，例如，_1 对应的 using 声明为：</p>
<p>~using std::placeholders::_1;~</p>
<p>对每个占位符名字，我们都必须提供一个单独的 using 声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的 using 语句（详细内容在 18.2.2 节中介绍），而不是分别声明每个占位符。如下所示：</p>
<p>~using namespace namespace_name;~</p>
<p>这种形式说明希望所有来自 namespace_name 的名字都可以在我们的程序中直接使用。 **** bind 的参数 如前文所述，我们可以用 bind 修正参数的值。更一般的，可以用 bind 绑定给定可调用对象中的参数或重新安排其顺序。例如，假定 f 是一个可调用对象，它有 5 个此哪哈苏，则下面对 bind 的调用：</p>
<p>#+BEGIN_SRC C++ // g是一个有两个参数的可调用对象 auto g = bind(f, a, b, _2, c, _1); #+END_SRC</p>
<p>生成一个信的可调用对象，它有两个参数，分别用占用符_2 和_1 表示。这个新的可调用对象将他自己的参数作为第三个和第五个参数传递给 f。f 的第一个、第二个和第四个参数分别绑定到给定的值 a、b 和 c 上。</p>
<p>传递给 g 的参数按位置绑定到占位符。即，第个参数绑定到_1，第二个参数绑定到_2，当我们调用 g 时，其第一个参数将被传递给 f 作为最后一个参数，第二个参数将被传递给 f 作为第三个参数。实际上，这个 bind 调用会将</p>
<p>~g(_1, _2)~</p>
<p>映射为</p>
<p>~f(a, b, _2, c, _2)~</p>
<p>即，对 g 的调用会调用 f，用 g 的参数代替占位符，再加上绑定参数 a、b 和 c。例如，调用 g(X,Y)会调用</p>
<p>~f(a, b, Y, c, X)~ **** 绑定引用参数 默认情况下，bind 的那些不是占位符的参数被拷贝到 bind 返回的可调用对象中。单是，与 lambda 类似，有时对有些绑定的参数我们希望以引用方式传递，或者要绑定参数的类型无法拷贝。例如：</p>
<p>#+BEGIN_SRC C++ // os是一个局部变量，引用一个输出流 // c是一个局部变量，类型为char ostream &amp;print(ostream &amp;os, const string &amp;s, char c) { return os &lt;&lt; s &lt;&lt; c; }</p>
<p>// 错误：不能拷贝os for_each(words.begin(), words.end(), bind(print, os, _1, ’’ )); #+END_SRC</p>
<p>如果我们希望传递给 bind 一个对象而又不拷贝它，就必须使用标准库 <em>ref</em> 函数：</p>
<p>#+BEGIN_SRC C++ for_each(words.begin(), words.end(), bind(print, ref(os), _1, ’ ’)); #+END_SRC</p>
<p>函数 ref 返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个 <em>cref</em> 函数，生成一个保存 const 引用的类。与 bind 一样，函数 ref 和 cref 也定义在头文件 functional 中。 ** 10.4 再探迭代器 除了为每个容器定义的迭代器之外，标准库在头文件 iterator 中还定义了额外几种迭代器。这些迭代器包括以下几种： - <em>插入迭代器</em> ：这些迭代器被绑定到一个容器上，可用来向容器插入元素。 - <em>流迭代器</em> ：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的 IO 流。 - <em>反向迭代器</em> ：这些迭代器向后而不是向前移动。除了 forward_list 之外的标准库容器都有反向迭代器。 - <em>移动迭代器</em> ：这些专用的迭代器不是拷贝其中的元素，而是移动它们。我们将在 13.6.2 节介绍移动迭代器。 *** 10.4.1 插入迭代器 插入器是一种适配器（参见 9.6 节），它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来想给定容器的指定位置插入一个元素。</p>
<p>#+CAPTION: 插入迭代器操作 | it=t | 在 it 指定的当前位置插入值 t。假定 c 是 it 绑定的容器，依赖于插入迭代器的不同种类，此赋值会分别调用 c.push_back(t)、c.push_front(t)或 c.insert(t,p)，其中 p 为传递给 inserter 的迭代器位置 | | *it,++it,it++ | 这些操作虽然存在，但不会 it 做任何事情。每个操作都返回 it |</p>
<p>插入器有三种类型，差异再与元素插入的位置： - <em>back_inserter</em> 创建一个使用 push_back 的迭代器 - <em>front_inserter</em> 创建一个使用 push_front 的迭代器 - <em>inserter</em> 创建一个使用 insert 的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>只有在容器支持 push_front 的情况下，我们才可以使用 front_inserter。类似的，只有在容器支持 push_back 的情况下，我们才能使用 back_inserter。 #+END_QUOTE *** 10.4.2 iostream 迭代器 虽然 iostream 类型不是容器，但标准库定义了可以用于这些 IO 类型对象的迭代器。 <em>istream_iterator</em> 读取输入流， <em>ostream_iterator</em> 向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据已经向其写入数据。 **** istream_iterator 操作 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个 istream_iterator 使用&gt;&gt;来读取流。因此，istream_iterator 要读取的类型必须定义了输入运算符。当创建一个 istream_iterator 时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。</p>
<p>#+BEGIN_SRC C++ istream_iterator<int> int_it(cin); // 从cin读取int istream_iterator<int> int_eof; // 尾后迭代器 ifstream in(“afile”); istream_iterator<string> str_it(in); // 从“afile”读取字符串 #+END_SRC</p>
<p>下面时一个用 istream_iterator 从标准输入读取数据，存入一个 vector 的例子：</p>
<p>#+BEGIN_SRC C++ istream_iterator<int> in_iter(cin); // 从cin读取int istream_iterator<int> eof; // istream尾后迭代器 while (in_iter != eof) // 先后置递增，再解引用 vec.push_back(*in_iter++); #+END_SRC</p>
<p>#+CAPTION: istream_iterator 操作 | istream_iterator<T> in(is); | in 从输入流 is 读取类型为 T 的值 | | istream_iterator<T> end; | 读取类型为 T 的值的 istream_iterator 迭代器，表示尾后位置 | | in1 == in2 | in1 和 in2 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等 | | in1 != in2 | | | <em>in | 返回从流中读取的值 | | in-&gt;mem | 与(</em>in).mem 的含义相同 | | =++in, in++= | 使用元素类型所定义的&gt;&gt;运算符从输入流读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值 | **** istream_iterator 允许使用懒惰求值 当我们将一个 istream_iterator 绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没有什么差别。单是，如果我们创建了一个 istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。</p>
<p>**** ostream_iterator 操作 我们可以对任何具有输出运算符（&lt;&lt;运算符）的类型定义 ostream_iterator。当创建一个 ostream_iterator 时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素之后都会打印此字符。此字符串必须时一个 C 风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。必须将 ostream_iterator 绑定到一个指定的流，不容许空的或表示尾后位置的 ostream_iterator。</p>
<p>#+CAPTION: ostream_iterator 操作 | ostream_iterator<T> out(os); | out 将类型为 T 的值写到输出流 os 中 | | ostream_iterator<T> out(os,d); | out 将类型为 T 的值写到输出流 os 中，每个值后面都输出一个 d。d 指向一个空字符结尾的字符数组 | | out = val | 用&lt;&lt;运算符将 val 写入到 out 所绑定的 ostream 中。val 的类型必须与 out 可写的类型兼容 | | <em>out, =++out, out++= | 这些运算符是存在的，但不对 out 做任何事情。每个运算符都返回 out | </em>** 10.4.3 反向迭代器 #+BEGIN_QUOTE Note：</p>
<p>反向迭代器的目的是表示元素范围、而这些范围是不对称的，这导致一个重要的结果：当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。 #+END_QUOTE ** 10.5 泛型算法结构 算法所要求的迭代器操操作可以分为 <em>5 个迭代器类别</em> ，如下表所示。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。</p>
<p>#+CAPTION: 迭代器类别 | 输入迭代器 | 只读，不写；单遍扫描，只能递增 | | 输出迭代器 | 只写，不读；单遍扫描，只能递增 | | 前向迭代器 | 可读写；多遍扫猫，只能递增 | | 双向迭代器 | 可读写；多遍扫猫，可递增递减 | | 随机访问迭代器 | 可读写，多遍扫猫，支持全部迭代器运算 | *** 10.5.1 5 类迭代器 #+BEGIN_QUOTE WARNING：</p>
<p>对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。 #+END_QUOTE **** 迭代器类别 <em>输入迭代器</em> ：可以读取序列中的元素。一个与输入迭代器必须支持 - 用于比较两个迭代器的相等和不相等运算符（==、!=） - 用于推进迭代器的前置和后置递增运算符（++） - 用于读取元素的解引用（×）：解引用只会出现赋值运算符的右侧 - 箭头运算符（-&gt;），等价于(*it).member，即，解引用迭代器，并提取对象的成员</p>
<p>输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，单递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此输入迭代器只能用于单遍扫描算法。算法 find 和 accumulate 要求输入迭代器；而 istream_iterator 是一种输入迭代器。</p>
<p><em>输出迭代器</em> ：可以看作输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持 - 用于推进迭代器的前置和后置递增运算（++） - 解引用运算符（*），只出现在赋值运算符的左侧（向一个已解引用的输出迭代器赋值，就是将值写入它所指向的元素）</p>
<p>我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy 函数的第三个参数就是输出迭代器。ostream_iterator 类型也是输出迭代器。</p>
<p><em>前向迭代器</em> ：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法 repalce 要求前向迭代器，forward_list 上的迭代器是前向迭代器。</p>
<p><em>双向迭代器</em> ：可以正向/反向读写序列中的元素。除了支持所有前向迭代器操作之外，双向迭代器还支持前置和后置递减运算符（–）。算法 reverse 要求双向迭代器，除了 forward_list 之外，其他前标准库都提供符合双向迭代器要求的迭代器。</p>
<p><em>随机访问迭代器</em> ：提供在常量时间内访问弗烈中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持表 3.7 中的操作： - 用于比较两个迭代器相对位置的关系运算符（&lt;、&lt;=、&gt;和&gt;=） - 迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置 - 用于两个迭代器上的减法元算符（-），得道两个迭代器的距离 - 下标运算符（iter[n]），与<em>(iter[n])等价 算法 sort 要求随机访问迭代器。array、deque、string 和 vector 的迭代器都是随机访问迭代器，用于访问内置数据元素的指针也是。 </em>** 10.5.2 算法形参模式 大多数算法具有如下 4 种形式之一： - alg(beg, end, other args); - alg(beg, end, dest, other args); - alg(beg, end, beg2, other args); - alg(beg, end, beg2, end2, other args);</p>
<p>其中 alg 是算法的名字，beg 和 end 表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种——dest、beg2 和 end2,都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。 **** 接受单个目标迭代器的算法 dest 参数是一个表示算法可以写入的目的位置的迭代器。算法假定：按其需要写入数据，不管写入多少个元素都是安全的。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。 #+END_QUOTE</p>
<p>如果 desk 是一个指向容器的迭代器，那么算法将输出数据写到容器种已存在的元素内。更常见的情况是，dest 被绑定到一个插入迭代器或是一个 ostream_iterator。插入迭代器会将新元素添加到容器中，因而保证空间元素是足够的。ostream_iterator 会将数据写入到一个输出流，同样不管要写多少个元素都么有问题。 **** 接受第二个输入序列的算法 #+BEGIN_QUOTE WARNING：</p>
<p>接受单独 beg2 的算法假定从 beg2 开始的序列与 beg 和 end 所表示的范围至少一样大。 #+END_QUOTE *** 10.5.3 算法命名规则 **** 一些算法使用重载形式传递一个谓词 接受谓词参数来代替&lt;或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，啊里代替&lt;或==。 **** _if 版本的算法 接受一个元素值的算法通常有另一个不同名（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的_if 前缀。</p>
<p>#+BEGIN_SRC C++ find(beg, end, val); // 查找输入范围中val第一次出现的位置 find_if(beg, end, pred); // 查找第一个名pred为真的元素 #+END_SRC</p>
<p>这两个算法提供了命名差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义。虽然很罕见，但为了避免任何可能的歧义，标准库选择提供不同名字的版本而不是重载。 **** 区分拷贝元素的版本和不拷贝的版本 默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的的空间的算法都在名字后面附加了一个_copy（参见 10.2.2 节）：</p>
<p>#+BEGIN_SRC C++ reverse(beg, end); // 反转输入范围中的元素 reserve(beg, end, dest); // 将元素按逆序拷贝到dest #+END_SRC</p>
<p>一些算法同时提供_copy 和_if 版本。这些版本接受一个目的位置迭代器和一个谓词。 ** 10.6 特定容器算法 与其他容器不同，链表类型 list 和 forward_list 定义了几个成员函数形式的算法，如下表所示。特别是，它们定义了独有的 sort、merge、remove、reverseh 额 unique。通用版本的 sort 要求随机访问迭代器，因此不能用于 list 和 forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。</p>
<p>链表类型定义的其他算法的通用版本可以用于链接，但代加太高。这些算法需要交换输入序列中的元素。一个列表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换元素”。因此，这些链表版本的算法的性能比对应的通用版本好得多。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>对于 list 和 forward_list，应该优先使用成员函数版本的算法而不是通用算法。 #+END_QUOTE</p>
<p>#+CAPTION: list 和 foward_list 成员函数版本的算法 | | 这些操作都返回 void | | lst.merge(lst2) | 将来自 lst2 的元素合并入 lst。list 和 lst2 都必须是有序的。 | | lst.merge(lst2,comp) | 元素将从 lst2 中删除。在合并之后，lst2 变空。第一个版本使用&lt;运算符；第二个版本使用给定的比较操作 | | lst.remove(val) | 调用 erase 删除掉与给定值相等（==）或令一元谓词为真的每个元素 | | lst.remove_if(pred) | | | lst.reserve() | 反转 lst 中元素的顺序 | | lst.sort() | 使用&lt;或给定比较操作排序元素 | | lst.sort(comp) | | | lst.unique() | 调用 erase 删除同一个值的连续拷贝。第一个版本使用==；第二版本使用给定的二元谓词 | | lst.unique(pred) | | **** splice 成员 链表类型还定义了 splice 算法，其描述见下表。此算法是链表数据结构所特有的，因此不需要通用版本。</p>
<p>#+CAPTION: list 和 forward_list 的 splice 成员函数的参数 | | lst.splice(args)或 flst.splice_after(args) | | (p, lst2) | p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。函数将 lst2 的所有元素移动到 lst 中 p 之前的位置或是 flst 中 p 之后的位置。将元素从 lst2 中删除。lst2 的类型必须与 lst 或 flst 相同，且不能是同一个链表 | | (p, lst2, p2) | p2 是一个指向 lst2 中位置的有效的迭代器。将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中。lst2 可以是与 lst 或 flst 相同的链表 | | (p, lst2, b, e) | b 和 e 必须表示 lst2 中的合法范围。将给定范围中的元素从 lst2 移动到 lst 或 flst。lst2 与 lst（或 flst）可以是相同的链表，但 p 不能指向给定范围中元素 | **** 链表特有的操作会改变容器 多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，remove 的链表版本会删除指定的元素。unique 的链表版本会删除第二个和后继的重复元素。</p>
<p>类似的 merge 和 splice 会销毁其桉树。例如，通用版本的 mrege 将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的 merge 函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用 merge 的链表对象中。在 merge 之后，来自两个链表的元素仍然存在，但它们都已在同一个链表中。 * 第 11 章 关联容器 关联容器支持高效的关键字查找和访问。两个主要的 <em>关联容器</em> 类型是 <em>map</em> 和 <em>set</em> 。map 中的元素是一些关键字-值对；关键字起到索引的作用，值则表示与索引相关联的数据。set 中每个元素只包含一个关键字；set 支持高效的关键字查寻操作——检查一个给定关键字是否在 set 中。</p>
<p>标准库提供 8 个关联容器，如下表所示。这 8 个容器间的不同体现在三个维度上：每个容器（1）说这是一个 set，或者是一个 map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字都包含但此 multi；不保存关键字按顺序存储的容器的名字都以 unordered 开头。</p>
<p>类型 map 和 mulimap 定义在头文件 map 中；set 和 multiset 定义在头文件 set 中；无须容器则定义在头文件 unordered_map 和 unordered_set 中。</p>
<p>#+CAPTION: 关联容器 | | <em>按关键字有序保存元素</em> | | map | 关联数组；保存关键字-值对 | | set | 关键字即值，即只保存关键字的容器 | | multimap | 关键字可重复出现的 map | | multiset | 关键字可重复出现的 set | | | <em>无序集合</em> | | unordered_map | 用哈希函数组织的 map | | unordered_set | 用哈希函数组织的 set | | unordered_multimap | 哈希组织的 map；关键字可以重复出现 | | unordered_multiset | 哈希组织的 set；关键字可以重复出现 | ** 11.1 使用关联容器 **** 使用 map #+BEGIN_SRC C++ map&lt;string, size_t&gt; word_count; // string到size_t的空map string word; while (cin &gt;&gt; word) ++word_count[word] // 提取word的计数器并将其加1 for (const auto &amp;w : word_count) count &lt;&lt; w.first &lt;&lt; " occurs " &lt;&lt; w.second &lt;&lt; ((w.second &gt; 1) ? " times" : " time") &lt;&lt; endl; #+END_SRC</p>
<p>当从 map 中提取一个元素时，会得到一个 pair 类型的对象，我们将在 11.2.3 节介绍它。简单来说，pair 是一个模板类型，保存两个名为 first 和 second 的（公有）数据成员。map 所使用的 pair 用 first 成员保存关键字，用 second 成员保存对应值。 **** 使用 set #+BEGIN_SRC C++ // 统计输入中每个但此出现的次数 map&lt;string, size_t&gt; word_count; // string到size_t的空map set<string> exclude = {“The”, “But”, “And”, “Or”，“An”, “A”, “the”, “but”, “and”, “or”, “an”, “a”}; string word; while (cin &gt;&gt; word) if (exclude.find(word) == exclude.end()) ++word_count[word]; #+END_SRC ** 11.2 关联容器概述 关联容器（有序的和无序的）都支持[[9.2 容器库概览][9.2节]]中介绍的普通普通容器操作。关联容器不支持顺序容器的位置相关的操作，例如 push_front 或 push_back。原因时关联容器中元素时根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p>
<p>除了与顺序容器相同的操作之外，关联容器还支持一些顺序容器不支持的操作和类型别名。此外，无序容器还提供一些用来调整哈希性能的操作，我们将在 11.4 节中介绍。</p>
<p>关联容器的迭代器都是双向的（参见 10.5.1 节） *** 11.2.1 定义关联容器 如前所示，当定义一个 map 时，必须既指明关键字类型又指明值类型；而定义一个 set 时，只需指明关键字类型，因为 set 中没有值。每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。我们也可以将关联容器初始化为另一个同类型容器的拷贝，或时从一个值范围来初始化关联容器，只要这些值快诶又转换为容器所需类型就可以。在新标准下，我们也可以对关联容器进行值初始化：</p>
<p>#+BEGIN_SRC C++ map&lt;string, size_t&gt; word_count; set<string> exclude = {“The”, “But”, “And”, “Or”，“An”, “A”, “the”, “but”, “and”, “or”, “an”, “a”}; map&lt;string, string&gt; authors = { {“Joyce”, “James”}, {“Austen”, “Jane”}, {“Dickens”, “Charles”}}; #+END_SRC *** 11.2.2 关键字类型的要求 对于有序容器——map、multimap、set 以及 multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>传递给排序算法的可调用对象（参见 10.3.1 节）必须满足与关键容器中关键字一样的类型要求。 #+END_QUOTE **** 有序容器的关键字类型 可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供 i 自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个 <em>严格弱序</em> 。可以将严格弱序看作”小于等于“，虽然实际定义的操作可能是一个复杂的函数。无论我们怎么样定义比较函数，它必须具备如下基本性质： - 两个关键字不能同时”小于等于“对方；如果 k1”小于等于“k2,那么 k2 绝不能”小于等于“k1 - 如果 k1”小于等于“k2，且 k2”小于等于“k3，那么 k1 必须”小于等于“k3. - 如果存在两个关键字，任何一个都不”小于等于“另一个，那么我们称这两个关键字是“等价”的。如果 k1“等价于”k2,且 k2“等价于”k3,那么 k1 必须“等价于”k3.</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>在实际编程中，重要的是，如果有一个类型定义了“行为正常”的&lt;运算符，则它可以用作关键字类型。 #+END_QUOTE **** 使用关键字类型的比较函数 用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。</p>
<p>在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。</p>
<p>#+BEGIN_SRC C++ multiset&lt;Sales_data, decltype(compareIsbn)<em>&gt; bookstore(compareIsbn); #+END_SRC </em>** 11.2.3 pair 类型 在介绍关联容器操作之前，我们需要了解名为 <em>pair</em> 的标准库类型，它定义在头文件 utility 中。</p>
<p>一个 pair 保存两个数据成员。类型容器，pair 是一个用来生成特定类型的模板。当创建一个 pair 时，我们必须提供两个类型名，pair 的数据类型将具有对应的类型。两个类型不要求一样：</p>
<p>与其他标准库类型不同，pair 的数据成员是 public 的。两个成员分别命名为 first 和 second。</p>
<p>#+CAPTION: pair 上的操作 | pair&lt;T1, T2&gt; p; | p 是一个 pair，两个类型分别为 T1 和 T2 的成员都进行了值初始化 | | pair&lt;T1, T2&gt; p(v1, v2) | p 是一个成员类型为 T1 和 T2 的 pair；first 和 second 的成员分别用 v1 和 v2 进行初始化 | | pair&lt;T1, T2&gt;p = (v1, v2); | 等价于 p(v1, v2) | | make_pair(v1, v2) | 返回一个用 v1 和 v2 初始化的 pair。pair 的类型从 v1 和 v2 的类型推断出来 | | p.first | 返回 p 的名为 first 的（公有）数据成员 | | p.second | 返回 p 的名为 second 的（公有）数据成员 | | p1 relop p2 | 关系运算符（&lt;、&gt;、&lt;=、&gt;=）按字典序定义：例如，当 p1.first &lt; p2.first 或!(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second 成立时， | | | p1 &lt; p2 为 true。关系运算符利用元素的&lt;运算符来实现 | | p1 == p2 | 当 first 和 second 成员分别相等时，两个 pair 相等。相等性判断利用元素的==运算符来实现 | | p1 != p2 | | **** 创建 pair 对象的函数 在新标准下，我们可以对返回值进行列表初始化。 ** 11.3 关联容器操作 #+CAPTION: 关联容器额外的类型别名 | key_type | 此容器类型的关键字类型 | | mapped_type | 每个关键字关联的类型；只适用于 map | | value_type | 对于 set，与 key_type 相同 | | | 对于 map，为 pair&lt;const key_type, mapped_type&gt; | *** 11.3.1 关联容器迭代器 当解引用一个关联容器迭代器时，我们会得到一个类型为容器的 value_type 的值的引用。对 map 而言，value_type 是一个 pair 类型，其 first 成员保存 const 的关键字，second 成员保存至。</p>
<p>#+BEGIN_QUOTE 必须记住，一个 map 的 value_type 是一个 pair，我们可以改变 pair 的值，但不能改变关键字成员的值。 #+END_QUOTE **** set 的迭代器是 const 的 虽然 set 类型同时定义了 iterator 和 const_iterator 类型，但两种类型都只允许只读访问 set 中的元素。与不能改变一个 map 元素的关键字一样，一个 set 中的关键字也是 const 的。可以用一个 set 迭代器来读取元素的值，但不能修改。 **** 遍历关联容器 #+BEGIN_QUOTE Note：</p>
<p>当使用一个迭代器遍历一个 map、multimap、set 或 multiset 时，迭代器按关键字升序遍历元素。 #+END_QUOTE **** 关联容器和算法 我们通常不对关键容器使用泛型算法。关键字 const 这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而 set 类型中的元素时 const 的，map 中的元素是 pair，其第一个成员是 const 的。</p>
<p>关联容器可用于只读取元素的算法。但是很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行（快速）查找，因此对其使用泛型搜索算法几乎总是一个坏注意。</p>
<p>在实际编程中，如果我们真要对一个关联容器使用算法，要么将它当作一个源序列，要么当作一个目的位置。例如，可以用泛型 copy 算法将元素从一个关联容器拷贝到另一个序列。类似的，可以调用 inserter 将一个插入器绑定到一个关联容器。通过 inserter，我们可以将关联容器当作一个目的位置来调用另一个算法。 *** 11.3.2 添加元素 关联容器的 insert 成员向容器中添加一个元素或一个元素范围。由于 map 和 set（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响。 **** 向 map 添加元素 对一个 map 进行 insert 操作时，必须记住元素类型是 pair。通常，对于想要插入的数据，并没有一个现成的 pair 对象。可以在 insert 的参数列表中创建一个 pair：</p>
<p>#+BEGIN_SRC C++ // 向word_count插入word的4种方法 word_count.insert({word, 1}); word_count.insert(make_pair(word, 1)); word_count.insert(pair&lt;string, size_t&gt;(word, 1)); word_count.insert(map&lt;string, size_t&gt;::value_type(word, 1)); #+END_SRC</p>
<p>如我们所见，在新标准下，创建一个 pair 最简单的方法是在参数列表中使用花括号初始化。也可以调用 make_pair 或显式构造 pair。</p>
<p>#+CAPTION: 关联容器 insert 操作 | c.insert(v) | v 是 value_type 类型的对象；args 用来构造一个元素 | | c.emplace(args) | 对于 map 和 set，只有当元素的关键字不在 c 中时才插入（或构造）元素。函数返回一个 pair，包含一个迭代器，指向具有特定关键的元素，以及一个指示插入是否成功的 bool 值 | | | 对于 multimap 和 multiset，总会插入（或构造）给定元素，并返回一个指向新元素的迭代器 | | c.insert(b, e) | b 和 e 时迭代器，表示一个 c::value_type 类型值的范围；il 时这种值的花括号列表。函数返回 void | | | 对于 map 和 set，只插入关键字不在 c 中的元素。对于 multimap 和 multiset，则会插入范围中的每个元素 | | c.insert(p, v) | 类似 insert(v)（或 emplace(args)），但将迭代器 p 作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素 | **** 检测 insert 的返回值 insert（或 emplace）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的 insert 和 emplace 版本返回一个 pair，告诉我们插入操作是否成功。pair 的 first 成员是一个迭代器，指向具有给定关键字的元素；second 成员是一个 bool 值，指出元素是插入成功还是已经存在于容器中。如果关键字已经在容器中，则 insert 什么事情也不做，且返回值中的 bool 部分为 false。如果关键字不存在，元素被插入容器中，且 bool 值为 true。 **** 向 multiset 和 multimap 添加元素 对允许重复关键字的容器，接受单个元素的 insert 操作返回一个指向新元素的迭代器。这里无须返回一个 bool 值，因为 insert 总是向这类容器中加入一个新元素。 *** 11.3.3 删除元素 #+CAPTION: 从关联容器删除元素 | c.erase(k) | 从 c 中删除每个关键字为 k 的元素。返回一个 size_type 值，指出删除的元素的数据 | | c.erase(p) | 从 c 中删除迭代器 p 指定的元素。p必须指向 c 中一个真实元素，不能等于 c.end()。返回一个指向 p 之后元素的迭代器，若 p 指向 c 中的尾元素，则返回 c.end() | | c.erase(b, e) | 删除迭代器对 b 和 e 所表示的范围中的元素，返回 e | *** 11.3.4 map 的下标操作 #+CAPTION: map 和 unordered_map 的下标操作 | c[k] | 返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化 | | c.at(k) | 访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出一个 out_of_range 异常 | **** 使用下标操作的返回值 map 的下标运算符与我们用过的其他下标运算符的另一个不同之处是其返回类型。通常情况下，解引用一个迭代器返回的类型与下标运算符返回的类型是一样的。但对 map 则不然；当对一个 map 进行下标操作时，会获得一个 mapped_type 对象；但当解引用一个 map 迭代器时，会得到一个 value_type 对象。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>与 vector 与 string 不同，map 的下标运算符返回的类型与解引用 map 迭代器得到的类型不同。 #+END_QUOTE</p>
<p>如果关键字还未在 map 中，下标运算符会添加一个新元素，这一特定允许我们编写出异常简洁的程序。另一方面，有时指示向直到一个元素是否已在 map 中，但再不存在时并不想添加元素。在这种情况下，就不能使用下标运算符。 *** 11.3.5 访问元素 如果我们所关心的只不过时一个特定元素是否已在容器中，可能 find 是最佳选择。对于不允许重复关键字的容器，可能使用 find 还是 count 没什么区别。但对于允许重复关键字的容器，count 还会做更多的工作：如果元素在容器中，它还会统计有多少个元素有相同的关键字。如果不需要计数，最好使用 find。</p>
<p>#+CAPTION: 在一个关联容器中查找元素的操作 | | lower_bound 和 upper_bound 不适用于无序容器 | | | 下标和 at 操作只适用于非 const 的 map 和 unordered_map | | c.find(k) | 返回迭代器，指向第一个关键字为 k 的元素，若 k 不在容器中，则返回尾后迭代器 | | c.count(k) | 返回关键字等于 k 的元素的数量。对于不允许重复关键字的容器，返回值永远时 0 或 1 | | c.lower_bound(k) | 返回一个迭代器，指向第一个关键字不小于 k 的元素 | | c.upper_bound(k) | 返回一个迭代器，指向第一个关键字大于 k 的元素 | | c.equal_range(k) | 返回一个迭代器 pair，表示关键字等于 k 的元素的范围。若 k 不存在，pair 的两个成员均等于 c.end() | **** 一种不同的，面向迭代器的解决方法 #+BEGIN_QUOTE lower_bound 返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键在不在容器中，则 lower_bound 会返回关键字的第一个安全插入点——不影响容器中元素顺序的插入位置。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果 lower_bound 和 upper_bound 返回相同的迭代器，则给定关键字不在容器中。 #+END_QUOTE</p>
<p>** 11.4 无序容器 新标准定义了 4 <em>无序关联容器</em> 。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。</p>
<p>虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单（通常也会有更好的性能）。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>如果关键字类型固有就是无序的，或者性能测试发现问题可以使用哈希技术解决，就可以使用无序容器。 #+END_QUOTE **** 使用无序容器 除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作（find、insert 等）。这意味着我们曾用于 map 和 set 的操作也能用于 unordered_map 和 unordered_set。类似的，无序容器也有允许重复关键的版本。</p>
<p>因此，通常可以用一个无序容器替换对应的有序容器，反之亦然。但是，由于元素未按顺序存储，一个使用无序容器的程序输出（通常）会与使用有序容器的版本不同。 **** 管理桶 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同容器的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<p>对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。单是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。单是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。</p>
<p>无序容器提供了一组管理桶的函数，如下表所示。这些成员函数允许我们查寻容器的状态以及在必要的时强制容器进行重组。</p>
<p>#+CAPTION: 无序容器管理操作 | <em>桶接口</em> | | | c.bucket_count() | 正在使用的桶的数目 | | c.max_bucket_count() | 容器能容纳的最多的桶的数量 | | c.bucket_size(1) | 第 n 个桶中有多少个元素 | | c.bucket(k) | 关键字为 k 的元素在哪个桶中 | | <em>桶迭代</em> | | | local_iterator | 可以用来访问桶中元素的迭代器类型 | | const_local_iterator | 桶迭代器的 const 版本 | | c.begin(n), c.end(n) | 桶 n 的首元素迭代器和尾后迭代器 | | c.cbegin(n), c,cend(n) | 与前两个函数相似，但返回 const_local_iterator | | <em>哈希策略</em> | | | c.load_factor() | 每个桶的平均元素数量，返回 float 值 | | c.max_load_factor() | c 试图维护的平均桶大小，返回 float 值。c会在需要时添加新的桶，以使得 load_factor&lt;=max_load_factor | | c.rehash(n) | 重组存储，使得 bucket_count&gt;=n 且 bucket_count&gt;size/max_load_factor | | c.reserve(n) | 重组存储，使得 c 可以保存 n 个元素且不必 rehash | **** 无序容器对关键类型的要求 默认情况下，无序容器使用关键字类型的==运算符来比较元素，它们还时用一个 hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了 <em>hash</em> 模板。还为一些标准库类型，包括 string 和我们将要在第 12 章介绍的智能指针类型定义了 hash。因此，我们可以直接定义关键字时内置类型（包括指针类型）、string 还是智能指针类型的无序容器。</p>
<p>但是，我们不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的 hash 模板版本。我们将在 16.5 节中介绍如何做到这一点。</p>
<p>我们不使用默认的 hash，而是使用另一种方法，类似于有序容器重载关键字类型的默认比较操作。我们需要提供函数来替代==和哈希值计算函数。 * 第 12 章 动态内存 我们的程序到目前为止只使用过静态内存或栈内存。静态内存用来保存局部 static 对象、类 static 数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非 static 对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static 对象在使用之前分配，在程序结束时销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称为 <em>自由空间</em> 或 <em>堆</em> 。程序用堆来存储 <em>动态分配</em> 的对象——即那些程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。 ** 12.1 动态内存与智能指针 在 C++中，动态内存的管理是通过一对运算符来完成的： <em>new</em> ，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化； <em>delete</em> ，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>
<p>为了更容器（同时也更安全）地使用动态内存，新的标准库提供了两种 <em>智能指针</em> 类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式： <em>shared_ptr</em> 允许多个指针指向同一个对象； <em>unique_ptr</em> 则“独占”所指向的对象。标准库还定义了一个名为 <em>weak_ptr</em> 的伴随类，它是一种弱引用，指向 shared_ptr 所管理的对象。这三种类型都定义在 memory 头文件中。 *** 12.1.1 shared_ptr 类 #+CAPTION: shared_ptr 和 unique_ptr 都支持的操作 | shared_ptr<T> sp | 空智能指针，可以指向类型为 T 的对象 | | unique_ptr<T> upper_bound | | | p | 将 p 用作一个条件判断，若 p 指向一个对象，则为 true | | <em>P | 解引用 p，获得它指向的对象 | | p-&gt;mem | 等价于(</em>p).mem | | p.get() | 返回 p 中保存的指针，要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了 | | swap(p, q) | 交换 p 和 q 中的指针 | | p.swap(q) | |</p>
<p>#+CAPTION: shared_ptr 独有的操作 | make_shared<T>(args) | 返回一个 shared_ptr，指向一个动态分配的类型为 T 的对象。使用 args 初始化此对象 | | shared_ptr<T>p(q) | p 是 shared_ptr q 的拷贝；此操作会递增 q 中的计数器。q中的指针必须能转换为 T× | | p = q | p 和 q 都是 shared_ptr，所保存的指针必须能相互转换。此操作会递减 p 的引用计数，递增 q 的引用计数；若 p 的引用计数变为 0，则将其管理的原内存释放 | | p.unique() | 若 p.use_count()为 1，返回 true；否则返回 false | | p.use_count() | 返回与 p 共享对象的智能指针数量；可能很慢，主要用于调试 | **** make_shared 函数 最安全的分配和使用动态内存的方法是调用一个名为 make_shared 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr。与智能指针一样，make_shared 也定义在头文件 memory 中。 **** shared_ptr 的拷贝和赋值 当进行拷贝或赋值操作时，每个 shared_ptr 都会记录有多少个其他 shared_Ptr 指向相同的对象。</p>
<p>我们可以认为每个 shared_ptr 都有一个关联的计数器，通常称其为 <em>引用计数</em> 。无论何时我们拷贝一个 shared_ptr，计数器都会递增。例如，当用一个 shared_ptr 初始化一个另一个 shared_ptr，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增。当我们给 shared_ptr 赋予一个新值或是 shared_ptr 被销毁（例如一个局部的 shared_ptr 离开作用域）时，计数器就会递减。</p>
<p>一旦一个 shared_ptr 的计数器变为 0，它就自动释放自己所管理的对象：</p>
<p>#+BEGIN_SRC C++ auto r = make_shared<int>(42); // r指向的int只有一个引用者 r = q; // 给r赋值，令它指向另一个地址 // 递增q指向的对象的引用技术 // 递减r原来指向的对象的引用计数 // r原来指向的对象已经没有引用者，会自动释放 #+END_SRC **** shared_ptr 自动销毁所管理的对象…… 当指向一个对象的最后一个 shared_ptr 被销毁时，shared_ptr 类会自动销毁此对象。它是通过另一个特殊的成员函数—— <em>析构函数</em> 完成销毁工作的。类似于构造函数，每个类都有一个析构函数。就像构造函数控制初始化一样，析构函数控制此类型的对象销毁时做什么操作。</p>
<p>shared_ptr 的析构函数会递减它所指向的对象的引用计数。如果引用计数变为 0，shared_ptr 的析构函数将会销毁对象，并释放它占用的内存。 **** ……shared_ptr 还会自动释放相关联的内存 #+BEGIN_QUOTE Note：</p>
<p>如果你将 shared_ptr 存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用 erase 删除不再需要的那些元素。 #+END_QUOTE **** 使用了动态生存期的资源的类 程序使用动态内存出于以下三种原因之一： 1. 程序不知道自己需要使用多少对象 2. 程序不知道所需要对象的类型 3. 程序需要在多个对象间共享数据 *** 12.1.2 直接管理内存 **** 使用 new 动态分配和初始化对象 默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。</p>
<p>我们可以使用直接初始方式来初始化一个动态分配的对象。我们可以使用传统的构造方式（使用圆括号），在新标准下，也可以使用列表初始化（使用花括号）。</p>
<p>也可以对动态分配的对象进行值初始化，只需在类型名之后跟一对空括号即可。</p>
<p>对于定义了自己的构造函数的类类型来说，要求值初始化时没有意义的：不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>出于与变量初始化相同的原因，对动态分配的对象进行初始化通常个好主意。 #+END_QUOTE</p>
<p>如果我们提供了一个括号包围的初始化器，就可以使用 auto 从此初始化器来推断我们想要分配的对象的类型。但时，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器才可以使用 auto：</p>
<p>#+BEGIN_SRC C++ auto p1 = new auto(obj); // p指向一个与obj类型相同的对象 // 该对象用obj进行初始化 auto p2 = new auto{a, b, c}; // 错误：括号中智能有单个初始化器 #+END_SRC **** 动态分配 const 对象 类似其他任何 const 对象，一个动态分配的 const 对象必须进行初始化。对于一个定义了默认构造函数的类类型，其 const 动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是 const 的，new 返回的指针是一个指向 const 的指针。 **** 内存耗尽 一个一个程序用光了它所有可用的内存，new 表达式就会失败。默认情况下，如果 new 不能分配所要求的内存空间，它会抛出一个类型未 bad_alloc 的异常。我们可以改变 new 的方式来阻止它抛出异常：</p>
<p>#+BEGIN_SRC C++ // 如果分配失败，new返回一个空指针 int <em>p1 = new int; // 如果分配失败，new抛出std::bad_alloc int </em>p2 = new (nothrow) int; // 如果分配失败，new返回一个空指针 #+END_SRC</p>
<p>我们称这种形式的 new 为 <em>定位 new</em> ，其原因我们将在 19.1.2 节中解释。定位 new 表达式允许我们向 new 传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为 nothrow 的对象。如果 nothrow 传递给 new，我们的意图是告诉它不能抛出异常。如果这种形式的 new 不能分配所需内存，它会返回一个指针。bad_alloc 和 nothrow 都定义在头文件 new 中。 **** 指针值和 delete 我们传递给 delete 的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非 new 分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</p>
<p>虽然一个 const 对象的值不能被改变，但它本身是可以销毁的，如同任何其他动态对象一样，想要释放一个 const 动态对象，只要 delete 指向它的指针即可。 **** delete 之后重值指针值…… 在 delete 之后，指针就变成了人们所说的 <em>空悬指针</em> ，即，指向一块曾经保存数据对象但现在已经无效的内存指针。</p>
<p>未初始化指针的所有缺点空悬指针也都有。有一种方法可以避免空悬指针问题：在指针即将要离开其作用域之前释放掉它所关联的内存。这样，在指针关联的内存被释放掉之后，就没有机会继续使用指针了。如果我们需要保留指针，可以在 delete 之后将 nullptr 赋予指针，这样就清楚地指出指针不指向任何对象。 *** 12.1.3 shared_ptr 和 new 结合使用 如前所述，如果我们不初始化一个智能指针，它就会被初始化未一个空指针。</p>
<p>接受指针参数的智能指针构造函数是 explicit。因此我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：</p>
<p>#+BEGIN_SRC C++ shared_ptr<int> p1 = new int(1024); // 错误：必须使用直接初始化形式 shared_ptr<int> p2(new int(1024)); // 正确：使用了直接初始化形式 #+END_SRC</p>
<p>#+CAPTION: 定义和改变 shared_ptr 的其他方法 | shared_ptr<T> p(q) | p 管理内置指针 q 所指向的对象；q必须指向 new 分配的内存，且能够转换为 T<em>类型 | | shared_ptr<T> p(u) | p 从 unique_ptr u 那里接管了对象的所有权；将 u 置位空 | | shared_ptr<T> p(q, d) | p 接管了内置指针 q 所指向的对象的所有权。q必须能转换成 T</em>类型。p将使用可调用对象 d 来代替 delete | | shared_ptr<T> p(p2, d) | p 是 shared_ptr p2 的拷贝，唯一的区别是 p 将可调用对象 d 来代替 delete | | p.reset() | 若 p 是唯一指向其对象的 shared_ptr，reset 会释放此对象。 | | p.reset(q) | 若传递了可选的参数内置指针 q，会令 p 指向 q，否则会将 p 置为空。 | | p.reset(q, d) | 若还传递了参数 d，将会调用 d 而不是 delete 来释放 q | **** 不要混合使用普通指针和智能指针…… shared_ptr 可以协调对象的析构，但这仅限于其自身的拷贝（也是 shared_ptr）之间。这也是为什么我们推荐使用 make_shared 而不是 new 的原因。这样，我们就能在分配对象的同时就将 shared_ptr 与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的 shared_ptr 上。</p>
<p>当将一个 shared_ptr 绑定到一个普通指针时，我们就将内存的管理责任交给了这个 shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问 shared_ptr 所指向的内存了。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法直到对象何时被销毁。 #+END_QUOTE **** ……也不要使用 get 初始化另一个智能指针或为智能指针赋值 智能指针类型定义了一个名为 get 的函数，它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不使用智能指针的代码传递一个内置指针。使用 get 返回的指针的代码不能 delete 此指针。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>get 用来将指针的访问权限传递给代码，你只有在确定代码不会 delete 指针的情况下，才能使用 get。特别是，永远不要用 get 初始化另一个智能指针或为另一个智能指针赋值。 #+END_QUOTE **** 其他 shared_ptr 操作 我们可以用 reset 来将一个新的指针赋予一个 shared_ptr。与赋值类似，reset 会更新引用计数，如果需要的话，会释放 p 所指向的对象。reset 成员经常与 unique 一起使用，来控制多个 shared_ptr 共享的对象。在改变底层对象之前，我们检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的拷贝。 *** 12.1.4 智能指针和异常 如果使用智能指针，即是程序块过早结束，智能指针类也能确保在内存不再需要时将其释放：</p>
<p>#+BEGIN_SRC C++ void f() { shared_ptr<int> sp(new int(42)); // 分配一个新对象 // 这段代码抛出一个异常，且在f中未被捕获 // 在函数结束时shared_ptr自动释放内存 } #+END_SRC</p>
<p>与之相对的，当发生异常时，我们直接管理的内存是不会自动释放的。如果使用内置指针管理内存，且在 new 之后在对应的 delete 之前发生了异常，则内存不会被释放：</p>
<p>#+BEGIN_SRC C++ void f() { int *ip = new int(42); // 这段代码抛出一个异常，且在f中未被捕获 delete ip; } #+END_SRC</p>
<p>如果在 new 和 delete 之间发生异常，且异常未在 f 中被捕获，则内存就永远不会被释放了。在函数 f 之外没有指针指向这块内存，因此就无法释放它了。</p>
<p>#+BEGIN_QUOTE 注意：智能指针先经</p>
<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：</p>
<ul>
<li>不使用相同的内置指针值初始化（或 reset）多个智能指针</li>
<li>不 delete get()返回的指针</li>
<li>不使用 get()初始化或 reset 另一个智能指针</li>
<li>如果你使用 get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是 new 分配的内存，记住传递给他一个删除器。 #+END_QUOTE *** 12.1.5 unique_ptr 一个 unique_ptr“拥有”它所指向的对象。与 shared_ptr 不同，某个时刻智能有一个 unique_ptr 指向一个给定对象。当 unique_ptr 被销毁时，它所指向的对象也被销毁。</li>
</ul>
<p>与 shared_ptr 不同，没有类似 make_shared 的标准库函数返回一个 unique_ptr。当我们定义一个 unique_ptr 时，需要将其绑定到一个 new 返回的指针上。类似 shared_ptr，初始化 unique_ptr 必须采用直接初始化形式。</p>
<p>由于一个 unique_ptr 拥有它指向的对象，因此 unique_ptr 不支持普通的拷贝或赋值操作。</p>
<p>#+CAPTION: unique_ptr 操作 | unique_ptr<T> u1 | 空 unique_ptr，可以指向类型为 T 的对象。u1 会使用 delete 来释放它的指针； | | unique_ptr&lt;T, D&gt; u2 | u2 会使用一个类型为 D 的可调用对象来释放它的指针。 | | unique_ptr&lt;T, D&gt; u(d) | 空 unique_ptr，指向类型为 T 的对象，用类型为 D 的对象 d 代替 delete | | u = nullptr | 释放 u 指向的对象，将 u 置为空 | | u.release() | u 放弃对指针的控制区，返回指针，并将 u 置为空 | | u.reset() | 释放 u 指向的对象 | | u.reset(q) | 如果提供了内置指针 q，令 u 指向这个对象；否则将 u 置为空 | | u.reset(nullptr) | |</p>
<p>虽然我们不能拷贝或赋值 unique_ptr，但可以通过调用 release 或 reset 将指针的所有权从一个（非 const）unique_ptr 转移给另一个 unique：</p>
<p>#+BEGIN_SRC C++ // 将所有权从p1（指向string Stegosaurus）转移给p2 unique_ptr<string> p2(p1.release()); // release将p1置为空 unique_ptr<string> p3(new string(“Trex”)); // 将所有权从片转移给p2 p2.reset(p3.release()); // reset 释放了p2原来指向的内存 #+END_SRC **** 传递 unique_ptr 参数和返回 unique_ptr 不能拷贝 unique_ptr 的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 unique_ptr。最常见的例子就是从函数返回一个 unique_ptr：</p>
<p>#+BEGIN_SRC C++ unique_ptr<int> clone(int p) { // 正确：从int*创建一个unique_ptr<int> return unique_ptr<int>(new int(p)); } #+END_SRC</p>
<p>还可以返回一个局部对象的拷贝：</p>
<p>#+BEGIN_SRC C++ unique_ptr<int> clone(int p) { unique_ptr<int> ret(new int (p)); // … return ret; } #+END_SRC</p>
<p>对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”，我们将在 13.6.2 节中介绍它。</p>
<p>#+BEGIN_QUOTE 向后兼容：auto_ptr</p>
<p>标准库的较早版本包含了一个名为 auto_ptr 的类，它具有 unique_ptr 的部分特定，但不是全部。特别是，我们不能在容器中保存 auto_ptr，也不能从函数中返回 auto_ptr。</p>
<p>虽然 auto_ptr 是仍是标准库的一部分，但编写程序时应该使用 unique_ptr。 #+END_QUOTE *** 12.1.6 weak_ptr weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象。讲一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。即使有 weak_ptr 指向对象，对象也还是会被释放，因此，weak_ptr 的名字抓住了这种智能指针“弱”共享对象的特点。</p>
<p>#+CAPTION: weak_ptr | weak_ptr<T> w | 空 weak_ptr 可以指向类型为 T 的对象 | | weak_ptr<T> w(sp) | 与 shared_ptr sp 指向相同对象的 weak_ptr。T 必须能转换为 sp 指向的类型 | | w = p | p 可以是一个 shared_ptr 或一个 weak_ptr。赋值后 w 与 p 共享对象 | | w.reset() | 将 w 置为空 | | w.use_count() | 与 w 共享对象的 shared_ptr 的数量 | | w.expired() | 若 w.use_count()为 0,返回 true，否则返回 false | | w.lock() | 如果 expired 为 true，返回一个空 shared_ptr；否则返回一个指向 w 的对象的 shared_ptr |</p>
<p>由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须调用 lock。此函数检查 weak_ptr 指向的对象是否仍存在。如果存在，lock 返回一个指向共享对象的 shared_ptr。与任何其他 shrad_ptr 类似，只要此 shared_ptr 存在，它所指向的底层对象也就会一直存在。</p>
<p>#+BEGIN_SRC C++ if (shared_ptr<int> np = wp.lock()) { // 如果np不为空则条件成立 // 在if中，np与p共享对象 } #+END_SRC ** 12.2 动态数组 new 和 delete 运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。例如，vector 和 string 都是在连续内存中保存它们的元素，因此，当容器需要重新分配内存时，必须一次行为很多元素分配内存。</p>
<p>为了支持这种需求，C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种 new 表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为 allocator 的类，允许我们将分配和初始化分离。使用 allocator 通常会提供更好的性能和更灵活的内存管理能力。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容器出现内存管理错误并且可能有更好的性能。 #+END_QUOTE ** 12.2.1 new 和数组 为了让 new 分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new 分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针：</p>
<p>#+BEGIN_SRC C++ // 调用get_size确定分配多少个int int *pia = new int[get_size()]; // pia指向第一个int #+END_SRC</p>
<p>方括号中的大小必须是整型，但不必是常量。 *** 初始化动态分配对象的数组 默认情况下，new 分配的对象，不管是单个分配的还是数组中的。都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。</p>
<p>#+BEGIN_SRC C++ int <em>pia = new int[10]; // 10个未初始化的int int </em>pia2 = new int<a href="">10</a>; // 10个值初始化为0的int string <em>psa = new string[10]; // 10个空string string </em>psa2 = new string<a href="">10</a>; // 10个空string #+END_SRC</p>
<p>在新标准中，我们还可以提供一个元素初始化器的花括号列表：</p>
<p>#+BEGIN_SRC C++ int <em>pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9}; // 10个string，前4个用给定的初始化器初始化，剩余的进行值初始化 string </em>psa3 = new string[10]{“a”, “an”, “the”, string(3, ‘x’)}; #+END_SRC *** 释放动态数组 为了释放动态数组，我们使用一种特殊形式的 delete——在指针前加上一个空方括号对：</p>
<p>#+BEGIN_SRC C++ delete p; // p必须指向一个动态分配的对象或为空 delete [] pa; // pa必须指向一个动态分配的数组或为空 #+END_SRC</p>
<p>第二条语句销毁 pa 指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依次类推。</p>
<p>当我们释放一个指向数组的指针时，空方括号对是必须的：它指示编译器此指针指向一个对象数组的第一个元素。如果我们在 delete 一个指向数组的指针时中忽略了方括号（或者在 delete 一个指向单一对象的指针时使用了方括号），其行为是未定义的。 *** 智能指针和动态数组 标准库提供了一个可以管理 new 分配的数组的 unique_ptr 版本。为了用一个 unique_ptr 管理动态数组，我们必须在对象类型后面跟一对空方括号：</p>
<p>#+BEGIN_SRC C++ // up指向一个包含10个未初始化int的数组 unique_ptr&lt;int[]&gt; up(new int[10]); up.release(); // 自动用delete[]销毁其指针 #+END_SRC</p>
<p>类型说明符中的方括号（&lt;int[]&gt;）指出 up 指向一个 int 数组而不是一个 int。由于 up 指向一个数组，当 up 销毁它管理的指针时，会自动使用 delete[]。</p>
<p>#+CAPTION: 指向数组的 unique_ptr | | 指向数组的 unique_ptr 不支持成员访问运算符（点和箭头运算符）。 | | | 其他 unique_ptr 操作不变。 | | unique_ptr&lt;T[]&gt; u | u 可以指向一个动态分配的数组，数组元素类型为 T | | unique_ptr&lt;T[]&gt; u(p) | u 指向内置指针 p 所指向的动态分配的数组。p必须能转换为类型 T* | | u[i] | 返回 u 拥有的数组中位置 i 处的对象 | | | u 必须指向一个数组中位置 i 处的对象 | | | u 必须指向一个数组 |</p>
<p>与 unique_ptr 不同，shared_ptr 不直接支持管理动态数组。如果希望使用 shared_ptr 管理一个动态数组，必须提供自己定义的删除器。</p>
<p>shared_ptr 未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须用 get 获取一个内置指针，然后用它来访问数组元素。 ** 12.2.2 allocator 类 new 有一些灵活性上的局限，其中一方面表现在它将内存分配的对象构造组合在了一起。类似的，delete 将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配与对象初始化组合在一起。因为在这种情况下，我们几乎肯定直到对象应有什么值。</p>
<p>当分配一大块内存时，我们通常计数在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。</p>
<p>更重要的是，那些没有默认构造函数的类就不能动态分配数组了。 **** allocator 标准库 <em>allocator</em> 类定义在头文件 memory 中，它帮助我们将内存分配和对象构造分离开来。它以提供一个类型感觉的内存分配方法，它分配的内存是原始的、未构造的。</p>
<p>#+CAPTION: 标准库 allocator 类及其算法 | allocator<T> a | 定义了一个名为 a 的 allocator 对象，它可以为类型为 T 的对象分配内存 | | a.allocate(n) | 分配一段原始的、未构造的内存，保存 n 个类型为 T 的对象 | | a.deallocate(p, n) | 释放从 T<em>指针 p 中地是开始的内存，这块内存保存了 n 个类型为 T 的对象；p必须是一个先前由 allocate 返回的指针，且 n 必须是 p 创建时所要求的大小。 | | | 在调用 deallocate 之前，用户必须对每个在这块内存中创建的对象调用 destroy | | a.construct(p, args) | p 必须是一个类型为 T</em>的指针，指向一块原始内存；arg 被传递给类型为 T 的构造函数，用来在 p 指向的内存中构造一个对象 | | a.destroy(p) | p 为 T<em>类型的指针，此算法对 p 所指向的对象执行析构函数 | </em>*** allocator 分配未构造的内存 allocator 分配的内存是未构造的。我们按需要在此内存中构造对象。在新标准库中，construct 成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>为了使用 allocate 返回的内存，我们必须用 construct 构造对象。使用未构造的内存，其行为是未定义的。 #+END_QUOTE</p>
<p>当我们用完对象后，必须对每个构造的元素调用 destory 来销毁它们。函数 destory 接受一个指针，对指向的对象执行析构函数。</p>
<p>我们传递给 deallocate 的指针不能为空，它必须指向由 allocate 分配的内存。而且，传递给 deallocate 的大小参数必须与调用 allocated 分配内存时提供的大小参数具有一样的值。 **** 拷贝和填充未初始化内存的算法 标准库还为 allocator 类定义了两个伴随算法，可以在未初始化内存中创建对象。下表描述了这些函数，它们都定义在头文件 memory 中。</p>
<p>#+CAPTION: allocator 算法 | | 这些函数在给定目的位置创建元素，而不是由系统分配内存给它们。 | | uninitialized_copy(b,e,b2) | 从迭代器 b 和 e 指出的输入范围中拷贝元素到迭代器 b2 指定的未构造的原始内存中。b2 指向的内存必须足够大，能容纳输入序列中元素的拷贝 | | uninitialized_copy_n(b,n,b2) | 从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的内存中 | | uninitialized_fill(b,e,t) | 在迭代器 b 和 e 指定的原始内存范围中创建对象，对象的值均为 t 的拷贝 | | uninitialized_fill_n(b,n,t) | 从迭代器 b 指向的内存地址开始创建 n 个对象，b必须指向足够大的未构造的原始内存，能够容器给定数量的对象 |</p>
<p>传递给 uninitialized_copy 的目的位置迭代器必须指向未构造的内存。与 copy 不同 uninitialized_copy 在给定目的位置构造函数。</p>
<p>类似 copy，uninitialized_copy 返回（递增后）目的位置迭代器。因此，依次 uninitialized_copy 调用会返回一个指针，指向最后一个构造的元素之后的位置。</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[C++ Primer 第 III部分 类设计者的工具]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/C++/C++%20Primer%20Part%20III.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/C++/C++%20Primer%20Part%20III.html</guid>
    <description><![CDATA[<p>#+TITLE: C++ Primer 第 III部分 类设计者的工具 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>第 13 章 拷贝控制 当定义一个类时，我们显示地或隐士地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括： <em>拷贝构造函数</em> 、 <em>拷贝赋值运算符</em> 、 <em>移动构造函数</em> 、 <em>移动赋值运算符</em> 、 <em>析构函数</em> 。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了讲一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为 <em>拷贝控制操作</em> 。 ** 13.1 拷贝、赋值与销毁 *** 13.1.1 拷贝构造函数 如果一个构造函数的第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数时拷贝构造函数。</li>
</ul>
<p>#+BEGIN_SRC C++ class Foo { public: Foo(); // 默认构造函数 Foo(const Foo&amp;); // 拷贝构造函数 // … }; #+END_SRC</p>
<p>虽然我们可以定义一个接受非 const 引用的拷贝构造函数，但此参数几乎总是一个 const 的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应是 explicit 的。 **** 合成构造函数 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即是我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</p>
<p>如我们将在 13.1.6 节中所见，对某些类来说， <em>合成拷贝构造函数</em> 用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非 static 成员拷贝到正在创建的对象中。</p>
<p>每个成员的类型决定它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。虽然我们不能拷贝一个数组，但合成构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。 **** 拷贝初始化 当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来算则与我们提供的参数最匹配的构造函数。当我们使用 <em>拷贝初始化</em> 时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。</p>
<p>拷贝初始化不仅在我们用=定义变量时会发生，在下列情况也会发生。 - 将一个对象作为实参传递给一个非引用类型的形参 - 从一个返回类型为非已用类型的函数返回一个对象 - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（参见 7.5.5 节）</p>
<p>某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其 insert 或 push 成员时，容器会对其元素进行拷贝初始化。与之相对的，用 emplace 成员创建的元素都进行直接初始化。 **** 参数和返回值 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。 **** 拷贝初始化的限制 如前所述，如果我们使用的初始化值要求通过一个 explicit 的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了：</p>
<p>#+BEGIN_SRC C++ vector<int> v1(10); // 正确：直接初始化 vector<int> v2 = 10; // 错误：接受大小参数的构造函数是explicit的 void f(vector<int>); // f的参数进行拷贝初始化 f(10); // 错误：不能用一个explicit的构造函数拷贝一个实参 f(vector<int>(10)); // 正确：从一个int直接构造一个临时vector #+END_SRC</p>
<p>直接初始化 v1 是合法的，但 看起来与之等价的拷贝初始化 v2 则是错误的，因为 vector 的接受单一大小参数的构造函数是 explicit 的。出于同样的原因，当传递一个实参或从函数返回一个值时，我们不能隐式使用一个 explicit 构造函数。如果我们希望使用一个 explicit 构造函数，就必须显式地使用，就像此代码中最后一样那样。 **** 编译器可以绕过拷贝构造函数 在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即，编译器被允许将下面的代码</p>
<p>~string null_book = “9-999-99999-9”; // 拷贝初始化~</p>
<p>改写为</p>
<p>~string null_book(“9-999-99999-9”); // 编译器略过了拷贝构造函数~</p>
<p>但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的（例如，不能是 private 的）。 *** 13.1.2 拷贝赋值运算符 与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。 **** 重载赋值运算符 重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 operator=的函数。类似于任何其他函数，运算符函数也有一个返回类型和参数列表。</p>
<p>重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符。必须定义为成员函数。如果一个一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 this 参数。对一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p>
<p>拷贝赋值运算符接受一个与其所在类相同类型的参数：</p>
<p>#+BEGIN_SRC C++ class Foo { public: Foo&amp; operator=(const Foo&amp;); // … }; #+END_SRC</p>
<p>为了与内置类型的赋值保持一直，赋值运算符通常返回一个指向其左侧运算对象的引用。另外值得注意的是，标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。 #+END_QUOTE **** 合成拷贝赋值运算符 与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个 <em>合成拷贝赋值运算符</em> 。类似于拷贝构造函数，对于某些类，合成拷贝赋值运算符来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非 static 成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。 *** 13.1.3 析构函数 析构函数执行与构造函数相反的操作：构造函数初始化对象的非 static 数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。</p>
<p>析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数。 **** 析构函数完成什么工作 在一个构造函数中，成员的初始化是在函数体执行之前完成，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象。 #+END_QUOTE</p>
<p>与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。 **** 什么时候会调用析构函数 无论何时一个对象被销毁，就会自动调用其析构函数： - 当变量在离开其作用域时被销毁。 - 当一个对象被销毁时，其成员被销毁。 - 容器（无论是标准容器还是数组）被销毁时，其元素被销毁。 - 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁 - 对于临时对象，当创建它的完整表达式结束时被销毁</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当指向一个对象的引用或指针离开作用域时，析构函数不会执行。 #+END_QUOTE **** 合成析构函数 当一个类未定义自己的析构函数时，编译器会为它定义一个 <em>合成析构函数</em> 。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。</p>
<p>认识到析构函数体自身并不直接销毁成员函数是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象的销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。 *** 13.1.4 三/五法则 如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。</p>
<p>C++语言并不要求我们定义所有这些操作：可以只定义其中一个或两个，而不必定义所有。但是，这些操作通常应该被看作一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况是很少见的。 **** 需要析构函数的类也需要拷贝和赋值操作 当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求比对拷贝构造函数或赋值运算符的需求更为明显。如果一个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。 #+END_QUOTE **** 需要拷贝操作的类也需要赋值操作，反之亦然 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然——如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论时需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。 *** 13.1.5 使用=default 我们可以通过将拷贝控制成员定义为=default 来显示地要求编译器生成合成的版本。</p>
<p>当我们在类内使用=default 修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他前类内声明的成员一样）。如果我们不希望合成的成员时内联函数，应该只对成员的类外定义使用=default。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>我们只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）。 #+END_QUOTE *** 13.1.6 阻止拷贝 #+BEGIN_QUOTE Best Practices：</p>
<p>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。 #+END_QUOTE</p>
<p>虽然大多数类应该定义（而且通常也的确定义了）拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。 **** 定义删除的函数 在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为 <em>删除的函数</em> 来阻止拷贝。删除的函数时这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后加上=delete 来只出我们希望它定义为删除的。</p>
<p>与=defualt 不同，=delete 必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此=defualt 直到编译器生成代码时才需要。而另一方面，编译器需要直到一个函数是删除的，以便禁止试图使用它的操作。</p>
<p>与=deafult 的另一个不同之处是，我们可以对任何函数指定=delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=defualt）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。 **** 析构函数不能是删除的成员 值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象了。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员无法被销毁。而如果一个成员无法被销毁，则对象整个也就无法被销毁了。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。 #+END_QUOTE **** 合成的拷贝哦嗯直成员可能是删除的 如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似的，如果一个类未定义构造函数，编译器会为其合成一个默认构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数： - 如果类的某个成员的析构函数是删除的或不可访问的（例如，是 private 的），则类的合成析构函数被定义为删除的。 - 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。 - 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个 const 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。 - 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器（参见 2.6.1），或是类有一个 const 成员，它没有类内初始化器且类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。</p>
<p>本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数被定义为删除的。</p>
<p>虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。 #+END_QUOTE **** private 拷贝控制 新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private 的来阻止拷贝的。</p>
<p>声明但不定义一个成员函数是合法的，对此只有一个例外，我们将在 15.2.1 节中介绍。试图访问一个未定义的成员将导致一个链接时错误。通过声明（但不定义）private 的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译器阶段被标记为错误；成员函数或友元函数中的拷贝错误将会导致链接时错误。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>希望阻止拷贝的类应该使用=delete 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为 private 的。 #+END_QUOTE ** 13.2 拷贝控制和资源管理 通常，管理类外资源的类必须定义拷贝控制成员。入股我们在 13.1.4 节中所见，这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
<p>为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，是类的行为看起来像一个值或者像一个指针。</p>
<p>类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。</p>
<p>行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。 *** 13.2.1 行为像值的类 **** 类值拷贝赋值运算符 赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是，非常重要的一点是，这些操作是以正确的顺序执行的，即使将一个对想赋予它自身，也保证正确。而且，如果可能，我们编写的赋值运算还应该是异常安全的——当以常发生时能将左侧运算对象置于一个有意义的状态。</p>
<p>#+BEGIN_QUOTE 关键概念：赋值运算符</p>
<p>当你编写赋值运算符时，有两点需要记住： - 如果将一个对象赋予它自身，赋值运算符必须能正常工作 - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作</p>
<p>当你编写一个赋值运算符时，一个好的模式时先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦一个左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>对于一个赋值运算符来说，正确工作时非常正要的，即使是将一个对象赋予它自身，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。 #+END_QUOTE *** 13.2.2 定义行为像指针的类 令一个类展现类似指针的行为的最好办法是使用 shared_ptr 来管理类中的资源。拷贝（或赋值）一个 shared_ptr 会拷贝（赋值）shared_ptr 所指向的指针。shared_ptr 类自己记录有多少用户共享它所指向的对象。当没有用户使用对象时，shared_ptr 类负责释放资源。</p>
<p>单是，有时我们希望直接管理资源。在这种情况下，使用 <em>引用计数</em> 就很有用了。 **** 引用计数 引用计数的工作方式如下： - 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为 1. - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，只出给定对象的状态又被一个新用户所共享。 - 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为 0，则析构函数释放状态。 - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为 0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</p>
<p>唯一的难题时确定在哪里存放引用计数。解决此问题的一种方法是计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。 ** 13.3 交换操作 除了定义拷贝控制成员，管理资源的类通常还定义一个名为 swap 的函数。对于那些与重排元素顺序的算法一起使用的类，定义 swap 时非常重要的。这类算法在需要交换两个元素时会调用 swap。</p>
<p>如果一个类定义了自己的 swap，那么算法将使用类自定义版本。否则，算法将使用标准库定义的 swap。 *** 编写我们自己的 swap 函数 #+BEGIN_QUOTE Note：</p>
<p>与控制拷贝成员不同，swap 并不是必要的。但是，对于分配了资源的类，定义 swap 可能是一种很重要的优化手段。 #+END_QUOTE *** swap 函数应该调用 swap，而不是 std::swap 正确的 swap 函数如下所示：</p>
<p>#+BEGIN_SRC C++ void swap(Foo &amp;lhs, Foo, &amp;rhs) { using std::swap; swap(lhs.h, rhs.h); // 使用HasPtr版本的swap // 交换类型Foo的其他成员 } #+END_SRC</p>
<p>每个 swap 调用应该都是未加限定的。即，每个调用都应该是 swap，而不是 std::swap。如果存在类型特定的 swap 版本，其匹配程度会优于 std 中定义的版本，原因我们将在 16.3 节中进行解释。因此，如果存在类型特定的 swap 版本，swap 调用会与之匹配。如果不存在类型特定的版本，则会使用 std 中的版本（假定作用域中有 using 声明）。</p>
<p>非常仔细的读者可能会奇怪为什么 swap 函数中的 using 声明没有隐藏 HasPtr 版本的 swap 声明。我们将在 18.2.3 节中解释为什么这段代码能正常工作。 *** 在赋值运算符中使用 swap 定义 swap 的类通常用 swap 来定义它们的赋值运算符。这些运算符使用了一种名为 <em>拷贝并交换</em> 的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换：</p>
<p>#+BEGIN_SRC C++ // 注意rhs是按值传递的，意味着HasPtr的拷贝构造函数 // 将右侧运算对象中的string拷贝到rhs HasPtr&amp; HasPtr::operator=(HasPtr rhs) { // 交换左侧运算对象和局部变量rhs的内容 swap(<em>this, rhs); // rhs现在指向本对象曾经使用的内容 return </em>this; // rhs被销毁，从来delete了rhs中的指针 } #+END_SRC</p>
<p>这个技术的有趣之处是它自动处理了自赋值情况且天然就是异常安全的。它通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，这与我们在原来的赋值运算符中使用的方法是一致的。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。 #+END_QUOTE ** 13.4 拷贝控制示例 #+BEGIN_QUOTE Best Practices：</p>
<p>拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这种情况下，公共的工作应该放在 private 的工具函数中完成。 #+END_QUOTE ** 13.6 对象移动 新标准的一个最主要的特性是可以移动而非拷贝对象的能力。如我们在 13.1.1 节中所见，很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。</p>
<p>在旧 C++标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如 string），进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>标准库容器、string 和 shared_ptr 类既支持移动也支持拷贝。IO 类和 unique_ptr 类可以移动但不能拷贝。 #+END_QUOTE *** 13.6.1 右值引用 wile 支持移动操作，新标准引入了一种新的引用类型—— <em>右值引用</em> 。所谓右值因一哦嗯就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。如我们将要看到的，右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。</p>
<p>回忆一下，左值和右值是表达式的属性（参见 4.1.1 节），一些表达式生成或要求左值，而另外一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。</p>
<p>类似任何引用,一个右值引用也不过是某个对象的另一个名字而已。如我们所值，对于常规引用（为了与右值引用区分开，我们称之为 <em>左值引用</em> ），我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：</p>
<p>#+BEGIN_SRC C++ int i = 42; int &amp;r = i; // 正确：r引用i int &amp;&amp;rr = i; // 错误：不能将一个右值引用绑定到一个左值上 int &amp;r2 = i * 42; // 错误：i<em>42是一个右值 const int &amp;r3 = i </em> 42; // 正确：我们可以将一个const的引用绑定到一个右值上 int &amp;&amp;rr2 = i * 42; // 正确：将rr2绑定到乘法结果上 #+END_SRC</p>
<p>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。</p>
<p>返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const 左值引用或者一个右值引用绑定到这类表达式上。 **** 左值持久；右值短暂 考察左值和右值表达式的列表，两者相互区别之处就很明显了：左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p>
<p>由于右值引用只能绑定到临时对象，我们得知 - 所引用的对象将要被销毁 - 该对象没有其他用户</p>
<p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。 #+END_QUOTE **** 变量是左值 变量可以看作只有一个运算对象而没有运算符的表达式，虽然我们很少这样看待变量。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。 #+END_QUOTE **** 标准库 move 函数 虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为 <em>move</em> 的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件 utility 中。move 函数使用了我们将在 16.2.6 节中描述的机制来返回给定对象的右值引用。</p>
<p>~int &amp;&amp;r3 = std::move(rr1); // ok~</p>
<p>move 调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用 move 就意味着承诺；除了对 rr1 赋值或销毁它外，我们将不再使用它。在调用 move 之后，我们不能对移后源对象的值做任何假设。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值 #+END_QUOTE *** 13.6.2 移动构造函数和移动赋值运算符 类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用，不同拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数必须有默认实参。</p>
<p>除了完成资源移动，移动构造函数还必须确保移后原对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。</p>
<p>#+BEGIN_SRC C++ StrVec::StrVec(StrVec &amp;&amp;s) noexcept // 以冬操作不应抛出任何异常 // 成员初始化器接官s中的资源 : elements(s.elements), first_free(s.first_free), cap(s.cap) { // 令s进入这样的状态——对其运行析构函数是安全的 s.elements = s.first_free = s.cap = nullptr; } #+END_SRC</p>
<p>与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的 StrVec 中的内存。接官内存之后，它将给定对象中的指针置位 nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。 **** 移动操作、标准库容器和异常 由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当遍写一个不抛出异常的移动操作时，我们应该将此事通知标准库。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能而做一些额外的工作。</p>
<p>一种通知标准库的方法是在我们的构造函数中指明 noexcept。我们必须在类头文件的声明中和定义中（如果定义在类外的话）都指定 noexcept。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>不抛出异常的移动构造函数和移动赋值运算符必须标记为 noexcept。 #+END_QUOTE **** 移动赋值运算符 移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为 noexcept。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值。 **** 移后源对象必须可析构 从一个对象移动数据并不会销毁此对象，但有时在移动对象操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。</p>
<p>除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，移动操作对移后对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。 #+BEGIN_QUOTE WARNING：</p>
<p>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。 #+END_QUOTE **** 合成的移动操作 与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。因此，某些类就没有移动构造函数或移动赋值运算符。如我们将在 477 页所见，如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。</p>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员时类类型，且该类有对应的移动操作，编译器也能移动这个成员。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。 #+END_QUOTE</p>
<p>与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显示地要求编译器生成=defualt 的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则： - 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。 - 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。 - 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。 - 类似拷贝赋值运算符，如果有类成员是 const 的或是引用，则类的移动赋值运算符被定义为删除的。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员默认地被定义为删除的。 #+END_QUOTE **** 移动右值，拷贝左值…… 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个函数。 **** ……但如果没有移动构造函数，右值也被拷贝 #+BEGIN_QUOTE Note：</p>
<p>如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。 #+END_QUOTE **** 拷贝并交换赋值运算符和移动操作 #+BEGIN_SRC C++ class HasPtr { public: // 添加的移动构造函数 HasPtr(HasPtr &amp;&amp;p) noexcept : ps(p.ps), i(p.i) { p.ps = 0; } HasPtr&amp; operator=(HasPtr rhs) { swap(<em>this, rhs); return </em>this; } // i其他成员的定义，同13.2.1节 }; #+END_SRC</p>
<p>现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。因此，单一的赋值运算符就实现了拷贝赋值运算符和移动赋值运算符两种功能。</p>
<p>#+BEGIN_QUOTE 建议：更新三/五法则</p>
<p>所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确功能。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数的移动赋值运算符的类就可以避免此问题。 #+END_QUOTE **** 移动迭代器 新标准库中定义了一种 <em>移动迭代器</em> 适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。</p>
<p>我们通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。</p>
<p>#+BEGIN_QUOTE 建议：不能随意使用移动操作</p>
<p>由于一个移后源对象具有不确定的状态，对其调用 std::move 是危险的。当我们调用 move 时，必须绝对确认移后源对象没有其他用户。</p>
<p>通过在类代码中小心地调用 move，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提高升应用程序性能。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作时安全的，才可以使用 std::move #+END_QUOTE *** 13.6.3 右值引用和成员函数 除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受一个指向 const 的左值引用，第二个版本接受一个指向非 const 的右值引用。</p>
<p>一般来说，我们不需要为函数操作定义接受一个 const X&amp;&amp;或是一个（普通的）X&amp;参数的版本。当我们希望从实参“窃取”数据时，通常传递一个右值引用。为了达到这一目的，实参不能是 const 的。类似的，从一个对象进行拷贝的操作不应该改变该对象。因此，通常不需要定一个接受一个（普通的）X&amp;参数的版本。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>区分移动和拷贝的重载函数通常有一个版本接受一个 const T&amp;，而另一个版本接受 T&amp;&amp;。 #+END_QUOTE **** 右值和左值引用成员函数 有时，右值的使用方式可能令人惊讶：</p>
<p>~s1 + s2 = “wow!”;~</p>
<p>此处我们对两个 string 的连接结果——一个右值，进行了赋值。</p>
<p>在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望强制左侧运算对象（即，this 指向的对象）是一个左值。</p>
<p>我们指出 this 的左值/右值属性的方式与定义 const 成员函数相同（参见 7.1.2 节），即，在参数列表后放置一个 <em>引用限定符</em>：</p>
<p>#+BEGIN_SRC C++ class Foo { public: Foo &amp;operator=(const Foo&amp;) &amp;; // 只能向可修改的左值赋值 // Foo的其他参数 };</p>
<p>Foo &amp;Foo::operator=(const Foo &amp;rhs) &amp; { // 执行将rhs赋予本对象所需的工作 return *this; } #+END_SRC</p>
<p>引用限定符可以是&amp;或&amp;&amp;，分别指出 this 可以指向一个左值或右值。类似 const 限定符，引用限定符只能用于（非 static）成员函数，且必须同时出现在函数的声明和定义中。</p>
<p>一个函数可以同时用 const 和引用限定。在此情况下，引用限定符必须跟随在 const 限定符之后。 **** 重载和引用函数 就像一个成员函数可以根据是否有 const 来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本。</p>
<p>当我们定义 const 成员函数时，可以定义两个版本，唯一的差别是一个版本有 const 限定而另一个没有。引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。 #+END_QUOTE * 第 14 章 重载运算与类型转换 ** 14.1 基本概念 重载的运算符时具有特殊名字的函数：它们的名字由关键 operator 和其后要定义的运算符号共同组成。和其他前函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当一个重载的运算符时成员函数时，this 绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。 #+END_QUOTE</p>
<p>我们只能重载已有的运算符，而无权发明新的运算符号。例如，我们不能提供 operator**来执行幂操作。</p>
<p>有四个符号（+、-、*、&amp;）既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底定义的时哪种运算符。</p>
<p>对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。</p>
<p>[[file:../../../pics/C++/operator.png]] **** 某些运算符不应该被重载 回忆之前介绍过的，某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，&amp;&amp;和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。</p>
<p>因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它们。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用。</p>
<p>还有一个原因使得我们一般不重载欧好运算符和取地址运算符：C++语言定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。 #+END_QUOTE **** 使用内置类型一直的含义 #+BEGIN_QUOTE 提示：尽量明智地使用运算符重载</p>
<p>在实际编程过程中，一般没有特别明显的滥用运算符重载的情况。然而经常发生的一种情况是，程序员可能会强行扭曲了运算符“常规”含义使得其适应某种给定的类型，这显然是我们不希望发生的。因此我们的建议是：只有当操作的含义对于用户来说清晰明了时才使用运算符。如果用户对运算符可能有几种不同的理解，则使用这样的运算符将产生二义性。 #+END_QUOTE **** 选择作为成员或者非成员函数 当我们定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一些情况下，运算符作为普通函数比作为成员更好。</p>
<p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择： - 赋值（=）、下标（[ ]）、调用（( )）和成员访问箭头(-&gt;)运算符必须是成员。 - 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。 - 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。 - 具有对称性的运算符可能转换任意一段的运算对象，例如算符、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。 ** 14.2 输入和输出运算符 *** 14.2.1 重载输出运算符&lt;&lt; 通常情况下，输出运算符的第一个形参是一个非常量 ostream 对象的引用。之所以 ostream 是非常量是因为向流写入内容会改变其状态；而改型惨是引用是因为我们无法直接赋值一个 ostream 对象。</p>
<p>第二个形参一般来说是一个常量的引用，改常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量因为（通常情况下）打印对象不会改变对象的内容。</p>
<p>为了与其他输出运算符保持一致，operator&lt;&lt;一般要返回它的 ostream 形参。 **** 输出运算符尽量减少格式化操作 #+BEGIN_QUOTE Best Practices：</p>
<p>通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。 #+END_QUOTE **** 输入输出运算符必须是非成员函数 与 ostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。</p>
<p>如果我们希望为类自定义 IO 运算符，则必须将其定义成非成员函数。当然，IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元。 *** 14.2.2 重载输入运算符&gt;&gt; 通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参时将要读入到的（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。 #+END_QUOTE **** 输入时的错误 在执行输入运算符时可能发生下列错误： - 当流函数错误类型的数据时读取操作可能失败。例如在读取完 bookNo 后，输入运算符假定接下来读入的是两个数字数据，则读取操作及后续对流的其他使用都将失败。 - 当读取操作到达文件末尾或者与到输入流的其他错误时也会失败。</p>
<p>在程序中我们没有逐个检查每个读取操作，而是等读取了所有数据后赶在使用这些数据前一次性检查。</p>
<p>如果在发生错误前对象已经有一部分被改变，则适时地将对象置为合法状态显得异常重要。通过将对象置位合法的状态，我们能（略微）保护使用者免于受到输入错误的影响。此是的对象处于可用状态，即它的成员都是被正确定义的。而且该对象也不会产生误导性的结果，因为它的数据在本质上确实是一体的。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>当读取操作发生错误时，输入运算符应该负责从错误中恢复。 #+END_QUOTE ** 14.3 算术和关系运算符 通常情况下，我们把算符和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。 #+END_QUOTE *** 14.3.1 相等运算符 - 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 operator==而非一个普通的命名函数：因为用户肯定那希望能使用==比较对象，所以提供了==意味着用户无须再费时费力学习并即以一个全新的函数名字。此外，类定义了==运算符之后也更容器使用标准库容其和算法。 - 如果类行一了 operator==，则该运算符应该能判断一组给定的对象中是否函数重复数据。 - 通常情况下，相等运算符应该具有传递性，换句话说，如果 a==b 和 b==c 都为真，则 a==c 也应该为真。 - 如果类定义了 operator==，则这各类也应该定义 operator!=。对于用户来说，当它们能使用==时也希望能使用!=，反之亦然。 - 相等运算符和不相等运算符中的一个应该把工作委托给另一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>如果某个类在逻辑上有相等性的含义，则该类应该定义 operator==，这样做可以使得用户更容易使用标准库算法来处理这个类。 #+END_QUOTE *** 14.3.2 关系运算符 定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器喝一些算法要用到小于运算符，所以定义 operator&lt;会比较有用。</p>
<p>通常情况下关系运算符应该 1. 定义顺序关系，令其与关联容器中对关键字的要求一致；并且 2. 如果类同时也含有==运算符的话，则定义一种关系令其与==保持一致。特别是，如果两个对象是!=的，那么一个对象应该&lt;另外一个。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义喝==产生的结果一致时才定义&lt;运算符。 #+END_QUOTE ** 14.4 赋值运算符 #+BEGIN_QUOTE Note：</p>
<p>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。 #+END_QUOTE *** 复合赋值运算符 #+BEGIN_QUOTE Best Practices：</p>
<p>赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算都应该返回左侧运算对象的引用。 #+END_QUOTE ** 14.5 下标运算符 表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符 operator[]。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>下标运算符必须是成员函数。 #+END_QUOTE</p>
<p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。进一步，我们最好同时定义下标运算符的常量版本喝非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用。 #+END_QUOTE ** 14.6 递增和递减运算符 在迭代器类中通常会实现递增运算符（++）和递减运算符（–），这两种运算符使得类可以在元素的序列中前后移动。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>定义递增喝递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常被定义成类的成员。 #+END_QUOTE **** 定义前置递增/递减运算符 #+BEGIN_QUOTE Best Practices：</p>
<p>为了于内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。 #+END_QUOTE **** 区分前置和后置运算符 要想同时定义前值和后置运算符，必须好搜显解决一个问题，即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同。</p>
<p>为了解决这个问题，后置版本接受一个额外的（不被使用）int 类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为 0 的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</p>
<p>#+BEGIN_SRC C++ class StrBlobPtr { public: // 前置运算符，递增和递减运算符 StrBlobPtr&amp; operator++(); StrBlobPtr&amp; operator–();</p>
<p>// 后置运算符 StrBlobPtr operator++(int); StrBlobPtr operator–(int); }; #+END_SRC</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>为了于内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式时一个值而非引用。 #+END_QUOTE</p>
<p>对于后置版本来说，在递增对象之前首先要记录对象的状态。 ** 14.7 成员访问运算符 **** 对箭头运算符返回值的限定 和大多数其他运算符一样（尽管这么做不太好），我们能令 operator<em>完成任何我们指向的操作。换句话说，我们可以让 operator</em>返回一个固定值 42,或者打印对象的内容，或者其他。箭头运算符不是这样，它永远不会丢掉成员访问这个最近基本的含义。当我们重载箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永远不变。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。 #+END_QUOTE ** 14.8 函数调用运算符 如果类重载了函数调用运算符，则噢我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，互相之间应该在参数数量或类型上有所区别。 #+END_QUOTE</p>
<p>如果类定义了调用运算符，则该类的对象称作 <em>函数对象</em> 。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。 *** 14.8.1 lambda 是函数对象 当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象。在 lambda 表达式产生的类中含有一个重载的函数调用运算符。 **** 表示 lambda 及相应捕获行为的类 如我们所知，当一个 lambda 表达式通过引用捕获变量时，将由程序负责确保 lambda 执行时所引用的对象确实存在。因此，编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。</p>
<p>相反，通过值捕获的变量被拷贝到 lambda 中。因此，这种 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</p>
<p>lambda 表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。 *** 14.8.2 标准库定义的函数对象 标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，plus 类定义了有一个函数调用运算符用于一对运算对象执行+的操作；modulus 类定义了一个调用运算符执行二元的%操作；equl_to 类执行==，等等。</p>
<p>这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，plus<string>令 string 加法运算符作用于 string 对象；plus<int>的运算对象时 int；plus<Sales_data>对 Sales_data 对象执行加法运算，以此类推。</p>
<p>下表所列的类型定义在 functional 头文件中。</p>
<p>#+CAPTION: 标准库函数对象 | <em>算术</em> | <em>关系</em> | <em>逻辑</em> | | plus<Type> | equal_to<Type> | logical_and<Type> | | minus<Type> | not_equal_to<Type> | logical_or<Type> | | multiplies<Type> | greater<Type> | logical_not<Type> | | divides<Type> | greater_equal<Type> | | | modulus<Type> | less<Type> | | | negate<Type> | less_equal<Type> | | **** 在算法中使用标准库函数对象 表示运算符的函数对象类常用来替换算法中的默认运算符。如我们所知，在默认情况下排序算法使用 operator&lt;将序列按升序排列。如果要执行降序排序的话，我们可以传入一个 greater 类型的对象。该类将产生一个调用运算符并负责执行待排序类型的大于运算。例如，如果 svec 是一个 vector<string>。</p>
<p>#+BEGIN_SRC C++ // 传入一个临时的函数对象用于执行两个string对象的&gt;比较运算 sort(svec.begin(), svec.end(), greater<string>()); #+END_SRC</p>
<p>需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾经介绍过比较两个无关指针将产生未定义的行为，然而我们可能会希望通过比较指针的内存地址来 sort 指针的 vector。直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的。</p>
<p>关联容器使用 less<key_type>对元素排序，因此我们可以定义一个指针的 set 或者在 map 中使用指针作为关键值而无须直接声明 less。 *** 14.8.3 可调用对象与 function C++语言中有几种可调用的对象：函数、函数指针、lambda 表达式（参见 10.3.2 节）、bind 创建的对象（参见 10.3.4 节）以及重载了函数调用运算符的类。</p>
<p>和其他对象一样，可调用的对象也有类型。例如，每个 lambda 有它自己唯一的（未命名）类类型；函数及函数指针的类型则由返回值类型的实参类型决定，等等。</p>
<p>然而，两个不同类型的可调用对象却能共享同一种 <em>调用形式</em> 。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：</p>
<p>~int(int, int)~</p>
<p>是一个函数类型，它接受两个 int、返回一个 int。 **** 不同类型可能具有相同的调用形式 对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。例如，考虑下列不同类型的可调用对象：</p>
<p>#+BEGIN_SRC C++ // 普通函数 int add(int i, int j) { return i + j; } // lambda auto mod = <a href="int%20i,%20int%20j"></a> { return i % j; }; // 函数对像类 struct divide { int operator() (int denominator, int divisor) { return denominator / divisor; } }; #+END_SRC</p>
<p>上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但是共享同一种调用形式：</p>
<p>~int(int, int)~</p>
<p>我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，需要定义一个 <em>函数表</em> 用于存储指向这些可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。</p>
<p>在 C++语言中，函数表很容易通过 map 来实现。对于此例来说，我们使用一个表示运算符符号的 string 对象作为关键字；使用实现运算符的函数作为值。当我们需要求给定运算符的值时，先通过运算符索引 map，然后调用找到的那个于元素。 **** 标准库 function 类型 function 定义在 functional 头文件中。</p>
<p>#+CAPTION: function 的操作 | function<T> f; | f 是一个用来存储可调用对象的空 function，这些可调用对象的调用形式应该与函数类型 T 相同（即 T 是 retType(args)） | | function<T> f(nullptr); | 显式地构造一个空 function | | function<T> f(obj); | 在 f 中存储一个可调用对象 obj 的副本 | | f | 将 f 作为条件：当 f 含有一个可调用对象时未真；否则为假 | | f(args) | 调用 f 中的对象，参数是 args | | | <em>定义为 function<T>的成员的类型</em> | | result_type | 该 function 类型的可调用对象的返回类型 | | argument_type | 当 T 有一个或两个实参时定义的类型。如果 T 只有一个实参，则 argument_type 是该类型的同义词； | | first_argument_type | 如果 T 有两个实参，则 first_argument_type 和 second_argument_type 分别代表两个实参的类型 | | second_argument_type | |</p>
<p>function 是一个模板，和我们使用过的其他模板一样，当创建一个具体的 function 类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该 function 类型能够表示的对象的调用形式。参见其他模板，我们在一对尖括号内指定类型：</p>
<p>~function&lt;int(int, int)&gt;~</p>
<p>在这里我们声明了一个 function 类型，它可以表示接受两个 int，返回一个 int 的可调用对象。 **** 重载的函数与 function 我们不能（直接）将重载函数的名字存入 function 类型的对象中，这将会导致二义性。解决上述二义性问题的一条途径是存储函数指针而非函数的名字。同样，我们也可以使用 lambda 来消除二义性。 ** 14.9 重载、类型转换与运算符 我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了 <em>类类型转换</em> ，这样的转换有时也被称作 <em>用户定义的类型转换</em> 。 *** 14.9.1 类型转换运算符 <em>类型转换运算符</em> 是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：</p>
<p>~operator type() const;~</p>
<p>其实 type 表示某种类型。类型转换运算符可以面向任意类型（除了 void 之外）进行定义，只要该类型能作为函数的返回类型。因此，我们不允许转换成数组或函数类型，但允许转换横指针或者引用类型。</p>
<p>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成 const 成员。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是 const。 #+END_QUOTE **** 显式的类型转换运算符 类型转换运算符可能产生意外结果。为了防止这样的异常情况发生，C++11 新标准引入了 <em>显示的类型转换运算符</em> ：</p>
<p>#+BEGIN_SRC C++ class SmallInt { public: // 编译器不会自动执行这一类型转换 explicit operator int() const { return val; } }; #+END_SRC</p>
<p>和显示的构造函数一样，编译器（通常）也不会将一个显式的类型转换运算符用于隐式类型转换。</p>
<p>该规定存在一个例外，即如果表达式被用作条件，则编译器会将显示的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显示的类型转换将被隐式地执行：</p>
<ul>
<li>if、while 及 do 语句的条件部分</li>
<li>for 语句头的条件表达式</li>
<li>逻辑非运算符（!）、逻辑或运算符（||）、逻辑与运算符（&amp;&amp;）的运算对象</li>
<li>条件运算符（? :）的条件表达式 **** 转换为 bool 在标准库的早期版本中，IO 类型定义了向 void*的转换规则，以求避免上面提到的问题。在 C++11 新标准下，IO 标准库通过定义一个向 bool 的显式类型转换实现同样的目的。</li>
</ul>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>向 bool 的类型转换通常用在条件部分，因此 operator bool 一般定义成 explicit 的。 #+END_QUOTE *** 14.9.2 避免有二义性的类型转换 如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话，我们编写的代码将很可能会具有二义性。</p>
<p>在两种情况下可能产生多重转换路径。第一种情况是两个类提供相同的类型转换：例如，当 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符时，我们就说它们提供了相同的类型转换。</p>
<p>第二种情况是是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。 #+END_QUOTE **** 实参匹配和相同的类型转换 在下面的例子中，我们定义了两种将 B 转换成 A 的方法：一种使用 B 的类型转换运算符、另一种使用 A 的以 B 为参数的构造函数：</p>
<p>#+BEGIN_SRC C++ // 最好不要在两个类之间构建相同的类型转换 struct B; struct A { A() = defualt; A(const B&amp;); // 把一个B转换成A // 其他数据成员 }; struct B { operator A() const; // 也是把一个B转换成A // 其他数据成员 }; A f(const A&amp;); B b; A a = f(b); // 二义性错误：含义是f(B::operator A()) // 还是f(A::A(const B&amp;))？ #+END_SRC</p>
<p>因为同时存在两种由 B 获得 A 的方法，所以造成编译器无法判断应该运行哪个类型转换，也就是说，对 f 的调用存在二义性。该调用可以使用以 B 为参数的 A 的构造函数，也可以使用 B 当中把 B 转换成 A 的类型转换运算符。因为这两个函数效果相当、难分伯仲，所以该调用将产生错误。 **** 二义性与转换目标为内置类型的多重类型转换 另外如果类定义了一组类型转换，它们的转换源（或者转换目标）类型本身可以通过其他类型转换联系在一起，则同样会产生二义性的问题。最简单也是最困扰我们的例子就是类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符。</p>
<p>例如，在下面的类中包含两个转换构造函数，它们的参数是两种不同的算术类型；同时还包含两个类型转换运算符，它们的转换目标也恰好是两种不同的算术类型：</p>
<p>#+BEGIN_SRC C++ struct A { A(int = 0); // 最好不要创建两个转化源都是算术类型的类型转换 A(double); operator int() const; // 最好不要创建两个转换对象都是算术类型的类型转换 operator double() const; // 其他成员 }; void f2(long double); A a; f2(a); // 二义性错误：含义是f(A::operator int()) // 还是f(A::operator double())?</p>
<p>long lg; A a2(lg); // 二义性错误：函数是A::A(int)还是A::A(double) #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底时哪个。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE 提示：类型转换与运算符</p>
<p>要想正确地设计类的重载运算符、转换构造函数及类型转换函数，必须加倍小心。尤其时当类同时定义了类型转换运算符及重载运算符时特别容易产生二义性。以下的经验规则可能对你有所帮助：</p>
<ul>
<li>不要令两个类行执行相同的类型转换：如果 Foo 类有一个接受 Bar 类对象的构造函数，则不要在 Bar 类中再定义转换目标时 Foo 类的类型转换运算符。</li>
<li>避免转换目标是内置类型的类型转换。特别是当你已经定义了一个转换成算术类型的类型转换时，接下来
<ul>
<li>不要再定义接受算术类型的类型转换。如果用户需要使用这样的运算符，则类型转换操作将转换你的类型的对象，然后使用内置的运算符。</li>
<li>不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作。 一言以蔽之：除了显式地向 bool 类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。 #+END_QUOTE **** 重载函数与转换构造函数 当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型转换都提供了同一种可能匹配，则这些类型转换一样好。</li>
</ul></li>
</ul>
<p>#+BEGIN_SRC C++ struct C { C(int); // 其他成员 }; struct D { D(int); // 其他成员 }; void manip(const C&amp;); void manip(const D&amp;); manip(10); // 二义性错误：含义时manip(C(10))还是manip(D(10)) #+END_SRC</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>如果再调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足。 #+END_QUOTE **** 重载函数与用户定义的类型转换 当调用重载函数时，如果两个（或多个）用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好。再这个过程中，我们不会考虑任何可能出现的标准类型转换的级别。只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换。</p>
<p>#+BEGIN_SRC C++ struct E { E(double); // 其他成员 }; void manip2(const C&amp;); void manip2(const E&amp;); // 二义性错误：两个不同的用户定义的类型转换都能用在此处 manip2(10); // 函数是manip2(C(10))还是manip2(E(double(10)) #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。 #+END_QUOTE *** 14.9.3 函数匹配与重载运算符 重载的运算符也是重载的函数。因此，通用的函数匹配规则（参见 6.4 节）同样适用于判断在给定的表达式中到底应该使用内置运算符还是重载的运算符。不过当运算符函数出现在表达式中时，候选函数集的规模要比我们使用调用运算符调有函数时更大。如果 a 时一种类类型，则表达式 a sym b 可能时</p>
<p>#+BEGIN_SRC C++ a.operatorsym(b); // a有一个operatorsym成员函数 operatorsym(a, b); // operatorsym是一个普通函数 #+END_SRC</p>
<p>和普通函数调用不同，我们不能通过调用的形式区分当前调用的是成员函数还是非成员函数。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>表达式中运算符的候选函数集既包括成员函数，也应该包括非成员函数。 #+END_QUOTE</p>
<p>举个例子，我们为 SmallInt 类定义一个加法运算符：</p>
<p>#+BEGIN_SRC C++ class SmallInt { friend SmallInt operator+(const SmallInt&amp;, const SmallInt&amp;); public: SmallInt(int = 0); // 转换源为int的类型转换 operator int() const { return val; } // 转换目标为int的类型转换 private: std::size_t val; };</p>
<p>SmallInt s1, s2; SmallInt s3 = s1 + s2; // 使用重载的operator+ int i = s3 + 0; // 二义性错误 #+END_SRC</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。 #+END_QUOTE * 第 15 章 面向对象程序设计 ** 15.1 OOP：概述 <em>面对对象程序设计</em> 的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离；使用即成，可以定义相似的类型并对其相似关键建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。 **** 继承 通过 <em>继承</em> 联系在一起的类构成一种层次关系。通常在层次关系的根部有一个 <em>基类</em> ，其他类则直接或间接地从基类继承而来，这些继承得到的类称为 <em>派生类</em> 。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</p>
<p>在 C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成 <em>虚函数</em> 。</p>
<p>派生类必须通过使用 <em>类派生列表</em> 明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符。</p>
<p>派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字，但是并不是非得这么做。出于 15.3 节将要解释的原因，C++11 新标准允许派生类显式地注明它将使用哪个成员函数该写基类的虚函数，具体措施是在该函数的形参列表之后加上一个 override 关键字。 **** 动态绑定 因为在 <em>动态绑定</em> 在运行时选择函数的版本，所以动态绑定有时又被称为 <em>运行时绑定</em> 。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>在 C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。 #+END_QUOTE ** 15.2 定义基类和派生类 *** 15.2.1 定义基类 #+BEGIN_QUOTE Note：</p>
<p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。 #+END_QUOTE **** 成员函数与继承 派生类需要对虚函数提供自己的新定义以 <em>覆盖</em> 从基类继承而来的旧定义。</p>
<p>在 C++语言中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前着，基类通常将其定义为 <em>虚函数</em> 。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</p>
<p>基类通过在其成员函数的声明语句之前加上关键字 virtual 使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以时虚函数。关键字 virutal 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。 **** 访问控制与继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类还有这样一种成员，基类希望它的派生类有权访问该成员，同时仅只其他用户访问。我们用 <em>受保护的（protected）</em> 访问运算符说明这样的成员。 *** 15.2.2 定义派生类 派生类必须通过使用 <em>类派生列表</em> 明确指出它时从哪个（哪些）基类继承而来的。类派生列表的形式时：首先时一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected 或者 private。 **** 派生类中的虚函数 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖起基类中的某个虚函数，则虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
<p>派生类可以在它覆盖的函数前使用 virutal 关键字，但不是非得这么做。我们将在 15.3 节介绍其原因。C++11 新标准允许派生类显示地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在 const 成员函数的 const 关键字后面、或者在引用成员函数（参见 13.6.3 节）的引用限定符后面添加一个关键字 override。 **** 派生类对象及派生类向基类的类型转换 一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个于该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p>
<p>因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上。这种转换通常称为 <em>派生类到基类的</em> 类型转换。和其他类型一样，编译器会隐式地执行派生类到基类的转换。</p>
<p>这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>在派生类对象中含有与基类对应的组成部分，这一事实是继承的关键所在。 #+END_QUOTE **** 派生类构造函数 尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>每个类控制它自己的成员初始化过程。 #+END_QUOTE</p>
<p>#+BEGIN_SRC C++ Bulk_quote(const std::string&amp; book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc) { } #+END_SRC</p>
<p>除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。如果向使用其他的基类构造函数，我们需要以类名加圆括号的是惨烈表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。 #+END_QUOTE **** 继承与静态函数 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p>
<p>静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它。 **** 派生类的声明 派生类的声明与其他其类差别不大，声明中包含类名但是不包含它的派生列表。 **** 被用作基类的类 如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p>
<p>这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员派生类当然要知道它们是什么。因此该规定还有一层隐含的意思，即一个类不能派生它本身。 **** 防止继承的发生 有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final。 *** 15.2.3 类型转换与继承 #+BEGIN_QUOTE WARNING：</p>
<p>理解基类和派生类之间的类型转换是理解 C++语言面向对象变成的关键所在。 #+END_QUOTE</p>
<p>存在继承关系的类是一个重要的例外：我们可以将基类的指针或引用绑定到派生类对象上。</p>
<p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>和内置指针一样，智能指针也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。 #+END_QUOTE **** 静态类型与动态类型 当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的 <em>静态类型</em> 与该表达式表示对象的 <em>动态类型</em> 区分开来。表达式的静态类型在编译时总是已知的，它时变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。 **** 不存在从基类向派生类的隐式类型转换…… 因为一个基类的对象可能时派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换。</p>
<p>除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换。</p>
<p>编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用 dynamic_cast 请求一个类型转换，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用 static_cast 来强制覆盖掉编译器的检查工作。 **** ……在对象之间不存在类型转换 派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。很多时候，我们确实希望将派生类对象转换成它的基类类型，但是这种转换的实际发生过程往往与我们期望的有所差别。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略调。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE 关键概念：存在继承关系的类型之间的转换规则</p>
<p>要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：</p>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效。</li>
<li>基类向派生类不存在隐式类型转换。</li>
<li>和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行。我们将在 15.5 节详细介绍可访问性的问题。</li>
</ul>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数仍然（显式或隐士地）定义了拷贝控制成员。因此，我们通常能将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。 #+END_QUOTE ** 15.3 虚函数 如前所述，在 C++语言中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们直到运行时才能直到到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否用到了，这是因此连编译器也无法确定奥迪会使用哪个虚函数。 **** 派生类中的虚函数 当我们在派生类中覆盖了某个虚函数时，可以再一次使用 vitual 关键字指出该函数的性质。然而这么做并非必须，因此一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p>
<p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。</p>
<p>同样，派生类中虚函数的返回类型必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果 D 由 B 派生得到，则基类的虚函数可以返回 B<em>而派生类的对应函数可以返回 D</em>，只不过这样的返回类型要求从 D 到 B 的类型转换是可访问的。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>基类中的虚函数在派生类中因旱地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。 #+END_QUOTE **** final 和 override 说明符 如我们将要在 15.6 节介绍的，派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然时合法的行为。编译器将认为新定义的这个函数与基类中原有的函数时相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。</p>
<p>要想调试并发现这样的错误显然非常困难。在 C++11 新标准中我们可以使用 override 关键字来说明派生类中的虚函数。这么做的好出是在是得程序员的以意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得更加重要。如果我们使用 override 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此是编译器将报错。</p>
<p>我们还能把某个函数指定为 final，如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误。</p>
<p>final 和 override 说明符出现在形参列表（包括任何 const 或引用修饰符）以及尾置返回类型之后。 **** 虚函数与默认实参 和其他函数一样，虚函数也可以拥有默认实参。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</p>
<p>换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。此是，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。 #+END_QUOTE **** 回避虚函数的机制 在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码：</p>
<p>#+BEGIN_SRC C++ // 强行调用基类中定义的函数版本而不管baseP的动态类型到底是什么 double undiscounted = baseP-&gt;Quote::net_price(42); #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。 #+END_QUOTE ** 15.4 抽象基类 **** 纯虚函数 和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0 就可以将一个虚函数说明为纯虚函数。其中，=0 只能出现在类内部的虚函数声明语句处。</p>
<p>值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个=0 的函数提供函数体。 **** 含有纯虚函数的类是抽象基类 含有（或者未经覆盖直接继承）纯虚函数的类是 <em>抽象基类</em> 。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>我们不能创建抽象基类的对象。 #+END_QUOTE ** 15.5 访问控制与继承 **** 受保护的成员 如前所述，一个类使用 protected 关键字来声明那些它希望与派生类分享但是不想被其他其公共访问使用的成员。 - 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。 - 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可以访问的。 - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p>
<p>派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。 **** 公有、私有和受保护继承 某个类对其继承而来的成员的访问权限受到两个因素影响：一个是在基类中该成员的访问说明符，二是派生类的派生列表中的访问说明符。</p>
<p>派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没有设呢蜜影响。对基类成员的权限只与基类中的访问说明符有关。</p>
<p>派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限。 **** 派生类向基类转换的可访问性 派生类向基类的转换（参见 15.2.2 节）是否可访问由使用该转换的代码决定，同时派生类的的派生访问说明符也会有影响。假定 D 继承自 B： - 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类转换；如果 D 继承 B 的方式时受保护的或私有的，则用户代码不能使用该转换。 - 不论 D 以什么方式继承 B，D 的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。 - 如果 D 继承 B 的方式是公有的或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 继承 B 的方式是私有的，则不能使用。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。 #+END_QUOTE **** 友元与继承 就像友元关系不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>不能继承友元关系；每个负责控制各自成员的访问权限。 #+END_QUOTE **** 改变个别成员的可访问性 有时我们需要改变派生类继承的某个名字的访问级别，通过 using 声明可以达到这一目的：</p>
<p>#+BEGIN_SRC C++ class Base { public: std::size_t size() const { return n; } protected: std::size_t n; };</p>
<p>class Derived : private Base { // 注意：private继承 public: // 保持对象尺寸相关的成员访问级别 using Base::size; protected: using Base::n; } #+END_SRC</p>
<p>通过在类的内部使用 using 声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。using 声明语句中名字的访问权限由该 using 声明语句之前的访问说明符来决定。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>派生类只能为那些它可以访问的名字提供 using 声明 #+END_QUOTE **** 默认的继承保护级别 在 7.2 节中我们曾经介绍过使用 struct 和 class 关键字定义的类具有不噢它嗯的默认访问说明符。类似的，默认派生运算符也由定义派生类所用的关键字来决定。默认情况下，使用 class 关键字定义的派生类是私有继承的；而使用 struct 关键字定义的派生类是公有继承。 ** 15.6 继承中的类作用域 每个类定义自己的作用域（参见 7.4 节），在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在基类的作用之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。</p>
<p>派生类的作用域位于基类作用域之内这一事实可能有点儿出人意料，毕竟在我们的程序文本中派生类和基类的定义是相互分离开来的。不过也恰恰因为类作用域有这种继承嵌套的关系，所以派生类才能像使用自己的成员一样使用基类的成员。 **** 编译时进行名字查找 一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍是由静态类型决定的。 **** 名字冲突与继承 和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>派生类的成员将隐藏同名的基类成员。 #+END_QUOTE **** 通过作用域运算符来使用隐藏的成员 #+BEGIN_QUOTE Best Practices：</p>
<p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他其定义在基类中的名字 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE 关键概念：名字查找与继承</p>
<p>理解函数调用的解析过程对于理解 C++的继承关系至关重要，假定我们调用 p-&gt;mem()（或者 obj.mem()），则依次执行以下 4 个步骤：</p>
<ul>
<li>首先确定 p（或 obj）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。</li>
<li>在 p（或 obj）的静态类型对应的类中查找 mem。如果找不到，则依次在直接基类中不断查找知道到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错</li>
<li>一旦找到了 mem，就进行长会的类型检查（参见 6.1 节）以缺人对于当前找到的 mem，本次调用是否合法。</li>
<li>假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：
<ul>
<li>如果 mem 是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li>
<li>反之，如果 mem 不是虚函数或者我们通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用。 #+END_QUOTE **** 一如往常，名字查找先于类型检查 如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数（参见 6.4.1 节）。因此，定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉。 **** 虚函数与作用域 我们先在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了。假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。 **** 覆盖重载的函数 和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重在函数的 0 个或多个实例。如果派生类希望所有的重载版本对它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。</li>
</ul></li>
</ul>
<p>有时一个类仅需要覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐。</p>
<p>一个好的解决方案是为重载的成员提供一条 using 声明语句，这样我们就无须覆盖基类中的每一个重载版本了。using 声明语句指定一个名字而不指定形参列表，所以调基类成员函数的 using 声明就可以把该函数的所有重载实例添加到派生类作用域中。词是，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他其函数重新定义。</p>
<p>类内 using 声明的一般规则同样适用于重载函数的名字（参见 15.5 节）；基类函数的每个实例在派生类中必须是可以访问的。对派生类没有重新定义的重载版本的访问实际上对 using 声明点的访问。 ** 15.7 构造函数和拷贝控制 *** 15.7.1 虚析构函数 继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针将产生未定义的行为。 #+END_QUOTE</p>
<p>之前我们曾介绍过一条经验准则，即如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作（参见 13.1.4 节）。基类的析构函数并不遵循上述准则，它是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设计为虚函数。词是，该析构函数为了称为虚函数而令内容为空，我们显然无法由此推断该基类还需要赋值运算符或拷贝构造函数。 **** 虚析构函数将阻止合成移动操作 基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定了析构函数，即使它通过=defualt 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。 *** 15.7.2 合成拷贝控制与继承 基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似；它们对类本身的成员依次进行初始化、赋值和销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行了初始化、赋值或销毁的操作。例如： - 合成的 Bulk_quote 默认构造函数运行 Disc_quote 的默认构造函数，后者又运行 Quote 的默认构造函数。 - Quote 的默认构造函数将 bookNo 成员默认初始化为空字符串，同时使用类内初始值将 price 初始化为 0。 - Quote 够战术完成后，继续执行 Disc_quote 的构造函数，它使用类内初始值初始化 qty 和 discount。 - Disc_count 的构造函数完成后，继续执行 Bulk_quote 的够战术，但是它什么具体工作也不做。</p>
<p>值得注意的是，无论基类成员是合成的版本（如 Quote 继承体系中的例子）还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问（参见 15.5 节）并且不是一个被删除的函数。 **** 派生类中删除的拷贝控制与基类的关系 就像其他其任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员称为被删除的函数： - 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是 被删除的函数或不可访问（参见 15.5 节），则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。 - 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁被派生类对象的基类部分。 - 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用=defualt 请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。 **** 移动操作与继承 如前所述，大多数基类都会定义个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p>
<p>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。 *** 15.7.3 派生类的拷贝控制成员 如我们在 15.2.2 节介绍过的，派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<p>和构造函数及赋值运算符不同是的是，析构函数只负责销毁派生类自己分配的资源。如前所述，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。 #+END_QUOTE **** 定义派生类的拷贝或移动构造函数 当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们向拷贝（或移动）基类部分，则必须在派生类的构造函数初始化列表中显示地使用基类的拷贝（或移动）构造函数。 #+END_QUOTE</p>
<p>**** 派生类赋值运算符 与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示地为基类部分赋值。 **** 派生类析构函数 如前所述，在析构函数提执行完后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源：</p>
<p>#+BEGIN_SRC C++ class D: public Base { public: // Base::~Base被自动调用执行 ~D() { /* 该处由用户定义清楚派生类成员的操作 */ } }; #+END_SRC</p>
<p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。 **** 在构造函数和析构函数中调用虚函数 #+BEGIN_QUOTE Note：</p>
<p>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。 #+END_QUOTE *** 15.7.4 继承的构造函数 在 C++11 标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不放姑且称其为“继承”的。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p>
<p>派生类继承基类构造函数的方式是提供了一条注明了（直接）几类名的 using 声明语句。</p>
<p>通常情况下，using 声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using 声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
<p>这些编译器生成的构造函数形如：</p>
<p>~derived(params) : base(args) { }~</p>
<p>其中，derived 是派生类的名字，base 是基类的名字，parms 是构造函数的形参列表，args 将派生类构造函数的形参传递给基类的构造函数。 **** 继承的构造函数的特点 和普通成员的 using 声明不一样，一个构造函数的 using 声明不会改变该构造函数的访问级别。例如，不管 using 声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。</p>
<p>而且，一个 using 声明语句不能指定 explicit 或 constexpr。如果基类的构造函数是 explicit 或者 constexpr，则继承的构造函数也拥有相同的属性。</p>
<p>当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将会获得多个继承的构造函数，其中每个构造函数分别省略掉一个有默认实参的形参。例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数有两个形参（没有默认实参），另一个构造函数只接受一个形参，它对应基类最左侧的没有默认值的那个形参。</p>
<p>如果基类含有几个构造函数，则除了两个例外情况，大多数是后派生类会继承所有这些构造函数。第一个例外是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。</p>
<p>第二个例外是默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也拥有一个合成的默认构造函数。 ** 15.8 容器与继承 当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接放在容器当中。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>当派生类对象被赋值给基类对象时，其中的派生类部分将被”切掉“，因此容器和存在继承关系的类型无法兼容。 #+END_QUOTE **** 在容器中放置（智能）指针而非对象 当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）。和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型。 * 第 16 章 模板与泛型编程 ** 16.1 定义模板 *** 16.1.1 函数模板 我们可以定义一个通用的 <em>函数模板</em> ，而不是为了每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。</p>
<p>模板定义以关键字 template 开始，后跟一个 <em>模板参数列表</em> ，这是一个逗号分隔一个或多个 <em>模板参数</em> 的列表，用小于号（&lt;）和大于号（&gt;）包围起来。</p>
<p>模板参数列表的作用很像函数参数列表。函数参数列表定义了若干特定类型的局部变量，但并未指出如何初始化它们。在运行时，调用者提供实参来初始化形参。</p>
<p>类似的，模板参数表示在类或函数定义中用到的类型或值，当使用模板时，我们（隐士地或显式地）指定 <em>模板实参</em> ，将其绑定到模板参数上。 **** 实例化函数模板 当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。</p>
<p>编译器用推断出的模板参数来为我们 <em>实例化</em> 一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参来代替对应的模板参数来创建出模板的一个新“实例”。 **** 模板类型参数 一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p>
<p>类型参数前必须使用关键字 class 或 typename。在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字。 **** 非类型模板参数 除了定义类型参数，还可以在模板幻宗定义 <em>非类型参数</em> 。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数。</p>
<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须时常量表达式，从而允许编译器在编译时实例化模板。</p>
<p>#+BEGIN_SRC C++ template&lt;unsigned N, unsigned M&gt; int compare(const char (&amp;p1)[N], const char (&amp;p2)[M]) { reutrn strcmp(p1, p2); } #+END_SRC</p>
<p>当我们调用这个版本的 cmopare 时：</p>
<p>~compare(“Hi”, “Mon”)~</p>
<p>编译器会使用字面常量的大小来代替 N 和 M，从而实例化模板。编译器会实例化出如下版本：</p>
<p>~int compare(const char (&amp;p1)[3], const char (&amp;p2)[4])~</p>
<p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整数实参的参数必须是一个常量表达式。绑定到指针或引用非类型参数的参数必须具有静态的生存期。我们不能用一个普通（非 static）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 nullptr 或一个值为 0 的常量表达式来实例化。</p>
<p>在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>非类型模板参数的模板实参必须是常量表达式。 #+END_QUOTE **** inline 和 constexpr 的函数模板 函数模板可以声明为 inline 或 constexpr 的，如同非模板参数一样。inline 或 constexpr 说明符放在模板参数列表之后，返回类型之前。 **** 编写类型无关的代码 #+BEGIN_QUOTE Best Practices：</p>
<p>模板程序应该尽量减少对实参类型的要求。 #+END_QUOTE **** 模板编译 当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特定影响了我们如何阻止代码以及错误何时被检测到。</p>
<p>通常，当我们调用一个函数时，编译器值需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>函数模板和类模板成员函数的定义通常放在头文件中。 #+END_QUOTE</p>
<p>**** 大多数编译报错在实例化期间报告 模板直到实例化时才会生成代码，这一特定影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。</p>
<p>第一个阶段是编译模板本身时。这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。</p>
<p>第二个阶段是编译器遇到模板使用时。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。</p>
<p>第三个阶段时模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如果管理实例化，这类错误可能在链接时才报告。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。 #+END_QUOTE *** 16.1.2 类模板 <em>类模板</em> 是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。如果我们已经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。 **** 实例化类模板 我们已经多次见到，当使用一个类模板时，我们必须提供额外信息。我们现在直到这些额外信息是 <em>显式模板实参</em> 列表，它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>一个类模板的每一个实例都形成一个独立的类。类型 Blob<string>与任何其他 Blob 类型都没有关联，也不会对任何其他 Blob 类型的成员有特殊访问权限。 #+END_QUOTE **** 类模板的成员函数 与其他任何类相同，我既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。</p>
<p>类模板的成员函数本身是一个普通函数。但是，类模板的每个实例都有其自己版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数就必须以关键字 template 开始，后接类模板参数列表。 **** 类模板成员函数的实例化 如果一个成员函数没有被回私用，则它不会被实例化。成员函数只有被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才会被实例化。 #+END_QUOTE **** 在类代码内简化模板类名的使用 当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p>
<p>当我们处于一个类模板作用域中时，编译器处理模板自身引用就好像我们已经提供了与模板参数匹配的实参一样。 **** 在类模板外使用类模板名 当我们在类模板外定义其成员时，必须及诸，我们并不在类额作用域中，直到遇到类名才算进入类的作用域（参见 7.4 节）。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>在一个类模板的作用域值内，我们可以直接使用模板名而不必指定模板实参。 #+END_QUOTE **** 类模板和友元 当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。 **** 通用和特定的模板有好关系 一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元。</p>
<p>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。 **** 令模板自己的类型参数成员友元 在新标准中，我们可以将模板类型参数声明为友元：</p>
<p>#+BEGIN_SRC C++ template <typename Type> class Bar { friend Type; // 将访问权限授予用来实例化Bar的类型 // … }; #+END_SRC</p>
<p>此处我们将用来实例化 Bar 的类型声明为友元。因此，对于某个类型名 Foo，Foo 将成为 Bar<Foo>的友元，Sales_date 将成为 Bar<Sales_data>的友元，依次类推。</p>
<p>值得注意的是，虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一个内置类型来实例化 Bar。这种与内置类型的友好关系是允许的，以便我们能用内置类型来实例化 Bar 这样的类。 **** 类模板的 static 成员 与任何其他类相同，类模板可以声明 static 成员。</p>
<p>与任何其他 static 数据成员相同，模板类的每个 static 数据成员必须有且仅有一个定义。但是，类模板的每个实例都有一个独有的 static 对象。因此，与定义模板的成员函数类似，我们将 static 数据成员也定义为模板。</p>
<p>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的 static 成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问 static 成员，我们必须引用一个特定的实例。</p>
<p>类似任何其他成员函数，一个 static 成员函数只有在使用时才会实例化。 *** 16.1.3 模板参数 **** 模板参数与作用域 模板参数遵循普通的作用域。一个模板参数名的可用范围时在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在膜板内不能重用模板参数名：。</p>
<p>由于参数名不能重用，所以一般模板参数名在一个特定模板参数列表中只能出现依一次。 **** 模板声明 模板声明必须包含模板参数。与函数参数相同，声明中的模板参数的名字不必与定义相同。</p>
<p>当然，一个给定模板的每个声明和定义必须有相同数量和种类（即，类型和非类型）的参数。</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前，原因我们将在 16.3 节中解释。 #+END_QUOTE **** 使用类的类型成员 默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显示告诉编译器该名字是一个类型。如果通过使用关键字 typename 来实现这一点：</p>
<p>#+BEGIN_SRC C++ template <typename T> typename T::value_type top(const T&amp; c) { if (!c.empty()) return c.back(); else return typename T::value_type(); } #+END_SRC</p>
<p>我们的 top 函数期待一个容器类型的实参，它使用 typename 指明其返回类型并在 c 中没有元素时生成一个值初始化的元素返回给调用者。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当我们希望通知编译器一个名字表示类型时，必须使用关键字 typename，而不是能使用 class。 #+END_QUOTE **** 默认模板实参 就像我们能为函数参数提供默认实参一样，我们也可以提供 <em>默认模板实参</em> 。在新标准中，我们可以为函数和类模板提供默认实参。而更早的 C++标准值允许为类模板提供默认实参。</p>
<p>#+BEGIN_SRC C++ // compare有一个默认模板实参less<T>和一个默认函数实参F() template &lt;typename T, typename F = less<T>&gt; int compare(const T &amp;v1, const T &amp;v2, F f = F()) { if (f(v1, v2)) return -1; if (f(v2, v1)) return 1; return 0; } #+END_SRC 与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。 **** 默认模板实参与类模板 无论何时使用一个类模板，我们都必须再模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。</p>
<p>#+BEGIN_SRC C++ template <class T = int> class Numbers { // T默认为int public: Numbers(T v = 0): val(v) { } // 对数值的各种操作 private: T val; }; Numbers<long double> lots_of_precision; Numbers&lt;&gt; average_precision; // 空&lt;&gt;表示我们希望使用默认类型 #+END_SRC *** 16.1.4 成员模板 一个类（无论是普通类还是类模板）可以包含本是是模板的成员函数。这种成员被称为 <em>成员模板</em> 。成员模板不能是虚函数。 **** 普通（非模板）类的成员模板 **** 类模板的成员模板 对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的独立的模板参数。</p>
<p>#+BEGIN_SRC C++ template <typename T> class Blob { template <typename It> Blob(It b, It, e); // … }; #+END_SRC</p>
<p>与类模板的普通函数成员不同，成员模板是函数模板。当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。</p>
<p>#+BEGIN_SRC C++ template <typename T> // 类的类型参数 template <typename It> // 构造函数的类型参数 Blob<T>::Blob(It b, It e): data(std::make_shared&lt;std::vector<T>&gt;(b, e)) { } #+END_SRC **** 实例化与成员模板 为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的参数，与往常一样，我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断模板参数的实参。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板实参。 *** 16.1.5 控制实例化 当模板被使用才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</p>
<p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过 <em>显示实例化</em> 来避免这种开销。一个显式实例化有如下形式：</p>
<p>#+BEGIN_SRC extern template declaration; // 实例化声明 template declaration; // 实例化定义 #+END_SRC</p>
<p>declaration 时一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</p>
<p>#+BEGIN_SRC C++ // 实例化声明与定义 extern template class Blob<string>; // 声明 template int compare(const int &amp;, const int&amp;); // 定义 #+END_SRC</p>
<p>当编译器遇到 extern 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只定义一个。</p>
<p>由于编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使用此实例化版本的代码之前。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。 #+END_QUOTE **** 实例化定义会实例化所有成员 一个类模板的实例化会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数。 #+END_QUOTE ** 16.2 模板实参推断 我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板参数。从函数实参来确定模板实参的过程被称为 <em>模板实参推断</em> 。在模板实参推断过程中，编译器使用函数调用中的实参类型来寻找模板的实参，用这些模板实参生成的函数与给定的函数调用最为匹配。 *** 16.2.1 类型转换与模板类型参数 与非模板函数一样，我们在依次调用中传递给函数模板的实参被用来初始化函数的形参。如果一个函数形参的类型使用了模板类型参数，那么它采取特殊的初始化规则。只有很有限的几种类型转换会自动地应用于这些实参，编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。</p>
<p>与往常一样，顶层 const 无论是在形参中还是在实参中都会被忽略。在其他类型转换，能在调用中应用于函数模板的包括如下两项。 - const 转换：可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参。 - 数据或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参引用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</p>
<p>其他类型转换，如算术转换（参见 4.11.1 节）、派生类向基类的转换以及用户定义的转换（参见 7.5.4 节），都不能应用与函数模板。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>将实参传递给模板类型的函数形参时，能够自动应用的类型转换只有 const 转换及数组或函数到指针的转换。 #+END_QUOTE **** 使用相同模板参数类型的函数形参 一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。 **** 正常类型转换应用于普通函数实参 函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数实参不进行特殊处理；它们正常转换为对应形参的类型。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果函数参数类型不是模板参数，则对实参进行正常的类型转换。 #+END_QUOTE *** 16.2.2 函数模板显式实参 再某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。当函数返回类型与参数列表中任何类型都不相同时，这两种情况最常出现。 **** 指定显式模板实参 #+BEGIN_SRC C++ // 编译器无法推断T1,它未出现再函数参数列表中 template &lt;typename T1, typename T2, typename T3&gt; T1 sum(T2, T3); #+END_SRC</p>
<p>在本例中，没有任何函数实参的类型可用来推断 T1 的类型。每次调用 sum 时调用者必须为 T1 提供一个 <em>显式模板实参</em> 。</p>
<p>我们提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在尖括号中给出，位于函数名之后，实参列表之前：</p>
<p>#+BEGIN_SRC C++ // T1 时显式指定的，T2和T3是从函数实参类型推断而来的 auto val3 = sum<long long>(i, lng); // long long sum(int, long) #+END_SRC</p>
<p>显式模板实参按由左至右的顺序与对应的模板参数匹配：第一个模板实参与第一个模板参数匹配，第二实参与第个参数匹配，依次类推。只有尾部（最右）参数的显式模板实参才可以忽略，而且前提时它们可以从函数参数推断出来。 **** 正常类型转换应用于显式指定的实参 对于用普通类型定义的函数参数，允许进行正常的类型转换（参见 16.2.1 节），处于同样的原因，对于模板类型参数已经显式指定了的函数实参，也进行正常转换。 *** 16.2.3 尾置返回类型与类型转换 组合使用 remove_reference、尾置返回及 decltype，我们就可以在函数中返回元素的拷贝：</p>
<p>#+BEGIN_SRC C++ // 为了使用模板参数的成员，必须用typename，参见16.1.3节 template <typename It> auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(<em>beg)&gt;::type { // 处理序列 return </em>beg; // 返回序列中一个元素的拷贝 } #+END_SRC</p>
<p>注意，type 是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型的声明是使用 typename 来告知编译器，type 表示一个类型（参见 16.1.3 节）。 *** 16.2.4 函数指针和实参推断 当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值（参见 6.7 节）时，编译器使用指针的类型来推断模板实参。</p>
<p>例如，假如我们有一个函数指针，它指向的函数返回 int，接受两个参数，每个参数都是指向 const int 的引用。我们可以使用该指针指向 compare 的一个实例：</p>
<p>#+BEGIN_SRC C++ template <typename T> int compare(const T&amp;, const T&amp;); // pf1指向实例int compare(const int&amp;, const int&amp;) int (*pf1)(const int&amp;, const int&amp;) = compare; #+END_SRC</p>
<p>pf1 中参数的类型决定了 T 的模板实参的类型。在本例中，T的模板实参类型为 int。指针 pf1 指向 compare 的 int 版本实例。如果不能从函数指针类型确定模板实参，则产生错误：</p>
<p>#+BEGIN_SRC C++ // func的重载版本；每个版本接受一个不同的函数指针类型 void func(int (<em>)(const string&amp;, const string&amp;)); void func(int (</em>)(const int&amp;, const int&amp;)); func(compare); // 错误：使用compare的哪个实例？ #+END_SRC</p>
<p>该段代码的问题在于，通过 func 的参数类型无法确定模板实参的唯一类型。对 func 的调用既可以实例化接受 int 的 compare 版本，也可以实例化接受 string 的版本。由于不能确定 func 的实参的唯一实例化版本，此调用将编译失败。</p>
<p>我们可以通过使用显式模板实参来消除 func 调用的歧义：</p>
<p>#+BEGIN_SRC C++ // 正确：显式指出实例化哪个compare版本 func(compare<int>); // 传递compare(const int&amp;, const int&amp;) #+END_SRC</p>
<p>此表达式调用 func 版本接受一个函数指针，该指针指向的函数接受两个 const int&amp;参数。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能确定唯一其类型或值。 #+END_QUOTE *** 16.2.5 模板实参推断和引用 为了理解如何从函数调用进行类型推断，考虑下面的例子：</p>
<p>~template <typename T> void f(T &amp;p)~</p>
<p>其中函数参数 p 是一个模板类型参数 T 的引用，非常重要的是记住两点：编译器会应用正常的引用绑定规则；const 是底层的，不是顶层的。 **** 从左值引用函数参数推断类型 当一个函数参数是模板类型参数的一个普通（左值）引用时（即，形如 T&amp;），绑定规则告诉我们，只能传递给它一个左值（入，一个变量或一个返回引用类型的表达式）。实参可以是 const 类型，也可以不是。如果实参是 const 的，则 T 将被推断为 const 类型：</p>
<p>#+BEGIN_SRC C++ template <typename T> void f1(T&amp;); // 实参必须是一个左值 // 对f1的调用使用实参所引用的类型作为模板参数类型 f1(i); // i是一个int；模板参数类型T是int f1(ci); // ci是一个const int；模板参数T是const int f1(5); // 错误：传递给一个&amp;参数的实参必须是一个左值 #+END_SRC</p>
<p>如果一个函数参数的类型是 const T&amp;，正常的绑定规则告诉我们可以传递给它任何类型的实参——一个对象（const 或非 const）、一个临时对象或是一个字面常量值，当函数本身是 const 时，T的类型推断的结果不是一个 const 类型。const 已经是函数参数类型的一部分；因此，它也不会是模板参数类型的一部分：</p>
<p>#+BEGIN_SRC C++ template <typename T> void f2(const T&amp;); // 可以接受一个右值 // f2中的参数是const &amp;；实参中的const是无关的 // 在每个调用中，f2的函数参数都被推断为const int&amp; f2(i); // i是一个int；模板参数T是int f2(ci); // ci是一个const int，但模板参数T是int f2(5); // 一个const &amp;参数可以绑定到一个右值；T是int #+END_SRC **** 从右值引用函数参数推断类型 当一个函数参数是一个右值引用（即，形如 T&amp;&amp;）时，正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通左值引用函数参数的推断过程。推断出的 T 的类型时该右值实参的类型：</p>
<p>#+BEGIN_SRC C++ template <typename T> void f3(T&amp;&amp;); f3(42); // 实参是一个int类型的右值；模板参数T是int #+END_SRC **** 引用折叠和右值引用参数 假定 i 是一个 int 对象，我们可能认为像 f3(i)这样的调用是不合法的。毕竟，i是一个左值，而通常我们不能将一个右值引用绑定到一个左值上。但是，C++语言在正常绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是 move 这种标准库设施正确工作的基础。</p>
<p>第一个例外规则影响右值引用参数的推断是如何进行的。当我们将一个左值（如 i）传递给函数的右值引用参数，且此右值引用指向模板类型参数（如 T&amp;&amp;）时，编译器推断模板类型参数为实参额左值引用类型。因此，我们调用 f3(i)时，编译器推断 T 的类型为 int&amp;，而非 int。</p>
<p>T 被推断为 int&amp;看起来好像意味着 f3 的函数参数应该时一个类型 int&amp;的右值引用。通常，我们不能（直接）定义一个引用的引用（参见 2.3.1 节）。但是，通过类型别名或通过模板类型参数间接定义是可以的。</p>
<p>在这种情况下，我们可以使用第二个例外绑定规则：如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。在所有情况下（除了一个例外），引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则扩展到右侧引用，只在一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。即，对于一个给定类型 X： - X&amp; &amp;、X&amp; &amp;&amp;和 X&amp;&amp; &amp;都折叠成类型 X&amp; - 类型 X&amp;&amp; &amp;&amp;这叠成 X&amp;&amp;</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。 #+END_QUOTE</p>
<p>如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着我们可以对一个左值调用 f3。当我们将一个左值传递给 f3 的（右值引用）函数参数时，编译器推断 T 为一个左值引用类型：</p>
<p>#+BEGIN_SRC C++ f3(i); // 实参时一个左值；模板参数T是int&amp; f3(ci); // 实参是一个左值；模板参数T是一个const int&amp; #+END_SRC</p>
<p>当一个模板参数 T 被推断为引用类型时，折叠规则告诉我们函数实参 T&amp;&amp;折叠为一个左值引用类型。例如，f3(i)的实例化结果可能像下面这样：</p>
<p>#+BEGIN_SRC C++ // 无效代码，只是用于岩石目的 void f3&lt;int&amp;&gt;(int&amp; &amp;&amp;); // 当T是int&amp;时，函数参数为int&amp; &amp;&amp; #+END_SRC</p>
<p>f3 的函数参数是 T&amp;&amp;且 T 是 int&amp;，因此 T&amp;&amp;是 int&amp; &amp;&amp;，会折叠成 int&amp;。因此，即使 f3 的函数参数形式是一个右值引用（即，T&amp;&amp;），此调用也会用一个左值引用类型（即，int&amp;）实例化 f3：</p>
<p>~void f3&lt;int&amp;&gt;(int&amp;); // 当T是int&amp;时，函数参数折叠为int&amp;~</p>
<p>这两个规则导致了两个重要结果： - 如果一个函数参数是一个指向模板类型参数的右值引用（如，T&amp;&amp;），则他可以被绑定到一个左值；且 - 如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数（T&amp;）</p>
<p>另外值得注意的是，这两个规则暗示，我们可以将任意类型的实参传递给 T&amp;&amp;类型的函数参数。对于这种类型的啊才能熟，（显然）可以传递给它右值，而如我们刚刚看到的，也可以传递给它左值。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果一个函数参数是指向模板参数类型的右值（如，T&amp;&amp;），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&amp;）。 #+END_QUOTE **** 编写接受右值引用参数的模板函数 模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响：</p>
<p>#+BEGIN_SRC C++ template <typename T> void f3(T&amp;&amp; val) { T t = val; // 拷贝哈时绑定一个引用？ t = fcn(t); // 赋值只改变t还是既改变t又改变val？ if (val == t) { /* … */ } // 若T是引用类型，则一直为true } #+END_SRC</p>
<p>当代码涉及的类型可能是普通（非引用）类型，也可能是引用类型时，编写正确的代码就变得异常困难（虽然 remove_reference 这样的类型转换类可能会有帮助（参见 16.2.3 节））。</p>
<p>在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载。我们将在 16.2.7 介绍实参转发，在 16.3 节中介绍模板重载</p>
<p>目前应该注意的是，使用右值引用的函数模板通常使用我们在 13.6.3 节中看到的方式来进行重载：</p>
<p>#+BEGIN_SRC C++ template <typename T> void f(T&amp;&amp;); // 绑定到非const右值 template <typename T> void f(const T&amp;&amp;); // 左值和const右值 #+END_SRC</p>
<p>与非模板函数一样，第一个版本将绑定到可修改的右值，而第二个版本将绑定到左值或 const 右值。 *** 16.2.6 理解 std::move 在 13.6.2 节中我们注意到，虽然不能直接将一个右值引用绑定到一个左值上，但可以用 move 获得一个绑定到左值上的右值引用。由于 move 本质上可以接受任何类型的实参，因此我们不会惊讶于它是一个函数模板。 **** std::mvoe 是如何定义的 标准库是这样定义 move 的：</p>
<p>#+BEGIN_SRC C++ // 在返回类型和类型转换中也要用到typename，参见16.1.3节 // remove_reference是在16.2.3节中介绍的 template <typename T> typename remove_reference<T>::type&amp;&amp; move(T&amp;&amp; t) { return static_cast&lt;typename remove_reference<T>::type&amp;&amp;&gt;(t); } #+END_SRC</p>
<p>这段代码虽然很短，但其中有些微妙之处。首先，move 的函数参数 T&amp;&amp;是一个指向模板类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给 move 一个左值，也可以传递给它一个右值：</p>
<p>#+BEGIN_SRC C++ string s1(“hi!”), s2; s2 = std::move(string(“bye!”)); // 正确：从一个右值移动数据 s2 = std::move(s1); // 正确：但在赋值后，s1的值是不确定的 #+END_SRC **** std::move 是如何工作的 在第一个赋值中，传递给 move 的实参是 string 的构造函数的右值结果——string(“bye!”)。如我们已经见过的，当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型（参见 16.2.5 节）。因此，在 std::move(string(“bye!”))中： - 推断出的 T 的类型为 string。 - 因此，remove_reference 用 string 进行实例化。 - remove_reference<string>的 type 成员是 string。 - move 的返回类型是 string&amp;&amp; - move 的函数参数 t 的类型为 string&amp;&amp;</p>
<p>因此，这个调用实例化 move<string>，即函数</p>
<p>~string&amp;&amp; move(string &amp;&amp;t)~</p>
<p>函数体返回 static_cast&lt;string&amp;&amp;&gt;(t)。t的类型已经是 string&amp;&amp;，于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用。</p>
<p>现在考虑第二个赋值，它调用了 std::move()。在此调用中，传递给 move 的实参是一个左值。这样： - 推断出的 T 的类型为 string&amp;（string 的引用，而非普通 string）。 - 因此，remove_reference 用 string&amp;进行实例化。 - remove_reference&lt;string&amp;&gt;的 type 成员是 string - move 的返回类型仍是 string&amp;&amp; - move 的函数参数 t 实例化为 string&amp; &amp;&amp;，会折叠为 string&amp;。</p>
<p>因此，这个调用实例化 move&lt;string&amp;&gt;，即</p>
<p>~string&amp;&amp; move(string &amp;t)~</p>
<p>这正式我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回 static_cast&lt;string&amp;&amp;&gt;(t)。在此情况下，t的类型为 string&amp;，cast 将其转换为 string&amp;&amp; **** 从一个左值 static_cast 到一个右值引用是允许的 通常情况下，static_cast 只能用于其他合法的类型转换。但是，这里又有一条针对右值引用的特许规则：虽然不能隐式地将一个左值转换为右值引用，但我们可以用 static_cast 显式地将一个左值转换为一个右值。</p>
<p>对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断左值。有时候，我们知道截断一个左值是安全的。一方面，通过允许进行这样的转换，C++语言认可了这种做法。但另一个方面，通过强制使用 static_cast，C++语言试图阻止我们意外地进行这种转换。</p>
<p>最后，虽然我们可以直接编写这种类型转换代，但使用标准库 move 函数是容易得多的方式。而且，统一使用 std::move 使得我们在程序中查找潜在的截断左值的代码变得很容易。 *** 16.2.7 转发 某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转换实参的所有性质，包括实参类型是否是 const 的以及实参是左值还是右值。 **** 定义能保持信息的函数参数 通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数（无论是左值还是右值）使得我们可以保持 const 属性，因为在引用类型中的 const 是底层的。如果我们将函数参数定义为 T1&amp;&amp;和 T2&amp;&amp;，通过引用折叠就可以保持翻转实参的左值/右值属性。</p>
<p>#+BEGIN_SRC C++ template &lt;typename F, typename T1, typename T2&gt; void flip2(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2) { f(t2, t1); } #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>如果一个函数参数是指向模板类型参数的右值引用（如 T&amp;&amp;），它对应的实参的 const 属性和左值/右值属性将得到保持。 #+END_QUOTE</p>
<p>这个版本的 flip2 解决了一半问题。它对于接受一个左值引用的函数工作得很好，但不能用于接受右值引用参数的函数。 **** 在调用中使用 std::forward 保持类型信息 我们可以使用一个名为 forward 的新标准库设施来传递 flip2 的参数，它能保持原始实参的类型。俄罗斯 move，forward 定义在头文件 utility 中。与 move 不同，forward 必须哦它嗯过显式模板实参来调用（参见 16.2.2 节）。forward 返回该显式实参类型的右值引用。即，forward<T>的返回类型是&amp;&amp;。</p>
<p>通常状况下，我们使用 forward 传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，forward 可以保持给定实参的左值/右值属性：</p>
<p>#+BEGIN_SRC C++ template <typename Type> intermediary(Type &amp;&amp;arg) { finalFcn(std::forward<Type>(args)); // … } #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当用于一个指向模板参数类型的右值引用函数参数（T&amp;&amp;）时，forward 会保持实参类型的所有细节。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>与 std::move 相同，对 std::forward 不使用 using 声明是一个好主意。我们将在 18.2.3 节中解释原因。 #+END_QUOTE ** 16.3 重载与模板 函数模板可以被另一个模板或一个普通非函数模板重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。</p>
<p>如果涉及函数模板，则函数匹配规则会在以下几方面受到影响： - 对于一个调用，其候选函数包括所有模板实参推断（参见 16.2）成功的函数模板实例。 - 候选的函数模板总是可行的，因为模板实参推断会排除任何不行的模板。 - 与往常一样，可行函数（模板和非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（参见 16.2.1 节） - 与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但，如果有多个函数提供同样的匹配，则 - 如果同样好的函数中只有一个是非模板函数，则选择此函数。 - 如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。 - 否则，此调用有歧义。</p>
<p>#+BEGIN_QUOTE WARNING：</p>
<p>正确定义一组重载的函数模板需要对类型间的关系及模板函数允许的有限实参转换有深刻的理解。 #+END_QUOTE **** 编写函数模板 作为一个例子，我们将构造一组函数，它们在调试中可能很有用。我们将这些调试函数命名为 debug_rep，每个函数都返回一个给定对象的 string 表示。我们首先编写此函数的最通用版本，将它定义为一个模板，接受一个 const 对象的引用：</p>
<p>#+BEGIN_SRC C++ // 打印任何我们不能处理的类型 template <typename T> string debug_rep(const T &amp;t) { ostringstream ret; // 参见8.3节 ret &lt;&lt; t; // 使用T的输出运算符打印t的一个表示形式 return ret.str(); // 返回ret绑定的string的一个副本 } #+END_SRC</p>
<p>此函数可以用来生成一个对象对应的 string 表示，该对象可以是任意具备输出运算符的类型。</p>
<p>接下来，我们将定义打印指针的 debug_rep 版本：</p>
<p>#+BEGIN_SRC C++ // 打印指针的值，后跟指针指向的对象 // 注意：此函数不能用于char<em>；参见16.3节 template <typename T> string debug_rep(T </em>p) { ostringstream ret; ret &lt;&lt; “pointer:” &lt;&lt; p; // 打印指针本身的值 if (p) ret &lt;&lt; " " &lt;&lt; debug_rep(*p); // 打印p指向的值 else ret &lt;&lt; " null pointer"; // 或指出p为空 return ret.str(); // 返回ret绑定的string的一个副本 } #+END_SRC</p>
<p>此版本生成一个 string，包含指针本身的值和调用 debug_rep 获得的指向指针的值。注意此函数不能用于打印字符指针，因此 IO 库为 char*值定义了一个&lt;&lt;版本。此&lt;&lt;版本假定指针表示一个空字符结尾的字符数组，并打印数组的内容而非地址值。我们将在 16.3 介绍如何处理字符指针。</p>
<p>我们可以这样使用这些函数：</p>
<p>#+BEGIN_SRC C++ string s(“hi”); cout &lt;&lt; debug_rep(s) &lt;&lt; endl; #+END_SRC</p>
<p>对于这个调用，只有第一个版本的 debug_rep 是可行的。第二个 debug_rep 版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指针实参实例化一个期望指针类型的函数模板，因此实参推断失败。由于只有一个可能函数，所以此函数被调用。</p>
<p>如果我们用一个指针调用 debug_rep：</p>
<p>~cout &lt;&lt; debug_rep(&amp;s) &lt;&lt; end;~</p>
<p>两个版书都生成可行的实例： - debug_rep(const string <em>&amp;)，由第一个版本的 debug_rep 实例化而来，T被绑定到 string</em>。 - debug_rep(string*)，由第二个版本的 debug_rep 实例化而来，T被绑定到 string。</p>
<p>第二个版本的 debug_rep 的实例是此调用的精确匹配。第一个版本的实例需要进行普通指针到 const 指针的转换。正常函数匹配规则告诉我们应该选择第二个版本，实际上编译器确实选择了这个版本。 **** 多个可行模板 作为另外一个例子，考虑下面的调用：</p>
<p>#+BEGIN_SRC C++ const string *sp = &amp;s; cout &lt;&lt; debug_rep(sp) &lt;&lt; endl; #+END_SRC</p>
<p>此例中的两个模板都是可行的，而且两个都是精确匹配的： - debug_rep(const string <em>&amp;)，由第一个版本的 debug_rep 实例化而来，T被绑定到 string</em>。 - debug_rep(const string*)，由第二个版本的 debug_rep 实例化而来，T被绑定到 const string。</p>
<p>在此情况下，正常函数匹配规则无法区分这两个函数。我们可能觉得这个调用经是有歧义的。但是，根据重载函数模板的特殊规则，此调用被解析为 debug_rep(T*)，即，更特例化的版本。</p>
<p>设计这条规则的原因是，没有它，将无法对一个 const 的指针调用指针版本的 debug_rep。问题在于模板 debug_rep(const T&amp;)本质上可以用于任何类型，包括指针类型。此模板比 debug_rep(T*)更通用，后者只能用于指针类型。没有这条规则。传递 const 的指针的调用永远是有歧义的。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。 #+END_QUOTE **** 非模板和模板重载 作为下一个例子，我们将定义一个普通非模板版本的 debug_rep 来打印双引号包围的 string：</p>
<p>#+BEGIN_SRC C++ // 打印双引号包围的string string debug_rep(const string &amp;s) { return ‘"’ + s + ‘"’; } #+END_SRC</p>
<p>现在，当我们对一个 string 调用 debug_rep 时：</p>
<p>#+BEGIN_SRC C++ string s(“hi”); cout &lt;&lt; debug_rep(s) &lt;&lt; endl; #+END_SRC</p>
<p>有两个同样的好行函数： - debug_rep<string>(const string&amp;)，第一个模板，T被绑定到 string*。 - debug_rep（const string&amp;)，普通非模板函数。</p>
<p>在本例中，两个函数具有相同的参数列表，因此显然两者提供同样好的匹配。但是，编译器会选择非模板版本。当存在多个同样好的函数模板时，编译器选择最特例化的模板，出于同样的原因，一个非模板函数比一个函数模板更好。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>对于一个调用，如果一个非函数模板于一个函数模板提供同样好的匹配，则选择非模板版本。 #+END_QUOTE **** 重载模板和类型转换 还有一种情况我们到目前为止尚未讨论：C风格字符串指针和字符串字面常量。现在有了一个接受 string 的 debug_rep 版本，我们可能期望一个传递字符串的调用会匹配这个版本。但是，考虑这个调用：</p>
<p>~cout &lt;&lt; debug_rep(“hi world!”) &lt;&lt; end; // 调用debug_rep(T*)~</p>
<p>本例中所有三个 debug_rep 版本都是可行的： - debug_rep(const T&amp;)，T被绑定到 char[10]。 - debug_rep(T<em>)，T被绑定到 const char - debug_rep(const string&amp;)，要求从 const char</em>到 string 的类型转换。</p>
<p>对给定实参来说，两个模板都提供精确匹配——第二个模板需要进行依次（许可的）数组到指针的转换，而对函数匹配来说，这种转换被认为是精准匹配（参见 6.6.1 节）。非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配那么好，所以两个模板称为可能调用的函数。于之前一样，T*版本更加特例化，编译器会选择它。</p>
<p>如果我们希望将字符指针按 string 处理，可以定义另外两个非模板重载版本：</p>
<p>#+BEGIN_SRC C++ // 将字符串指针转换为string，并调用string版本的debug_rep string debug_rep(char <em>p) { return debug_rep(string(p)); } string debug_rep(const char </em>p) { return debug_rep(string(p)); } #+END_SRC **** 缺少声明可能导致程序行为异常 值得注意的是，为了使用 char*版本的 debug_rep 正常工作，在定义此版本时，debug_rep(const string&amp;)的声明必须在作用域中。否则，就可能调用错误的 debug_rep 版本：</p>
<p>#+BEGIN_SRC C++ template <typename T> string debug_rep(const T &amp;t); template <typename T> string debug_rep(T <em>t); // 为了使debug_rep(char</em>)的定义正常工作，下面的声明必须在作用域中 string debug_rep(const string &amp;); string debug_rep(char *p) { // 如果接受一个const string&amp;的版本的声明不在作用域中， // 返回语句将调用debug_rep(const T&amp;)的T实例为string的版本 return debug_rep(string(p)); } #+END_SRC</p>
<p>通常，如果使用了一个忘记声明的函数，代码将编译失败。但对于重载函数模板的函数而言，则不是这样。如果编译器可以从模板实例化出于调用匹配的版本，则缺少的声明就不重要了。在本例中，如果忘记了声明接受 string 参数的 debug_rep 版本，编译器会默默地实例化接受 const T&amp;的模板版本。</p>
<p>#+BEGIN_QUOTE Tip：</p>
<p>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。 #+END_QUOTE ** 16.4 可变参数模板 一个 <em>可变参数模板</em> 就是一个接受可变数目参数的模板函数或模板类。 可变数据的参数被称为 <em>参数包</em> 。存在两种参数包 <em>模板参数包</em> ，表示零个或多个模板参数； <em>函数参数包</em> ，表示零个或多个函数参数。</p>
<p>我们用省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数中，class…或 typename…指出接下来的参数表示零个或多个类型的列表；一个类型名后面紧跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数列表中，如果一个参数的类型是一个模板参数包，则此参数也是函数参数包。例如：</p>
<p>#+BEGIN_SRC C++ // Args是一个模板参数包；rest是一个函数参数包 // Args表示零个或多个模板类型参数 // rest表示零个或多个函数参数 template &lt;typename T, typename… Args&gt; void foo(const T&amp;, const Args&amp; … rest); #+END_SRC</p>
<p>于往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译器还会推断包中参数的数据。 **** sizeof…运算符 当我们需要知道包种有多少元素时，可以使用 sizeof…运算符。类似 sizeof，sizeof…也返回一个常量表达式，而且不会对其实参求值。 *** 16.4.2 包扩展 **** 理解包扩展 print 中的函数参数包扩展仅仅将其包扩展为构成元素，C++语言还允许更复杂的扩展模式。例如，我们可以编写第二个可变参数函数，对其每个实参调用 debug_rep，然后调用 print 打印结果 string：</p>
<p>#+BEGIN_SRC C++ // 在print调用中对每个实参调用debug_rep template &lt;typename… Args&gt; ostream &amp;errorMsg(ostream &amp;os, const Args&amp;… rest) { // print(os, debug_rep(a1), debug_rep(a2), …, debug_rep(an)) return print(os, debug_rep(rest)…); } #+END_SRC</p>
<p>这个 print 调用使用了模式 debug_reg(rest)。此模式表示我们希望对函数参数包 rest 中的每个元素调用 debug_rep。扩展结果将是一个逗号分隔的 debug_rep 调用列表。</p>
<p>与之相对，下面的模式会编译失败</p>
<p>#+BEGIN_SRC C++ // 将包传递给debug_rep; print(os, debug_rep(al, a2, …, an)) print(os, debug_rep(rest…)); // 错误：此调用无匹配函数 #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>扩展中的模式会独立地应用于包中的每个元素。 #+END_QUOTE *** 16.4.3 转发参数包 在新标准下，我们可以组合使用可变参数模板与 forward 机制来编写函数，实现将其实参不变地传递给其他函数。</p>
<p>#+BEGIN_QUOTE 建议：转发和可变参数模板</p>
<p>可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的 emplace_back 函数一样的形式：</p>
<p>// fun 有零个或多个参数，每个参数都是一个模板参数类型的右值引用 template&lt;typename… Args&gt; void fun(Args&amp;&amp;… args) // 将 Args 扩展为一个右值引用的列表 { // work 的实参既扩展 Args 又扩展 args work(std::forward<Args>(args)…); }</p>
<p>这里我们希望将 fun 的所有实参转发给另一个名为 work 的函数，假定由他完成函数的实际工作。类型 emplace_back 中对 construct 的调用，work 调用中的扩展既扩展了模板参数包也扩展了函数参数包。</p>
<p>由于 fun 的参数是右值引用，因此我们可以传递给它任意类型的实参；由于我们使用 std::forward 传递这些参数，因此它们的所有类型信息在调用 work 时都会得到保持。 #+END_QUOTE ** 16.5 模板特例化 编写单一模板，使之对任何可能的模板实参都时最适合的，都能实例化，这并不总是能办到。在某些情况下，通用模板的定义对特定类型是不适合的：通用定义可能编译失败或做得不正确。其他时候，我们也可以利用某些特定知识来编写更高效的代码，而不是从通用模板实例化。当我们不能（或不希望）使用模板版本时，可定义类或函数模板的一个特例化版本。</p>
<p>我们的 compare 函数是一个很好的例子，它展示了函数模板的通用定义不适合一个特定类型（即字符指针）的情况。我们希望 compare 通过调用 strcmp 比较两个字符串指针而非比较指针值。实际上，我们已经重载了 compare 函数来处理字符串字面常量（参见 16.1.1 节）：</p>
<p>#+BEGIN_SRC C++ // 第一个版本；可以比较任何两个类型 template <typename T> int compare(const T&amp;, const T&amp;); // 第二版本处理字符串字面常量 template&lt;size_t N, size_t M&gt; int compare(const char(&amp;)[N], const char(&amp;)[M]); #+END_SRC</p>
<p>但是，只有当我们传递给 compare 一个字符串字面常量或者一个数组时，编译器才会调用接受两个非类型模板参数的模板。如果我们传递给它字符指针，就会调用第一个版本：</p>
<p>#+BEGIN_SRC C++ const char <em>p1 = “hi”, </em>p2 = “mom”; compare(p1, p2); // 调用第个模板 compare(“hi”, “mom”); // 调用有两个非类型参数的版本 #+END_SRC</p>
<p>我们无法将一个指针转换为一个数组的引用，因此当参数是 p1 和 p2 时，第二个版本的 compare 是不可行的。</p>
<p>为了处理字符指针（而不是数组），可以为第一个版本的 compare 定义一个 <em>模板特例化</em> 版本。一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型。 **** 定义函数模板特例化 当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字 template 后跟一个空尖括号对（&lt;&gt;）。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<p>#+BEGIN_SRC C++ // compare的特殊版本，处理字符数组的指针 template &lt;&gt; int compare(const char* const &amp;p1, const char* const &amp;p2) { return strcmp(p1, p2); } #+END_SRC</p>
<p>理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。本例中我们特例化：</p>
<p>~template <typename T> int compare(const T&amp;, const T&amp;);~</p>
<p>其中函数参数为一个 const 类型的引用。类似类型别名，模板参数类型、指针及 const 之间的互相作用会令人惊讶（参见 2.5.1 节）</p>
<p>我们希望定义此函数的一个特例化版本，其中 T 为 const char<em>。我们的函数要求一个指向此类型 const 版本的引用。一个指针类型的 const 版本是一个常量指针而不是指向 const 类型的指针。我们需要在特例化版本中使用的类型是 const char </em> char &amp;，即一个指向 const char 的 const 指针的引用。 **** 函数重载与模板特例化 当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而非函数名的一个重载版本。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE 关键概念：普通作用域规则应用于特例化</p>
<p>为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中。</p>
<p>对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特例化版本声明顺序错误导致的错误，而这种错误又很难查找。</p>
<p>如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参即和，就会产生错误。但是，这种错误编译器又无法发现。 #+END_QUOTE</p>
<p>#+BEGIN_QUOTE Best Practices：</p>
<p>模板及其特例化版本应该声明在同一头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。 #+END_QUOTE **** 类模板部分实例化 与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的 <em>部分实例化</em> 本身是一个模板，使用它时用户还必须为那些在特例化版本中指定的模板参数提供实参。</p>
<p>#+BEGIN_QUOTE Note：</p>
<p>我们只能部分特例化类模板，而不能部分特例化函数模板 #+END_QUOTE **** 特例化成员而不是类 我们可以只特例化特定成员函数而不是特例化整个模板。例如，如果 Foo 是一个模板类，包含一个成员 Bar，我们可以只特例化该成员：</p>
<p>#+BEGIN_SRC C++ template <typename T> struct Foo { Foo(const T &amp;t = T()) : mem(t) { } void Bar() { /* … */ } T mem; // FOo的其他成员 }; template&lt;&gt; // 我们正在特例化一个模板 void Foo<int>::Bar() // 我们正在特例化Foo<int>的成员Bar { // 进行应用于int的特例化处理 } #+END_SRC</p>
<p>本例中我们只特例化 Foo<int>类的一个成员，其他成员将由 Foo 模板提供：</p>
<p>#+BEGIN_SRC C++ Foo<string> fs; // 实例化Foo<string>::Foo() fs.Bar(); // 实例化Foo<string>::Bar() Foo<int> fi; // 实例化Foo<int>::Foo() fi.Bar(); // 使用我们特例化版本的Foo<int>::Bar() #+END_SRC</p>
<p>当我们使用 int 之外的任何类型使用 Foo 时，其成员像往常一样进行实例化。当我们用 int 使用 Foo 时，Bar 之外的成员像往常一样进行实例化。如果我们使用 Foo<int>的成员 Bar，则会使用我们定义的特例化版本。</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[USE Flags]]></title>
    <link>https://www.codeplayer.org/Wiki/Gentoo/Ebuild/USE%20Flags.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Gentoo/Ebuild/USE%20Flags.html</guid>
    <description><![CDATA[<p>#+TITLE: USE Flags #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<p>=USE= flag 用于控制可选的依赖和用户可能会希望选择的设置。例如， =app-editors/vim= 可以可选的构建支持 ruby 解释器，并且它需要安装 =dev-lang/ruby= 来达成此目的 —— 我们使用 ruby =USE= flag 来提供这个选项。在另一方面， =app-test/glark= 无论什么都要求 =ruby= ，所以在这里没有使用 =USE= flag。</p>
<p>=USE= flag 的任何组合都不应导致软件包构建失败，因为用户可以设置任何组合的 flag。</p>
<p>软件包不应基于编译时可用的内容进行配置和链接 —— 任何自动检测都必须被覆盖。这通常指依赖项“automagic”。这很不好，因为包管理器无法间的到该依赖，并且很容易破坏依赖和一些其他的问题。</p>
<p>automagic 依赖最好通过准备构建系统 patch 来修复，其 patch 添加适当的选项来控制有疑问的依赖，并且提交该 patch 到上游让所有用户收益。为避免在下游携带附加的补丁，通常可以使用特殊的构建系统选项来解决（例如在 autotools 中缓存变量）或无条件的依赖相关软件包来解决 automagic 依赖（即强制检查总是成功）。</p>
<p>#+BEGIN_QUOTE Note: USE flag 的状态保存在 VDB 中，并且它们在 =pkg_prerm= 和 =pkg_postrm= 中的值从这里获取。这意味着在 merge 和 unmerge 之间设置或取消设置 USE flag 是无效的。 #+END_QUOTE</p>
<ul>
<li>When not to use USE flags? 尽管通常认为 =USE= flag 对用户有利，但也有一些避免使用它们的有效用例。当写 ebuild 时的，考虑是否为一个特定功能添加 flag，或探索以下描述的替代方案之一。</li>
</ul>
<p>当软件包未链接时， =USE= flag 的使用不应该控制运行时依赖。这样做会未软件包创建额外的配置，并重新编译磁盘上没有更改的底层文件。这应该避免这种情况，改为如果有需要则通过安装后的消息传达给用户。</p>
<p>=USE= flag 不得用于控制小型、非侵入式、不会引入其他构建时依赖或导致构建时间显著增加的文件。例如此类文件包括 bash 补全文件，init.d 脚本，logrotate 配置文件，systemd 服务文件。基本原理与上述相同。这些文件必须无条件的安装。</p>
<p>对于具有多个条件程序或模块的包，可以进行类似的处理。每当这会导致大量的 =USE= flag，迫使用户花费大量的时间选择兼容的 flag，并可能在不完整的选择后重新构建，考虑减少将 flag 用于那些具有外部依赖和/或构建时间较长的程序或模块。剩余的部分应该改为无条件构建，或由像 =minimal= 的 flag 控制。</p>
<p>你不应该引入仅用于操作 =CFLAGS= 、 =FEATRUES= 等类似由用户直接配置的变量的 USE flag。反而，软件包应避免操作它们，并让用户直接设置它们。常见的错误包括：</p>
<ol type="1">
<li>使用 =debug= USE flag 来强制 =-O0 -g= 并禁用 stripping。 =debug= flag 的正确目的应该是控制附加的调试代码路径。用户应该负责使用正确的 flags 和特性来保留调试信息。</li>
<li>引入 =lto= flag 并强制 =-flto= 。这是用户应该直接在 flag 变量设置的。</li>
<li>使用 =CPU_FLAGS_<em>= 来控制 =-m</em>= 选项。这些 flag 旨在显式控制要求特定 CPU 扩展的代码路径，例如 separate assembly。编译器生成的程序集应尊重用户的 =-march= 选择。</li>
</ol>
<p>在某些极端情况下，这些规则可能不适用。例如，一些上游要求用户使用特定的 =CFLAGS= 并且拒绝使用其他值构建的错误报告。在这种情况，默认情况下会 strip flag 并提供 =custom-cflags= flag，以允许用户强制使用其首选 flag。</p>
<ul>
<li>=noblah= USE Flags 避免 =noblah= 风格的 =use= flag。它们会破坏 =use.mask= 并且对架构开发者造成各种复杂问题。原因如下：</li>
</ul>
<p>考虑一个名为’vplayer’的假想包，其功能为播放视频。该软件包通过 =USE= flag 对各种声音和视频输出方法、各种视频解码等提供可选支持。</p>
<p>vplayer 的可选功能之一是提供对’fakemdia’的解码支持，不幸的是它仅以狡猾的 x86 二进制形式提供。我们通过执行嗯以下操作来解决此问题：</p>
<p><sub>RDEPEND=“x86? ( fakemdia? ( &gt;=media-libs/fakemdia-1.1 ) )”</sub></p>
<p>除了这种方法非常肮脏 —— 当 AMD64 二进制文件也这样做会发生什么？还有，在其他架构的用户会在 =emerge -pv= 输出中看到列出的 fakemdia，即使它实际上不可用。</p>
<p>类似的，假如 vplayer 将支持通过 ALSA 解码器输出作为一个选项。然而 ALSA 在 SPARC 或 Alpha 上不可用（或在编写此示例时）。所以我们可以这样做：</p>
<p><sub>DEPEND=“!sparc? ( !alpha? ( alsa? ( media-libs/alsa-lib ) ) )”</sub></p>
<p>同样，这很混乱，并且 ALSA 同样会出现在 =emerge -p= 的输出中。而且，一旦 ALSA 开始在 SPARC 上工作时，每一个这么做的 ebuild 都必须手动编辑。</p>
<p>解决办法是 =use.mask= ，该文件记录在[[https://devmanual.gentoo.org/profiles/use.mask/index.html][Profile use.make]]文件中。每个 profile 都可以有一个 =use.mask= 文件，该文件用于强制禁用给定架构（或子架构，或 subprofile）上的特定 USE flag。所以，如果 =fakemdia= USE flag 在每一个非 x86 pofile 的 use.mask 中，以下内容完全合法并且不会破坏任何内容：</p>
<p><sub>RDEPEND=“fakemedia? ( &gt;=media-libs/fakemedia-1-1 )”</sub></p>
<p>非 x86 的用户在执行 =emerge -pv vplayer= 时会看到以下内容：</p>
<p>=[ebuild R ] media-video/vplayer-1.2 alsa -blah (-fakemedia) xyz=</p>
<p>要向 =use.mask= 添加一个 flag，请询问相关的架构团队。</p>
<ul>
<li>IUSE defaults 在 =IUSE= 中 use flag 的名称前添加 =+= 或 =-= 以默认将其打开或关闭。</li>
</ul>
<p>#+BEGIN_QUOTE Important：在 =IUSE= 中添加 =-= 到 flag 之前时非常没有用的，因为它既不会覆盖用户的配置(=make.conf=)，也不会覆盖 profile 默认(=make.defualts=和=package.use=)。有关 Portage 中 USE 顺序的详细信息，请参见 amke.conf(5)。 #+END_QUOTE</p>
<ul>
<li><p>Local and Global USE Flags USE flag 可分为本地或全局。一个全局 USE flag 必须满足几个标准：</p></li>
<li><p>它被许多不同的软件包使用，至少 5 个似乎满足以上条件。</p></li>
<li><p>它具有一般的非特定用途。</p></li>
</ul>
<p>第二点非常重要。如果 USE flag 对 =pkg-one= 于对 =pkg-two= 的影响大不相同，那么该表示不是成为全局 flag 的合适候选者。尤其要注意，如果曾经引入 =client= 和 =server= USE flag，则由于这个原因它们不能成为全局 USE flag。</p>
<p>在引入一个新的全局 USE flag 之前， 它必须在 gentoo-dev 邮件列表中进行讨论。</p>
<ul>
<li>USE Flag Descriptions 必须在 =profile/= 目录的 =use.desc= 或软件包目录的 =metadata.xml= 中描述所有 USE flag。见 =man portage= 或这些文件中的注释以获取格式说明。 记得保持这些文件的排序。 =use.local.desc= 文件自动从软件包的 =metadata.xml= 生成的，并且可以由解析树的工具使用。因为 =use.local.desc= 是自动生成的，因此绝对不能在树中进行手动编辑。更多信息见[[https://www.gentoo.org/glep/glep-0056.html][GLEP 56]]。</li>
</ul>
<p>=USE_EXPAND= flag 是一个例外，其必须记录在 =profile/desc/= 目录中。每个 =USE_EXPAND= 变量需要一个文件，该文件必须包含该变量可以采用的可能的值的说明。格式见这些文件中的注释，并且记住保持这些文件的排序。</p>
<ul>
<li>Conflicting USE Flags 偶尔 ebuild 的 USE 会因为功能性产生冲突。检查它们并返回一个错误不是一个可行的方法。相反，你必须在冲突中选择一个青睐的 USE flag，并应警告用户使用了特定的 flag。</li>
</ul>
<p>一个示例来自 =mail-mta/mstmp= ebuild。软件包可以使用代 GnuTLS 的 SSL，代 OpenSSL 的 SSL 或者完全不使用 SSL。因为 GnuTLS 比 OpenSSL 具有更多功能，因此受到青睐：</p>
<p>#+BEGIN_SRC sh src_compile() { local myconf</p>
<pre><code>    if use ssl &amp;&amp; use gnutls ; then
    myconf=&quot;${myconf} --enable-ssl --with-ssl=gnutls&quot;
    elif use ssl &amp;&amp; ! use gnutls ; then
    myconf=&quot;${myconf} --enable-ssl --with-ssl=openssl&quot;
    else
        myconf=&quot;${myconf} --disable-ssl&quot;
    fi

    econf \
    # Other stuff
    ${myconf}

    emake
}</code></pre>
<p>#+END_SRC</p>
<p>在某些特殊情况下，上述策略会破坏反向 USE 依赖。为了避免如此，ebuild 可以使用 =REQUIRED_USE= 指定允许的 USE flag 组合。关于其语法的描述请见[[https://devmanual.gentoo.org/ebuild-writing/variables/index.html#required_use][REQUIRED_USE]]章节。</p>
<p>例如，如果一个软件包 =dev-libs/foo= 可以使用 <sub>USE=“a”</sub> 或 <sub>USE=“b”</sub> 之一构建，但不是同时使用，那么首选其中一个 flag 将破坏依赖于 =dev-libs/foo[a]= 或 =dev-libs/foo[b]= 的软件包。因此在这种情况中，ebuild 应该指定 <sub>REQUIRED_USE=“a ? ( !b )”</sub> 。</p>
<p>#+BEGIN_QUOTE NOTE: 为了避免迫使用户过多的 micro-manage falg，应谨慎的使用 =REQUIRED_USE= 。只要有可能进行满足用户需求的构建，就应遵循常规策略。 #+END_QUOTE</p>
<ul>
<li>USE_EXPAND and ARCH USE Flags =VIDEO_CARDS= 、 =INPUT_DEVICES= 和 =L10N= 变量会自动扩展为 USE flag。这些称为 =USE_EXPAND= 变量。例如，如果用户在 =make.conf= 中有 <sub>L10N=“en fr”</sub> ，那么 <sub>USE=“l10n_en l10n_fr”</sub> 会自动被 portage 设置。会自动被 portage 设置。会自动被 portage 设置。会自动被 portage 设置。</li>
</ul>
<p>自 Prtage 2.0.51.20 其， =USE_EXPAND= 列表被设置在 =profile/bas/make.defaults= 中。未经过 gentoo-dev 列表的讨论，不能对其进行修改，并且在任何 subprofile 中也不能对其修改。</p>
<p>当前架构（例如， =x86= 、 =sparc= 、 =ppc-macos= ）会被自动设置为 USE flag。有关有效的有关架构关键词的完整列表，请见 =profile/arch.list= ，[[https://www.gentoo.org/glep/glep-0022.html][GLEP 22]]对其格式进行了说明。</p>
<p>#+BEGIN_QUOTE Warning：架构变量与 =ACCEPT_KEYWORDS= 有某种联系是一个常见的误解。它们没有联系。例如，在 =sparc= 上接受 =x86= 关键字，并不会设置 =USE"x86"= 。类似的，也没有 =~arch= USE flag，所以不要尝试 =if use ~x86= 。 #+END_QUOTE</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[The Basics of Autotools]]></title>
    <link>https://www.codeplayer.org/Wiki/Gentoo/Ebuild/The%20Basics%20of%20Autotools.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Gentoo/Ebuild/The%20Basics%20of%20Autotools.html</guid>
    <description><![CDATA[<p>#+TITLE: The Basics of Autotools #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>Major Autotools Components Autotools 是相关软件包的集合，这些软件包一起使用时，可以消除创建可移植软件时遇到的许多困难。这些工具和一些相对简单的上游提供的输入文件以其，用于为软件包创建构建系统。</li>
</ul>
<p>#+CAPTION: A basic overview of how the main autotools components fit together. [[file:../../../pics/Gentoo/autotools_diagram.png]]</p>
<p>/A basic overview of how the main autotools components fit together./</p>
<p>在一个简单的设置中：</p>
<ul>
<li>=autoconf= 程序从 =configure.in= 或 =configure.ac= 中产生 =configure= 脚本（见下面的 NOTE）。</li>
<li>=automake= 程序从 =Makefile.am= 中产生 =Makefile.in= 。</li>
<li>=configure= 脚本从 =Makefile.in= 文件中产生一个或多个 =Makefile= 文件。</li>
<li>=make= 程序使用 =Makefile= 来编译程序。</li>
</ul>
<p>#+BEGIN_QUOTE NOTE: =configure.in= 名字曾经是标准。然而，GNU 文档现在建议使用 =configure.ac= 因为当处理它时会更清楚该使用哪个程序。两个文件具有相同的用途并且具有相同的格式 —— 唯一的区别时名称。 #+END_QUOTE</p>
<p>你可能会看到在各个阶段函数都使用了 autotools。src_prepare 函数时在配置和编译之前处理源代码的最适合的位置。特别是，src_prepare 在 src_cofigure 之前调用，src_cofigure 通常期望 =configure= 脚本存在。</p>
<p>=autoreconf= 工具据推测可以根据需要运行 =autoconf= （以及 =automake= 、 =autoheader= 、 =aclocal= 、 =autopoint= 和 =libtoolize= ）。有时运行起来没问题。一些软件包附带了一个名为 =autogen.sh= 的 shell 脚本，该脚本会执行相同的操作（与 =autogen= 无关）。autotools.eclass 包含了与它们名字对应的独立工具的 helper 函数，例如 =eautoconf= 和 =eautomake= 。</p>
<p>#+BEGIN_QUOTE Warning：你必须不能尝试修改在运行 =configure= 和 =make= 之间生成的任何文件。这可能会导致 autotools 尝试变得更加聪明并且重建文件，进而导致你的更改被删除。在一些情况下，这还会导致 =./configure= 参数被悄然删除，这可能会破坏依赖关键。最佳的的处理方法通常是改用 <sub>.ac=/=.in</sub> 文件。 #+END_QUOTE</p>
<p>** The =configure.ac= File =configure.ac= 文件用来创建 =/.configure= 脚本。它包括一系列由 =autoconf= 处理和展开的宏。这些宏可以检查软件包和库，处理 =–enable= 和 =–with= 的切换，并且生成各种文件。</p>
<ul>
<li>Further Autotools Reading</li>
</ul>
<ol type="1">
<li>https://devmanual.gentoo.org/general-concepts/autotools/index.html</li>
</ol>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Ebuild Revisions]]></title>
    <link>https://www.codeplayer.org/Wiki/Gentoo/Ebuild/Ebuild%20Revisions.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Gentoo/Ebuild/Ebuild%20Revisions.html</guid>
    <description><![CDATA[<p>#+TITLE: Ebuild Revisions #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>Ebuild Revisions Ebuild 可能具有与其有关系的 Gentoo 修订号。其为 =-rX= 后缀，其中 =X= 是整数 —— 见[[https://devmanual.gentoo.org/ebuild-writing/file-format/index.html#file-naming-rules][文件命名规则]]。该组件必须用于 Gentoo 的改变，而不是上游的发布。如果 ebuild 没有显式的修订号，则它具有隐式的 =-r0= 修订号。</li>
</ul>
<p>Ebuild 修订版通常用于两个目的：</p>
<ol type="1">
<li>在做潜在的重大改变时，保留旧版本的 ebuild。</li>
<li>当执行有意义的改变时传播软件包的重建，否则已经安装当前版本的用户不会注意到改变。</li>
</ol>
<p>开发者鼓励使用常识来决定是否引入新的=-rX=修订版时。以下经验法则可以用作指导原则：</p>
<ol type="1">
<li>如果更改可能导致软件包损坏，以至于要求用户还原到之前的版本（对于标记为稳定的软件包，每个非重要的修改都被归为此类），那么应该引入新的修订版并保留旧的版本。如果软件包有 stable 关键字，新的修订版应该降为 =~arch= （见[[https://devmanual.gentoo.org/keywording/index.html#keywording-on-upgrades][Keywording on Upgrades]]。对于任何修订版的 bump，新的 ebuild 应该基于之前的修订版，以确保修复不会意外丢失。</li>
<li>如果更改对已安装了软件包的用户产生了很大的用户（修复运行时问题，改变安装文件等）并且它不会通过其他方式传播，那么 ebuild 应该重命名为新的修订版。如果软件包有 stable 关键字，那么它们应该不删除直接移动到新的修订版。提交 ebuild 时，应该使用=repoman commit –straight-to-stable=选项。</li>
<li>否则，更改可以在 ebuild 的当前修订版完成。</li>
</ol>
<p>需要新修订版的更改示例包括：</p>
<ul>
<li>添加 patch 修复运行时问题</li>
<li>安装可能对用户有用的附加文件</li>
<li>向现有的 blocks 之一添加缺失的运行时依赖</li>
<li>添加缺失的构建时依赖，缺少该依赖会构建成功，但不正确（例如缺少某些功能）</li>
<li>限制运行时依赖版本，除非 <sub>:=</sub> subslot 运算符触发重建</li>
</ul>
<p>无需修订版即可进行更改的示例如下：</p>
<ul>
<li>添加 patch 以解决导致用户无法构建软件的构建时问题。（因为它不影响已构建的用户）</li>
<li>添加不重要的文档修复</li>
<li>安装对比需要重新构建软件包（特别是如果预计很快有新的 bump），其价值相对较小（次要文档，编辑器语法文件，bash 补全）的附加文件。</li>
<li>添加缺失并导致构建失败的构建时依赖。</li>
<li>添加新的 USE flag 或删除已存在的（因为 USE flags 的变化可以通过触发 =–changed-use= 重新构建）</li>
<li>不重要的风格/ebuild 代码更改（只有新的代码等同于旧的代码）</li>
<li>导致软件包移动的依赖变化（slot move）</li>
</ul>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Common Mistakes]]></title>
    <link>https://www.codeplayer.org/Wiki/Gentoo/Ebuild/Common%20Mistakes.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Gentoo/Ebuild/Common%20Mistakes.html</guid>
    <description><![CDATA[<p>#+TITLE: Common Mistakes #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<p>本章节包含有关开发人员在编写 ebuild 时犯的常见错误的资料。</p>
<ul>
<li>Common Ebuild Writing Mistakes ** Invalid use of =static= use-flag =static= use-flag 应该仅用于使二进制文件静态链接而不是动态链接。它不应该用于使一个库安装静态库。相反， =static-libs= use-flag 应该用于此目的。</li>
</ul>
<p>** Invalid use of ROOT =ROOT= 的使用仅旨在影响软件包的安装方式（即安装到 =ROOT= ） —— 构建和编译不应该依赖于 =ROOT= 。因此不允许在 =src_*= 函数中使用 =ROOT= 。</p>
<p>也请见[[https://devmanual.gentoo.org/ebuild-writing/variables/index.html#root][ROOT]]。</p>
<p>** 引用可以压缩的文档的完整路径 当向用户打印在那里可以找到诸如 INSTALL 值文件的文件时，不要指定完整路径因为=PORTAGE_COMPRELESS=会起作用。文件可能会会被用 gzip、bzip2 或其他压缩工具压缩。因此，不要这样做：</p>
<p>=elog “They are listed in /usr/share/doc/${PF}/INSTALL.gz”=</p>
<p>而要像这样做：</p>
<p>=elog “They are listed in the INSTALL file in /usr/share/doc/${PF}”=</p>
<p>** Build log not verbose 当编写 ebuild 时，你应该总是检查构建日志，因为构建系统可能会葫芦俄 CC/CXX/LD/CFLAGS/LDFAGS 都能或默认添加不需要的 flag。为了分析此问题并获得完整的信息，以防有人报告你的软件包存在漏洞， <em>构建日志必须总是详细的</em> 。</p>
<p>根据构建系统，有几个方法来修复构建日志不详细的问题：</p>
<p>对于基于 =cmake= 的构建系统，ebuild 只要调用 cmake-utils_src_compile 即可，默认情况下该函数会拾取 camke-utils.eclass 变量 =CMAKE_VERBOSE=1= 。如果你出于任何原因直接调用 emake，那可以执行 =emake VERBOSE=1= （注意，cmake-utils_src_compile 也接受传递给 make 的参数）。</p>
<p>对于基于 =autotools= 的构建系统你可以传递 =–disable-silent-rules= 到 econf，或使用自动传递该参数的 EAPI 5。 =emake -V1= 也有同样的效果。</p>
<p>对于自定义的 Makefile，你通常必须编写一个 patch。尝试向上游添加诸如=V=1=之类的选项以开启完整详细信息。</p>
<p>#+BEGIN_QUOTE Note：如果你遇到受影响的软件包或 eclass，其使用的构建系统无法被 portage 控制，你应该提交 bug（与 patch 一起更好）并且使它屏蔽 bug #429308。ebuild 级别之上的解决方案是首选。 #+END_QUOTE</p>
<p>** -Werror compiler flag not removed =-Werror= flag 将所有的警告变成错误，所以如果遇到任何警告会停止编译。</p>
<p>*** 基本原理 该 flag 对 release 并不推荐并且在构建日志中遇到时总是应该禁用的，因为在很多情况下这种破坏都是无目的的，例如：</p>
<ul>
<li>在 GCC/GLIBC 版本 bump 时出现新的警告，开发人员在编码时尚未意识到</li>
<li>一些 autoconf 检查将会严重失败</li>
<li>库添加已弃用 API 的警告，尽管该 API 仍在工作/受支持</li>
<li>在鲜为人知的架构上，我们可能会比在普通架构上得道不同/更多的警告</li>
<li>随机破坏取决于开发人员在哪个发行版/架构/库版本/内核/用户空间测试 =-Werror=</li>
</ul>
<p>关闭 =-Werror= 我们仍可见到警告，但没有理由它们会造成编译失败。还请注意，portage 已经发出了有关可能会造成运行时损坏的 gcc 警告的 QA notices。</p>
<p>*** 如何修复 你应该使用如下方法修复受影响的构建系统：</p>
<ul>
<li>从构建系统中移除编译 flag，例如 Makefile.am 或 configure.ac 或甚至提供开关（对于基于 autotools 的构建系统可能是 =–disable-werror= ，其非常适合向上游发送 patch）</li>
<li>使用 append-flags -Wno-error（需要 flag-o-matic.eclass）；为此环境 flag 必须尊重并放在构建系统 flag 之后；该方法不是首选，因为它将同时禁用所有 =-Werror=specific-warning= flag，请见下一节</li>
</ul>
<p>始终检查构建日志中真的没有该 flag。</p>
<p>*** Specific -Werror=… flags GCC 可以使任何指定警告变成错误。例如一个指定的-Werror flag 可以是 =-Werror=implicit-function-declaration= ，并将仅影响关于隐式函数声明的警告。保留这些鸳鸯是最安全的，因为将它们固定在此问题上，并且不会造成随机的构建时间破坏。还有，我们可以期望上游这么做是为了避免已知的运行时错误，而不仅仅是测试其构建。然而你应该自己检查指定的警告，或在不确定时询问其他开发人员。</p>
<p>*** 例外情况 从 configure.ac 中删除 =-Werror= 会在极少数的情况下（其中配置阶段依赖于退出代码）导致中断。见[[https://sourceforge.net/p/open-vm-tools/tracker/81/][app-emulation/open-vm-tools bug]]。但是即使如此，我们仍将其从生成的 Makefile 中删除。</p>
<p>** Missing/Invalid/Broken Header 当你提交 ebuild 时，header 必须和[[https://gitweb.gentoo.org/repo/gentoo.git/tree/skel.ebuild][skel.ebuild]]中的完全形同。</p>
<p>前两行必须如下所示：</p>
<p>#+BEGIN_SRC sh # Copyright 1999-2020 Gentoo Authors # Distributed under the terms of the GNU General Public License v2 #+END_SRC</p>
<p>#+BEGIN_QUOTE Note：header 以前包括带有一个 CVS =<span class="math inline"><em>I</em><em>d</em></span>= 或 =<span class="math inline"><em>H</em><em>e</em><em>a</em><em>d</em><em>e</em><em>r</em></span>= 关键字的第三行。这一行在转为 git 后废除了，其由[[https://bugs.gentoo.org/611234][decision of the Gentoo Council on 28 February 2017]]决定并不能再继续添加。 #+END_QUOTE</p>
<p>** Redefined P, PV, PN, PF 你应该永远不重新定义这些变量。总是使用 MY_P、MY_PN、MY_PV、P0 等。有关更多信息，请见再 portage 其他这样做的 ebuild。大多数 ebuild 使用 bash 的“Parameter Expansion”。请阅读 bash 的 man page 以理解“Parameter Expansion”是怎么样工作的。</p>
<p>顺便，如果你找到重新定义这些变量的软件包，请不要复制它。提交有关该 ebuild 的 bug。</p>
<p>** Including version numbers in SRC_URI and S 你应该尽量不要再 SRC_URI 和 S 中包含版本号。总是尝试使用 =<span class="math inline"><em>P</em><em>V</em> = <em>或</em>=</span>{P}= 。这会使得维护 ebuild 更加容易。如果版本号与压缩包/源代码的名字不是一致，则使用 MY_P。一个例子是 dev-python/pyopenal 拉取一个名为 PyOpenAL 的压缩包，所以我们可以像这样重新定义：</p>
<p>#+BEGIN_SRC sh MY_P=<span class="math inline">${P/pyopenal/PyOpenAL}  SRC_URI="http://download.gna.org/pyopenal/$</span>{MY_P}.tar.gz" S=<span class="math inline"><em>W</em><em>O</em><em>R</em><em>K</em><em>D</em><em>I</em><em>R</em>/</span>{MY_P} #+END_SRC</p>
<p>** DEPEND has syntactical errors 用户提交的 DEPEND 和 RDEPEND 字段可能会出现很多错误。在编写依赖的时候，需要注意以下几点。</p>
<ul>
<li>总是包括 CATEGORY。例如，使用 =&gt;=x11-libs/gtk+-2= ，而不是 =&gt;=gtk+2= 。</li>
<li>不要在&gt;=依赖项添加星号(<em>)。例如，应该使用 =&gt;=x11-libs/gtk+-2= ，而不是 =&gt;=x11-libs/gtk+-2</em>= 。</li>
<li>指定 GTK。对于 GTK+1 的应用，总是使用 ==x11-libs/gtk+-1.2*= 。</li>
<li>永远不要依赖 meta 包。所以，不要依赖于 gnome-base/gnome，总是依赖于指定的库，像 libgnome。</li>
<li>一行一个依赖项。不要把多个依赖项放到同一行。这会使阅读变得难看并且难以遵循。</li>
</ul>
<p>** DEPEND is incomplete 这是另一个非常常见的错误。ebuild 提交者提交“可以正常工作”的 ebuild，而不检查依赖是否正确。这里有一些如何找到正确依赖的提示。</p>
<ul>
<li>查看 =configure.in= 或 =configure.ac= 。在此处查找软件包的检查。需要注意的是 pkg-config 的检查或检查特定版本的 AM_*函数。</li>
<li>查看包含的.spec 文件。一个好的依赖关系指示是查看其中包含的.spec 文件以获取相关的依赖。然而，不要相信它们是绝对完整的依赖关系列表。</li>
<li>查看应用程序/库的网站。检查应用程序的网站，以了解他们建议的可能的依赖关系。</li>
<li>阅读软件包的 README 和 INSTALL。它们通常包含关于构建和安装软件包的有用信息。</li>
<li>记住非二进制依赖，如 pkg-config、文档生成程序等。通常构建过程要求一些依赖，像 inittool、libtool、pkg-config、doxygen、scrollkeeper、gtk-doc 等。确保明确说明这些内容。</li>
</ul>
<p>** LICENSE Invalid 另一个用户犯的常见错误是当提交 ebuild 时提供了无效的 license。例如， =GPL= 不是一个有效的 license。你需要指定 =GPL-1= 或 =GPL-2= 。 =LGPL= 也是同样的情况。确保你在 =LICENSE= 字段中使用的 license 在 =licenses= 目录下存在。一个提示，检查源代码压缩文件中的 =COPYING= 文件以获取许可证。如果软件包没有指定使用 =GPL-1= 或 =GPL-2= ，软件包很有可能使用 =GPL-2= 。</p>
<p>如果你提交的软件包 license 是独一无二的并且不在 =licenses/= 中，那么你必须在单独的文件中提交新的许可证。</p>
<p>** Untested ARCHs in KEYWORDS 请不要添加其他的 ARCH 到 KEYWORDS 中，除非 ebuld 在该 ARCH 上经过了测试。还有所有新的 ebuild 应该使用 ~x86 或无论架构是什么。确保当你 bump 版本时，稳定(?)的 KEYWORDS 全部标记为~。</p>
<p>** SLOT missing 确保在 ebuild 中又 SLOT 变量。如果你不打算使用它，也不要将其删除。设为：</p>
<p><sub>SLOT=“0”</sub></p>
<p>** DESCRIPTION and HOMEPAGE wrong 请检查 =HOMEPAGE= 变量是否正确，并且如果用户想了解有关软件包的更多信息，引导用户进入正确的页面。确保 =DESCRIPTION= 不会太长。好的描述将在一句话内描述软件包的主要功能。如果软件包没有 homepage 可用，则设置 =HOMEPAGE= 变量为 =https://wiki.gentoo.org/wiki/No_homepage= 。</p>
<p>** Wrongfully used spaces instead of TABS 因为提交者没有遵循使用 TABS 而不是空格的方针，而重新格式化 ebuild 的每一行并不有趣。所有请使用 tabs。</p>
<p>** Trailing whitespace 我经常对此感到内疚。记住在你的 build 上运行 repoman，它可以告诉你在行尾是否有空白或者是否有空行。</p>
<p>** 添加多余的 =S=<span class="math inline"><em>W</em><em>O</em><em>R</em><em>K</em><em>D</em><em>I</em><em>R</em>/</span>{P}= 如果 =S=<span class="math inline"><em>W</em><em>O</em><em>R</em><em>K</em><em>D</em><em>I</em><em>R</em>/</span>{P}= ，那么应该将其添加到你的 ebuild 中。这已经默认设置了，你应该仅在其值与 =<span class="math inline"><em>W</em><em>O</em><em>R</em><em>K</em><em>D</em><em>I</em><em>R</em>/</span>{P}= 不同时才添加它。</p>
<p>** Documentation missing 如果你的软件包有文档，确保使用 =dodoc= 安装或安装到 =/usr/share/doc/${PF}= 。到运行 =dodoc= / =doins= 时检查错误。</p>
<p>如果软件包的文档非常大或需要额外的依赖来构建，你应该用 =doc= USE flag 使它成为可选的。如果文档很小并且不需要额外的依赖（例如 =README= 文件），那么应无条件的安装它。</p>
<p>** Masking unsupported/broken USE flags 异常情况下，软件包可能具有不支持/损坏的 USE flag（这可能发生在原生或 custom-cflags 上）。那么该 USE flag 必须在该 ebuild 中屏蔽（通常在 profile/base/package.use.mask），至少当 ebuild 到达稳定分支时。</p>
<ul>
<li>Common Ebuild Submission Mistakes ** Introduction 请根据[[https://devmanual.gentoo.org/ebuild-maintenance/new-ebuild/index.html][Adding a New Ebuild]]教程正确提交 ebuild。</li>
</ul>
<p>** Tarball’ing an ebuild 请不要把 ebuild 或 patch 作为 tarball 附加。以避免 review 时的额外操作。</p>
<p>** Inlining Ebuilds 不要将 ebuild 剪切并粘贴到 bugzilla 的注释字段中。</p>
<p>** No description on what the package is 请让我们知道这是什么软件包，并填写应用程序的主页（如果有）的 URL。</p>
<p>** 更新软件包但不说明更改的内容 如果你提交了软件包的更新，那么确保你解释了在 ebuild 中做了什么更改。例如，如果软件包引入了一个新的特性/功能并且你使用了 USE flag， 将它列在你的 bug 中。不要让我们因此受伤。</p>
<p>提交 diff 而不是整个 ebuild 来更新软件包时明智的。生成它的最佳方法时：</p>
<p>=$ diff -u some-package-0.1.0.ebuild some-package-0.2.0.ebuild &gt; ~/some-package-0.2.0.diff=</p>
<p>** 因版本 bump 提交未更改的 ebuild 如果你提交一个新版本的软件包到 portage 中，确保存在的 ebuild 正常工作并且确保更改已合并到新的 build 中（例如添加文档）。如果对闲钱版本的 ebuild 不需要进行任何更改，那么请不要附加 ebuild。只要在 bug report 中说明你复制了 ebuild 并验证了该软件包可以正常安装和工作。</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Github ssh密钥配置]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/Github/Github%20ssh%e5%af%86%e9%92%a5%e9%85%8d%e7%bd%ae.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/Github/Github%20ssh%e5%af%86%e9%92%a5%e9%85%8d%e7%bd%ae.html</guid>
    <description><![CDATA[<p>#+TITLE: Github ssh密钥配置 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>Github ssh 密钥配置 #+BEGIN_SRC bash git config —global user.email xxx@gmai.com #添加自己邮箱到 git git config —global user.name xxx #添加自己用户名到 git git config —list #查看配置列表 #+END_SRC</li>
</ul>
<p>#+BEGIN_SRC bash ssh-keygen -t rsa -C “xxx@gmai.com”</p>
<p>Enter file in which to save the key (/home/shadow/.ssh/id_rsa): /home/shadow/.ssh/github_rsa #自定义输入文件名</p>
<p>Enter passphrase (empty ‘for’ no passphrase): #这里输入你想设置的密码，6位以上</p>
<p>Enter same passphrase again: #再次输入密码，6位以上</p>
<p>ssh-add ~/.ssh/github_rsa #添加私钥</p>
<p>ssh-add -l #查看私钥是否运行 #+END_SRC</p>
<p>#+BEGIN_SRC bash vim ~/.ssh/github_rsa.pub #复制公钥内容</p>
<p>https://github.com/settings/keys #git 添加复制的公钥都 git 网站</p>
<p>ssh -T git@github.com #测试是否联通 #+END_SRC</p>
<ul>
<li>Links</li>
<li>https://help.github.com/articles/adding-a-new-ssh-key-to-your-github-account/</li>
<li>https://help.github.com/articles/checking-for-existing-ssh-keys/</li>
<li>https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/</li>
</ul>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[docker compose模板文件]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/docker/docker%20compose%e6%a8%a1%e6%9d%bf%e6%96%87%e4%bb%b6.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/docker/docker%20compose%e6%a8%a1%e6%9d%bf%e6%96%87%e4%bb%b6.html</guid>
    <description><![CDATA[<p>#+TITLE: docker compose模板文件 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<p>模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。 但大部分指令跟 docker run 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 =docker-compose.yml=，格式为 YAML 格式。</p>
<p>#+BEGIN_EXAMPLE version: “3”</p>
<pre><code>services:
  webapp:
    image: examples/web
    ports:
      - &quot;80:80&quot;
    volumes:
      - &quot;/data&quot;</code></pre>
<p>#+END_EXAMPLE</p>
<p>注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中重复设置。</p>
<ul>
<li>build 指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</li>
</ul>
<p>#+BEGIN_EXAMPLE version: ‘3’ services:</p>
<pre><code>  webapp:
    build: ./dir</code></pre>
<p>#+END_EXAMPLE</p>
<p>你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。</p>
<p>使用 dockerfile 指令指定 Dockerfile 文件名。</p>
<p>使用 arg 指令指定构建镜像时的变量。</p>
<p>#+BEGIN_EXAMPLE version: ‘3’ services:</p>
<pre><code>  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1</code></pre>
<p>#+END_EXAMPLE</p>
<p>使用 =cache_from= 指定构建镜像的缓存</p>
<p>#+BEGIN_EXAMPLE build: context: . cache_from: - alpine:latest - corp/web_app:3.14 #+END_EXAMPLE</p>
<ul>
<li>cap_add, cap_drop 指定容器的内核能力（capacity）分配。</li>
</ul>
<p>例如，让容器拥有所有能力可以指定为：</p>
<p>#+BEGIN_EXAMPLE cap_add: - ALL #+END_EXAMPLE</p>
<p>去掉 NET_ADMIN 能力可以指定为：</p>
<p>#+BEGIN_EXAMPLE cap_drop: - NET_ADMIN #+END_EXAMPLE</p>
<ul>
<li>command 覆盖容器启动后默认执行的命令。</li>
</ul>
<p>=command: echo “hello world”=</p>
<ul>
<li><p>configs 仅用于 Swarm mode</p></li>
<li><p>cgroup_parent 指定父 cgroup 组，意味着将继承该组的资源限制。</p></li>
</ul>
<p>例如，创建了一个 cgroup 组名称为 cgroups_1。</p>
<p>=cgroup_parent: cgroups_1=</p>
<ul>
<li>container_name 指定容器名称。默认将会使用 =项目名称_服务名称_序号= 这样的格式。</li>
</ul>
<p>=container_name: docker-web-container=</p>
<p>#+BEGIN_QUOTE 注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。 #+END_QUOTE</p>
<ul>
<li><p>deploy 仅用于 Swarm mode</p></li>
<li><p>devices 指定设备映射关系。</p></li>
</ul>
<p>#+BEGIN_EXAMPLE devices: - “/dev/ttyUSB1:/dev/ttyUSB0” #+END_EXAMPLE</p>
<ul>
<li>depends_on 解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web</li>
</ul>
<p>#+BEGIN_EXAMPLE version: ‘3’</p>
<pre><code>services:
  web:
    build: .
    depends_on:
      - db
      - redis

  redis:
    image: redis

  db:
    image: postgres</code></pre>
<p>#+END_EXAMPLE</p>
<p>#+BEGIN_QUOTE 注意：web 服务不会等待 redis db 「完全启动」之后才启动。 #+END_QUOTE</p>
<ul>
<li>dns 自定义 DNS 服务器。可以是一个值，也可以是一个列表。</li>
</ul>
<p>#+BEGIN_EXAMPLE dns: 8.8.8.8</p>
<pre><code>dns:
  - 8.8.8.8
  - 114.114.114.114</code></pre>
<p>#+END_EXAMPLE</p>
<ul>
<li><p>dns_search #+BEGIN_EXAMPLE 配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p>
<p>dns_search: example.com</p>
<p>dns_search: - domain1.example.com - domain2.example.com #+END_EXAMPLE</p></li>
<li><p>tmpfs 挂载一个 tmpfs 文件系统到容器。</p></li>
</ul>
<p>#+BEGIN_EXAMPLE tmpfs: /run tmpfs: - /run - /tmp #+END_EXAMPLE</p>
<ul>
<li>env_file 从文件中获取环境变量，可以为单独的文件路径或列表。</li>
</ul>
<p>如果通过 =docker-compose -f FILE= 方式来指定 =Compose= 模板文件，则 =env_file= 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。</p>
<p>#+BEGIN_EXAMPLE env_file: .env</p>
<pre><code>env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env</code></pre>
<p>#+END_EXAMPLE</p>
<p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p>
<p>#+BEGIN_EXAMPLE # common.env: Set development environment PROG_ENV=development #+END_EXAMPLE</p>
<ul>
<li>environment 设置环境变量。你可以使用数组或字典两种格式。</li>
</ul>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<p>#+BEGIN_EXAMPLE environment: RACK_ENV: development SESSION_SECRET:</p>
<pre><code>environment:
  - RACK_ENV=development
  - SESSION_SECRET</code></pre>
<p>#+END_EXAMPLE</p>
<p>如果变量名称或者值中用到 =true|false=，=yes|no= 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<p>=y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF=</p>
<ul>
<li>expose 暴露端口，但不映射到宿主机，只被连接的服务访问。</li>
</ul>
<p>仅可以指定内部端口为参数</p>
<p>#+BEGIN_EXAMPLE expose: - “3000” - “8000” #+END_EXAMPLE</p>
<ul>
<li>external_links #+BEGIN_QUOTE 注意：不建议使用该指令。 #+END_QUOTE</li>
</ul>
<p>链接到 =docker-compose.yml= 外部的容器，甚至并非 Compose 管理的外部容器。</p>
<p>#+BEGIN_EXAMPLE external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql #+END_EXAMPLE</p>
<ul>
<li>extra_hosts 类似 Docker 中的 =–add-host= 参数，指定额外的 host 名称映射信息。</li>
</ul>
<p>#+BEGIN_EXAMPLE extra_hosts: - “googledns:8.8.8.8” - “dockerhub:52.1.157.61” #+END_EXAMPLE</p>
<p>会在启动后的服务容器中 =/etc/hosts= 文件中添加如下两条条目。</p>
<p>#+BEGIN_EXAMPLE 8.8.8.8 googledns 52.1.157.61 dockerhub #+END_EXAMPLE</p>
<ul>
<li>healthcheck 通过命令检查容器是否健康运行。</li>
</ul>
<p>#+BEGIN_EXAMPLE healthcheck: test: [“CMD”, “curl”, “-f”, “http://localhost”] interval: 1m30s timeout: 10s retries: 3 #+END_EXAMPLE</p>
<ul>
<li>image 指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</li>
</ul>
<p>#+BEGIN_EXAMPLE image: ubuntu image: orchardup/postgresql image: a4bc65fd #+END_EXAMPLE</p>
<ul>
<li>labels 为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</li>
</ul>
<p>#+BEGIN_EXAMPLE labels: com.startupteam.description: “webapp for a startup team” com.startupteam.department: “devops department” com.startupteam.release: “rc3 for v1.0” #+END_EXAMPLE</p>
<ul>
<li>logging 配置日志选项。</li>
</ul>
<p>#+BEGIN_EXAMPLE logging: driver: syslog options: syslog-address: “tcp://192.168.0.42:123” #+END_EXAMPLE</p>
<p>目前支持三种日志驱动类型。</p>
<p>#+BEGIN_EXAMPLE driver: “json-file” driver: “syslog” driver: “none” #+END_EXAMPLE</p>
<p>options 配置日志驱动的相关参数。</p>
<p>#+BEGIN_EXAMPLE options: max-size: “200k” max-file: “10” #+END_EXAMPLE</p>
<ul>
<li>network_mode 设置网络模式。使用和 =docker run= 的 =–network= 参数一样的值。</li>
</ul>
<p>#+BEGIN_EXAMPLE network_mode: “bridge” network_mode: “host” network_mode: “none” network_mode: “service:[service name]” network_mode: “container:[container name/id]” #+END_EXAMPLE</p>
<ul>
<li>networks 配置容器连接的网络。</li>
</ul>
<p>#+BEGIN_EXAMPLE version: “3” services: some-service: networks: - some-network - other-network</p>
<pre><code>networks:
  some-network:
  other-network:</code></pre>
<p>#+END_EXAMPLE</p>
<ul>
<li>pid 跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</li>
</ul>
<p>=pid: “host”=</p>
<ul>
<li>ports 暴露端口信息。</li>
</ul>
<p>使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<p>#+BEGIN_EXAMPLE ports: - “3000” - “8000:8000” - “49100:22” - “127.0.0.1:8001:8001” #+END_EXAMPLE</p>
<p>#+BEGIN_QUOTE 注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。 #+END_QUOTE</p>
<ul>
<li>secrets 存储敏感数据，例如 mysql 服务密码。</li>
</ul>
<p>#+BEGIN_EXAMPLE version: “3.1” services:</p>
<pre><code>mysql:
  image: mysql
  environment:
    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
  secrets:
    - db_root_password
    - my_other_secret

secrets:
  my_secret:
    file: ./my_secret.txt
  my_other_secret:
    external: true</code></pre>
<p>#+END_EXAMPLE</p>
<ul>
<li>security_opt 指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</li>
</ul>
<p>#+BEGIN_EXAMPLE security_opt: - label:user:USER - label:role:ROLE #+END_EXAMPLE</p>
<ul>
<li>stop_signal 设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</li>
</ul>
<p>=stop_signal: SIGUSR1=</p>
<ul>
<li>sysctls 配置容器内核参数。</li>
</ul>
<p>#+BEGIN_EXAMPLE sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0</p>
<pre><code>sysctls:
  - net.core.somaxconn=1024
  - net.ipv4.tcp_syncookies=0</code></pre>
<p>#+END_EXAMPLE</p>
<ul>
<li>ulimits 指定容器的 ulimits 限制值。</li>
</ul>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<p>#+BEGIN_EXAMPLE ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 #+END_EXAMPLE</p>
<ul>
<li>volumes 数据卷所挂载路径设置。可以设置为宿主机路径(HOST:CONTAINER)或者数据卷名称(VOLUME:CONTAINER)，并且可以设置访问模式 （HOST:CONTAINER:ro）。</li>
</ul>
<p>该指令中路径支持相对路径。</p>
<p>#+BEGIN_EXAMPLE volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:ro #+END_EXAMPLE</p>
<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<p>#+BEGIN_EXAMPLE version: “3”</p>
<pre><code>services:
  my_src:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:</code></pre>
<p>#+END_EXAMPLE</p>
<ul>
<li>其它指令 此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。</li>
</ul>
<p>指定服务容器启动后执行的入口文件。</p>
<p>=entrypoint: /code/entrypoint.sh=</p>
<p>指定容器中运行应用的用户名。</p>
<p>=user: nginx=</p>
<p>指定容器中工作目录。</p>
<p>=working_dir: /code=</p>
<p>指定容器中搜索域名、主机名、mac 地址等。</p>
<p>#+BEGIN_EXAMPLE domainname: your_website.com hostname: test mac_address: 08-00-27-00-0C-0A #+END_EXAMPLE</p>
<p>允许容器中运行一些特权命令。</p>
<p>=privileged: true=</p>
<p>指定容器退出后的重启策略为始终重启。 该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 =always= 或者 =unless-stopped= 。</p>
<p>=restart: always=</p>
<p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<p>=read_only: true=</p>
<p>打开标准输入，可以接受外部输入。</p>
<p>=stdin_open: true=</p>
<p>模拟一个伪终端。</p>
<p>=tty: true=</p>
<ul>
<li>读取变量 Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。</li>
</ul>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。</p>
<p>#+BEGIN_EXAMPLE version: “3” services:</p>
<pre><code>db:
  image: &quot;mongo:${MONGO_VERSION}&quot;</code></pre>
<p>#+END_EXAMPLE</p>
<p>如果执行 =MONGO_VERSION=3.2 docker-compose up= 则会启动一个 mongo:3.2 镜像的容器； 如果执行 =MONGO_VERSION=2.8 docker-compose up= 则会启动一个 mongo:2.8 镜像的容器。</p>
<p>若当前目录存在 .env 文件，执行 =docker-compose= 命令时将从该文件中读取变量。</p>
<p>在当前目录新建 .env 文件并写入以下内容。</p>
<p>#+BEGIN_EXAMPLE # 支持 # 号注释 MONGO_VERSION=3.6 #+END_EXAMPLE</p>
<p>执行 =docker-compose up= 则会启动一个 mongo:3.6 镜像的容器。</p>]]></description>
    <pubDate>Tue, 14 Sep 2021 16:02:38 +0800</pubDate>
    </item>
</channel>
</rss>
