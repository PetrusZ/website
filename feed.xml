<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
<title>codeplayer</title>
<atom:link href="https://www.codeplayer.org/publish/feed.xml" rel="self" type="application/rss+xml" />
<link>https://www.codeplayer.org</link>
<description>codeplayer wiki</description>
    <item>
    <title><![CDATA[酒吧圣经笔记]]></title>
    <link>https://www.codeplayer.org/Wiki/Others/%e9%85%92%e5%90%a7%e5%9c%a3%e7%bb%8f%e7%ac%94%e8%ae%b0.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Others/%e9%85%92%e5%90%a7%e5%9c%a3%e7%bb%8f%e7%ac%94%e8%ae%b0.html</guid>
    <description><![CDATA[<p>#+TITLE: 酒吧圣经笔记 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>开胃酒 Aperitifs 我们将苦酒、味美思、金鸡纳酒和茴香酒都归为开胃酒。开胃酒有许多共性。第一，它们有相同的起源，在黑暗时代都是用作药。这使得开胃酒同利口酒很近似；第二，开胃酒在生产中具有许多共同点；最后，开胃酒的最大相似点——每种酒都各有特色各不相同。如果这些酒的口味和颜色没有区别，那酒吧会变得非常枯燥无聊。</li>
</ul>
<table>
<thead>
<tr class="header">
<th></th>
<th>苦艾酒</th>
<th>茴香酒</th>
<th>苦酒</th>
<th>味美思</th>
<th>金鸡纳酒</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>酒基</td>
<td>酒精</td>
<td>酒精</td>
<td>酒精</td>
<td>白葡萄酒</td>
<td>葡萄酒</td>
</tr>
<tr class="even">
<td>香料</td>
<td>艾草和</td>
<td>绿大茴香，</td>
<td>龙胆，陈皮，</td>
<td>艾草，</td>
<td>金鸡纳树皮，</td>
</tr>
<tr class="odd">
<td></td>
<td>其他药草</td>
<td>八角，茴香…</td>
<td>其他香料</td>
<td>金鸡纳树皮，龙胆…</td>
<td>陈皮和药草</td>
</tr>
<tr class="even">
<td>酒度</td>
<td>达 72 度</td>
<td>25-51 度</td>
<td>6-50 度</td>
<td>15-23 度</td>
<td>15-23 度</td>
</tr>
<tr class="odd">
<td>用途</td>
<td>开胃酒</td>
<td>开胃酒</td>
<td>开胃酒，消化酒</td>
<td>开胃酒，任何时候可饮</td>
<td>开胃酒</td>
</tr>
<tr class="even">
<td>最好的混合用料</td>
<td>水和糖</td>
<td>水、</td>
<td>酒、果汁等</td>
<td>苏打水，柠檬，</td>
<td>苏打水，</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>甜薄荷汁和甜柠檬汁</td>
<td></td>
<td>奎宁水，果汁，酒</td>
<td>果汁，酒</td>
</tr>
<tr class="even">
<td>著名的鸡尾酒</td>
<td>下午死去</td>
<td>鹦鹉</td>
<td>美国佬</td>
<td>干马天尼</td>
<td>杜本内鸡尾酒</td>
</tr>
<tr class="odd">
<td></td>
<td>飞翔的荷兰人</td>
<td></td>
<td>尼格罗尼</td>
<td>曼哈顿</td>
<td></td>
</tr>
</tbody>
</table>
<p>** 苦艾酒 Absinthe 苦艾酒的历史源于瑞士。18 世界奥尔基内尔医生用当前的植物——星形大茴香及 Artemisia Absinthium（一种艾草）制成药酒，他将这种药酒用于改善自己病人的脑力活动。这种淡绿色苦味的药酒疗效显著。 *** 现代苦艾酒 不久前欧洲法律放宽了对含有艾草酒的限制，规定根据酒精浓度的高低不同每升酒含 5-10 毫升侧卜酮。此后，商标上注有 Absinthe（苦艾酒）的许多款酒问世了。 ** 茴香酒 Anises *** 茴香酒的历史 茴香酒源于地中海地区。这里的人们自古以来就知道大茴香可入药。茴香酒获得巨大成功还是在欧洲禁止生产苦艾酒以后。当然茴香酒的生产商达成了如下协议： - 具有迷幻成分的侧柏酮存在于艾草皮中。因此，要用艾草的根和叶来酿酒。 - 各种大茴香和茴香可为酿酒提供必须的跟水接触能产生结晶的茴香脑。 - 一些甘草和其他的香草叶已列入茴香酒的配方中，应保持原料成分的统一。 - 这样酿制的酒同真正的茴香酒口味差别不大，略带苦味。 *** 茴香酒的生产 欧洲的法规规定：茴香酒的独特芬香应出自于绿色的大茴香，星形大茴香或者茴香这些香料。实际上生产中经常使用的就是这三种香料。星形大茴香，又叫八角，产于越南北部。它能使酒口味强烈，而绿色大茴香使酒口味绵长，略带甜味。再添加各种香草和少量甘草，可增酒酒的香气。 将以上各种植物连根放在酒精中泡软，然后浸酒蒸馏。最后在馏出物中添加水和少量的糖。 这样酿好的茴香酒的浓度在 25-51 度之间。 ** 味美思 Vermouth *** 酿造史 味美思有着悠久的历史。公元前 4 世纪在有关希波克拉底（Hippocrat）的穿梭中最早提及到味美思的“祖先”——Vinum Absinthiatum。含有药草、松脂的有色葡萄酒在古代被广为接受。后来威尼斯的商人从世界各地往意大利带回很多种调料：豆蔻、甘菊、丁香、生姜和其他香料。这些香料为完善当时用于医学目的的葡萄酒的香型注入了新的动力。“味美思”（wermut wein）这个词本身产生于巴伐利亚的宫廷，使意大利的草药医生阿列西奥创造的。 17 世纪味美思的生产开始真正发展起来，意大利皮埃蒙特大取的都灵市成为味美思的发展中心。这里可以生产干葡萄酒和甜白葡萄酒。这个地区的阿尔卑斯山山坡上可以采到富含香味的植物。 *** 味美思的生产 每个公司都按各自的秘方生产味美思，但仍可找到一些共同点。通常是以从一些区域运来的各种白葡萄酒为基酒。有时基酒混合物要陈化一段时间，通常在大橡木桶中储存一年。 主要香料有：艾草——味美思因其而得名（wermut 德语“艾草”）；金鸡纳树树皮、桂皮、龙胆、柯拉子、生姜、当归、甘菊、调料丁香、苦橘子皮、香草荚等等，有时香料数量能达到 40 种。这些植物的萃取物是通过酒精浸泡或者蒸馏获得的。再将植物萃取液、适量的糖和纯酒精加入葡萄酒中混合。 红色味美思使用胭脂红和焦糖上色的。所用成分和比例决定了每种产品和类型的味美思的口味。 酿制的味美思有时需陈化，再经过滤、巴氏消毒后分瓶包装。 *** 种类 1. 意大利 味美思产于都灵地区。口味通常略甜些。其中最普及的是： - Vermouth Extra Dry 干味美思，每升酒含糖量不超过 40 毫升。 - Vermouth Bianco 白味美思，每升含糖 100-150 毫升。 - Vermouth Rose 桃红味美思。 - Vermouth Rosso 红味美思，它的琥珀色是焦糖产生的。每升含糖 150 毫升。</p>
<p>著名生产商：马天尼（Martini &amp; Rossi）、仙山路（Cinzano），卡帕诺（Carpano，Barbero），利开多诺（Riccadonna）。 2. 法国 味美思使以固定品种的葡萄酿成的干白味基酒酿造的。酒呈金黄色，口味通常更为干醇。 著名生产商：诺利·普拉 Noilly Prat（最好的干型味美思），里丽 Lillet，以及萨瓦省（曾属意大利）的尚贝里地区的一些企业。 * 威士忌 Whisky *** 无休止的争论 爱尔兰人和苏格兰人一直就威士忌酒的发明权争论不休。但无论哪一方，都没有足够确凿的证据。 ** 苏格兰威士忌 Scotch Whisky *** 曲折的经历 早在 15 世纪，蒸馏酒在苏格兰流行起来。但在当时，蒸馏还比较原始，并且只能生产粗糙的酒。</p>
<p>在 16 世纪和 17 世纪，苏格兰人在蒸馏领域进行了大胆的技术改进。第一次改进发生在修道院被关闭之后。僧侣们掌握了比任何人都多的蒸馏技术，它们把这些几个世纪秘密积累在修道院高墙之内的经验与酿酒师们分享。技术的进步表现在蒸馏中。酿酒师们逐渐学会了利用冰水来冷却蛇形管。在 16 世纪中叶，蒸馏釜就具有了今天的葱头形状。 *** 苏格兰威士忌的种类 苏格兰威士忌在使用的原料、蒸馏和陈年的方式上各不相同。可以分成四大类：</p>
<p><em>单一麦芽威士忌（Single Malt）</em> 以发芽的大麦为原料酿造。</p>
<p><em>纯麦芽威士忌（Pure Malt）</em> 它使各种单一麦芽威士忌的混合物</p>
<p><em>调和型威士忌（Blend）</em> 它使麦芽威士忌和谷物威士忌的混合物</p>
<p><em>谷物威士忌（Grain Whisky）</em> 谷物威士忌主要用来生产调和型威士忌，偶尔也单独出售。 *** 单一麦芽威士忌 单一麦芽威士忌是一种传统的苏格兰威士忌，通常以生产这种威士忌的酒厂名命名。它是由用泥煤烘干的大麦发酵生产出来的。 **** 原料 大麦、泥煤和水是单一麦芽威士忌的原料，而蒸馏器、酒桶和储存环境决定了酒的最终口味。 **** 大麦 大麦非常适合制作易于发酵的酒醪。对大麦种子提出了许多严格的要求。其中有如下要求： - 种子必须大小相同以保证同时发芽。 - 应色泽鲜黄，没有霉变迹象，散发诱人的自然的气息。 - 含有尽可能多的淀粉。 - 种子应该具有非常好的形状，大小均匀、颗粒饱满。</p>
<p>大麦反映了它生长的土地的特点。土壤影响了大麦中的淀粉，糖、含氮化合物以及其他一些味道因素。为了追求地道的原汁原味，那些曾经喜欢进口大麦的生产者们又开始重新使用那些适应苏格兰气候和土壤的本地产大麦。 **** 泥煤 泥煤使苏格兰威士忌的一大特点。它由树叶和各种植物其中包含帚石南的腐烂残渣组成，有时会混合有海水泡沫的气味。它的颜色非常暗，在北方地区甚至完全是黑色的，在南方地区呈较为明亮的褐色。泥煤用来烘干大麦。它不易燃烧，会散发具有特殊香味的烟，这些香味会渗入到麦芽中，这也是这种威士忌的特色。因此，在上好的威士忌中我们会味到各种花和植物的香气。当然，烟的香味特点取决于泥煤的成分。 **** 水 当然，水应当是尽可能的绿色清洁。水的意义非常重要，因为水是决定威士忌的最终口味的关键，这一奥秘至今没有被完全揭开。苏格兰威士忌用的是低矿水。经过简单的过滤和加工它酒可以使用了，在威士忌的生产过程中，至少三次要用到水。 - 浸泡谷物时需要水； - 在酿造过程中，水溶解淀粉，分解出发酵所必须的芳香物质和元素； - 威士忌酒装瓶之前需要加水稀释，以降低酒度。</p>
<p>一些挑剔的酒类鉴别家，甚至从威士忌酒的产地订购水，用来稀释他们的酒品。 *** 生产 生产单一麦芽威士忌包括几个步骤：制麦芽、煮沸、蒸馏和陈年。每一个步骤都影响酒的味道。 1. 制麦芽 制麦芽的目的：在大麦种子中有一种淀粉糖化酶的物质。它将促进大麦中所含淀粉溶解并使其转换为糖。随后，糖在酵母的作用下转换为酒精。此外，制麦芽还可以使种子变得酥脆易碎，以利于把它淹没呈粉末。而借助于泥煤的烟，麦芽还可以获得特有的芬香。下面我们来详细了解一下制麦芽的抓哟步骤。 - 浸泡大麦 要仔细清洗并逐个挑选种子。将它们在水中浸泡 48 小时。要注意： - 大麦种子易于被手指碾碎； - 易被牙齿咬碎； - 用种子在粗糙的表面写字，会留下像粉笔一样的白色痕迹。</p>
<ul>
<li><p>发芽 浸泡过的种子分层摆在育芽室的架子上。为了让种子充分和氧气接触，要定时翻晒。过一段时间，种子开始萌芽。从这时开始，发芽时间持续 10 天。在这一期间，在种子会形成下一阶段必须的淀粉糖化酶。发芽的大麦被称作”绿色麦芽“。</p></li>
<li><p>制麦芽 绿麦芽在高温影响下，发芽过程会骤然停止，这一过程发生在带顶流盖的塔形育芽室中。它们使苏格兰风景画中不可分割的部分。在火上烘干种子，并要不断朝或中撒泥煤。被烟熏透的种子可以成为”酒曲“了。</p>
<p>干燥的强度、时间和烟的多少都是影响未来威士忌酒口味的重要因素。这些因素因具体酒厂的不同而有所区别。</p></li>
</ul>
<ol start="2" type="1">
<li><p>酿造 这一过程使用于生产啤酒类似的方法</p>
<ul>
<li><p>清洗和碾磨 首先，去除麦芽中无用的幼芽，并且磨成细粉。</p></li>
<li><p>与水混合 上一步获得的粉末称作 grist，将它慢慢与热水混合。水在淀粉糖化酶的作用下溶解受热变为麦芽糖的淀粉，而麦芽糖随后又转换为糖。</p>
<p>过滤后就得到了麦芽汁，称作 wort，被用于发酵，而麦芽汁的剩余物（麦芽沉淀物）用作家畜的饲料。</p></li>
<li><p>发酵 在麦芽汁中加入酵母，发酵持续 45-48 小时。为了不使发酵停止，温度要不超过 35 摄氏度——37 摄氏度。最终，得到酒醪，称作 wash，酒度为 5%。酒醪要在壶式蒸馏器中蒸馏两次。</p></li>
</ul></li>
<li><p>蒸馏 壶式蒸馏器是威士忌的一种象征。它由铜铸造而呈。在生产单一麦芽威士忌的时候，常常用到两个壶式蒸馏器。第一个蒸馏器称作 wash still，容量为 7000 至 23000 升。在第一个蒸馏器的馏出物称作 low wines，酒度为 25% - 30%。它流入第二个蒸馏器中。第二个蒸馏器称作 spirit still，容量为 6000 至 21000 升，在第二个蒸馏器中再进行依次蒸馏。第二次蒸馏的最终产物就是威士忌，酒度为 60% - 70%。</p>
<ul>
<li>蒸馏器的形状 用壶式蒸馏器生产威士忌并不便宜，由于需要大量的能量和价格昂贵的维护（在两次蒸馏之间蒸馏器必须进行刷洗，并且，蒸馏器受到高温的作用，会受到腐蚀，因此必须经常维修和更换）。斌且，蒸馏器的特征与酿酒师的技能和多变的自然条件一起，共同决定了威士忌的品质。因此，人们不断在寻找最理想的蒸馏器形状，这种形状要同时满足它在容量、液体蒸发面积、铜的厚度与蒸馏温度方面的要求。每一家酿酒厂都有自己特有的形状和容积的壶式蒸馏器。人们认为，细高的蒸馏器会生产出含糖较多的威士忌，而短粗的壶式蒸馏器生产的威士忌气味芬芳且含糖较少。 在不同的部分，被蒸馏的液体的温度取决于蒸馏器的形状。通过敲打使蒸馏器变形，可以在凹陷处产生出特殊的温度和蒸发条件。有时，蒸馏师会在更新蒸馏器的时候，丝毫不差的复制出旧的蒸馏器形状。有一些更加迷信的人，害怕以后酿造出的威士忌会变味，在按照旧蒸馏器复制新的蒸馏器时，连瑕疵和维修时留下的痕迹也一并复制。</li>
</ul></li>
<li><p>老熟 蒸馏后，向威士忌中加入清水，使其酒精浓度将为 55%左右。然后将其装入橡木桶中。不同的桶对酒的味道产生不同的影响。单一麦芽威士忌可使用曾经盛装过波本酒，雪利酒或波特酒的橡木桶中进行陈酿。这些橡木桶被酒浸透了，使威士忌具有了芬芳的气味。因此，一些著名的单一麦芽威士忌都具有酒或香草的香味，以及杏仁和干果的色泽。</p>
<p>陈酿使生产威士忌酒的重要阶段。在陈酿的过程中，酒会通过木桶上的微孔蒸发，称作”天使的一份“。这种作用能促进威士忌避免一些不理想物质的影响，使酒中的成分充分混合，并产生所期望的混合芬香。此外，酒精的挥发比水快，这样，威士忌的酒度会慢慢降低，达到通常市场上销售的 40%。如果在陈酿期间威士忌没有自然达到需要的度数，那么，需要用水来进行勾兑。按规定，威士忌的陈酿不用少于 3 年。但实际上陈酿时间要长很多。据计算，理想的单一麦芽威士忌的陈酿时间为 12 年，但是，一些生产者非常由把握的把自己的酒保存 25 年甚至于 50 年。</p>
<p>苏格兰潮湿的气候非常有利于陈年蒸馏酒，可以更好地开发酒的潜力。威士忌酒一旦装瓶，蒸发作用即告停止，酒将不再陈化。 *** 爱尔兰威士忌与苏格兰威士忌的法规 1909 年颁布的不列颠法律调节了威士忌的生产。它规定了在如下条件下，通过蒸馏混合谷物的方式获得的蒸馏酒称做威士忌 Whisky（或者为 Whiskey）。</p></li>
</ol>
<ul>
<li>谷物中的糖通过麦芽中含有的淀粉酶分解出来，不适用管理部门禁止使用的其他种类的酶。</li>
<li>在酵母的作用下进行发酵。</li>
<li>为使馏出物保持有使用的原料的芬香，蒸馏结束时酒的浓度不超过 94.8%。</li>
<li>酒在木桶中贮藏不低于 3 年。</li>
</ul>
<p>#+CAPTION: 泥煤、谷物、时间、火焰和原木——各种各样的因素影响着威士忌的口味 | 威士忌的种类威 | 谷物 | 蒸馏 | 酒桶 | 陈年 | 品质的秘密 | 基本香型 | |——————+—————————-+——————+—————-+—————-+————————–+———————-| | 爱尔兰威士忌 | - 不发芽或者是发芽的大麦， | 在壶式蒸馏器中 | 通常为盛装过 | 至少 3 年 | - 蒸馏技术 | 辛香料，香草， | | | 但是不用泥煤来熏制 | 进行三次蒸馏 | 波本酒、雪利酒 | | - 蒸馏“酒心”的严格选择 | 蜂蜜，苹果，雪 | | | - 燕麦 | | 或波特酒的旧 | | - 酒桶的正确选择 | 利酒和胡桃木香， | | | - 黑麦 | | 酒桶 | | | 扁桃… | | | | | | | | | | 苏格兰调和威士忌 | - 发芽或不发芽的大麦 | 用壶式蒸馏器通过 | 盛装过波本酒， | 至少 3 年 | - 单一麦芽威士忌的和谐 | 馥郁浓烈的芳香 | | | - 小麦 | 两次蒸馏得到的单 | 雪利酒或波特酒 | | 组合 | 取决于混合的程序； | | | - 玉米 | 一麦芽威士忌和用 | 的木桶 | | - 谷物威士忌的成功比例能 | 干果，香草，植物的 | | | - 燕麦 | 连续蒸馏器获得的 | | | 提供圆滑的口感 | 的香型、特点、烟味、 | | | | 谷物威士忌的混合 | | | | 雪利酒味 | | | | 物 | | | | | | | | | | | | | | 苏格兰单一麦芽 | - 用泥煤熏制的发芽大麦 | 在壶式蒸馏器中进 | 盛装过波本酒、 | 至少 3 年 | - 泉水 | 蜂蜜，香料，桔皮， | | 威士忌 | | 行两次蒸馏 | 雪利酒或波特酒 | 但常常是 10 年 | - 泥煤特点 | 巧克力，烟，碘， | | | | | 的旧木桶 | | - 壶式蒸馏器 | 干果… | | | | | | | - 正确的酒桶选择 | | | | | | | | - 气候条件 | | | | | | | | | | | 美国拨备威士忌 | - 不少于 51%的玉米 | 连续蒸馏 | 新的烘烤橡木桶 | 至少 2 年 | - 玉米的含量很高 | 焦糖，香草，蜂蜜， | | | - 发芽或不发芽的大麦 | | | | （60%——65%） | 烟草… | | | - 其他谷物 | | | | - 使用酸麦芽浆，使酒具有 | | | | | | | | 更加柔和的口味 | | | | | | | | | | | 加拿大威士忌 | - 玉米 | 连续蒸馏，有时在 | 新的橡木桶或者 | 至少 2 年 | - 很多数量的燕麦 | 禾本科植物特色， | | | - 黑麦 | 壶式蒸馏器中进行 | 是盛装过波本 | | - 8 年的陈酿 | 淡淡的苦味，柑橘 | | | - 发芽或不发芽的大麦 | 两次蒸馏 | 酒、雪利酒或波 | | | 果实，姜… | | | - 其他谷物 | | 特酒的旧木桶 | | | | ** 爱尔兰威士忌 *** 历史 爱尔兰的蒸馏技术历史非常悠久。在爱尔兰发现了约公元 6 世纪时期的青铜蒸馏器。第一次关于“生命之水”的书面记载（但是没有提到采用何种原料）出自于爱尔兰并且确定其写作日期为 1405 年。同赋税征收的无休止的斗争见证了爱尔兰威士忌的发展历程。16 世纪末，爱尔兰存在着许多地下酿酒厂。他们当中的布什米尔酿酒厂在 1608 年第一个成为了合法的酿酒厂。 *** 生产 传统的爱尔兰威士忌使用发芽的大麦，不经过熏制，通过三次蒸馏来生产。 **** 制芽和发酵 同苏格兰威士忌不同，大麦不需要用泥煤来熏制。为了生成发酵必须的糖，润湿种子，使其发芽，然后使发芽骤然停止，用火将种子烘干。种子磨成细粉然后用热水混合。将混合物蒸煮，然后过滤，获得麦芽汁，在酵母的作用下，麦芽汁发酵，变为浓度为 6%-8%的就酒醪。 **** 蒸馏 酒醪要经过三次蒸馏，第三次蒸馏是爱尔兰威士忌最大的独创之处。在第一次蒸馏锅蒸馏后进入第二个蒸馏锅，然后进入第三个蒸馏锅，渐渐去除了一些多余的物质并且使其酒精浓度增加，从第三个蒸馏锅出来后，酒精浓度将达到 70%左右。加入清水，使其浓度降低至 55%左右。爱尔兰威士忌使一种含糖较高，有芳香气味并且细腻圆滑的酒，不需要长时间的陈年。 **** 老熟 陈年对威士忌的口味有显著的影响。在酒桶中陈化期间，部分酒精会透过木质的细孔挥发出来，这样威士忌就会失掉一些酒精浓度。去除掉最后的一些不理想的组成部分，剩余的物质酒决定了酿制的酒的特色。木质酒桶赋予威士忌一种特殊的芳香。 在爱尔兰，人们常常使用曾经盛装过雪利酒或者是波特酒的酒桶。在一些酒窖利，盛装威士忌的酒桶一个叠一个的垂直摆放，这样可以抑制酒桶间的空气循环，从而减缓被称作”天使的一份“的挥发。 **** 调和（混合） 调酒师将几种威士忌混合在一起，从而制造出最完美的酒。用来调和的威士忌各不相同： - 陈年时间（从 3 年到 20 年甚至更久） - 生产原料（发芽或者未发芽的大麦，燕麦，小麦，黑麦） - 蒸馏方式（蒸馏锅的尺寸，酒心部分分离管的宽度）</p>
<p>所有的这些威士忌将自己的优点混合起来，赋予它最馥郁浓烈的芬香，调号的酒药放置几天，这一时期称做”婚配期“，然后装瓶。 ** 美国威士忌 *** 生产 **** 原料 生产美国威士忌所使用的主要谷物有玉米、大麦和黑麦。虽然有时也是用小麦。发酵的意义非常重大，它对于生成的威士忌的气味和口感起着重要的作用。对于水也有严格的要求，特别是水的软硬度。 **** 煮沸和发酵 玉米磨成细粉，用水搅拌后煮沸。麦芽汁冷却到 156 华氏度（69 摄氏度），然后按一定的比例加入磨成细粉的黑麦和小麦。将混合物煮沸，然后冷却到 146 华氏度（63 摄氏度），在其中加入磨成细粉的大麦芽。其中含有重要的淀粉糖化酶，这是在发酵过程中将淀粉转换为糖的重要物质。麦芽汁冷却到室温时，向其中加入酵母。发酵需要持续大约 3 甜，最后，形成的醪液称作 distiller’s beer（蒸馏啤酒）。这种”啤酒“要经过蒸馏、加水勾兑和过滤。 **** 蒸馏和老熟 酒醪在科菲蒸馏器中进行连续蒸馏。蒸馏后得到的威士忌酒度不高于 190proof（95% vol.），以保证使用的原来的特色不变。威士忌加水勾兑，使其浓度降至 125 proof（62.5% vol.）。经过在橡木桶中陈年 2～4 年，有时会更长，之后可装瓶。每一种美国威士忌都有其生产上的独有的特色。 * 伏特加 样式讲究，清澈纯正的伏特加是酒吧里最重要的酒精饮料之一。在它的诞生国——波兰和俄罗斯，它被看作民族象征。在那里。关于谁先发明了伏特加的争论至今没有停止。伏特加在这些地方拥有和总要的经济和社会地位。几个世纪以来，它还担负着充实国库的重任。 ** 伏特加的清澈历程 伏特加是清澈的酒精饮料。但这种完全彻底的清澈不是与生俱来的，它是自身独特演化的结果。其他酒精饮料的发展方向是口感复杂，寻找最佳的贮藏条件和理想酒龄。与之不同的是，伏特加追求的是清澈和精致。不管使何种风格，精细雅致使所有著名伏特加共同的特点。 ** 伏特加和鸡尾酒 鸡尾酒的出现是伏特加酒发展过程中的里程碑。色彩丰富，口味众多的鸡尾酒世界需要精美的酒。这些酒能够与其他元素组合而不改变它们的味道，不但品质要高，而且在提高酒度的同时，不能使混合出的气味失真。这里，伏特加扮演了主要角色。 ** 伏特加：工艺卡片 | 原料 | 谷物（黑麦、小麦、大麦）用于酿造上等的伏特加，而对于低级别的，则可以用土豆甚至甜菜作为原料 | | 酿造 | 在容器中进行连续的蒸馏和精馏 | | 存放 | 绝大多数情况下，伏特加都不久存。但在俄罗斯和波兰有一种叫做”starka“的陈年烈性酒，是用木桶盛装存放，效率不错 | | 质量秘诀 | 精挑细选的谷物，酒精的纯度，水的质量 | | 酒度 | 高于 40% | | 香味 | 伏特加可以有水果香味或其他一些淡淡的味道 | | 外观形态 | 可能使静态的白色，或者是串香的（柠檬的，毛嵩豆的，胡椒的等等） | | 饮用方式 | 可以用普通瓶子也可以用长颈玻璃瓶 | | 酒杯 | 高脚杯 | | 饮用温度 | -10 摄氏度到-18 摄氏度 | | 伴侣 | 各种果汁、奎宁水、甜酒、苦艾酒、苦酒 | | 鸡尾酒 | 血腥玛丽、螺丝刀、马天尼、大都会 | ** 生产工艺 伏特加酒给人的第一印象使简单，它的生产原则非常简单——追求最终产品的最大纯度。但是，又没有什么比它更复杂的了。生产伏特加需要极高的工艺，完善的设置，丰富的经验，集中的注意力。没有任何杂志可以残留在酒中，因为它无法藏身。</p>
<p>原料、酒精和水的质量区分开了酒的品质，让有的牌子名扬天下，而有的牌子却默默无闻。 *** 酒醪的制备 谷物使酿造上等伏特加必备的原料。把谷物磨成粉，加水，加压蒸煮。使谷物中含有的淀粉变成糊状，然后加入糖。得到的麦芽糊冷却后，加入酵母使之发酵。整个发酵过程持续 40 小时，得到的酒醪约为 9 度。 *** 蒸馏 在不少于两座蒸馏塔中用连续蒸馏和精馏的方法对酒醪进行提纯，制成度数最高的酒精。蒸馏塔一般 20-40 米高。让我们看一下工厂中制造酒精的方法：进行蒸馏的容器有 5 座蒸馏塔，先使用其中的两座进行蒸馏，用以除去大部分的有害物质。加入热酒醪，使其蒸汽由下往上进入第一个蒸馏塔，再顶不和向下送入的水蒸汽相遇。水蒸汽从酒醪中提取酒精。酒醪的残留物——酒槽，从下方排出，用作家畜饲料。而含有约 30%酒精的混合蒸汽上升到顶部，并沿管道向下进入第二座蒸馏塔。在它的顶部，酒精浓缩，达到 93%的酒度，并准备进行下一步的精馏。 *** 精馏 这是决定伏特加酒纯净度的非常重要的过程。粗馏酒精在连续的三个蒸馏塔中进行精馏。去除杂醇油和甲醇，最终得到的酒精达到 96%的酒度。它没有气味，没有初级原料的味道。 *** 稀释 将酒精与水混合，使其酒度降低到 40%。稀释用水的纯度和质量很重要。此时伏特加经过严格的质量检查就可以装瓶了。 *** 精滤和串香 以上讲述了生产上等的，高品质的伏特加酒的一般过程。在不同的生产厂，此过程可能不太一样。</p>
<p>有些厂家，特别是在俄罗斯，使用厚度达 8 米的木炭层过滤伏特加酒，并向其中加入香料（比如：茴芹，调料丁香，桦树芽，樱桃叶），它们带给伏特加淡淡的，不易觉察的香味。串香的另一个方法使将香料浸透。这个方法用于生产带有特殊味道的伏特加，例如柠檬味的，黑加仑味的，香草味的。 * 金酒 ** 生产 *** 配料 酒精、植物香料和水是金酒的三种基本配料。</p>
<ul>
<li><p><em>酒精</em> 酒度不低于 96%，被完全净化，没有任何邪杂味。谷物（通常为大麦、玉米）是基本原料，偶尔也用糖蜜（制糖的副产物）和土豆。</p></li>
<li><p><em>香料</em> 按照纯净度和质量的标准要求，精心选择，严格检查。金酒的主要和不可或缺的成分使杜松子，通常产自意大利和南斯拉夫。有些酿造商用布口袋装杜松子，存放在干燥阴凉的房间里一年左右，让它们熟透并浓缩香气。其他香料有：香菜、当归、鸢尾根、扁桃、桔皮、柠檬皮、甘草、肉豆蔻、小豆蔻、桂皮等等。按照规定，生产高质量的金酒必须有 6 到 10 种植物成分。基本上，酿造金酒的配方都是厂家的商业秘密。</p></li>
<li><p><em>水</em> 无论是蒸馏用水还是装瓶前稀释用水都应保证足够纯净、透明、没有任何异味。通常在使用前应对水进行脱矿处理，以去除水中含有的各种化合物。 ** 生产方法 今天，在很多国家生产金酒的方法大致有两种。第一种传统的生产方法是蒸馏法，用它生产的金酒品质纯正，也称作 Distilled Gin 或 London Gin。第二种方法使混合法，用于生产价格低廉的金酒。</p></li>
<li><p>第一种生产方法（蒸馏法） 酒精用水稀释到酒度为 45%，加入香料。把得到的混合物加入到蒸馏器（通常为铜制）中。在某些场合，把香料放入特质的槽子或者口袋里，并且把它摆在酒精上面。</p>
<p>然后进行蒸馏，目的是让酒精充满了香料的味道。掐头去尾，保留了中间饱和了香料味道的馏出物，其酒度达到了 80%。加入水，降低酒精含量。这时得到的金酒就可以饮用了，其酒度介于 37.5%到 47.3%之间。</p></li>
<li><p>第二种生产方法（混合法） 这种方法由于”金酒精“的出现而便得十分简单。它可以通过在小尺寸的蒸馏器中蒸馏混有少量酒精的植物配料或者香料渣得到。然后，将得到的精华与少量的普通酒精混合并加水稀释。 ** 金酒：工艺卡片 | 原料 | 一般是谷物，有时也用糖蜜和土豆。可以使用杜松子、香菜、当归、鸢尾根、扁桃等做串香剂 | | 酿制方法 | 第一种方法：酒精和香料一起蒸馏。第二种方法：将酒精和香料精混合 | | 陈年 | 比较少用 | | 品质关键 | 经过充分精华的酒精，清洁的水，优质的香料，成熟的配方，蒸馏法酿造 | | 酒精度 | 37.5%到 47.3%之间 | | 基本香型 | 金酒拥有酿造过程中使用的香料的味道：杜松子、香菜、柠檬、橙子等等 | | 类型 | 按照生产方法的不同可以分为：蒸馏金酒，又称 Distilled 或 London Gin；而通过混合法生产 | | | 的金酒就不能这么叫。还有几种串香型的金酒，Lemon Gin，Sloe Gin 等等 | | 饮用方式 | 主要是用作鸡尾酒的基酒 | |”伴侣“ | 奎宁水、柠檬、干苦艾酒、苦酒、果汁、蜜酒 | | 鸡尾酒 | Dry Martini（干马天尼），Gin Fizz（金非士），White Lady（白色佳人），Negroni（尼格罗尼）等等很多 |</p></li>
<li><p>TODO 朗姆酒</p></li>
</ul>]]></description>
    <pubDate>Wed, 14 Apr 2021 17:52:17 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[Dbus Send与dbus Monitor命令的使用]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/Linux/dbus-send%e4%b8%8edbus-monitor%e5%91%bd%e4%bb%a4%e7%9a%84%e4%bd%bf%e7%94%a8.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/Linux/dbus-send%e4%b8%8edbus-monitor%e5%91%bd%e4%bb%a4%e7%9a%84%e4%bd%bf%e7%94%a8.html</guid>
    <description><![CDATA[<p>#+TITLE: Dbus Send与dbus Monitor命令的使用 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>dbus-send ** 获取属性值 ~dbus-send –print-reply –type=method_call –session –dest=com.deepin.daemon.Display /com/deepin/daemon/Display org.freedesktop.DBus.Properties.Get string:com.deepin.daemon.Display string:Primary~ ** 调用方法</li>
</ul>
<ol type="1">
<li>不带参数 ~dbus-send –session –print-reply –type=method_call –dest=com.deepin.daemon.Display /com/deepin/daemon/Display com.deepin.daemon.Display.CanRotate~</li>
<li>带参数 ~dbus-send –session –print-reply –type=method_call –dest=com.deepin.daemon.Display /com/deepin/daemon/Display com.deepin.daemon.Display.SetBrightness string:Virtual-1 double:1.0~ ** 参考</li>
<li>https://wikidev.uniontech.com/index.php?title=Dbus-send</li>
<li>https://note.youdao.com/ynoteshare1/index.html?id=94b62364769faff9eb92cc82cf5aced4&amp;type=note</li>
</ol>
<ul>
<li>dbus-monitor ~dbus-monitor [–system | –session | –address ADDRESS] [–profile | –monitor | –pcap | –binary] [watch expressions]~ ** 使用手册 dbus-monitor 具有两种不同的文本输出模式：“经典”风格的监视模式和配置文件模式</li>
</ul>
<p>配置文件模式：一种紧凑格式，每条消息只有一行，并且具有微秒分辨率的定时信息</p>
<p>dbus-monitor 也有两种特殊的二进制输出模式：–binary 和–pcap #+begin_src –binary：二进制模式将输出整个二进制消息流 –pcap：将PCAP文件头添加到输出的开头，并为每个消息添加PCAP消息头 #+end_src</p>
<p>如果未指定任何模式，则 dbus-monitor 将使用监视输出格式。 #+begin_src –system 和 –session表示系统总线和会话总线，默认为–session –address ADDRESS：监视在ADDRESS处给定的任意消息总线 –profile：使用配置文件模式打印 –monitor：使用dbus-monitor模式打印 #+end_src</p>
<p>输出概要： #+begin_src type：分为signal和method_call sender：消息或方法调用者 dest：消息接收或方法拥有者 interface：接口名 path：服务路径 member：方法名或属性名 replay：方法调用的返回值 #+end_src</p>
<p>监视某些系统级接口时，需要加上 sudo 权限，如监视 lastore 更新模块 ~sudo dbus-monitor –system “interface=com.deepin.lastore.Manager”~ ** 监视信号 ~dbus-monitor type=‘signal’,sender=‘org.gnome.TypingMonitor’,interface=‘org.gnome.TypingMonitor’~ ** 监视方法 ~dbus-monitor –session “interface=com.deepin.daemon.Display”~ ** TODO 监视属性 ** 参考 1. https://wikidev.uniontech.com/index.php?title=Dbus-monitor</p>]]></description>
    <pubDate>Wed, 14 Apr 2021 17:52:17 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[go中使用dbus和gsettings]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/go/%e5%9c%a8go%e4%b8%ad%e4%bd%bf%e7%94%a8dbus%e5%92%8cgsettings.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/go/%e5%9c%a8go%e4%b8%ad%e4%bd%bf%e7%94%a8dbus%e5%92%8cgsettings.html</guid>
    <description><![CDATA[<p>#+TITLE: go中使用dbus和gsettings #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>dbus in go ** 使用 dbus 包 *** 连接 dbus</li>
</ul>
<p>#+BEGIN_SRC go dbus.SessionBus() dbus.SystemBus() #+END_SRC *** 调用方法</p>
<p>比如调用 dbus-daemon 提供的对象的一个方法，服务名： =org.freedesktop.DBus=, 路径： =/org/freedesktop/DBus= ，接口名： =org.freedesktop.DBus= ， 方法名： =GetNameOwner= , 此方法输入参数是一个字符串，返回参数也是一个字符串。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) var ret string err = obj.Call(“org.freedesktop.DBus.GetNameOwner”, 0, “com.deepin.dde.daemon.Dock”).Store(&amp;ret) #+END_SRC</p>
<p>需要注意传给 =obj.Call= 方法的第一个参数 =method= 的值是接口名 + “.” + 方法名。</p>
<p>在处理没有返回值的方法时，可以不调用 =Store= 方法，而直接检查 =Err= 字段。 *** 获取和设置属性</p>
<p>属性的获取和设置本质也是方法调用。 **** 获取属性 获取单个属性是调用对象的 =org.freedesktop.DBus.Properties= 接口的 =Get= 方法，此方法传入参数是接口名和属性名，返回值是属性值，类型为 =dbus.Variant= 。</p>
<p>下面的代码是要获取 =org.freedesktop.DBus= 接口的 =Features= 属性，此属性的类型是 =[]string= 。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) var ret dbus.Variant err = obj.Call(“org.freedesktop.DBus.Properties.Get”, 0, “org.freedesktop.DBus”, “Features”).Store(&amp;ret) v := ret.Value().([]string) #+END_SRC</p>
<p>从 =ret= 中获取内部的值，需要调用 =Value= 方法，获取 =interface{}= 类型的内部值，再使用类型断言 =.([]string)= 。</p>
<p>一次获取对象在某个接口下的全部属性，可调用 =Get= 方法旁边的 =GetAll= 方法。 **** 设置属性 设置属性是调用对象的 =org.freedesktop.DBus.Properties= 接口的 =Set= 方法，此方法的传入参数是接口名、属性名、属性值，没有返回值。</p>
<p>下面的代码是要设置 =org.freedesktop.DBus= 接口的 =Features= 属性。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) propVal := dbus.MakeVariant([]string{“abc”}) err = obj.Call(“org.freedesktop.DBus.Properties.Set”, 0, “org.freedesktop.DBus”, “Features”, propVal).Err #+END_SRC</p>
<p>传入参数中属性值是 =dbus.Variant= 类型，制造这种类型可用 =dbus.MakeVariant= 方法。 *** 监控信号 调用 =AddMatch= 方法添加监控规则，如果不需要监控了，就调用 =RemoveMatch= 方法去掉监控规则。</p>
<p>go 的 dbus 库提供了方便的方法： =AddMatchSignal= 和 =RemoveMatchSignal= 。</p>
<p>下面的代码是要监控 =Session Bus= 上的 =/org/freedesktop/Bus= 对象的 =org.freedesktop.DBus= 接口的 =NameOwnerChanged= 信号。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() err = sessionBus.BusObject().AddMatchSignal(“org.freedesktop.DBus”, “NameOwnerChanged”, dbus.WithMatchObjectPath(“/org/freedesktop/DBus”)).Err</p>
<p>signalCh := make(chan *dbus.Signal, 10) sessionBus.Signal(signalCh) go func() { for { select { case sig := &lt;-signalCh: log.Printf(“sig: %#v”, sig) if sig.Path == “/org/freedesktop/DBus” &amp;&amp; sig.Name == “org.freedesktop.DBus.NameOwnerChanged” { var name string var oldOwner string var newOwner string err = dbus.Store(sig.Body, &amp;name, &amp;oldOwner, &amp;newOwner) log.Printf(“%s %s %s”, name, oldOwner, newOwner) } } } }()</p>
<p>time.Sleep(100*time.Second) err = sessionBus.BusObject().RemoveMatchSignal(“org.freedesktop.DBus”, “NameOwnerChanged”, dbus.WithMatchObjectPath(“/org/freedesktop/Bus”)).Err sessionBus.RemoveSignal(signalCh) #+END_SRC</p>
<p>将调用 =sessionBus.Signal= 方法注册 =signalCh= 通道，以此来通过该通道接收信号， =go func ()= 中的代码是循环接收 =signalCh= 通道传来的数据并处理。如果不需要再从这个通道接收信号了，可以调用 =sessionBus.RemoveSignal= 取消注册 =signalCh= 通道，这样信号就不会再被发送到 =signalCh= 通道中了。</p>
<p>在处理信号时，可以先验证信号（ =<em>dbus.Signal= 类型）的 =Path= 和 =Name= 字段，不必验证 =Sender= 字段。 处理信号的 =Body= 字段，它是 =[]interface{}= 类型，就可以用 =dbus.Store= 方法了。 </em>** 导出对象 将自己代码中的一个变量作为对象的一个接口导出在 DBus 上，然后供其他人调用。</p>
<p>下面的代码是要把类型为 =Obj= 结构的 =obj= 变量作为对象的一个接口导出，它有一个 =GetString= 方法，路径 =/p1/p2/p3= ，接口名 =p1.p2.p3= 。</p>
<p>#+BEGIN_SRC go type Obj struct { }</p>
<p>func (o <em>Obj) GetString() (string, </em>dbus.Error) { return “object”, nil }</p>
<p>func main() { sessionBus, err := dbus.SessionBus() obj := &amp;Obj{} err = sessionBus.Export(obj, “/p1/p2/p3”, “p1.p2.p3”) log.Print(“names:”, sessionBus.Names()) select { } } #+END_SRC</p>
<p>程序运行后会打印类似的输出：</p>
<p>=names:[:1.4239 :1.4239]=</p>
<p>这是此程序目前在 DBus 上的名字，冒号 =:= 开头的是唯一名。</p>
<p>导出对象接口，可以调用 =sessionBus.Export= 方法，要停止导出，并没有一个专门的的方法，依旧要使用 =Export= 方法， 但是第一个参数（之前放 =obj= 的位置）要换成 =nil= 。</p>
<p>自动导出的方法有如下要求：</p>
<ol type="1">
<li>公开的，方法名第一字母是大写的。</li>
<li>最后一个返回值是 <em>dbus.Error 类型。 </em>*** 注册服务名 下面的代码是要申请一个服务名 =p1.p2.p3=, 不是完整代码，可以插在前一份代码的 =sessionBus.Export= 方法调用之后。现有的各个项目里也一般是先导出主要对象，然后再申请服务名。</li>
</ol>
<p>~_, err = sessionBus.RequestName(“p1.p2.p3”, 0)~</p>
<p>*** 发送信号 下面的代码是要发送信号，路径 =/p1/p2/p3=, 接口名 =p1.p2.p3=, 信号名 =Signal1= ， 参数是字符串和数字。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() for { err = sessionBus.Emit(“/p1/p2/p3”, “p1.p2.p3.Signal1”, “arg1”, 2) time.Sleep(2*time.Second) } #+END_SRC</p>
<p>程序每 2 秒发送一次信号，发送信号时，不要求对象是否已经导出。 ** 使用 go-dbus-factory 项目 此项目实现了根据 dbus 服务的自省 XML 文件和一点配置文件，自动生成访问 dbus 服务的 go 代码。</p>
<p>项目地址：https://gitlab.deepin.io/dde-v20/go-dbus-factory ，可以打成 deb 包，软件包名 =golang-github-linuxdeepin-go-dbus-factory-dev= ，每个服务放在不同的包中，包名的前缀是 =github.com/linuxdeepin/go-dbus-factory/= 。 *** 方法调用 下面的代码要调用 =com.deepin.dde.daemon.Dock= 服务的 =/com/deepin/dde/daemon/Dock= 对象的 =RequestDock= 方法。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() dockObj := dock.NewDock(sessionBus) ok, err := dockObj.RequestDock(0, “/usr/share/applications/deepin-editor.desktop”, -1) log.Println(“ok:”, ok) #+END_SRC</p>
<p>需要注意传给 =obj.Call= 方法的第一个参数 =method= 的值是接口名 + “.” + 方法名。</p>
<p>在处理没有返回值的方法时，可以不调用 =Store= 方法，而直接检查 =Err= 字段。 *** 获取和设置属性</p>
<p>属性的获取和设置本质也是方法调用。 **** 获取属性 获取单个属性是调用对象的 =org.freedesktop.DBus.Properties= 接口的 =Get= 方法，此方法传入参数是接口名和属性名，返回值是属性值，类型为 =dbus.Variant= 。</p>
<p>下面的代码是要获取 =org.freedesktop.DBus= 接口的 =Features= 属性，此属性的类型是 =[]string= 。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) var ret dbus.Variant err = obj.Call(“org.freedesktop.DBus.Properties.Get”, 0, “org.freedesktop.DBus”, “Features”).Store(&amp;ret) v := ret.Value().([]string) log.Println(v) #+END_SRC</p>
<p>从 =ret= 中获取内部的值，需要调用 =Value= 方法，获取 =interface{}= 类型的内部值，再使用类型断言 =.([]string)= 。</p>
<p>一次获取对象在某个接口下的全部属性，可调用 =Get= 方法旁边的 =GetAll= 方法。 **** 设置属性 设置属性是调用对象的 =org.freedesktop.DBus.Properties= 接口的 =Set= 方法，此方法的传入参数是接口名、属性名、属性值，没有返回值。</p>
<p>下面的代码是要设置 =org.freedesktop.DBus= 接口的 =Features= 属性。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() obj := sessionBus.Object(“org.freedesktop.DBus”, “/org/freedesktop/DBus”) propVal := dbus.MakeVariant([]string{“abc”}) err = obj.Call(“org.freedesktop.DBus.Properties.Set”, 0, “org.freedesktop.DBus”, “Features”, propVal).Err #+END_SRC **** 监控信号 下面的代码是要监控之前说过的 =Dock= 对象的 =EntryAdded= 信号。</p>
<p>#+BEGIN_SRC go sessionBus, err := dbus.SessionBus() dockObj := dock.NewDock(sessionBus) sigLoop := dbusutil.NewSignalLoop(sessionBus, 10) sigLoop.Start() dockObj.InitSignalExt(sigLoop, true) sigHid, err := dockObj.ConnectEntryAdded(func(entryPath dbus.ObjectPath, index int32) { log.Println(entryPath, index) })</p>
<p>time.Sleep(100*time.Second) sigLoop.Stop() dockObj.RemoveHandler(sigHid) #+END_SRC</p>
<p>程序运行后，从启动器打开一个任务栏上之前没有的应用，然后程序就能收到 =EntryAdded= 信号并打印参数值出来。</p>
<p>这部分代码用到了新的包 =pkg.deepin.io/lib/dbusutil= 包，使用它的 =SignalLoop= 功能来处理信号。调用 =dbusutil.NewSignalLoop= 创建一个信号循环，然后调用 =Start= 方法开始，当不需要时调用 =Stop= 结束。 =dockObj= 默认是不支持监听信号的，直接调用 =dockObj.ConnectXXX= 方法会崩溃，必须先调用 =InitSignalExt= 方法，传入 SignalLoop。 ** 使用 dbusutil 包 之前介绍了使用 dbus1 包，现在介绍使用更多的 dbusutil 包，它是对 dbus1 包的功能的一次包装，更加偏向于导出服务。</p>
<p>*** 导出对象 #+BEGIN_SRC go type Obj struct { methods *struct { GetString func() <code>out:"result"</code> } }</p>
<p>func (o <em>Obj) GetString() (string, </em>dbus.Error) { return “object”, nil }</p>
<p>func (o *Obj) GetInterfaceName() string { return “p1.p2.p3” }</p>
<p>func main() { service, err := dbusutil.NewSessionService() obj := &amp;Obj{ } err = service.Export(“/p1/p2/p3”, obj) err = service.RequestName(“p1.p2.p3”) service.Wait() } #+END_SRC</p>
<p>在 =main= 方法中，使用 =dbusutil.NewSessionService= 创建 =<em>dbusutil.Service= 类型的变量 =service= ，然后调用 =service.Export= 方法导出 =obj= 变量。要导出 =obj= 变量，就得让它的类型 =</em>Obj= 实现 =GetInterfaceName= 方法，此方法要返回接口名。 *** 定义属性 定义一个属性的简单方式是，给导出的结构增加公开字段，比如想要导出 =Obj= 结构，导出的接口 =p1.p2.p3= 中会有一个 =Name= 属性，类型为字符串，就要有如下定义：</p>
<p>#+BEGIN_SRC go type Obj struct { Name string } #+END_SRC</p>
<p>这个 =Name= 属性是只读的，如果要让它可以写、设置，就要给 =Name= 字段加上结构字段 =tag= : =prop:“access:rw”= ， 如下：</p>
<p>#+BEGIN_SRC go type Obj struct { Name string <code>prop:"access:rw"</code> } #+END_SRC *** 发送信号 下面的代码是要发送信号，路径 =/p1/p2/p3=, 接口名 =p1.p2.p3=, 信号名 =Signal1= ， 参数是字符串和数字。</p>
<p>#+BEGIN_SRC go</p>
<p>type Obj struct { signals *struct { Added struct { arg0 string arg1 int32 } } }</p>
<p>func (o *Obj) GetInterfaceName() string { return “p1.p2.p3” }</p>
<p>func main() { service, err := dbusutil.NewSessionService() obj := &amp;Obj{ } err = service.Export(“/p1/p2/p3”, obj) err = service.RequestName(“p1.p2.p3”) for { err = service.Emit(obj, “Added”, “val0”, 11) time.Sleep(2*time.Second) } } #+END_SRC</p>
<p>要点是在定义 Obj 结构时，加上 =signals= 字段，并在 =signals= 字段类型定义结构中加上 =Added= 字段 ，然后调用 =service.Emit= 方法发送信号。 *** 发送属性改变信号 下面的代码是要发送属性改变信号，路径 =/p1/p2/p3=, 接口名 =p1.p2.p3=, 属性名 =Name= ，类型字符串。</p>
<p>#+BEGIN_SRC go type Obj struct { Name string }</p>
<p>func (o *Obj) GetInterfaceName() string { return “p1.p2.p3” }</p>
<p>func main() { service, err := dbusutil.NewSessionService() obj := &amp;Obj{ } err = service.Export(“/p1/p2/p3”, obj) err = service.RequestName(“p1.p2.p3”) for { err = service.EmitPropertyChanged(obj, “Name”, “name1”) time.Sleep(2*time.Second) } } #+END_SRC</p>
<p>要点是先在 Obj 结构中定义一个属性 =Name= ，然后调用 =service.EmitPropertyChanged= 方法发送属性改变信号。</p>
<ul>
<li>gsettings in go gsettings 是 gio 提供的功能，go 语言要用就得用 cgo 包装一下，这部分代码是由 =go-gir-generator= 工具自动生成的，软件包 =golang-gir-gio-2.0-dev= 提供了源码文件，安装之后放在 =/usr/share/gocode/src/pkg.deepin.io/gir/gio-2.0= 文件夹下。</li>
</ul>
<p>项目地址： https://gitlab.deepin.io/github-linuxdeepin-mirror/go-gir-generator</p>
<p>** 简单使用 下面的代码是要获取和设置 gsettings =ca.desrt.dconf-editor.Demo= 的几个设置项。</p>
<p>#+BEGIN_SRC go gs := gio.NewSettings(“ca.desrt.dconf-editor.Demo”) str := gs.GetString(“string”)</p>
<p>gs.SetString(“string”, str)</p>
<p>int0 := gs.GetInt(“integer-32-signed”)</p>
<p>gs.SetInt(“integer-32-signed”, int0) gs.Unref() #+END_SRC</p>
<p>=NewSettings= 方法，创建 Settings 对象。 =GetString= 方法获取字符串类型的设置项的值，=SetString= 方法设置字符串类型的设置项的值。 =GetInt= 方法获取整数 int32 类型的设置项的值，=SetInt= 方法设置整数 int32 类型的设置项的值。 =Unref= 方法，在不再需要 gs 对象时，减少引用计数的值。 ** 监听改变信号（原生） 下面的代码是要监听 gsettings =ca.desrt.dconf-editor.Demo= 的 =boolean= 设置项的值改变事件。</p>
<p>#+BEGIN_SRC go gs := gio.NewSettings(“ca.desrt.dconf-editor.Demo”) gs.Connect(“changed::boolean”, func(gs *gio.Settings, key string) { boolean := gs.GetBoolean(key) log.Println(boolean) }) glib.StartLoop() #+END_SRC</p>
<p>调用 =Connect= 方法注册事件监听处理函数，第一个参数为事件名，第二个参数为事件处理函数。</p>
<p>=glib.StartLoop()= 开始一个 Main Loop 事件循环。 ** 监听改变信号（dbus 实现） 由于原生的信号监听方式之前在一种特殊架构上偶尔出现发生了改变事件但不触发处理函数的问题，于是写了另外一种信号监听方式，来规避这种问题。</p>
<p>下面的代码使用了另外一个包 =pkg.deepin.io/lib/gsettings= 也实现了监听 =boolean= 设置项的值改变事件。</p>
<p>#+BEGIN_SRC go gs := gio.NewSettings(“ca.desrt.dconf-editor.Demo”) gsettings.ConnectChanged(“ca.desrt.dconf-editor.Demo”, “boolean”, func(key string) { boolean := gs.GetBoolean(key) log.Println(boolean) }) err := gsettings.StartMonitor() select { } #+END_SRC</p>
<p>=ConnectChanged= 方法注册改变事件的处理函数，第一个参数是 =schema id= ， 第二个参数是设置项名，第三个参数是事件处理函数。</p>
<p>=StartMonitor= 方法开始监听循环。 ** dbus 服务中作为属性 下面的代码是要导出 DBus 服务，服务名 =p1.p2.p3=, 对象路径 =/p1/p2/p3=, 接口名 =p1.p2.p3= ，把 gsettings =ca.desrt.dconf-editor.Demo= 的 =boolean= 设置项当作接口的属性。</p>
<p>#+BEGIN_SRC go type Obj struct { Boolean gsprop.Bool <code>prop:"access:rw"</code> }</p>
<p>func (o *Obj) GetInterfaceName() string { return “p1.p2.p3” }</p>
<p>func main() { gs := gio.NewSettings(“ca.desrt.dconf-editor.Demo”)</p>
<pre><code>service, err := dbusutil.NewSessionService()

obj := &amp;Obj{}
obj.Boolean.Bind(gs, &quot;boolean&quot;)
log.Println(&quot;get result:&quot;, obj.Boolean.Get())

err = service.Export(&quot;/p1/p2/p3&quot;, obj)
err = service.RequestName(&quot;p1.p2.p3&quot;)
err = gsettings.StartMonitor()
service.Wait()</code></pre>
<p>} #+END_SRC</p>
<p>这算是 gsettings 与 dbusutil 包知识相结合的内容。</p>
<p>要点是 Obj 结构定义了一个公开字段 =Name= ，类型为 =gsprop.Bool= ，然后调用 =Bind= 方法绑定了 =gs= 的 =boolean= 设置项和 =obj= 的 =Name= 属性的关联，使得对 =Name= 属性的读写即是对 =gs= 的 =boolean= 设置项的读写， 如果 =gs= 的 =boolean= 设置项的值改变会自动发出 =Name= 属性改变信号。</p>
<p>gsprop 包中还有其他的类型，来支持各种数据类型，比如 =String=，=Int=，=Uint= 等。</p>
<p>同样要记得调用 =StartMonitor= 方法开始监听循环。</p>]]></description>
    <pubDate>Wed, 14 Apr 2021 17:52:17 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[搭建VNC服务器]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/Linux/%e6%90%ad%e5%bb%baVNC%e6%9c%8d%e5%8a%a1%e5%99%a8.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/Linux/%e6%90%ad%e5%bb%baVNC%e6%9c%8d%e5%8a%a1%e5%99%a8.html</guid>
    <description><![CDATA[<p>#+TITLE: 搭建VNC服务器 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>搭建 VNC 服务器 服务器上安装 x11vnc，构建 vnc 的服务端：</li>
</ul>
<p>~sudo apt-get install x11vnc~</p>
<p>设置并存储 vnc 连接密码</p>
<p>~sudo x11vnc -storepasswd <password> /etc/x11vnc.pass~</p>
<p>启动 x11vnc 服务端</p>
<p>~sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -rfbauth /etc/x11vnc.pass -shared -noxdamage -xrandr “resize” -rfbport 5900~</p>
<p>无密码启动 vnc</p>
<p>~sudo x11vnc -display :0 -auth /var/run/lightdm/root/:0 -forever -bg -o /var/log/x11vnc.log -noxdamage -xrandr “resize” -rfbport 5900~</p>]]></description>
    <pubDate>Wed, 14 Apr 2021 17:52:17 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[性能分析]]></title>
    <link>https://www.codeplayer.org/Wiki/Program/C++/%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Program/C++/%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90.html</guid>
    <description><![CDATA[<p>#+TITLE: 性能分析 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>google-perftools ** 介绍 性能分析通过抽样方法完成，默认是 1 秒 100 个样本，一个样本是 10 毫秒，即时间单位是 10 毫秒；可以通过环境变量 CPUPROFILE_FREQUENCY 设置采样频率。</li>
</ul>
<p>CPU profiler 是基于采样工作的。所以采样次数影响着性能报告的准确性。如果采样次数过少，则你会发现同样的程序同样的数据，每次输出的性能报告中的热点都不一样。 ** 使用方法 *** 直接调用 API 在代码中调用 <sub>ProfilerStart</sub> 和 <sub>ProfilerStop</sub> 这两个函数。 *** 链接静态库 在代码 link 过程中添加参数 –lprofiler</p>
<p>~gcc […] -o helloworld –lprofiler~</p>
<p>运行程序： ~CPUPROFILE=./helloworld.prof ./helloworld~</p>
<p>指定要 profile 的程序为 helloworld，并且指定产生的分析结果文件的路径为./helloworld.prof *** 链接动态库 这种方式和静态库的方式差不多，但不用重新编译或重新链接，所以使用非常方便。只需要在运行时添加 LD_PRELOAD 变量。</p>
<p>~LD_PRELOAD=“/usr/lib/libprofiler.so” CPUPROFILE=./helloworld.prof ./helloworld~ *** 使用信号触发 profile **** 手动设置信号 由于我们的程序有可能是服务程序，而服务程序不会自动执行完退出，如果以 =ctrl+c= 退出也不是正常的 =exit(0)= 的方式退出，而这会导致我们在 profile 的时候，收集到的数据不全甚至是空的，采用如下解决办法：</p>
<p>将 <sub>ProfilerStart</sub> 和 <sub>ProfilerStop</sub> 这 2 个函数封装到两个信号处理函数中，给服务程序发信号 SIGUSR1，就开始 profile，给服务程序发信号 SIGUSR2，就停止 profile。这样我们可以随时对程序进行 profiling，并获得数据。代码如下：</p>
<p>#+BEGIN_SRC C #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; #include &lt;signal.h&gt; #include &lt;google/profiler.h&gt;</p>
<p>//SIGUSR1: start profiling //SIGUSR2: stop profiling</p>
<p>static void gprof_callback(int signum) { if (signum == SIGUSR1) { printf(“Catch the signal ProfilerStart”); ProfilerStart(“bs.prof”); } else if (signum == SIGUSR2) { printf(“Catch the signal ProfilerStop”); ProfilerStop(); } }</p>
<p>static void setup_signal() { struct sigaction profstat; profstat.sa_handler = gprof_callback; profstat.sa_flags = 0; sigemptyset(&amp;profstat.sa_mask); sigaddset(&amp;profstat.sa_mask, SIGUSR1); sigaddset(&amp;profstat.sa_mask, SIGUSR2);</p>
<p>if ( sigaction(SIGUSR1, &amp;profstat,NULL) &lt; 0 ) { fprintf(stderr, “Fail to connect signal SIGUSR1 with start profiling”); } if ( sigaction(SIGUSR2, &amp;profstat,NULL) &lt; 0 ) { fprintf(stderr, “Fail to connect signal SIGUSR2 with stop profiling”); } }</p>
<p>int main(int argc,char** argv) { // // … //</p>
<p>setup_signal();</p>
<p>// // … //</p>
<p>return 0; } #+END_SRC</p>
<p>启动程序后，可以采用 kill -s SIGUSR1 <pid> 和 kill -s SIGUSR2 <pid> 来开始采样和停止采样。 **** 使用 CPUPROFILESIGNAL 设置信号 设置的信号必须是正常情况下未被程序使用的。</p>
<p>~CPUPROFILE=./helloworld.prof CPUPROFILESIGNAL=12 ./helloworld~</p>
<p>可以使用 ~killall -12 hellworld~ 触发 profile 开始，然后过一段时间后再次使用 ~killall -12 hellworld~ 触发 profile 结束并生成文件。 ** 数据分析 *** 生成数据 1. 生成文字数据 ~google-pprof <bin path> <profile path> –text~ 2. 生成网页数据 ~google-pprof <bin path> <profile path> –web~ *** 数据含义 每一列的数据解释：</p>
<ol type="1">
<li>该函数中的采样数量</li>
<li>该函数中的采样百分比</li>
<li>到目前为止打印的函数中的采样百分比</li>
<li>该函数和被其调用的函数中的采样数量</li>
<li>该函数和被其调用的函数中的采样百分比</li>
</ol>
<ul>
<li>gprof ** 介绍 grof 可以获取 C 程序运行期间的统计数据，如每个函数的耗时，调用次数及各个函数的调用关系，（gprof 统计的是 CPU 占用时间，I/O 时间不计算在内。通常 gprof 的采样周期是 0.01s，统计项越接近这个值误差可能越大。若函数的运行时间低于 0.01S，统计值会显示为 0。</li>
</ul>
<p>类似于 gdb，gprof 需要对待分析的程序做一些改动，因此在程序编译的时候需要加上“-pg”选项，如果程序的某个模块在编译的时候没有加上“-pg”，则该模块的函数会被排除在统计范围之外。比如想要查看库函数的 profiling，则需在链接库函数的时候用“-lc_p”代替”-lc“（gprof 是各个类 UNIX 的标准工具，系统自带的链接库通常有两个版本，它们的区别在于编译的时候是否加上了”-pg“。用-lc_p 等于告诉编译器选择加上了”-pg“的那个版本）。 加上”-pg"选项后，程序的入口会于 main()之前调用 monstartup()，主要是申请内存存储接下来获取的统计信息。</p>
<p>在每个函数中会调用_mcount()，主要是在函数的堆栈中查询父函数和子函数的地址并保存下来。最后会在程序退出前调用_mcleanup()，将统计结果保存到 gmon.out 中，并完成清除工作。</p>
<p>gprof 统计各个函数的运行时间是采用的抽样的方法，周期性的查看 Programcounter 指向哪一个函数的地址段，并把结果以直方图的形式保存下来。 ** 使用方法 1. 编译时添加选项 =-pg= 2. 运行程序，生成 gmonf.out 文件 3. 使用 gprof 进行分析， ~gprof <bin path> <gmonf path>~ ** 数据分析 *** Flat Profile 示例图 | 标注 | 释义 | |——————–+———————————————————–| | %time | 每个函数占用的时间比例，所有函数占比和为 100% | | cumulative seconds | 函数及其调用函数执行累计占用时间 | | self seconds | 单独函数执行累计占用时间 | | calls | 函数调用次数 | | self ms/call | 每次调用函数花费的时间,单位毫秒, 不包含调用函数运行的时间 | | total ms/call | 每次调用函数花费的时间,单位毫秒,包括调用函数运行的时间 | | name | 函数名称 | *** Call Graph 示例图 | 标注 | 释义 | |———-+————————————————————————–| | index | 每个函数第一次出现时分配一个编号，根据编号可以方便查找函数的具体分析数据 | | %time | 函数以及调用子函数所占用的总运行时间的百分比 | | self | 函数的总运行时间 | | children | 子函数执行的总时间 | | called | 函数被调用的次数，不包括递归调用 | | name | 函数名称, name 列中，可查看函数之间的调用关系 |</p>]]></description>
    <pubDate>Wed, 14 Apr 2021 17:52:17 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[self-host mail]]></title>
    <link>https://www.codeplayer.org/Wiki/Computer-Science/self-host%20mail.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/Computer-Science/self-host%20mail.html</guid>
    <description><![CDATA[<p>#+TITLE: self-host mail #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li><p>DNS record ** SPF 全名 Sender Policy Framework，用来鉴别发送邮件的服务器或者 IP，是否为该域允许的范围。 这需要在发送邮件的域名下添加一条 TXT 记录，举个例子： =example.net. TXT “v=spf1 mx a:pluto.example.net include:aspmx.googlemail.com -all” v=spf1= 做开头为必须，spf1 说明这是第一版 spf 协议 SPF 规定有 6 种机制：</p></li>
<li><p>ALL 匹配所有的结果，一般放在最后</p></li>
<li><p>A 匹配所有该域的 A 记录</p></li>
<li><p>MX 匹配所有该域的 MX 记录</p></li>
<li><p>IP4 所有之后的 IPv4 地址，可以用 mask 匹配多项，比如：192.168.0.0/24</p></li>
<li><p>IP6 所有之后的 IPv6 地址，同 IPv4</p></li>
<li><p>INCLUDE 去之后对应地址查找，比如 INCLUDE:spf.34nm.com，就是去 spf.34nm.com 继续查找 TXT/SPF 记录</p></li>
</ul>
<p>还有四种修饰符分别意义是：</p>
<ul>
<li>“+“：允许，默认记录都是允许</li>
<li>“-“：不允许</li>
<li>“~“：中立，也就是没有相关策略</li>
<li>“?“：同样是中立，但是为 debug</li>
</ul>
<p>这样例子中 =example.net. TXT “v=spf1 mx a:pluto.example.net include:aspmx.googlemail.com -all”= 的意思是</p>
<table>
<thead>
<tr class="header">
<th>mx</th>
<th>允许所有 MX 记录</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a:pluto.example.net</td>
<td>pluto.example.net 的 A 记录也允许</td>
</tr>
<tr class="even">
<td>include:aspmx.googlemail.com</td>
<td>其余记录参考 aspmx.googlemail.com</td>
</tr>
<tr class="odd">
<td>-all</td>
<td>拒绝所有其他记录</td>
</tr>
</tbody>
</table>
<p>** DKIM 由于 SPF 天生只验证是否可以发信, 不保证这个发信人是验证的,因此,SPF 验证通过的仍然可能是伪造的邮件. 这就需要 DKIM 来进一步保证这封邮件不是伪造的. 在特殊的子域名”_domainkey”(例如:_domainkey.example.com)的 TXT 记录中插入一对 RSA 密钥中的公钥, 而 RSA 的私钥用来加密邮件的部分字段. 收到邮件的服务器发现有 DKIM-SIGNATURE 字段时,会自动校验 DKIM 的公钥, 按照匹配程度进行处理. 这样就完成了验证.</p>
<p>#+BEGIN_EXAMPLE +—————+ +—————–+ | SenderServer | | ReceiverServer | +—————+ +—————–+ | —————–  | |-| Calculate DKIM | | | |—————-| | | | | Send singed mail | |—————————&gt;| | | | Check DKIM record | |&lt; ————————–| | | —————————<br />
| |-| OK, found key and verify | | | |————————–| | | #+END_EXAMPLE</p>
<p>还可以在特殊子域名之上,再建立一堆域名,例如 authmail._domainkey.example.com,这样在校验邮件时还可以选择不同的密钥. 协议的内容相对来说就简单很多了,只有三种值:</p>
<ul>
<li>v=DKIM1; 使用 DKIM 第一版协议</li>
<li>k=rsa; 使用 RSA 加密</li>
<li>p=长长的一段公钥</li>
</ul>
<p>** DMARC</p>
<p>该验证的都验证了,还有个 DMARC 是干吗的呢? 这是为了给域名邮件的拥有者报告垃圾邮件的状况而设定的规则. 和之前的方法一样,在_dmarc.example.com 下面设定自己的 DMARC 规则, 具体就参考 Google 提供的文档吧.</p>
<p>https://support.google.com/a/answer/2466580?hl=zh-Hans&amp;ref_topic=2759254</p>
<ul>
<li><p>self-host service</p></li>
<li><p>Poste.io</p>
<ul>
<li>https://poste.io</li>
<li>Demo: https://demo.poste.io/admin/login#admin@poste.io;admin</li>
<li>1 GiB RAM</li>
</ul></li>
<li><p>Mailu</p>
<ul>
<li>https://mailu.io/1.7/index.html</li>
<li>Github: https://github.com/Mailu/Mailu</li>
<li>Demo: https://test.mailu.io/admin admin@test.mailu.io/letmein</li>
<li>at least 2GB of total memory and 1GB of free memory</li>
</ul></li>
<li><p>docker-mailserver</p>
<ul>
<li>Github: https://github.com/tomav/docker-mailserver</li>
<li>Recommended: 1-2GB RAM, Minimum 512MB RAM</li>
<li>NO webpanel</li>
</ul></li>
<li><p>mailcow</p>
<ul>
<li>https://mailcow.email/</li>
<li>Github: https://github.com/mailcow/mailcow-dockerized</li>
<li>Demo: https://demo.modoboa.org admin/moohoo</li>
<li>3 GiB RAM</li>
</ul></li>
<li><p>modoboa</p>
<ul>
<li>https://modoboa.org/en/</li>
<li>Demo: https://demo.modoboa.org/</li>
<li>2 GB RAM</li>
</ul></li>
<li><p>Mail-in-a-Box</p></li>
<li><p>Zarafa</p></li>
<li><p>Kopano</p></li>
<li><p>IRedMail</p></li>
<li><p>EwoMail</p></li>
<li><p>https://www.reddit.com/r/selfhosted/comments/bmsum7/selfhosted_email_setup_howto/</p></li>
<li><p>Links</p></li>
</ul>
<ol type="1">
<li>[[https://wiki.archlinux.org/index.php/Mail_server][Mail server/archwiki]]</li>
<li>[[https://newpants.top/2019/11/14/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8Poste%E4%BA%94%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA/][邮件服务器 Poste 五分钟搭建]]</li>
</ol>]]></description>
    <pubDate>Wed, 14 Apr 2021 17:52:17 +0800</pubDate>
    </item>
</channel>
</rss>
