<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
<channel>
<title>codeplayer</title>
<atom:link href="https://www.codeplayer.org/publish/feed.xml" rel="self" type="application/rss+xml" />
<link>https://www.codeplayer.org</link>
<description>codeplayer wiki</description>
    <item>
    <title><![CDATA[虚拟语气]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e8%99%9a%e6%8b%9f%e8%af%ad%e6%b0%94.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e8%99%9a%e6%8b%9f%e8%af%ad%e6%b0%94.html</guid>
    <description><![CDATA[<p>#+TITLE: 虚拟语气 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>动词语气 Verb Moods 这里的“语气”是语法概念或语法术语，可不是”说话的语气“。</li>
</ul>
<p>英语语气最主要有三种语气： - 陈述语气 - 祈使语气 - 虚拟语气 ** 陈述语气 陈述语气说白了就是描述现实，比如：</p>
<p>The rabbit <em>ate</em> the carrot. 这兔子 <em>吃了</em> 这胡萝卜。 ** 祈使语气 祈使语气说白了就是命令/请求。</p>
<p>Rabbit, <em>eat</em> the carrot! 兔子， <em>吃</em> 这胡萝卜！</p>
<p>构成： 1. 用第二人称（“你”）&amp;用一般现在时态 2. 去掉“你”，并保证动词原形</p>
<p>+You+ eat the carrot! -&gt; Eat the carrot!</p>
<p>+You+ don’t eat it! -&gt; Don’t eat it!</p>
<p>+You+ are quiet! -&gt; Be quiet!</p>
<p>+You+ never give up! -&gt; Never give up! ** 虚拟语气 *** 英语思维：如何描述动作/时间 - 与现实相悖的想像，主观意愿：使用动词的虚拟语气 - 现实的描述，直接请求/命令：不用动词的虚拟语气，而且用陈述语气、祈使语气 *** 举例 张三被兔子咬了，进了医院，张三决心报复兔子。张三在出院的时候，夸下海口，说是要咬兔子。可是，时间慢慢过去了，来到了现在。兔子就是没有出现。因为兔子听到风声，躲起来了。</p>
<p>**** 和现在事实相反 于是张三说：如果我现在 <em>看到</em> 那只兔子的话，我会 <em>咬</em> 它。</p>
<p>If I <em>saw</em> the rabbit now, I <em>would</em> bite him.</p>
<p>这里动词是过去式，但是并不表示过去时间，也就是说，这句话不是在描述过去发生的事实，而是在描述现在的，没发生，但是希望发生的事，是一个主观意愿或者说想象的假设。</p>
<p>以上是虚拟语气的第一种用法，表示和 <em>现在</em> 事实相反。 **** 和将来事实相反（可能性很小） 然而，咬了张三的兔子，听到风声，昨晚就跑到月亮上了。张三知道，接下来一段时间里，他是多半找不到这兔子了。</p>
<p>于是他只能说：万一我明天看见那只兔子，我要咬它。他这里说“万一”，其实就是表明可能性太小了。对应的那英文，一般也要用虚拟语气。用来表示，像这样的，将来时间里，可能性很小的动作。</p>
<p>If I <em>should see</em> the rabbit tomorrow, I <em>would</em> bite him.</p>
<p>条件句里动词虚拟语气构成是 <em>Should + 动词原型</em> ；而主句里，因为这里是假想，所以要用 would。</p>
<p>以上是虚拟语气的第二种主要用法：表示和 <em>将来</em> 事实相反，或者说，描述将来很小可能性的动作/事件。 **** 和过去事实相反 按么张三现在找不到这兔子，也知道接下来多半还是找不到这兔子，所以就特别后悔，没在前段时间刚出院时就去咬兔子。</p>
<p>他就说，我要是前几天看见那只兔子就好了，当时就会咬他。</p>
<p>和过去事实相反，动词虚拟语气的变位就要改成过去完成态的形式：</p>
<p>If I +saw+ the rabbit a few days ago, I +would+ bite him.</p>
<p>-&gt; If I <em>had seen</em> the rabbit a few days ago, I <em>would have bitten</em> him.</p>
<p>你可以把过去时间的虚拟理解为，假设对过去某一点有影响，所以是“完成态”。而这样的假设当然在条件句中。那主句里就不能说 I would bite him，否则又回到了现在时间，所以主句也同样要改成完成态。</p>
<p>以上是虚拟语气的第三种主要用法：和 <em>过去</em> 已经发生的事实相反。不可能的情况。 *** 虚拟语气的两大用法 上面就是讲的虚拟语气的两大用法之一：表“不可能“假设。按时间分，又可分为对现在的假设，对将来的假设，对过去的假设。 **** 虚拟语气表”不可能假设“ ***** 与现在相反 条件句： <em>过去式</em></p>
<p>主句： <em>would + 动词原形</em></p>
<p>If I <em>were</em> you, I <em>would bookmark</em> this article. ***** 与将来相反 真的不可能，如：兔子下蛋</p>
<p>可能性极小，如：该文章排在搜索排名第一</p>
<p>条件句： <em>should + 动词原形</em></p>
<p>主句： <em>would + 动词原形</em></p>
<p>If <em>should meet</em> thee after longs years, how <em>should</em> I <em>greet</em> thee?</p>
<p><em>万一</em> 我们将来 <em>重逢</em> 了， 我又该如何 <em>面对</em> 你呢？</p>
<p>注意，should 其实是 shall 的过去式，构成将来时态往往用 will 或 shall，这里其实就是用了 shall 的过去式，并没有”应该“这个含义。而 should 的另一个身份，做情态动词时，才有”应该“这个含义。顺便提一下相似的助动词的过去式变位：</p>
<p>#+begin_example shall -&gt; should will -&gt; would can -&gt; could may -&gt; might #+end_example</p>
<p>主句中的 would，也可以用 <em>should/could/might</em> 来替换，当然也要看具体语境。另外，条件句中的 should 也可以用 <em>were to</em> 来取代 ***** 与过去相反 条件句： <em>had + 动词过去分词</em> 主句： <em>would have + 动词过去分词</em></p>
<p>If I <em>had watched</em> this video before, I <em>would have aced</em> my test.</p>
<p>我要是之间就 <em>看了</em> 这视频，那绝对能 <em>考个</em> 好成绩。言下之意：我没考出好成绩。 **** 虚拟语气表达愿望、请求、建议、命令等 虚拟语气表达愿望、请求、建议、命令等，说白了就是”希望某个动作/事件“发生。其实这也很好理解，因为这样的”希望“也是发生在我们脑中的，而非在现实中已经发生了的事。而这样的虚拟语气用法特征也很明显，因为这样的虚拟语气用法特征也很明显，因为这样的动词虚拟语气一般和一些”表达愿望的词“一起使用；最具代表性的就是 wish 这个词。</p>
<p>wish 是希望可能性小的事发生，而 hope 比较中性。 ***** wish - 对现在的愿望</p>
<p>构成： <em>wish + 动词过去式</em></p>
<p>I wish (that) I <em>were</em> a rabbit. 我希望我是只兔子。</p>
<ul>
<li><p>对过去的愿望</p>
<p>构成： <em>wish + had/would have + 动词过去分词</em></p>
<p>I wish (that) I <em>had eaten</em> the carrot. 我希望我 <em>吃了</em> 那只胡萝卜。</p></li>
<li><p>对将来的愿望</p>
<p>构成： <em>wish + should/would/could/might + 动词原形</em></p>
<p>I wish (that) I <em>could eat</em> the carrot. 我希望我 <em>能吃</em> 那只胡萝卜。 ***** would rather I would rather that you <em>didn’t eat</em> the carrot. 我宁愿你 <em>不会吃</em> 那胡萝卜。</p></li>
</ul>
<p>I would rather that you <em>hadn’t eat</em> the carrot. 我宁愿你 <em>没吃掉</em> 那胡萝卜。 ***** demand, suggset, insist, order… 这样的词后面接的虚拟语气一律是 <em>should + 动词原形</em> 。</p>
<p>I demand/suggest/insist/order that you <em>+should+ give</em> me a carrot. 我要求/建议/坚持/命令你给我一根胡萝卜。</p>
<p>上面的 should 也可以省略。 * 英语动词语气总结 ** 陈述语气 描述现实 ** 祈使语气 命令，请求…… ** 虚拟语气 “脑中的”，“非现实的”…… *** 与事实相反的假设 **** 与现在相反 构成：if + 过去式；would + 原形 **** 与过去相反 构成：if + 过去完成式；would have + 过去分词 **** 与将来相反（可能性小） 构成：if + should + 原形；would + 原形 *** 表达愿望、请求、建议、命令等 **** wish ***** 与现在相反 构成：wish + 过去式 ***** 与过去相反 构成：wish + 过去完成式 ***** 与将来相反 构成：wish + would/should/could/might + 动词原形 **** demand, suggest, insist, would rather… +(should) + 动词原形</p>
<p>虚拟语气可以存在于不同类型的从句中： - 主语从句 - 宾语从句 - 主语补语从句（表语从句） - 定语从句</p>]]></description>
    <pubDate>Thu, 5 Aug 2021 21:02:23 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[语法框架]]></title>
    <link>https://www.codeplayer.org/Wiki/English/%e8%af%ad%e6%b3%95%e6%a1%86%e6%9e%b6.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/%e8%af%ad%e6%b3%95%e6%a1%86%e6%9e%b6.html</guid>
    <description><![CDATA[<p>#+TITLE: 语法框架 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>介绍 英语语法的目的：造句。</li>
<li>句子的成分 #+begin_quote <em>什么</em> /怎么样/ = 主语 + 谓语 #+end_quote</li>
</ul>
<p>“什么”和“怎么样”分别对应了两个最基本的“句子成分”——“主语”（subject）和“谓语”（predicate）。</p>
<p>主语一般为人或物，不管抽象或者具体。谓语为“动作”或发生了什么事。广义上的“动作”是语法上的“动词”。 ** 有哪些“动作”（动词） 5 种动词 -&gt; 5 种”基本句型“ 1. 可以独立完成的动作： <em>不及物动词</em></p>
<p><em>主语+（不及物）动词</em></p>
<p>Papa Rabbit <em>sleeps</em>. 2. 有 <em>一个</em> 动作的承受者： <em>单及物动词</em></p>
<p><em>主语+（单及物）动词+宾语</em></p>
<p>Papa Rabbit <em>likes</em> /<em>you</em>/. 3. 有 <em>两个</em> 动作的承受者： <em>双及物动词</em></p>
<p><em>主语+（双及物）动词+间接宾语+直接宾语</em></p>
<p>Papa Rabbit <em>teaches</em> /<em>you</em>/ /English/.</p>
<p>其中”you“为间接宾语，”English“为直接宾语 4. 只有一个动作承受者（不同于 2）： <em>复杂及物动词</em></p>
<p><em>主语+（复杂及物）动词+宾语+（宾语）补语</em></p>
<p>Papa Rabbit <em>considers</em> /<em>you</em>/ /smart/.</p>
<p>其中”smart“为（宾语）补语 5. 把这个词后面的信息赋予给前者： <em>系动词</em></p>
<p><em>主语+（系）动词+（主语）补语</em></p>
<p>主语补语也是表语</p>
<p>Papa Rabbit <em>is</em> tall. / Papa Rabbit <em>&lt;-</em> tall. / Papa Rabbit <em>=</em> tall.</p>
<p>Papa Rabbit <em>looks</em> tall. / Papa Rabbit <em>&lt;-</em> tall.</p>
<p>把后者信息赋予前者 ** 快速小结 英语中的所有句子，当拆到不能再拆后，都是在说： <em>什么</em> /怎么样/ 。”什么“是语法中的主语，”怎么样“是谓语，谓语都有一个核心动词，叫做谓语动词。</p>
<p>*** 谓语动词 1. 无承受者</p>
<p>主语 + <em>动词</em> 2. 一个承受者</p>
<p>主语 + <em>动词</em> + /<em>宾语</em>/ 3. 两个承受者</p>
<p>主语 + <em>动词</em> +（间接） /<em>宾语</em>/ + （直接） /<em>宾语</em>/ 4. 一个承受者（不同于 2）</p>
<p>主语 + <em>动词</em> + /<em>宾语</em>/ + （宾语） /补语/ 5. 赋予信息</p>
<p>主语 + <em>动词</em> + （主语） /补语/ （表语）</p>
<p>谓语和谓语动词是有区别的，句子主语后面的余下句子部分都是谓语，谓语动词只是谓语的一部分。与谓语动词相对的，还有 <em>非</em> 谓语动词。 ** 句子成分 1. 主语 Subject 2. 谓语动词（~谓语） Predicate Verb 3. 宾语 Object 4. 宾语补语 Object Complement 5. 主语补语（表语） Subject Complement 6. 定语 Attributive</p>
<p>主要用来修饰主语或宾语</p>
<p><em>The little white</em> rabbit ate <em>a large</em> carrot.</p>
<p>“The little white”是”rabbit”的定语，“a large”是“carrot”的定语 7. 状语 Adverbial</p>
<p>主要用来修饰谓语动词</p>
<p>The rabbit ate <em>quickly</em>.</p>
<p>“quickly”就是“ate”的状语 8. 同位语 Appositive</p>
<p>主要用来再把主语或宾语说一遍</p>
<p>Papa Rabbit, <em>an English teacher</em>, eats a carrot.</p>
<p>“an English teacher”其实就是把“Papa Rabbit”用不同方式再说一遍，在这里算是和主语同等地位 ** 简单句的组合 以上所说的都是简单句，简单句就是不能再拆否则句意不完整的句子。简单句互相组合就形成了 Compound Sentence 复合句，还有 Complex Sentence 复杂局。复合句是简单句的并列组合，而复杂句是简单句的嵌套组合。</p>
<p>一个句子嵌套另一个句子，在英语语法上分别叫做 <em>主句</em> 和 <em>从句</em> 。从句说白了就是把简单句修改一下来充当另一个句子的句子成分。</p>
<p>*** 从句 - 名词性从句 + 主语从句 + 宾语从句 + 表语（主语补语）从句 + 同位语从句 - 定语从句 - 状语从句 * 词类 英语的十大词类。</p>
<ol type="1">
<li><p>名词 Nouns</p>
<p>表人和物</p>
<p><em>Papa Rabbit</em> is a <em>rabbit</em>.</p>
<p>其中“Papa Rabbit”是专有名词，“rabbit”是普通名词</p></li>
<li><p>冠词 Articles</p>
<p>说明人和事物</p>
<p>Papa Rabbit is <em>a</em> rabbit.</p></li>
<li><p>代词 Pronouns</p>
<p>代替人和物</p>
<p><em>I</em> am a rabbit.</p></li>
<li><p>形容词 Adjectives</p>
<p>形容人和物</p>
<p>I am a <em>smart</em> rabbit.</p></li>
<li><p>数词 Numerals</p>
<p>表数量</p>
<p>I ate <em>two</em> carrot.</p></li>
<li><p>副词 Adverbs</p>
<p>修饰动作或形容词等等</p>
<p>I ate two carrots <em>quickly</em>.</p></li>
<li><p>介词 Prepositions</p>
<p>表示和其他词关系的词</p>
<p>I ate two carrots <em>with</em> chopsticks.</p></li>
<li><p>叹词 Interjections</p>
<p>表感叹</p>
<p><em>Ah</em>, the carrots is tasty!</p></li>
<li><p>连词 Conjunctions</p>
<p>连接词和句子</p>
<p>I ate two carrots <em>and</em> a potato, <em>because</em> I was hungry.</p></li>
<li><p>动词 Verbs</p></li>
</ol>
<p>句子成分和句子中的词类是完全不同的概念。每一种句子成分，除了谓语动词是动词，其他都有可能包含不同的词类。 * 谓语动词的“三大本领” 1. 表示动作的 <em>时间</em> ：现在，过去，将来，从过去某个时间点“算将来”（过去将来）</p>
<p>比如动作可能在过去或将来 2. 表示动作的 <em>状态</em> ：未说明（一般），完成，进行，不但完成而且继续（完成进行）</p>
<p>比如动作可能是已经完成的状态或者正在进行的状态 3. 表示动作的 <em>假设，情感等</em></p>
<p>表示动词的语气</p>
<p>If I <em>were</em> a rabbit… 虚拟语气</p>
<p>I <em>ate</em> a carrot… 陈述语气</p>
<p><em>Eat</em> this carrot and… 祈使语气</p>
<p>1 和 2 合在一起称为 <em>时态</em> 。时间和状态组合，一共有 16 种时态：</p>
<p>[[file:../../pics/English/tense.png]] * 助动词 谓语动词本身往往是不能够独立完成之前说的那些本领，以及另外一些其他的本领，而且谓语动词独自也无法完成比如表示否定，可能性，必须性等意思。想要谓语动词充分发挥，我们必须用到另一类经常和动词一起用的词帮助完成任务， <em>助动词</em> 。</p>
<p>** Eat 为了协助它表示吃过了（完成态），就要用到助动词： <em>have</em>, eg, have eaten.</p>
<p>为了协助它表示正在吃（进行态），就要用到助动词： <em>be</em>, eg, is eating.</p>
<p>为了协助它表示是“被”吃，就要用到助动词： <em>be</em>, eg, is eaten.</p>
<p>为了协助它表示有能力吃，就要用到助动词： <em>can</em>, eg, can eat.</p>
<p>为了协助它表示有可能吃，就要用到助动词： <em>might</em>, eg, might eat.</p>
<p>为了协助它表示有义务吃，就要用到助动词： <em>must</em>, eg, must eat.</p>
<p>为了协助它表示否定，不吃，就要用到助动词： <em>do</em>, eg, do not eat.</p>
<p>但是很多助动词特别喜欢伪装，它们除了做助动词（没有实义，只是帮助谓语动词而已），还可以做实义动词，甚至其他词性。比如 can 还可以是易拉罐，might 可以是力量，must 可以是发霉，do 可以是做某事，have 可以是拥有，be 可以是存在。 * 非谓语动词 动词除了充当句子中的谓语动词，还有可能充当：主语、宾语、宾语补语、主语补语、定语、状语、同位语等。只不过需要把谓语动词修改一下，改成非谓语动词。不仅如此，非谓语动词几乎可以 <em>取代所有的从句</em> ，从而 <em>简化句子</em> 。只不过这样的动词就不再具有表示动作时间、状态、语态、语气的功能。</p>
<p>它们是以不同的形式出现在句中，包括： - 动词不定式，e.g. to eat - 现在分词，e.g. eating - 动名词，e.g. eating - 过去分词，e.g. eaten * 总结 英语语法的核心就是 <em>动词</em> 。动词能够串起几乎所有语法概念。</p>
<p>[[file:../../pics/English/verbs.png]] * 参考视频 https://www.youtube.com/watch?v=is7vn5URVcc</p>]]></description>
    <pubDate>Thu, 5 Aug 2021 21:02:23 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[16种时态详解]]></title>
    <link>https://www.codeplayer.org/Wiki/English/16%e7%a7%8d%e6%97%b6%e6%80%81%e8%af%a6%e8%a7%a3.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Wiki/English/16%e7%a7%8d%e6%97%b6%e6%80%81%e8%af%a6%e8%a7%a3.html</guid>
    <description><![CDATA[<p>#+TITLE: 16种时态详解 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>动词时间 过去、现在、将来、过去将来。其中“过去将来”和“现在”，没有必然关系。在下图中，我们默认过去的将来在现在的过去，但并不一定是这样，也有可能过去的将来在现在的将来。其实，过去将来时间在现实中也不常见，一般只出现在从句中。</li>
</ul>
<p>[[file:../../pics/English/verbs_time.png]] * 动词状态 - <em>进行</em> 状态</p>
<p>这兔子 <em>正在吃</em> 着胡萝卜。</p>
<p>兔子这个吃胡萝卜的动作（过程） <em>正在进行</em> 中。</p>
<p>用图例 <sub>——&gt;</sub> 表示一个正在进行的过程。</p>
<ul>
<li><p><em>完成</em> 状态</p>
<p>这兔子 <em>吃掉了</em> 胡萝卜。</p>
<p>胡萝卜已经在兔子肚子里， <em>吃完了，饱了</em> 。</p>
<p>用图例 <sub>====</sub> 表示动作完成了。注意，完成态的重点在动作完成了，而并没有指出动作具体发生的时间。</p></li>
<li><p><em>完成进行</em> 状态</p></li>
</ul>
<p>这兔子 <em>从早上就开始</em> 吃胡萝卜，现在 /<em>还没停</em>/ 呢。</p>
<p>不但有好多胡萝卜 <em>进了兔子肚子</em> ，这 /<em>还没完</em>/ 呢，这兔子还有一堆胡萝卜没吃呢。</p>
<p>用图例 <sub>==——&gt;</sub> 表示动作的一部分完成了，但剩下的还在进行中。</p>
<ul>
<li><p>默认的，简单的， <em>一般</em> 的状态</p>
<p>”没有状态信息“，这样的状态就是所谓“一般状态”。</p>
<p>用图例 <sub>•</sub> 表示“一般，没有具体说明”。</p></li>
<li><p>时间+状态</p></li>
<li><p>现在进行时态：这兔子现在正在吃胡萝卜。</p></li>
<li><p>现在完成时态：这兔子现在已经吃完了胡萝卜。</p></li>
<li><p>现在完成进行时态：这兔子现在已经吃完了一些胡萝卜，还要继续吃。</p></li>
<li><p>现在一般时态：这兔子吃胡萝卜。</p></li>
<li><p>过去进行时态：这兔子昨天下午三点那个时候正在吃胡萝卜。</p></li>
<li><p>过去完成时态：这兔子昨天下午三点那个时候已经吃完了胡萝卜。</p></li>
<li><p>过去完成进行时态：这兔子昨天下午三点那个时候已经吃完了一些胡萝卜，还要继续吃。</p></li>
<li><p>过去一般时态：兔子过去吃了胡萝卜。</p></li>
<li><p>将来进行时态：这兔子昨天下午三点那个时候会正在吃胡萝卜。</p></li>
<li><p>将来完成时态：这兔子明天下午三点那个时候会已经吃完了胡萝卜。</p></li>
<li><p>将来完成进行时态：这兔子明天下午三点那个时候已经吃完了一些胡萝卜，还要继续吃。</p></li>
<li><p>将来一般时态：兔子将来吃胡萝卜。</p></li>
</ul>
<p>张三上个月被一直兔子咬了，还进了医院。上个月张三出院的时候，说我要报仇，要咬那只兔子一口。</p>
<ul>
<li><p>过去将来进行时态：如果张三在上个月说，“下个月的某一天，你一定会看见我，正在咬那只兔子。”</p></li>
<li><p>过去将来完成时态：如果张三在上个月说，“下个月的某一天，你一定会发现我已经咬了那只兔子。”</p></li>
<li><p>过去将来完成进行时态：如果张三在上个月说，“下个月的某一天，你一定会发现我不但咬了那只兔子，还会一直咬下去。”</p></li>
<li><p>过去将来一般时态：如果张三在上个月说，“等着瞧，我一定咬那只兔子。”</p></li>
<li><p>时态的四大难点</p></li>
<li><p>难点 1：时&amp;态未分清</p></li>
<li><p>难点 2：动词变位</p>
<p>eat -&gt; ate 时态变位， eat -&gt; eats 人称变位</p></li>
<li><p>难点 3：助动词</p>
<p>以下都是进行状态，助动词 be。但是因为动词变位，be 变成了 was been。</p>
<p>The rabbit <em>was</em> eating a carrot. The rabbit has <em>been</em> eating a carrot. The rabbit will <em>be</em> eating a carrot.</p></li>
<li><p>难点 4：与其他语法概念混合</p>
<ul>
<li>现在完成：The rabbit <em>has eaten</em> a carrot.</li>
<li>+情态：The rabbit <em>may have eaten</em> a carrot.</li>
<li>改时间+否定：The rabbit <em>could not have eaten</em> a carrot.</li>
<li>改为被动：The carrot <em>could not have been eaten</em> by the rabbit.</li>
</ul></li>
<li><p>每种时态的构成 ** 现在 *** 一般现在时态 构成： <em>+ 动词原型 / +动词原型 + s（第三人称单数）</em></p></li>
</ul>
<p>#+begin_example I <em>eat</em> carrots. You <em>eat</em> carrots. We <em>eat</em> carrots. She <em>eats</em> carrots. The rabbit <em>eats</em> carrots. #+end_example</p>
<ol type="1">
<li><p>表达事实 #+begin_example I eat carrots. The rabbit eats carrots. The sun rises in the east. #+end_example</p></li>
<li><p>表达习惯/重复的动作</p>
<p>I play baskball.</p></li>
<li><p>表示预计发生的事</p>
<p>The bus leaves at 8PM tonight. *** 现在进行时态 构成： <em>助动词 be 的变位 + 动词的现在分词</em> **** be</p></li>
<li><p>（连）系动词</p>
<p>I am smart rabbit -&gt; I = a smart rabbit.</p></li>
<li><p>助动词，构成时态 #+begin_example I <em>am</em> You/we/they <em>are</em> She/he/it <em>is</em> #+end_example **** 现在分词 通常：+ ing</p></li>
</ol>
<p>如：looking, smelling, tasting…</p>
<p>有些动词在此基础上改变拼写，如： #+begin_example write -&gt; writing，不是writeing hit -&gt; hitting，不是hiting die -&gt; dying，不是dieing #+end_example</p>
<p>**** 现在进行时态 I eat carrots.</p>
<p>-&gt; I <em>am eating</em> carrots. 我正在吃（一些）胡萝卜。</p>
<p>-&gt; I <em>am eating</em> a carrot. 我正在吃一根胡萝卜。</p>
<p>You/we/they <em>are eating</em> a carrot.</p>
<p>She/he/it <em>is eating</em> a carrot.</p>
<p>The rabbit <em>is eating</em> a carrot. （这兔子现在正在吃胡萝卜的过程中。）</p>
<p>You <em>are watching</em> my video. （你现在处在看我的视频的过程中。）</p>
<p>I <em>am thinking</em> of you. （我现在处在想你的过程中。） *** 现在完成时态 构成： <em>助动词 have 的变位 + 动词的过去分词</em> **** have 1. 实义动词</p>
<p>I have some coins.</p>
<ol start="2" type="1">
<li><p>助动词，构成时态</p>
<p>I/you/we/they <em>have</em></p>
<p>She/he/it <em>has</em> **** 过去分词 通常：+ ed</p></li>
</ol>
<p>如：looked, smelled, tasted…</p>
<p>有些动词是“不规则变化”，如： #+begin_example eat -&gt; eaten; eat, give, see, fall -&gt; eaten, given, seen, fallen bring -&gt; brought; bring, buy, fight, think -&gt; brought, bought, fought, thought feel -&gt; felt; feel, keep, sleep, leave -&gt; felt, kept, slept, left #+end_example</p>
<p>动词除了过去分词这种变位，还有一种变位叫过去式。过去分词 != 过去式。 **** 现在完成时态 I eat carrots.</p>
<p>-&gt; I <em>have eaten</em> carrots. 我吃过胡萝卜。（言下之意：我曾吃过这种食物，是只见过市面的兔子。）</p>
<p>-&gt; I <em>have eaten</em> a carrot. 我吃过了一根胡萝卜。（言下之意：我已经吃了，所以不饿。）</p>
<p>You/we/they <em>have eaten</em> a carrot.</p>
<p>She/he/it <em>has eaten</em> a carrot.</p>
<p>The rabbit <em>has eaten</em> a carrot. （这兔子到现在为止已经吃了个萝卜。）</p>
<p>You <em>have watched</em> my video. （你到现在为止已经看过了我的视频。）</p>
<p>I <em>have thought</em> of you. （我到现在为止已经想过你了。） *** 现在完成进行时态 1. 现在完成时态的构成是：have 的变位 + 动词的过去分词 2. 现在进行时态的构成是：be 的变位 + 动词的现在分词</p>
<p>两者的综合，其实就是把 2 中的 be 作为 1 中的动词。也就是说 1 中的动词是 be，更进一步的说，2中 be 的变位 = 1 中的 be 的过去分词。</p>
<p>1 + 2 -&gt; have 的变位 + be 的过去分词 + 动词的现在分词 -&gt; <em>have 的变位 + been + 动词的现在分词</em> 。</p>
<p>构成： <em>have 的变位 + been + 动词的现在分词</em></p>
<p>1 eat carrot.</p>
<p>-&gt; I + <em>have 的变位 + been + eat 的现在分词</em> + carrots.</p>
<p>-&gt; I <em>have been eating</em> carrots. 我在吃胡萝卜。（不但 <em>已经</em> 吃了些，还将 <em>继续</em> 。）</p>
<p>The rabbit <em>has been eating</em> a carrot. （这兔子到现在为止 <em>已经</em> 吃了胡萝卜一段时间了，还要 <em>再继续吃</em> 一段时间。）</p>
<p>You <em>have been watching</em> my video. （你到现在为止 <em>已经</em> 看了我视频一段时间了，还要 <em>再继续看</em> 一段时间。）</p>
<p>I <em>have been thinking</em> of you. （我到现在为止 <em>已经</em> 想你一段时间了，还要 <em>再继续想</em> 一段时间。） ** 过去 过去时间的四种时态，其实就是把现在时间的四种时态往前推一个时间段而已。 *** 一般过去时态 构成： <em>+ 动词过去式</em></p>
<p>I/you/we/she/he/it/they <em>ate</em> a carrot yesterday. **** 过去式 通常：+ ed</p>
<p>如：looked, smelled, tasted</p>
<p>有些动词是“不规则变化”，如： | 动词原形 | 动词过去式 | 动词过去分词 | |———-+————+————–| | do | did | done | | go | went | gone | | take | took | taken |</p>
<p>“不规则”过去式的“规律” | 动词原形 | 动词过去式 | 动词过去分词 | |———-+————+————–| | bring | brought | brought | | blow | blew | blown | | begin | began | begun | | speak | spoke | spoken | **** 一般过去时态 - 动作发生了 √ - 动作多久 ？ - 动作何时开始 ？ - 动作何时结束 ？</p>
<p>“一般”单纯地指出有个动作发生了而已，至于这个动作多久，什么时候开始，什么时候结束，如果没有上下文则不得而知。</p>
<p>The rabbit <em>ate</em> a carrot. 兔子 <em>吃了</em> 胡萝卜。（只知道这兔子过去某个时刻在吃胡萝卜。）</p>
<p>You <em>watched</em> my video. 你 <em>看了</em> 我的视频。（可能的言下之意，这是事实，别抵赖哦。）</p>
<p>I <em>thought</em> of you. 我 <em>想了</em> 你。（可能的言下之意，这是事实，不骗你。） *** 过去进行时态 过去进行时态其实就是现在进行时态往前推一个时间段。</p>
<p><em>现在</em> 进行时态： <em>助动词 be 的变位</em> + 动词的现在分词</p>
<p><em>过去</em> 进行时态： <em>助动词 be 的变位</em> + 动词的现在分词</p>
<p>现在时间里助动词 be 的变位为：</p>
<p>#+begin_example I <em>am</em> You/we/they <em>are</em> She/he/it <em>is</em> #+end_example</p>
<p>但是，在过去时间里的变位就成了：</p>
<p>#+begin_example I/she/he/it <em>was</em> You/we/they <em>were</em> #+end_example</p>
<p>所以说，其实过去进行时态很简单，就是在现在进行时态的基础上，把助动词 be 改成过去式就好。</p>
<p>The rabbit <em>is</em> eating a carrot. -&gt; The rabbit <em>was</em> eating a carrot. （这兔子在过去某个时间点处在正在吃胡萝卜的过程中。）</p>
<p>You <em>are</em> watching my video. -&gt; You <em>were</em> watching my video. （你在过去某个时间点处在看我的视频的过程中。）</p>
<p>I <em>am</em> thinking of you. -&gt; I <em>was</em> thinking of you. （我在过去的某个时间点处在想你的过程中。） *** 现在完成时态 vs. 一般过去时态 vs. 过去进行时态 **** 现在完成时态 vs. 一般过去时态 现在完成时态的重点是动作完成了吗？I have seen a carrot. I know its color. / I have gone to Shanghai. Are you looking for me? Sorry, I have gone to Shanghai(so you can’t find me).</p>
<p>一般过去时代的重点是动作有没有发生？I saw a carrot. I’m not lying! / I went to Shanghai. I am back. **** 一般过去时态 vs. 过去进行时态 一般过去时态你可以想做一张照片（The rabbit ate a carrot.），那么过去进行时态，因为是强调过去时间中的进行状态，一个过程，所以可以想做一段视频（The rabbit was eating a carrot.）。</p>
<p>粗略的说，一般过去时态和过去进行时态都是在过去时间里，但是前者重点是某个动作做了没有，后者是某个动作在某个时间是在进行过程中的。 *** 过去完成时态 过去完成时态其实就是现在完成时态往前推一个时间段。</p>
<p><em>现在</em> 完成时态： <em>助动词 have 的变位</em> + 动词的过去分词</p>
<p><em>过去</em> 完成时态： <em>助动词 have 的变位</em> + 动词的过去分词</p>
<p>现在时间里助动词 have 的变位为：</p>
<p>#+begin_example I/you/we/they <em>have</em> She/he/it <em>has</em> #+end_example</p>
<p>但是，在过去时间里的变位就成了：</p>
<p>#+begin_example I/you/we/they/she/he/it <em>had</em> #+end_example</p>
<p>其实，助动词 had 在过去时间的变位，就是 have 的过去式（只有一个）而已。</p>
<p>所以说，其实过去完成时态很简单，就是在现在完成时态的基础上，把助动词 have 改成过去式就好。</p>
<p>过去完成时态主要是为了表达，过去某一个点（A）的过去（B）对过去那个一点（A）的影响，比如：</p>
<p>B —— A —— 现在</p>
<p>I had eaten 5 carrots for <em>lunch yesterday</em>, so I wasn’t hungry at all <em>yesterday afternonn</em>.</p>
<p>这里要表达的意思就是，对于 <em>昨天下午（时间点 A）</em> 来说，因为昨天下午的过去（ <em>时间点 B，也就是中饭时间</em> ），我已经吃了一堆胡萝卜，所以 B 对 A 有影响——这个影响就是：我一点都不饿。</p>
<p>He tried to find me <em>yesterday afternonn</em>, but I <em>had</em> already <em>gone</em> to Shanghai.</p>
<p>对于他试图找我那个 <em>时间点 A（昨天下午）</em> 来说，A的过去 <em>某一点 B</em> （可能是昨天上午，或前天，没说明，但是肯定是昨天下午之前）我已经离开了，去上海了，所以 B 对 A 有影响——这个影响就是：他找不到我。</p>
<p>The rabbit <em>has</em> eaten a carrot. -&gt; The rabbit <em>had</em> eaten a carrot. （这兔子在过去某个时间点已经吃了胡萝卜。）</p>
<p>You <em>have</em> watched my video. -&gt; You <em>had</em> watched my video. （你在过去某个时间点已经看过了我的视频。）</p>
<p>I <em>have</em> thought of you. -&gt; I <em>had</em> thought of you. （我在过去某个时间点已经想过你了。） *** 过去完成进行时态 过去完成进行时态其实就是现在完成进行时态往前推一个时间段。</p>
<p><em>现在</em> 完成进行时态： <em>助动词 have 的变位</em> + been + 动词的现在分词</p>
<p><em>过去</em> 完成进行时态： <em>助动词 have 的变位</em> + been + 动词的现在分词</p>
<p>现在时间里助动词 have 的变位为：</p>
<p>#+begin_example I/you/we/they <em>have</em> She/he/it <em>has</em> #+end_example</p>
<p>但是，在过去时间里的变位就成了：</p>
<p>#+begin_example I/you/we/they/she/he/it <em>had</em> #+end_example</p>
<p>所以说，其实过去完成进行时态很简单，就是在现在完成进行时态的基础上，把助动词 have 改成过去式就好。</p>
<p>The rabbit <em>has</em> been eating a carrot. -&gt; The rabbit <em>had</em> been eating a carrot. （这兔子在过去某个时间点已经吃（某根）胡萝卜一段时间了，还要在过去那个时间点之后继续吃一段时间。）</p>
<p>You <em>have</em> been watching my video. -&gt; You <em>had</em> been watching my video. （你在过去某个时间点之前已经看了我视频一段时间了，还要在那个时间点之后继续看一段时间。）</p>
<p>I <em>have</em> been thinking of you. -&gt; I <em>had</em> been thinking of you. （我在过去某个时间点之前已经想你一段时间了，还要在那个时间点之后继续想一段时间。） ** 将来 将来时间的四种状态，其实就是把现在时间的四种状态，往后推一个时间段而已。</p>
<p>将来时态需要 <em>助动词</em> 帮忙，放在主动词，也就是谓语动词之前。这个将来时态里用到的助动词就是：will。（有时也会用 shell，有些微妙区别。） *** 英语“表达”将来时态 - <em>一般现在时态</em> 可以表达将来的动作，如：The bus <em>leaves</em> at 8PM. - 助动词 <em>be 的变位 + going + to</em> +动词原型，如：I <em>am going to</em> eat a carrot. - 甚至上句的 going 也可以省略，变为助动词 <em>be 的变位 + to</em> + 动词原型，如：You <em>are to</em> eat carrot. - 又或者也可以用介词 about 取代 going，即：+ <em>about + to</em> + 动词原型，如：I <em>am about to</em> eat a carrot. *** 一般将来时态 构成： <em>will + 动词原形</em></p>
<p>eat -&gt; will eat</p>
<p>I/you/she/he/it/they <em>will eat</em> a carrot.</p>
<p>描述：将来某个时间点发生的动作（说话者 <em>十分确定</em> 会发生的事）</p>
<p>如果 <em>不太确定</em> ，就不能用一般将来时态。（要借助动词的“语气”。） *** 将来进行时态 将来进行时态其实就是现在进行时态往后推一个时间段。</p>
<p><em>现在</em> 进行时态： <em>助动词 be 的变位</em> + 动词的现在分词</p>
<p><em>将来</em> 进行时态： will + <em>助动词 be 的变位</em> + 动词的现在分词 -&gt; will + <em>be</em> + 动词的现在分词</p>
<p>描述：在将来某个时间，某个动作是在 <em>进行的过程中</em> 。</p>
<p>I will be eating a carrot for lunch tomorrow. （我明天午饭会在吃萝卜这个动作过程中。）</p>
<p>将来进行时态比一般将来时态还要笃定，所以当你特别确定某个动作/事件一定会发生时，就可以考虑用将来进行时。</p>
<p>之前用过照片和视频的类比，这里也适用，一般将来时态相当于一张（你想象）的照片，而将来进行时态相当于一段（你想像）的视频。 *** 将来完成时态 将来完成时态其实就是现在完成时态往后推一个时间段。</p>
<p><em>现在</em> 完成时态： <em>助动词 have 的变位</em> + 动词的过去分词</p>
<p><em>将来</em> 完成时态： will + <em>助动词 have 的变位</em> + 动词的过去分词 -&gt; will + <em>have</em> + 动词的过去分词</p>
<p>将来完成时态主要是为了表达，将来某一个点（A）的过去（B和现在的前后不能确定）对将来那一点（A）的影响，比如：</p>
<p>将来 —— B —— A</p>
<p>I will have finished making the video by <em>4PM tomorrow</em>, so I can publish it <em>after that</em>.</p>
<p>这里要表达的意思就是，对于 <em>明天下午 4 点钟</em> 那个时间点来说，我在那之前就会完成做视频的这个动作，所以对 4 点钟那时候是有影响的——什么影响呢， <em>4 点钟之后</em> 我就能够发视频啦。</p>
<p>The rabbit <em>has</em> eaten a carrot. -&gt; The rabbit <em>will have</em> eaten a carrot. （这兔子在将来某个时间点已经吃了胡萝卜。）</p>
<p>You <em>have</em> watched my video. -&gt; You <em>will have</em> watched my video. （你在将来某个时间点已经看过了我的视频。）</p>
<p>I <em>have</em> thought of you. -&gt; I <em>will have</em> thought of you. （我在将来某个时间点已经想过你了。）</p>
<p>这个时态甚至比刚才的将来进行时态更加笃定，说得都好像已经发生了似的，所以，如果想表达特别特别确定某事，就可以用这个将来完成时态。 *** 将来完成进行时态 将来完成进行时态其实就是现在完成进行时态往后推一个时间段。</p>
<p><em>现在</em> 完成进行时态： <em>助动词 have 的变位</em> + been + 动词的现在分词</p>
<p><em>将来</em> 完成进行时态： <em>will + 助动词 have 的变位</em> + been + 动词的现在分词 -&gt; <em>will + have</em> + been + 动词的现在分词</p>
<p>现在完成进行时态描述，对于现在这个时间点，不但已经完成了一部分而且还要继续进行的动作；那么将来完成进行时态，自然是描述，对于将来某个点，不但已经完成了一部分而且还要继续进行的动作，比如：</p>
<p>将来 —— B —— A</p>
<p>I will have been eating carrots <em>for 2 hours</em> by <em>3PM tomorrow</em>.</p>
<p>这里表达的意思就是：我确定 <em>明天下午三点钟</em> 时， 我不但 <em>已经吃了俩钟头胡萝卜</em> （也就是从昨天下午 1 点开始吃）而且还要继续吃。</p>
<p>You <em>have been</em> watching my video -&gt; You <em>will have been</em> watching my video. （你在将来某个时间点之前已经看了我视频一段时间了，还要在那个时间点之后继续看一段时间。）</p>
<p>I <em>have been</em> thinking of you. -&gt; I <em>will have been</em> thinking of you. （我在将来某个时间点之前已经想你一段时间了，还要在那个时间点之后继续想你一段时间。） ** 过去将来 过去将来时态常出现于从句。</p>
<p>过去将来的四种时态，只不过事把讲来时间的四种时态，往前推一个时间段（推到现在的过去）而已。 *** 一般过去将来时态 一般 <em>将来</em> 时态： <em>will</em> + 动词原型</p>
<p>一般 <em>过去将来</em> 时态： <em>would</em> + 动词原型</p>
<p>I <em>said</em> I <em>would eat</em> a carrot for lunch. 我 <em>（之前）说过</em> 我 <em>会</em> 午饭 <em>吃</em> 根胡萝卜。 （午饭时间对于之前我说那句话的时间来说是在将来，但至于现在午饭时间有没有到，不得而知。）</p>
<p>I <em>knew</em> you <em>would watch</em> my video. 我 <em>（之前）就知道</em> 你 <em>会看</em> 我的视频。 （你看我视频这件事对于我作出这个判断的时间来说是在将来。）</p>
<p><em>助动词 be 的变位 + going + to</em> 也可以表示一般 <em>过去将来</em> 时态。只不过需要把助动词 be 变位体现过去，也就是：</p>
<p>#+begin_example I/she/he/it <em>was</em> You/they <em>were</em> #+end_example</p>
<p>上面两句就可以变为：</p>
<p>I said I <em>would</em> eat a carrot for lunch. -&gt; I said I <em>was going to</em> eat a carrot for lunch.</p>
<p>I knew you <em>would</em> watch my video. -&gt; I knew you <em>were going to</em> watch my video. *** Would 的多义 I said I <em>would</em> eat a carrot for lunch. 我（之前）说过我会午饭吃根胡萝卜。 <em>（will 的过去式变位，构成时态）</em></p>
<p>If I were you, I <em>would</em> eat a carrot. 如果我是你，我会吃根胡萝卜。 （构成动词 eat 的 <em>虚拟语气</em> ：我不可能是你，所以这里的“吃”是“虚拟”动作。）</p>
<p><em>Would</em> you pass me the carrot, please? 能请你把胡萝卜递过来吗？（比 Willl you pass me the carrot? 更礼貌。）</p>
<p><em>Would</em> you like a carrot for lunch? 你是否中饭想吃胡萝卜？（比 Do you want a carrot for lunch? 更礼貌。） *** 过去将来进行时态 <em>将来</em> 进行时态： <em>will</em> + be + 动词的现在分词</p>
<p><em>过去将来</em> 进行时态： <em>would</em> + be + 动词的现在分词</p>
<p>I <em>said</em> I <em>would be eating</em> a carrot at 1PM tomorrow/yesterday. 我（之前）说我明天下午 1 点会在吃胡萝卜。（我 <em>之前说</em> 我明天/昨天下午 1 点 <em>会</em> 是 <em>在吃</em> 胡萝卜这个过程中。） *** 过去将来完成时态 <em>将来</em> 完成时态： <em>will</em> + have + 动词的完成分词</p>
<p><em>过去将来</em> 完成时态： <em>would</em> + have + 动词的完成分词</p>
<p>I <em>said</em> I <em>would have eaten</em> a carrot by 1PM tomorrow/yesterday. 我 <em>（之前）说</em> 我明天/昨天下午 1 点 <em>会</em> 已经 <em>吃掉了</em> 根胡萝卜。（我之前说我明天/昨天下午一点会已经做完了吃胡萝卜这个动作。） *** 过去将来完成进行时态 <em>将来</em> 完成进行时态： <em>will</em> + have + been + 动词的完成分词</p>
<p><em>过去将来</em> 完成进行时态： <em>would</em> + have + been + 动词的完成分词</p>
<p>I <em>said</em> I <em>would have been eating</em> lunch for 2 hours by 1Pm tomorrow/yesterday. 我（之前）说我明天/昨天下午 1 点前会已经吃了两个钟头中饭。 （我 <em>之前说</em> 我 <em>会</em> 明天/昨天下午 1 点时在吃中饭这个过程中， <em>之前已经吃了 2 个钟头</em> ，之后还会 <em>继续吃</em> 。） * “不规则”动词的“规律” https://www.yingyutu.com/bgz * 参考视频 https://www.youtube.com/watch?v=P5FrIGgyNSc</p>]]></description>
    <pubDate>Thu, 5 Aug 2021 21:02:23 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[配置zfs]]></title>
    <link>https://www.codeplayer.org/Blog/%e9%85%8d%e7%bd%aeZFS.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e9%85%8d%e7%bd%aeZFS.html</guid>
    <description><![CDATA[<p>#+TITLE: 配置zfs #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li><p>环境 ST2000LM003 是仅有的一款 2T 大小的 CMR 2.5 英寸硬盘，目前非常稀有，淘宝上卖的 ST2000LM003 散装硬盘大概率是清零盘。不过我从咸鱼买到了两块内芯是 ST2000LM003 的移动硬盘，拆解后将其中的 2.5 英寸硬盘放到 deskmini 中组成小型 NAS。</p></li>
<li><p>系统：Gentoo Linux</p></li>
<li><p>机器：deskmini A300</p></li>
<li><p>硬盘：ST2000LM003 * 2</p></li>
<li><p>安装 ZFS Gentoo 系统安装 zfs 还算简单，不过要注意开启一些方便使用的 USE。</p></li>
</ul>
<p>#+begin_src sh echo “sys-fs/zfs dist-kernel” &gt;&gt; /etc/portage/package.use echo “sys-fs/zfs-kmod dist-kernel” &gt;&gt; /etc/portage/package.use emerge -avt sys-fs/zfs #+end_src</p>
<p>注意，每次更新内核后，都需要重新安装 zfs 模块。Gentoo 可以通过命令 =emerge -avt <span class="citation" data-cites="module-rebuild">@module-rebuild</span>= 完成。</p>
<p>由于这里我并不使用 zfs 作为 root 的文件系统，所以省略了将 zfs 模块添加到 initramfs 中等步骤。 * 配置 ZFS ** 设置 ARC 内存大小 zfs 的 ARC 缓存默认最大使用系统的三分之二内存。如果想要内存占用少一点，就需要使用下面的方法加以限制，这里限制了最大使用 4GB 内存。</p>
<p>#+begin_src sh echo “options zfs zfs_arc_max=4294967296” &gt;&gt; /etc/modprobe.d/zfs.conf #+end_src ** 开启 systemd 服务 开启以下服务后，zfs 才能正常使用。注意开启后需要重启，或者手动启动以下服务。</p>
<p>#+begin_src sh systemctl enable zfs.target systemctl enable zfs-import-cache systemctl enable zfs-mount systemctl enable zfs-import.target #+end_src * 创建 zpool 与 dataset 现在我们就可以正式开始使用 zfs 了，我们先创建 zpool 与 dataset，并设置一些优化参数。这里我们将两块 ST2000LM003 组成 raid0。</p>
<p>首先，使用命令查看硬盘的 id，通过 id 创建 zpool 是最佳的方法，可以避免因盘序或 UUID 变化带来的一些问题。</p>
<p>#+begin_src sh ➜ ls -lh /dev/disk/by-id/ total 0 lrwxrwxrwx 1 root root 9 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918 -&gt; ../../sdb lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918-part1 -&gt; ../../sdb1 lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9DG938918-part9 -&gt; ../../sdb9 lrwxrwxrwx 1 root root 9 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993 -&gt; ../../sda lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993-part1 -&gt; ../../sda1 lrwxrwxrwx 1 root root 10 Jul 18 15:06 ata-ST2000LM003_HN-M201RAD_S362J9EG922993-part9 -&gt; ../../sda9 #+end_src</p>
<p>这里，我们得到两块硬盘的 id 分别为 ata-ST2000LM003_HN-M201RAD_S362J9DG938918 和 ata-ST2000LM003_HN-M201RAD_S362J9EG922993。接下来，就通过这两个参数来创建 zpool。</p>
<p>#+begin_src sh # 创建zpool，注意机械硬盘必须使用参数ashift=12，具有8K扇区的SSD应使用ashift=13。该参数在创建zpool完毕以后，就无法修改了。 zpool create -f -o ashift=12 storage ata-ST2000LM003_HN-M201RAD_S362J9DG938918 ata-ST2000LM003_HN-M201RAD_S362J9EG922993 # 创建dataset并设置挂载点 zfs create -o mountpoint=/srv/data storage/data zfs create -o mountpoint=/srv/data/nas storage/data/nas # 开启压缩并使用压缩算法lz4 zfs set compression=lz4 storage # 因为性能原因，最好设置xattr。详情见https://github.com/zfsonlinux/zfs/issues/170#issuecomment-27348094 zfs set acltype=posixacl storage zfs set xattr=sa storage zfs set aclinherit=passthrough storage # 仅在modified time或changed time 改变，或者acces time24小时内没有更新时，才更新access time zfs set atime=on storage zfs set relatime=on storage # SSD还需要开启autotrim zpool set autotrim=on storage #+end_src</p>
<p>最后，我们还需要生成 hostid 和更新 cachefile。</p>
<p>#+begin_src sh # 生成hostid，注意生成完hostid后需要更新initramfs zgenhostid # 更新cachefile zpool set cachefile=/etc/zfs/zpool.cache storage #+end_src * 参考链接 1. ZFS archwiki：https://wiki.archlinux.org/title/ZFS 2. ZFS Gentoo wiki：https://wiki.gentoo.org/wiki/ZFS 3. 在 Gentoo 上优雅的吃 ZFS：https://www.yafa.moe/post/gentoo-on-zfs/ 4. 在 Linux 上安装和使用 ZFS：https://www.escapelife.site/posts/caf259ea.html 5. ZFS dedup 属性：https://docs.oracle.com/cd/E26926_01/html/E25826/gazss.html#gjhav 6. Attaching and Detaching Devices in a Storage Pool：https://docs.oracle.com/cd/E19120-01/open.solaris/817-2271/gcfhe/index.html</p>]]></description>
    <pubDate>Thu, 5 Aug 2021 21:02:23 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[双显卡笔记本独显直通]]></title>
    <link>https://www.codeplayer.org/Blog/%e5%8f%8c%e6%98%be%e5%8d%a1%e7%ac%94%e8%ae%b0%e6%9c%ac%e7%8b%ac%e6%98%be%e7%9b%b4%e9%80%9a.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e5%8f%8c%e6%98%be%e5%8d%a1%e7%ac%94%e8%ae%b0%e6%9c%ac%e7%8b%ac%e6%98%be%e7%9b%b4%e9%80%9a.html</guid>
    <description><![CDATA[<p>#+TITLE: 双显卡笔记本独显直通 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li>介绍 双显卡笔记本中直通独显（dGPU）到 win10 虚拟机。</li>
</ul>
<p>环境： - 联想 Legion R7000P 2020 笔记本 - RTX2060 笔记本显卡 - libvirt+qemu - Host: Gentoo Linux - Guest: Windows 10 LTSC 2019 * MUXed MUXed 结构的笔记本才容易实现独立显卡直通，Legion R7000P 应该就是 MUXed 的。关于什么是 MUXed 的，可以看下图的解释。</p>
<p>[[file:../pics/Blog/muxed.jpg]]</p>
<p>关于如何检测笔记本是否是 MUXed 的，目前没有什么好的办法。有一种说法是运行 lspci，查找有关 Intel HD Graphics/AMD GPU 和 NVIDIA 的设备：</p>
<ul>
<li>如果独显设备名以 3D Controller 开头，那你的电脑就是第二种 MUXless（核显直连显示器）。</li>
<li>如果独显设备名以 VGA Controller 开头，并且有一个 HD Graphics/AMD GPU 核显，那你的电脑是第三种 MUXed（核显、独显切换）。</li>
<li>启用 IOMMU 和 vfio 模块 ** IOMMU</li>
<li>intel CPU：添加内核参数 =intel_iommu=on iommu=pt= ，BIOS 开启 VT-d</li>
<li>amd CPU：添加内核参数 =iommu=pt= ，BIOS 开启 AMD-Vi ** vfio 添加模块 =vfio_pci vfio vfio_iommu_type1 vfio_virqfd= 到 initramfs 中。如果是像我一样使用 dracut 生成 initramfs，则在 =/etc/dracut.conf= 中添加配置 ~add_drivers+=" vfio_pci vfio vfio_iommu_type1 vfio_virqfd "~ ，之后重新生成 initramfs。</li>
<li>隔离 GPU #+begin_src sh #!/bin/bash shopt -s nullglob for g in <code>find /sys/kernel/iommu_groups/* -maxdepth 0 -type d | sort -V</code>; do echo “IOMMU Group ${g##<em>/}:" for d in <span class="math inline">$g/devices/*; do  echo -e "\t$</span>(lspci -nns ${d##</em>/})” done; done; #+end_src</li>
</ul>
<p>运行上述脚本，查看显卡所在的 IOMMU Group，并得到显卡相关设备的 device id。</p>
<p>#+begin_src IOMMU Group 10: 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation TU106M [GeForce RTX 2060 Mobile] [10de:1f15] (rev a1) 01:00.1 Audio device [0403]: NVIDIA Corporation TU106 High Definition Audio Controller [10de:10f9] (rev a1) 01:00.2 USB controller [0c03]: NVIDIA Corporation TU106 USB 3.1 Host Controller [10de:1ada] (rev a1) 01:00.3 Serial bus controller [0c80]: NVIDIA Corporation TU106 USB Type-C UCSI Controller [10de:1adb] (rev a1) #+end_src</p>
<p>如上所见，device id 分别为 <sub>10de:1f15</sub> 、 <sub>10de:10f9</sub> 、 <sub>10de:1ada</sub> 、 <sub>10de:1adb</sub> 。再将以上 deivce id 作为参数添加到内核参数或 =/etc/modprobe.d/vfio.conf= 中。</p>
<ul>
<li>内核参数：vfio-pci.ids=10de:1f15,10de:10f9,10de:1ada,10de:1adb</li>
<li>=/etc/modprobe.d/vfio.conf= ：options vfio-pci ids=10de:1f15,10de:10f9,10de:1ada,10de:1adb</li>
</ul>
<p>dracut 必须将 device id 添加到内核参数中，并且添加参数 =rd.driver.pre=vfio_pci= 。</p>
<p>最后重启电脑。开机后通过命令 =lspci -k= 确认上述 device id 对应的设备在使用 vfio-pci 驱动。如果有各别设备没有使用 vfio-pci 驱动，则可以通过手动 unbind 和 bind 驱动的方式加载 vfio-pci 驱动。比如如果 0000:01:00.2 仍在使用 xhci_hcd 驱动，则：</p>
<p>#+begin_src sh # run as root echo -n “0000:01:00.2” &gt; /sys/bus/pci/drivers/xhci_hcd/unbind echo -n “0000:01:00.2” &gt; /sys/bus/pci/drivers/vfio-pci/bind #+end_src * 创建虚拟机 首先使用 libvirt 创建一个非显卡直通的虚拟机，如果你有多余的显示器和键鼠，也可以直接创建显卡直通的虚拟机。这里我们假设没有多余的设备，并且之后使用 RDP 连接虚拟机。</p>
<p>首先下载[[https://msdn.itellyou.cn/][windows 10 LTSC 2019]]和 [[https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso][virtio windows驱动]]镜像。</p>
<p>创建虚拟机： - =Overview= ：Firmware 选择 UEFI x86_64:/usr/share/edk2-ovmf/OVMF_CODE.fd - =CPUs= ：选择 Topology，Manually set CPU topology，Sockets 设为 1，Cores 按需要来，我设为 4，Threads 设置为 2。这样一共就分配了 4 核 8 线程的 CPU - =Memory= ：内存我设置为 32G - =SATA Disk= ：Disk Bus 选择 Virtio，可以最小化磁盘性能损耗 - =NIC= ：Device model 也选择 virtio - 之后再添加一个 =Stroage= ，选择 Select custom storage 并选中之前下载的 virtio windows 驱动镜像，然后 Device type 选择 CDROM device - 最后在 =Boot Options= 中选中需要启动的设备</p>
<p>开始安装，在 windows 安装进行到选择硬盘的时候，通过之前加载的 virtio win 驱动的 CDROM，安装 virtio 的磁盘和网络驱动。具体参考可见视频 https://www.bilibili.com/video/BV1dQ4y1o78R 的 29 分 35 秒。安装完毕进入 windows，开启远程桌面并记下 IP，之后通过 RDP 连接虚拟机。 * 配置和优化 RemoteFX ** 配置 RemoteFX 1. 通过 =Win+R= 运行 =gpedit.msc= 2. 定位到 =计算机配置= -&gt; =管理模板= -&gt; =Windows组件= -&gt; =远程桌面服务= -&gt; =远程桌面会话主机= -&gt; =远程会话环境= - 开启 =对 RemoteApp 使用高级 RemoteFX 图形= - （可选）开启 =配置 RemoteFX 自适应图形的图像质量= ，设置为高 - 开启 =为专门针对 Windows Server 2008 R2 SP1 设计的 RemoteFX 客户端启动 RemoteFX 编码= - 开启 =配置 RemoteFX 数据的压缩= ，并设置为不需使用 RDP 压缩算法 + 连接压缩会导致编码和解码时产生额外的延迟 3. 定位到 =计算机配置= -&gt; =管理模板= -&gt; =Windows组件= -&gt; =远程桌面服务= -&gt; =远程桌面会话主机= -&gt; =远程会话环境= -&gt; =RemoteFX for Windows Server 2008 R2= - 开启 =配置RemoteFX= - （可选）开启 =使用RemoteFX时优化视觉体验= ，并都设置为最高 ** 解除 30-ish fps 限制 1. 启动注册表编辑器 2. 定位并单击以下注册表子键： =HKEY_LOCAL_MACHINEServer= 3. 在 =编辑= 菜单中选择 =新建= ，然后再选择 =DWORD（32位）值= 4. 输入 =DWMFRAMEINTERVAL= 并回车 5. 右键 =DWMFRAMEINTERVAL= ，选择 =修改= 6. 选择十进制，并输入 15。该设置将最大帧率设置为每秒 60 帧 (FPS)。 * 显卡直通 先关闭虚拟机。首先我们需要确认 host 和 guest 中的 GPU 硬件 ID 一致的，然而 Legion R7000P 中两者不一致，准确的来说是其中的 Sub ID 部分不一致，所以需要手动修改一下。首先通过命令 =lspci -nnk | egrep -A3 “VGA|3D”= 查看显卡的 Vendor ID 和 Device ID。</p>
<p>#+begin_src ➜ lspci -nnk | egrep -A3 “VGA|3D” 01:00.0 VGA compatible controller [0300]: NVIDIA Corporation TU106M [GeForce RTX 2060 Mobile] [10de:1f15] (rev a1) Subsystem: Lenovo TU106M [GeForce RTX 2060 Mobile] [17aa:3a43] Kernel driver in use: vfio-pci Kernel modules: nouveau – 06:00.0 VGA compatible controller [0300]: Advanced Micro Devices, Inc. [AMD/ATI] Renoir [1002:1636] (rev c6) Subsystem: Lenovo Renoir [17aa:3a47] Kernel driver in use: amdgpu Kernel modules: amdgpu</p>
<p>#+end_src</p>
<p>其中 NVIDIA 独显的 Vendor ID 为 10de，Device ID 为 1f15。再用命令 ~grep “PCI_SUBSYS_ID=” /sys/bus/pci/devices/0000:01:00.0/uevent~ 查看 Sub Vendor ID 和 Sub Device ID。</p>
<p>#+begin_src ➜ grep “PCI_SUBSYS_ID=” /sys/bus/pci/devices/0000:01:00.0/uevent PCI_SUBSYS_ID=17AA:3A47 #+end_src</p>
<p>其中 Sub Vendor ID 为 17AA，Sub Device ID 为 3A47。将 17AA 和 3A47 转换为十进制 6058 和 14919，并在虚拟机的 XML 中添加配置：</p>
<p>#+begin_src xml <domain xmlns:qemu="http://libvirt.org/schemas/domain/qemu/1.0" type="kvm"> … <qemu:commandline> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-vendor-id=6058'/> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-device-id=14919'/> </qemu:commandline> </domain> #+end_src</p>
<p>注意 XML 的第一行一定要添加 <sub>xmlns:qemu=“http://libvirt.org/schemas/domain/qemu/1.0”</sub> ，否则后面的配置无法成功添加。</p>
<p>在 libvirt 中添加硬件，选择 PCI Host Device，然后将 =0000:01:00.0 NVIDIA Corporation GeForce RTX 2060 Mobile= 和 =0000:01:00.1 NVIDIA Corporation High Definition Audio Controller= 等都添加进去。</p>
<p>最后再在 libvirt 中删除虚拟机的 =Display Spice= 和 =Video QXL= ，在 =CPUs= 中取消 Copy host CPU configuration 并将 Model 选择为 host passthrough。如果你需要直通鼠标和键盘，也可以在这个时候添加。 * 创建网桥 有线网卡的网桥创建起来较为简单，这里就不详细介绍了，有需要的可以查看我上一篇[[file:软路由虚拟机.org][软路由虚拟机]]的 BLOG。因为是笔记本，所以这里主要介绍无线网卡的桥接方法。</p>
<p>先开启 proxy_arp 和 ip_forward，修改配置文件 =/etc/sysctl.conf= ，添加下述配置：</p>
<p>#+begin_src conf net.ipv4.ip_forward = 1 net.ipv4.conf.all.proxy_arp = 1 #+end_src</p>
<p>再点击 libvirt 菜单栏上的 =Edit= -&gt; =Connection Details= ，假设 host 的 ip 为 192.168.3.12，无线网卡为 wlp4s0，新建一个 Network， =Name= 设置为 proxyArp， =Mode= 选择 Routed， =Forward to= 选择 Physical device， =Device= 设置为 wlp4s0， IPv4 的 =Network= 设置为 192.168.3.100/28，完成创建。</p>
<p>然后修改 win10 虚拟机的 =NIC= 配置，将 =Network source= 改为 Virtual network ‘proxyArp’: Route to wlp4s0，最后重新启动虚拟机与物理机。 * 远程连接 重新启动虚拟机后，使用 RDP 连接到虚拟机中。到 nvidia 官网下载驱动，并进行安装。如果安装过程中并未出现问题，则至此显卡直通配置完成。另外如果不外接显示器的话，windows 的分辨率似乎会被限制在 640x480，不知道会不会对游戏有影响，所以有条件还是买一个 HDMI 欺骗器接到独显连接的显示接口上。</p>
<p>远程连接方式一共有三种，分别可以适用于不同的情况。 ** RDP 简单使用方法： - 确保使用 FreeRDP 2.0 - 获取 windows 虚拟机 IP，比如 192.168.3.108 - xfreerdp /v:192.168.3.108:3389 /w:1600 /h:900 /bpp:32 +clipboard +fonts /gdi:hw /rfx /rfx-mode:video /sound:sys:pulse +menu-anims +window-drag</p>
<p>对于使用 xfreedp 的 RemoteFX 连接的一些问题： - 只有窗口化的游戏可以运行，全屏将会触发 d3d11 0x087A0001 不能设置分辨率等问题。媒体播放器不受其影响。 + 作为解决方案，使用无边框模式游戏，或其他等效方案 + windows 客户端似乎没有该问题 - 由于 RDSH/RDVH 连接不支持“相对”鼠标，鼠标会乱跑 + 重定向 XBOX 手柄或 USB 摇杆可能会解决这个问题？ + 使用 Synergy (v1) 并启用相对鼠标模式 + 通过 RDP RemoteFX 运行 3D 游戏鼠标不稳定 ** Looking glass Looking glass 的优点是低延迟，其并不是通过网络与虚拟机通信，而是直接使用一块共享内存。缺点是只能本地连接，而且似乎需要外接一个显示设备（或 HDMI 欺骗器）才能让键盘、鼠标正常工作，并且似乎不能使用 spice 套娃远程操作 looking glass。</p>
<p>*** 安装 client 首先在 host 系统上安装 looking glass client，在 gentoo 上可以通过如下步骤直接安装我打包的 looking glass。</p>
<p>#+begin_src sh sudo eselect repository enable gig sudo emerge –sync gig sudo emerge -avt looking-glass #+end_src *** 计算内存大小 通过以下公式，根据你期望的最大分辨率来计算内存大小。</p>
<p>#+begin_src width x height x 4 x 2 = total bytes</p>
<p>total bytes / 1024 / 1024 = total megabytes + 10 #+end_src</p>
<p>比如，我想要最大使用 4K 分辨率（3840x2160）：</p>
<p>#+begin_src 3840 x 2160 x 4 x 2 = 66355200 bytes</p>
<p>66355200 / 1024 / 1024 = 63.28 MB + 10 = 73.28 #+end_src</p>
<p>最后要注意内存的大小要上向取整到最接近的 2 的幂，在上面的例子中则应为 128。 *** 配置 libvirt #+begin_src xml … <devices> … <shmem name='looking-glass'> <model type='ivshmem-plain'/> <size unit='M'>128</size> </shmem> </devices> … #+end_src</p>
<p>将以上内容添加到虚拟机的 XML 配置中，其中 128 即为上面计算出来的大小。</p>
<p>如果想要通过 spice 实现键盘和鼠标输入与剪贴板共享，则必须添加 spice 设备。 - 在 libvirt 中，选择 =Add Hardware= ，然后再选择 =Graphics= ，使用默认的 spice 配置即可，最后完成添加 - 选择 =Video= 设备，然后在 =Model= 栏中输入 none，注意必须要完成这一步，否则可能会造成虚拟机不使用直通的显卡渲染 - 如果有 =tablet= 设备，则删除 - 如果没有 =Mouse= 设备，则添加一个 - 如果没有 =Keyboard= 设备，则添加一个 + 这里使用 Virtio 的键盘可以更好的提高性能，然而 PS/2 的键盘没办法删掉，不知道被哪个设备依赖了，所以就使用 PS/2 的键盘了 + 还有如果使用 Virtio 的键盘，则需要通过上面加载的 virtio windows 驱动 的 CDROM，以安装驱动 *** 创建共享内存文件 新建文件 =/etc/tmpfiles.d/10-looking-glass.conf= ，其内容为：</p>
<p>#+begin_src conf #Type Path Mode UID GID Age Argument f /dev/shm/looking-glass 0660 user kvm - #+end_src</p>
<p>将其中的 user，改为你自己的用户名。最后使用命令 =systemd-tmpfiles –create /etc/tmpfiles.d/10-looking-glass.conf= 创建共享内存文件，无需等待下次重启。 *** 安装 host 首先需要在 windows 中安装 IVSHMEM 驱动，windows 不会自己安装 IVSHMEM 设备，相反它只会为该设备安装一个假驱动。先下载需要安装的驱动程序，https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/upstream-virtio/ ，注意必须下载 0.1.161 或更高的版本，最后将其解压。</p>
<p>安装 IVSHMEM 驱动需要打开 =设备管理器= ，然后在 =系统设备= 下，找到 =PCI标准内存控制器= ，然后选择 =更新驱动程序= ，再选择手动更新，选择我们之前下载并解压好的驱动目录，然后安装驱动即可。</p>
<p>host 需要在 windows 虚拟机中安装，先下载与 client 版本对应的 host 安装文件：https://looking-glass.io/downloads 。下载完成后解压、安装即可，完成后重启虚拟机，然后通过 log 文件查看其是否正常启动，log 在开始菜单里就有。</p>
<p>最后再安装一下 spice guest tools， https://www.spice-space.org/download.html#windows-binaries ，以更好的支持鼠标与剪贴板共享。 *** 配置 client 我使用的配置如下，将配置文件放在 =~/.looking-glass-client.ini= 或 =/etc/looking-glass-client.ini= ：</p>
<p>#+begin_src ini [app] renderer=egl shmFile=/dev/shm/looking-glass</p>
<p>[win] borderless=yes fullScreen=yes size=1920x1080</p>
<p>[input] grabKeyboard=yes escapeKey=97</p>
<p>[spice] captureOnStart=yes #+end_src</p>
<p>由于我的笔记本没有 ScrLk 按键，所以将 escape 键设置为了 右 Ctrl 按键。</p>
<p>至此 looking glass 配置完成，运行命令 looking-glass-client 连接到虚拟机。 *** 配置 Scream 由于 looking glass 不支持传递音频，所以我们还需要使用 Scream 将 VM 的音频传递给 host。</p>
<p>首先，编辑 windows 虚拟机的 XML，添加以下部分：</p>
<p>#+begin_src xml … <devices> … <shmem name='scream-ivshmem'> <model type='ivshmem-plain'/> <size unit='M'>2</size> </shmem> </devices> … #+end_src</p>
<p>然后再如 looking glass 一样，添加配置文件 =/etc/tmpfiles.d/11-scream-ivshmem.conf= ，并运行命令 =systemd-tmpfiles –create /etc/tmpfiles.d/11-scream-ivshmem.conf= 。</p>
<p>#+begin_src conf f /dev/shm/scream-ivshmem 0660 user kvm - #+end_src</p>
<p>如果没有安装 IVSHMEM 驱动，则需要安装一下，跟上面一样。然后下载 scream 的 windows 驱动，地址： https://github.com/duncanthrax/scream/releases ，解压并进行安装。</p>
<p>再以管理员权限在 CMD 中运行 =REG ADD HKLM/v UseIVSHMEM /t REG_DWORD /d 2= 。</p>
<p>在 Linux 物理机中安装 scream，然后创建配置文件 =~/.config/systemd/user/scream-ivshmem-pulse.service= ：</p>
<p>#+begin_src [Unit] Description=Scream IVSHMEM pulse receiver After=pulseaudio.service Wants=pulseaudio.service</p>
<p>[Service] Type=simple ExecStartPre=/usr/bin/truncate -s 0 /dev/shm/scream-ivshmem ExecStartPre=/bin/dd if=/dev/zero of=/dev/shm/scream-ivshmem bs=1M count=2 ExecStart=/usr/bin/scream -m /dev/shm/scream-ivshmem</p>
<p>[Install] WantedBy=default.target #+end_src</p>
<p>最后运行以下命令即可：</p>
<p>#+begin_src sh systemctl start –user scream-ivshmem-pulse systemctl enable –user scream-ivshmem-pulse #+end_src</p>
<p>这样就配置完成了，在 looing glass 里就可以听到声音了。 ** steam 远程畅玩（流式传输） 因为 RDP 的限制，像 steam 家庭串流或 Geforce Experience 的方式对游戏来说更为推荐。</p>
<p>如果不想每次串流游戏都输入密码解锁屏幕，则可以通过 RDP 以管理员权限运行 cmd，然后运行以下命令，也可以将其保存为脚本，方便以后使用。注意运行完该命令会立马断开 RDP。</p>
<p>#+begin_src <span class="citation" data-cites="powershell">@powershell</span> -NoProfile -ExecutionPolicy unrestricted -Command “$sessionid=((quser $env:USERNAME | select -Skip 1) -split ‘+’)[2]; tscon $sessionid /dest:console” 2&gt; UnlockErrors.log #+end_src * benchmark 简单运行了一下 3dmark 的 Time Spy，做虚拟机的图形性能测试。测试了以下几种情况：</p>
<ul>
<li>win10 + 物理机直接运行，3dmark 得分 6900</li>
<li>win10 + 虚拟机显卡直通 + 外接显示器，3dmark 得分 6000</li>
<li>win10 + 虚拟机显卡直通 + steam 串流，3dmark 得分 5600</li>
<li>win10 + 虚拟机显卡直通 + looking glass，3dmark 得分 5000，并且在加载的时候，画面延迟近 10 秒</li>
</ul>
<p>由此可见，想要玩游戏，还是最好外接显示器，或者起码使用 steam 串流吧，个人感觉 looking glass 的性能甚至可能没有 RDP 高，但 RDP 无法运行 3dmark，所以无法比较测试。另外这几种情况中，CPU 得分的差距更大，但一般游戏也不会占用过多 CPU 资源，所以这里并没有记录。</p>
<p>PS：win10 + 虚拟机显卡直通 + looking glass + HDMI 欺骗器，3dmark 得分也是 5600，looking glass 的性能有待进一步测试。 * 参考链接 1. PCI passthrough via OVMF https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF 2. [GUIDE] Optimus laptop dGPU passthrough https://gist.github.com/Misairu-G/616f7b2756c488148b7309addc940b28 3. Vendor ID &amp; Device ID https://github.com/marcosscriven/ovmf-with-vbios-patch/issues/2 4. 笔记本 Optimus MUXless 下的 Intel 和 NVIDIA 虚拟机显卡直通 https://lantian.pub/article/modify-computer/laptop-intel-nvidia-optimus-passthrough.lantian/ 5. ledis 的单显卡直通教程 https://github.com/ledisthebest/LEDs-single-gpu-passthrough/blob/main/README-cn.md 6. Looking glass Installation https://looking-glass.io/docs/676/install 7. Bridging Network Connections with Proxy ARP https://wiki.debian.org/BridgeNetworkConnectionsProxyArp 8. setup kvm on a wireless interface on a laptop machine https://unix.stackexchange.com/questions/159191/setup-kvm-on-a-wireless-interface-on-a-laptop-machine 9. 桥接无线网卡 https://blog.lilydjwg.me/2020/5/19/bridged-wireless-network.215330.html * 附录：XML 配置 最后附上我的虚拟机的 XML 配置。</p>
#+begin_src xml <domain type='kvm' id='1' xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0'> <name>win10</name> <uuid>d5da831a-c1eb-4668-a864-0731557d80a0</uuid> <metadata> <libosinfo:libosinfo xmlns:libosinfo="http://libosinfo.org/xmlns/libvirt/domain/1.0"> <libosinfo:os id="http://microsoft.com/win/10"/> </libosinfo:libosinfo> </metadata> <memory unit='KiB'>33554432</memory> <currentMemory unit='KiB'>33554432</currentMemory> <vcpu placement='static'>8</vcpu> <resource> <partition>/machine</partition> </resource> <os> <type arch='x86_64' machine='pc-q35-6.0'>hvm</type> <loader readonly='yes' type='pflash'>/usr/share/edk2-ovmf/OVMF_CODE.fd</loader> <nvram>/var/lib/libvirt/qemu/nvram/win10_VARS.fd</nvram> <bootmenu enable='no'/> </os> <features> <acpi/> <apic/> <hyperv> <relaxed state='on'/> <vapic state='on'/> <spinlocks state='on' retries='8191'/> </hyperv> <vmport state='off'/> </features> <cpu mode='host-passthrough' check='partial' migratable='on'> <topology sockets='1' dies='1' cores='4' threads='2'/> </cpu> <clock offset='localtime'> <timer name='rtc' tickpolicy='catchup'/> <timer name='pit' tickpolicy='delay'/> <timer name='hpet' present='no'/> <timer name='hypervclock' present='yes'/> </clock> <on_poweroff>destroy</on_poweroff> <on_reboot>restart</on_reboot> <on_crash>destroy</on_crash> <pm> <suspend-to-mem enabled='no'/> <suspend-to-disk enabled='no'/> </pm> <devices> <emulator>/usr/bin/qemu-system-x86_64</emulator> <disk type='file' device='disk'> <driver name='qemu' type='qcow2'/> <source file='/var/lib/libvirt/images/win10.qcow2' index='3'/> <backingStore/> <target dev='vda' bus='virtio'/> <boot order='1'/> <alias name='virtio-disk0'/>
<address type='pci' domain='0x0000' bus='0x04' slot='0x00' function='0x0'/>
</disk> <disk type='file' device='cdrom'> <driver name='qemu' type='raw'/> <source file='/home/petrus/Downloads/iso/cn_windows_10_enterprise_ltsc_2019_x64_dvd_9c09ff24.iso' index='2'/> <backingStore/> <target dev='sdb' bus='sata'/> <readonly/> <boot order='2'/> <alias name='sata0-0-1'/>
<address type='drive' controller='0' bus='0' target='0' unit='1'/>
</disk> <disk type='file' device='cdrom'> <driver name='qemu' type='raw'/> <source file='/home/petrus/Downloads/iso/virtio-win-0.1.185.iso' index='1'/> <backingStore/> <target dev='sdc' bus='sata'/> <readonly/> <alias name='sata0-0-2'/>
<address type='drive' controller='0' bus='0' target='0' unit='2'/>
</disk> <controller type='usb' index='0' model='qemu-xhci' ports='15'> <alias name='usb'/>
<address type='pci' domain='0x0000' bus='0x02' slot='0x00' function='0x0'/>
</controller> <controller type='sata' index='0'> <alias name='ide'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x1f' function='0x2'/>
</controller> <controller type='pci' index='0' model='pcie-root'> <alias name='pcie.0'/> </controller> <controller type='pci' index='1' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='1' port='0x10'/> <alias name='pci.1'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0' multifunction='on'/>
</controller> <controller type='pci' index='2' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='2' port='0x11'/> <alias name='pci.2'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x1'/>
</controller> <controller type='pci' index='3' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='3' port='0x12'/> <alias name='pci.3'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x2'/>
</controller> <controller type='pci' index='4' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='4' port='0x13'/> <alias name='pci.4'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x3'/>
</controller> <controller type='pci' index='5' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='5' port='0x14'/> <alias name='pci.5'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x4'/>
</controller> <controller type='pci' index='6' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='6' port='0x15'/> <alias name='pci.6'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x5'/>
</controller> <controller type='pci' index='7' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='7' port='0x8'/> <alias name='pci.7'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x0' multifunction='on'/>
</controller> <controller type='pci' index='8' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='8' port='0x9'/> <alias name='pci.8'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/>
</controller> <controller type='pci' index='9' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='9' port='0xa'/> <alias name='pci.9'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x2'/>
</controller> <controller type='pci' index='10' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='10' port='0xb'/> <alias name='pci.10'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x3'/>
</controller> <controller type='pci' index='11' model='pcie-to-pci-bridge'> <model name='pcie-pci-bridge'/> <alias name='pci.11'/>
<address type='pci' domain='0x0000' bus='0x0a' slot='0x00' function='0x0'/>
</controller> <controller type='pci' index='12' model='pcie-root-port'> <model name='pcie-root-port'/> <target chassis='12' port='0xc'/> <alias name='pci.12'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x4'/>
</controller> <controller type='virtio-serial' index='0'> <alias name='virtio-serial0'/>
<address type='pci' domain='0x0000' bus='0x03' slot='0x00' function='0x0'/>
</controller> <interface type='network'> <mac address='52:54:00:9c:b1:61'/> <source network='proxyArp' portid='dea4d995-d8d9-408d-ac30-ac45bfd5627e' bridge='virbr1'/> <target dev='vnet0'/> <model type='virtio'/> <alias name='net0'/>
<address type='pci' domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
</interface> <serial type='pty'> <source path='/dev/pts/0'/> <target type='isa-serial' port='0'> <model name='isa-serial'/> </target> <alias name='serial0'/> </serial> <console type='pty' tty='/dev/pts/0'> <source path='/dev/pts/0'/> <target type='serial' port='0'/> <alias name='serial0'/> </console> <channel type='spicevmc'> <target type='virtio' name='com.redhat.spice.0' state='connected'/> <alias name='channel0'/>
<address type='virtio-serial' controller='0' bus='0' port='1'/>
</channel> <input type='mouse' bus='ps2'> <alias name='input0'/> </input> <input type='keyboard' bus='ps2'> <alias name='input1'/> </input> <graphics type='spice' port='5900' autoport='yes' listen='127.0.0.1'> <listen type='address' address='127.0.0.1'/> <image compression='off'/> <gl enable='no'/> </graphics> <sound model='ich9'> <alias name='sound0'/>
<address type='pci' domain='0x0000' bus='0x00' slot='0x1b' function='0x0'/>
</sound> <audio id='1' type='spice'/> <video> <model type='none'/> <alias name='video0'/> </video> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x0'/>
</source>
<alias name='hostdev0'/>
<address type='pci' domain='0x0000' bus='0x06' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x1'/>
</source>
<alias name='hostdev1'/>
<address type='pci' domain='0x0000' bus='0x07' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x2'/>
</source>
<alias name='hostdev2'/>
<address type='pci' domain='0x0000' bus='0x08' slot='0x00' function='0x0'/>
</hostdev> <hostdev mode='subsystem' type='pci' managed='yes'> <driver name='vfio'/> <source>
<address domain='0x0000' bus='0x01' slot='0x00' function='0x3'/>
</source>
<alias name='hostdev3'/>
<address type='pci' domain='0x0000' bus='0x09' slot='0x00' function='0x0'/>
</hostdev> <redirdev bus='usb' type='spicevmc'> <alias name='redir0'/>
<address type='usb' bus='0' port='2'/>
</redirdev> <redirdev bus='usb' type='spicevmc'> <alias name='redir1'/>
<address type='usb' bus='0' port='3'/>
</redirdev> <memballoon model='virtio'> <alias name='balloon0'/>
<address type='pci' domain='0x0000' bus='0x05' slot='0x00' function='0x0'/>
</memballoon> <shmem name='looking-glass'> <model type='ivshmem-plain'/> <size unit='M'>128</size> <alias name='shmem0'/>
<address type='pci' domain='0x0000' bus='0x0b' slot='0x01' function='0x0'/>
</shmem> <shmem name='scream-ivshmem'> <model type='ivshmem-plain'/> <size unit='M'>2</size> <alias name='shmem1'/>
<address type='pci' domain='0x0000' bus='0x0b' slot='0x02' function='0x0'/>
<p></shmem> </devices> <seclabel type='dynamic' model='dac' relabel='yes'> <label>+77:+77</label> <imagelabel>+77:+77</imagelabel> </seclabel> <qemu:commandline> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-vendor-id=6058'/> <qemu:arg value='-set'/> <qemu:arg value='device.hostdev0.x-pci-sub-device-id=14919'/> </qemu:commandline> </domain> #+end_src</p>]]></description>
    <pubDate>Thu, 5 Aug 2021 21:02:23 +0800</pubDate>
    </item>    <item>
    <title><![CDATA[软路由虚拟机]]></title>
    <link>https://www.codeplayer.org/Blog/%e8%bd%af%e8%b7%af%e7%94%b1%e8%99%9a%e6%8b%9f%e6%9c%ba.html</link>
    <guid isPermaLink="false">https://www.codeplayer.org/Blog/%e8%bd%af%e8%b7%af%e7%94%b1%e8%99%9a%e6%8b%9f%e6%9c%ba.html</guid>
    <description><![CDATA[<p>#+TITLE: 软路由虚拟机 #+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup</p>
<ul>
<li><p>准备环境 摸着石头过河，折腾了几天，终于装好了心心念念的虚拟机软路由。</p></li>
<li><p>硬件环境：3400G + deskmini A300（自带一个网口） + M2 转网口，物理机双网口</p></li>
<li><p>物理机系统： Gentoo Linux</p></li>
<li><p>网络拓扑，见下图。除了 host 以外的本地设备都是通过设置为 AP 模式的硬路由连接网络。</p></li>
</ul>
<p>[[file:../pics/Blog/router_topology.jpg]] * 固件选择 固件我们选择基于 openwrt 官方 21.02 代码定制的 garypang13 的固件，github 项目地址为 https://github.com/garypang13/OpenWrt_x86-r2s-r4s-Rpi ，固件下载地址为 https://op.supes.top/ 。</p>
<p>其特点是原生固件非常纯净，只自带少量插件。而作者自建的 opkg 源又包含了 openwrt 的绝大部分主流插件，想要安装插件只需要在 luci 上搜索，然后点击安装即可，不再需要自己编译等复杂步骤。同时还自带了一键升级固件功能，作者基本上每周都会放出新的固件，如果想要升级，一键便可完成。 * 创建网桥 首先创建用于 eth1 网口和软路由虚拟机 lan 口连接的网桥。</p>
<p>#+begin_src sh # 创建网桥 nmcli connection add type bridge ifname br0 stp no # 将eth1添加倒网桥中 nmcli connection add type bridge-slave ifname eth1 master br0 # 关闭现有的连接（可以使用nmcli connection show –active命令查看） nmcli connection down <Connection> # 开启新创建的网桥 nmcli connection up bridge-br0 #+end_src</p>
<p>注意以上操作会关闭正在使用的网口，如果是远程连接到物理机且仅有单网口，请 <em>谨慎操作</em> ！</p>
<p>这时如果 eth1 是连接在带 DHCP 的硬路由中，那么会自动为网桥 br0 分配 IP，同时 eth1 上的 ip 地址会消失，可以直接通过网桥 br0 的 ip 访问 eth1 网口。 * 创建虚拟机 使用 libvirt + qemu(kvm)创建虚拟机：</p>
<ul>
<li>CPU 2 核心</li>
<li>内存 1G</li>
<li>硬盘直接使用 openwrt 的 img 文件</li>
</ul>
<p>eth0 网卡直接设置为直通，另外添加一张网卡，[Network Source]设置为 Bridge device，[Device name]设置为 br0，[Device model]设置为 virtio。即创建桥接到 br0 的第二张网卡。</p>
<p>其他配置默认，之后正常启动 openwrt 虚拟机即可。 * 配置 openwrt 通过 virt-manager 或 vnc 进入刚刚创建好的 openwrt 虚拟机，修改配置文件 =/etc/config/network= 。将其中的 =config interface ‘lan’= 中的 =option ipaddr= 地址设置为 192.168.3.2。之后重启 openwrt。</p>
<p>这样就可以在网页上通过地址 192.168.3.2 登陆 openwrt 的管理页面 luci 了。再进入[网络-&gt;接口]页面，编辑 WAN 接口，选择 PPPoE 选择，填入用户名、密码连接互联网。</p>
<p>这时将光猫的网线插到 eth0 网口中，再将路由器改为 AP 模式，再通过以下步骤为 br0 设置静态 ip，然后重启整个物理机。这样最基本的网络就应该已经配置完成了。</p>
<p>#+begin_src sh nmcli connection modify bridge-br0 ipv4.addresses 192.168.3.10 nmcli connection modify bridge-br0 ipv4.gateway 192.168.3.2 nmcli connection modify bridge-br0 ipv4.dns 192.168.3.2 nmcli connection modify bridge-br0 ipv4.method manual nmcli connection up interface #+end_src * 插件安装 在 luci 的[系统-&gt;软件包]页面中，安装 openclash、passwall、ddns、wake on line、upnp、netdata、online user 等常用插件后，再对插件进行简单的配置，即可正常使用了，科学上网、路由监控等功能都已完备。 * 参考链接 1. Network_bridge wiki https://wiki.archlinux.org/title/Network_bridge 2. 软路由折腾记 https://github.com/fanchangyong/blog/issues/22 3. qemu-kvm 安装 koolshare LEDE-X64 固件 https://koolshare.cn/thread-68876-1-1.html 4. 将 ubuntu 设置为 NAS——10. 虚拟机 KVM 及软路由 LEDE 安装 https://post.smzdm.com/p/adwrn5gn/ 5. KVM 虚拟化网络优化技术总结 https://www.cnblogs.com/lsgxeva/p/8964363.html 6. OpenWrt 编译 LuCI -&gt; Applications 添加插件应用说明 https://www.right.com.cn/forum/thread-3682029-1-1.html</p>]]></description>
    <pubDate>Thu, 5 Aug 2021 21:02:23 +0800</pubDate>
    </item>
</channel>
</rss>
